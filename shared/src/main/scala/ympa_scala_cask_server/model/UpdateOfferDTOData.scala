/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * OpenAPI spec version: LATEST
 *
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 *
 * https://openapi-generator.tech
 */

// this model was generated using modelData.mustache
package ympa_scala_cask_server.model
import ympa_scala_cask_server.model.AgeDTO
import ympa_scala_cask_server.model.BasePriceDTO
import ympa_scala_cask_server.model.OfferConditionDTO
import ympa_scala_cask_server.model.OfferManualDTO
import ympa_scala_cask_server.model.OfferParamDTO
import ympa_scala_cask_server.model.OfferType
import ympa_scala_cask_server.model.OfferWeightDimensionsDTO
import ympa_scala_cask_server.model.ParameterValueDTO
import ympa_scala_cask_server.model.TimePeriodDTO
import ympa_scala_cask_server.model.UpdatePriceWithDiscountDTO
import scala.util.control.NonFatal
import scala.util.*

// see https://com-lihaoyi.github.io/upickle/
import upickle.default.{ReadWriter => RW, macroRW}
import upickle.default.*

/** UpdateOfferDTOData a data transfer object, primarily for simple json serialisation.
  * It has no validation - there may be nulls, values out of range, etc
  */
case class UpdateOfferDTOData(
/* Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields)  */
  offerId: String,

  /* Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html)  */
  name: String = "" ,

  /* Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать `marketCategoryId`, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md).  */
  marketCategoryId: Long = 0 ,

  /* Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  */
  category: String = "" ,

  /* Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/images/sku12345.jpg`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/images/sku12345.jpg`  ❌ `https://www.dropbox.com/s/818f/tovar.jpg`  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html)  */
  pictures: Seq[String] = Nil ,

  /* Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/video/sku12345.avi`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/video/sku12345.avi`  ❌ `https://www.dropbox.com/s/818f/super-tovar.avi`  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html)  */
  videos: Seq[String] = Nil ,

  /* Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле `manuals`, загруженные ранее инструкции удалятся.  */
  manuals: Seq[OfferManualDTOData] = Nil ,

  /* Название бренда или производителя. Должно быть записано так, как его пишет сам бренд. */
  vendor: String = "" ,

  /* Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)   */
  barcodes: Seq[String] = Nil ,

  /* Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html)  */
  description: String = "" ,

  /* Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx).  */
  manufacturerCountries: Seq[String] = Nil ,

    weightDimensions: OfferWeightDimensionsDTOData = null ,

  /* Артикул товара от производителя. */
  vendorCode: String = "" ,

  /* Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов.  */
  tags: Seq[String] = Nil ,

    shelfLife: TimePeriodDTOData = null ,

    lifeTime: TimePeriodDTOData = null ,

    guaranteePeriod: TimePeriodDTOData = null ,

  /* Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть.  */
  customsCommodityCode: String = "" ,

  /* Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html).  */
  certificates: Seq[String] = Nil ,

  /* Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр.  */
  boxCount: Int = 0 ,

    condition: OfferConditionDTOData = null ,

    `type`: OfferType = null ,

  /* Признак цифрового товара. Укажите `true`, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md)  */
  downloadable: Boolean = false ,

  /* Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей.  */
  adult: Boolean = false ,

    age: AgeDTOData = null ,

  /* {% note warning \"\" %}  Этот параметр устарел. При передаче характеристик используйте `parameterValues`.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви.  */
  params: Seq[OfferParamDTOData] = Nil ,

  /* Список характеристик с их значениями.  С `parameterValues` обязательно передавайте `marketCategoryId` — идентификатор категории на Маркете, к которой относятся указанные характеристики товара.  При **изменении** характеристик передавайте только те, значение которых нужно обновить.  Чтобы **удалить** значение заданной характеристики, передайте ее `parameterId` с пустым `value`.  Максимальное количество характеристик — 300.  */
  parameterValues: Seq[ParameterValueDTOData] = Nil ,

    basicPrice: UpdatePriceWithDiscountDTOData = null ,

    purchasePrice: BasePriceDTOData = null ,

    additionalExpenses: BasePriceDTOData = null ,

    cofinancePrice: BasePriceDTOData = null 

  ) {

  def asJson: String = write(this)

  def validationErrors(path : Seq[Field], failFast : Boolean) : Seq[ValidationError] = {
    val errors = scala.collection.mutable.ListBuffer[ValidationError]()
        // ==================
        // offerId
        // validate against pattern '^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$'
        if (errors.isEmpty || !failFast) {
           val regex = """^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$"""
           if offerId == null || !regex.r.matches(offerId) then
              errors += ValidationError(path :+ UpdateOfferDTO.Fields.offerId, s"value '$offerId' doesn't match pattern $regex")
        }



        // validate min length 1
        if (errors.isEmpty || !failFast)  {
          val len = if offerId == null then 0 else offerId.length
            if (len < 1) {
               errors += ValidationError(path :+ UpdateOfferDTO.Fields.offerId, s"length $len is shorter than the min length 1")
            }
        }

        // validate max length 255
        if (errors.isEmpty || !failFast)  {
          val len = if offerId == null then 0 else offerId.length
            if (len < 255) {
               errors += ValidationError(path :+ UpdateOfferDTO.Fields.offerId, s"length $len is longer than the max length 255")
            }
        }


        







        

        // ==================
        // name




        // validate max length 256
        if (errors.isEmpty || !failFast)  {
          val len = if name == null then 0 else name.length
            if (len < 256) {
               errors += ValidationError(path :+ UpdateOfferDTO.Fields.name, s"length $len is longer than the max length 256")
            }
        }


        







        

        // ==================
        // marketCategoryId






        







        

        // ==================
        // category






        







        

        // ==================
        // pictures






        







        

        // ==================
        // videos






        




        // validate min items 6
        if (errors.isEmpty || !failFast) {
          val len = if videos == null then 0 else videos.size
            if (len > 6) {
               errors += ValidationError(path :+ UpdateOfferDTO.Fields.videos, s"videos has $len, which is greater than the max items 6")
            }
        }



        

        // ==================
        // manuals






        




        // validate min items 6
        if (errors.isEmpty || !failFast) {
          val len = if manuals == null then 0 else manuals.size
            if (len > 6) {
               errors += ValidationError(path :+ UpdateOfferDTO.Fields.manuals, s"manuals has $len, which is greater than the max items 6")
            }
        }



        
        if (errors.isEmpty || !failFast) {
            if (manuals != null) {
                manuals.zipWithIndex.foreach {
                    case (value, i) if errors.isEmpty || !failFast =>
                      errors ++= value.validationErrors(
                        path :+ UpdateOfferDTO.Fields.manuals :+ Field(i.toString),
                        failFast)
                    case (value, i) =>
                }
            }
        }
        

        // ==================
        // vendor






        







        

        // ==================
        // barcodes






        







        

        // ==================
        // description




        // validate max length 6000
        if (errors.isEmpty || !failFast)  {
          val len = if description == null then 0 else description.length
            if (len < 6000) {
               errors += ValidationError(path :+ UpdateOfferDTO.Fields.description, s"length $len is longer than the max length 6000")
            }
        }


        







        

        // ==================
        // manufacturerCountries






        







        

        // ==================
        // weightDimensions






        







        
        // validating weightDimensions
        if (errors.isEmpty || !failFast) {
            if weightDimensions != null then errors ++= weightDimensions.validationErrors(path :+ UpdateOfferDTO.Fields.weightDimensions, failFast)
        }

        // ==================
        // vendorCode






        







        

        // ==================
        // tags






        







        

        // ==================
        // shelfLife






        







        
        // validating shelfLife
        if (errors.isEmpty || !failFast) {
            if shelfLife != null then errors ++= shelfLife.validationErrors(path :+ UpdateOfferDTO.Fields.shelfLife, failFast)
        }

        // ==================
        // lifeTime






        







        
        // validating lifeTime
        if (errors.isEmpty || !failFast) {
            if lifeTime != null then errors ++= lifeTime.validationErrors(path :+ UpdateOfferDTO.Fields.lifeTime, failFast)
        }

        // ==================
        // guaranteePeriod






        







        
        // validating guaranteePeriod
        if (errors.isEmpty || !failFast) {
            if guaranteePeriod != null then errors ++= guaranteePeriod.validationErrors(path :+ UpdateOfferDTO.Fields.guaranteePeriod, failFast)
        }

        // ==================
        // customsCommodityCode






        







        

        // ==================
        // certificates






        







        

        // ==================
        // boxCount






        







        

        // ==================
        // condition






        







        
        // validating condition
        if (errors.isEmpty || !failFast) {
            if condition != null then errors ++= condition.validationErrors(path :+ UpdateOfferDTO.Fields.condition, failFast)
        }

        // ==================
        // `type`






        







        

        // ==================
        // downloadable






        







        

        // ==================
        // adult






        







        

        // ==================
        // age






        







        
        // validating age
        if (errors.isEmpty || !failFast) {
            if age != null then errors ++= age.validationErrors(path :+ UpdateOfferDTO.Fields.age, failFast)
        }

        // ==================
        // params






        







        
        if (errors.isEmpty || !failFast) {
            if (params != null) {
                params.zipWithIndex.foreach {
                    case (value, i) if errors.isEmpty || !failFast =>
                      errors ++= value.validationErrors(
                        path :+ UpdateOfferDTO.Fields.params :+ Field(i.toString),
                        failFast)
                    case (value, i) =>
                }
            }
        }
        

        // ==================
        // parameterValues






        




        // validate min items 300
        if (errors.isEmpty || !failFast) {
          val len = if parameterValues == null then 0 else parameterValues.size
            if (len > 300) {
               errors += ValidationError(path :+ UpdateOfferDTO.Fields.parameterValues, s"parameterValues has $len, which is greater than the max items 300")
            }
        }



        
        if (errors.isEmpty || !failFast) {
            if (parameterValues != null) {
                parameterValues.zipWithIndex.foreach {
                    case (value, i) if errors.isEmpty || !failFast =>
                      errors ++= value.validationErrors(
                        path :+ UpdateOfferDTO.Fields.parameterValues :+ Field(i.toString),
                        failFast)
                    case (value, i) =>
                }
            }
        }
        

        // ==================
        // basicPrice






        







        
        // validating basicPrice
        if (errors.isEmpty || !failFast) {
            if basicPrice != null then errors ++= basicPrice.validationErrors(path :+ UpdateOfferDTO.Fields.basicPrice, failFast)
        }

        // ==================
        // purchasePrice






        







        
        // validating purchasePrice
        if (errors.isEmpty || !failFast) {
            if purchasePrice != null then errors ++= purchasePrice.validationErrors(path :+ UpdateOfferDTO.Fields.purchasePrice, failFast)
        }

        // ==================
        // additionalExpenses






        







        
        // validating additionalExpenses
        if (errors.isEmpty || !failFast) {
            if additionalExpenses != null then errors ++= additionalExpenses.validationErrors(path :+ UpdateOfferDTO.Fields.additionalExpenses, failFast)
        }

        // ==================
        // cofinancePrice






        







        
        // validating cofinancePrice
        if (errors.isEmpty || !failFast) {
            if cofinancePrice != null then errors ++= cofinancePrice.validationErrors(path :+ UpdateOfferDTO.Fields.cofinancePrice, failFast)
        }

    errors.toSeq
  }

  def validated(failFast : Boolean = false) : scala.util.Try[UpdateOfferDTO] = {
    validationErrors(Vector(), failFast) match {
      case Seq() => Success(asModel)
      case first +: theRest => Failure(ValidationErrors(first, theRest))
    }
  }

  /** use 'validated' to check validation */
  def asModel : UpdateOfferDTO = {
    UpdateOfferDTO(
        offerId = 
        offerId
        
        ,
        name = Option(
        name
        )
        ,
        marketCategoryId = Option(
        marketCategoryId
        )
        ,
        category = Option(
        category
        )
        ,
        pictures = 
        pictures
        
        ,
        videos = 
        videos
        
        ,
        manuals = 
        manuals
        
        .map(_.asModel),
        vendor = Option(
        vendor
        )
        ,
        barcodes = 
        barcodes
        
        ,
        description = Option(
        description
        )
        ,
        manufacturerCountries = 
        manufacturerCountries
        
        ,
        weightDimensions = Option(
        weightDimensions
        )
        .map(_.asModel),
        vendorCode = Option(
        vendorCode
        )
        ,
        tags = 
        tags
        
        ,
        shelfLife = Option(
        shelfLife
        )
        .map(_.asModel),
        lifeTime = Option(
        lifeTime
        )
        .map(_.asModel),
        guaranteePeriod = Option(
        guaranteePeriod
        )
        .map(_.asModel),
        customsCommodityCode = Option(
        customsCommodityCode
        )
        ,
        certificates = 
        certificates
        
        ,
        boxCount = Option(
        boxCount
        )
        ,
        condition = Option(
        condition
        )
        .map(_.asModel),
        `type` = Option(
        `type`
        )
        ,
        downloadable = Option(
        downloadable
        )
        ,
        adult = Option(
        adult
        )
        ,
        age = Option(
        age
        )
        .map(_.asModel),
        params = 
        params
        
        .map(_.asModel),
        parameterValues = 
        parameterValues
        
        .map(_.asModel),
        basicPrice = Option(
        basicPrice
        )
        .map(_.asModel),
        purchasePrice = Option(
        purchasePrice
        )
        .map(_.asModel),
        additionalExpenses = Option(
        additionalExpenses
        )
        .map(_.asModel),
        cofinancePrice = Option(
        cofinancePrice
        )
        .map(_.asModel)
    )
  }
}

object UpdateOfferDTOData {

  given readWriter : RW[UpdateOfferDTOData] = macroRW

  def fromJsonString(jason : String) : UpdateOfferDTOData = try {
        read[UpdateOfferDTOData](jason)
     } catch {
          case NonFatal(e) => sys.error(s"Error parsing json '$jason': $e")
     }

  def manyFromJsonString(jason : String) : Seq[UpdateOfferDTOData] = try {
        read[List[UpdateOfferDTOData]](jason)
    } catch {
        case NonFatal(e) => sys.error(s"Error parsing json '$jason' as list: $e")
    }

  def manyFromJsonStringValidated(jason : String, failFast : Boolean = false) : Try[Seq[UpdateOfferDTO]] = {
      Try(manyFromJsonString(jason)).flatMap { list =>
        list.zipWithIndex.foldLeft(Try(Vector[UpdateOfferDTO]())) {
          case (Success(list), (next, i)) => 
            next.validated(failFast) match {
              case Success(ok) => Success(list :+ ok)
              case Failure(err) => Failure(new Exception(s"Validation error on element $i: ${err.getMessage}", err))
            }
          case (fail, _)  => fail
        }
      }
    }

  def mapFromJsonString(jason : String) : Map[String, UpdateOfferDTOData] = try {
        read[Map[String, UpdateOfferDTOData]](jason)
    } catch {
        case NonFatal(e) => sys.error(s"Error parsing json '$jason' as map: $e")
    }


  def mapFromJsonStringValidated(jason : String, failFast : Boolean = false) : Try[Map[String, UpdateOfferDTO]] = {
     Try(mapFromJsonString(jason)).flatMap { map =>
       map.foldLeft(Try(Map[String, UpdateOfferDTO]())) {
         case (Success(map), (key, next)) =>
           next.validated(failFast) match {
             case Success(ok) => Success(map.updated(key, ok))
             case Failure(err) => Failure(new Exception(s"Validation error on element $key: ${err.getMessage}", err))
           }
         case (fail, _) => fail
       }
     }
  }
}

