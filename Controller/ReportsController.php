<?php

/**
 * ReportsController
 * PHP version 8.1.1
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * Партнерский API Маркета
 *
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов.
 *
 * The version of the OpenAPI document: LATEST
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Controller;

use \Exception;
use JMS\Serializer\Exception\RuntimeException as SerializerRuntimeException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Validator\Constraints as Assert;
use OpenAPI\Server\Api\ReportsApiInterface;
use OpenAPI\Server\Model\ApiClientDataErrorResponse;
use OpenAPI\Server\Model\ApiForbiddenErrorResponse;
use OpenAPI\Server\Model\ApiLimitErrorResponse;
use OpenAPI\Server\Model\ApiNotFoundErrorResponse;
use OpenAPI\Server\Model\ApiServerErrorResponse;
use OpenAPI\Server\Model\ApiUnauthorizedErrorResponse;
use OpenAPI\Server\Model\GenerateBoostConsolidatedRequest;
use OpenAPI\Server\Model\GenerateCompetitorsPositionReportRequest;
use OpenAPI\Server\Model\GenerateGoodsFeedbackRequest;
use OpenAPI\Server\Model\GenerateGoodsMovementReportRequest;
use OpenAPI\Server\Model\GenerateGoodsRealizationReportRequest;
use OpenAPI\Server\Model\GenerateGoodsTurnoverRequest;
use OpenAPI\Server\Model\GenerateMassOrderLabelsRequest;
use OpenAPI\Server\Model\GeneratePricesReportRequest;
use OpenAPI\Server\Model\GenerateReportResponse;
use OpenAPI\Server\Model\GenerateShelfsStatisticsRequest;
use OpenAPI\Server\Model\GenerateShipmentListDocumentReportRequest;
use OpenAPI\Server\Model\GenerateShowsSalesReportRequest;
use OpenAPI\Server\Model\GenerateStocksOnWarehousesReportRequest;
use OpenAPI\Server\Model\GenerateUnitedMarketplaceServicesReportRequest;
use OpenAPI\Server\Model\GenerateUnitedNettingReportRequest;
use OpenAPI\Server\Model\GenerateUnitedOrdersRequest;
use OpenAPI\Server\Model\GetReportInfoResponse;
use OpenAPI\Server\Model\PageFormatType;
use OpenAPI\Server\Model\ReportFormatType;

/**
 * ReportsController Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */
class ReportsController extends Controller
{

    /**
     * Operation generateBoostConsolidatedReport
     *
     * Отчет по бусту продаж
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateBoostConsolidatedReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateBoostConsolidatedRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateBoostConsolidatedRequest = $this->deserialize($generateBoostConsolidatedRequest, 'OpenAPI\Server\Model\GenerateBoostConsolidatedRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateBoostConsolidatedRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateBoostConsolidatedRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateBoostConsolidatedReport($generateBoostConsolidatedRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateCompetitorsPositionReport
     *
     * Отчет «Конкурентная позиция»
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateCompetitorsPositionReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateCompetitorsPositionReportRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateCompetitorsPositionReportRequest = $this->deserialize($generateCompetitorsPositionReportRequest, 'OpenAPI\Server\Model\GenerateCompetitorsPositionReportRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateCompetitorsPositionReportRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateCompetitorsPositionReportRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateCompetitorsPositionReport($generateCompetitorsPositionReportRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateGoodsFeedbackReport
     *
     * Отчет по отзывам о товарах
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateGoodsFeedbackReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateGoodsFeedbackRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateGoodsFeedbackRequest = $this->deserialize($generateGoodsFeedbackRequest, 'OpenAPI\Server\Model\GenerateGoodsFeedbackRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateGoodsFeedbackRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateGoodsFeedbackRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateGoodsFeedbackReport($generateGoodsFeedbackRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateGoodsMovementReport
     *
     * Отчет по движению товаров
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateGoodsMovementReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateGoodsMovementReportRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateGoodsMovementReportRequest = $this->deserialize($generateGoodsMovementReportRequest, 'OpenAPI\Server\Model\GenerateGoodsMovementReportRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateGoodsMovementReportRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateGoodsMovementReportRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateGoodsMovementReport($generateGoodsMovementReportRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateGoodsRealizationReport
     *
     * Отчет по реализации
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateGoodsRealizationReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateGoodsRealizationReportRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateGoodsRealizationReportRequest = $this->deserialize($generateGoodsRealizationReportRequest, 'OpenAPI\Server\Model\GenerateGoodsRealizationReportRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateGoodsRealizationReportRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateGoodsRealizationReportRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateGoodsRealizationReport($generateGoodsRealizationReportRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateGoodsTurnoverReport
     *
     * Отчет по оборачиваемости
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateGoodsTurnoverReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateGoodsTurnoverRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateGoodsTurnoverRequest = $this->deserialize($generateGoodsTurnoverRequest, 'OpenAPI\Server\Model\GenerateGoodsTurnoverRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateGoodsTurnoverRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateGoodsTurnoverRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateGoodsTurnoverReport($generateGoodsTurnoverRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateMassOrderLabelsReport
     *
     * Готовые ярлыки‑наклейки на все коробки в нескольких заказах
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateMassOrderLabelsReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateMassOrderLabelsRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateMassOrderLabelsRequest = $this->deserialize($generateMassOrderLabelsRequest, 'OpenAPI\Server\Model\GenerateMassOrderLabelsRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\PageFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateMassOrderLabelsRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateMassOrderLabelsRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\PageFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateMassOrderLabelsReport($generateMassOrderLabelsRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый файл.  Если при генерации не удалось найти часть заказов, в ответе на запрос получения готового файла вернется подстатус &#x60;RESOURCE_NOT_FOUND&#x60;.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generatePricesReport
     *
     * Отчет «Цены на рынке»
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generatePricesReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generatePricesReportRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generatePricesReportRequest = $this->deserialize($generatePricesReportRequest, 'OpenAPI\Server\Model\GeneratePricesReportRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GeneratePricesReportRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generatePricesReportRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generatePricesReport($generatePricesReportRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateShelfsStatisticsReport
     *
     * Отчет по полкам
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateShelfsStatisticsReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateShelfsStatisticsRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateShelfsStatisticsRequest = $this->deserialize($generateShelfsStatisticsRequest, 'OpenAPI\Server\Model\GenerateShelfsStatisticsRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateShelfsStatisticsRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateShelfsStatisticsRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateShelfsStatisticsReport($generateShelfsStatisticsRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateShipmentListDocumentReport
     *
     * Получение листа сборки
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateShipmentListDocumentReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $generateShipmentListDocumentReportRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateShipmentListDocumentReportRequest = $this->deserialize($generateShipmentListDocumentReportRequest, 'OpenAPI\Server\Model\GenerateShipmentListDocumentReportRequest', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateShipmentListDocumentReportRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateShipmentListDocumentReportRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateShipmentListDocumentReport($generateShipmentListDocumentReportRequest, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый документ.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateShowsSalesReport
     *
     * Отчет «Аналитика продаж»
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateShowsSalesReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateShowsSalesReportRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateShowsSalesReportRequest = $this->deserialize($generateShowsSalesReportRequest, 'OpenAPI\Server\Model\GenerateShowsSalesReportRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateShowsSalesReportRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateShowsSalesReportRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateShowsSalesReport($generateShowsSalesReportRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateStocksOnWarehousesReport
     *
     * Отчет по остаткам на складах
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateStocksOnWarehousesReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateStocksOnWarehousesReportRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateStocksOnWarehousesReportRequest = $this->deserialize($generateStocksOnWarehousesReportRequest, 'OpenAPI\Server\Model\GenerateStocksOnWarehousesReportRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateStocksOnWarehousesReportRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateStocksOnWarehousesReportRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateStocksOnWarehousesReport($generateStocksOnWarehousesReportRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateUnitedMarketplaceServicesReport
     *
     * Отчет по стоимости услуг
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateUnitedMarketplaceServicesReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateUnitedMarketplaceServicesReportRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateUnitedMarketplaceServicesReportRequest = $this->deserialize($generateUnitedMarketplaceServicesReportRequest, 'OpenAPI\Server\Model\GenerateUnitedMarketplaceServicesReportRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateUnitedMarketplaceServicesReportRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateUnitedMarketplaceServicesReportRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateUnitedMarketplaceServicesReport($generateUnitedMarketplaceServicesReportRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateUnitedNettingReport
     *
     * Отчет по платежам
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateUnitedNettingReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateUnitedNettingReportRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateUnitedNettingReportRequest = $this->deserialize($generateUnitedNettingReportRequest, 'OpenAPI\Server\Model\GenerateUnitedNettingReportRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateUnitedNettingReportRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateUnitedNettingReportRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateUnitedNettingReport($generateUnitedNettingReportRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation generateUnitedOrdersReport
     *
     * Отчет по заказам
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function generateUnitedOrdersReportAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $format = $request->query->get('format');
        $generateUnitedOrdersRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $generateUnitedOrdersRequest = $this->deserialize($generateUnitedOrdersRequest, 'OpenAPI\Server\Model\GenerateUnitedOrdersRequest', $inputFormat);
            $format = $this->deserialize($format, '\OpenAPI\Server\Model\ReportFormatType', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\GenerateUnitedOrdersRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($generateUnitedOrdersRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\ReportFormatType");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->generateUnitedOrdersReport($generateUnitedOrdersRequest, $format, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет.',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getReportInfo
     *
     * Получение заданного отчета
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getReportInfoAction(Request $request, $reportId)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'OAuth' required
        // Oauth required
        $securityOAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $reportId = $this->deserialize($reportId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($reportId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'OAuth'
            $handler->setOAuth($securityOAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getReportInfo($reportId, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Статус генерации отчета и ссылка, если она уже есть.  {% note tip %}  Если статус генерации отчета — &#x60;FAILED&#x60; или &#x60;NO_DATA&#x60;, проверьте корректность запроса на генерацию. Например, верно ли указан идентификатор магазина, период или номер платежного поручения.  {% endnote %}   ',
                400 => 'Запрос содержит неправильные данные.',
                401 => 'В запросе не указаны данные для авторизации.',
                403 => 'Данные для авторизации неверны или доступ к ресурсу запрещен.',
                404 => 'Запрашиваемый ресурс не найден.',
                420 => 'Превышено ограничение на доступ к ресурсу.',
                500 => 'Внутренняя ошибка сервера.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Returns the handler for this API controller.
     * @return ReportsApiInterface
     */
    public function getApiHandler()
    {
        return $this->apiServer->getApiHandler('reports');
    }
}
