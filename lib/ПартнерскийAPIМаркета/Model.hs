{-
   Партнерский API Маркета

   API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 

   OpenAPI Version: 3.0.3
   Партнерский API Маркета API version: LATEST
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : ПартнерскийAPIМаркета.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module ПартнерскийAPIМаркета.Model where

import ПартнерскийAPIМаркета.Core
import ПартнерскийAPIМаркета.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Archived
newtype Archived = Archived { unArchived :: Bool } deriving (P.Eq, P.Show)

-- ** Availability
newtype Availability = Availability { unAvailability :: [OfferAvailabilityStatusType] } deriving (P.Eq, P.Show)

-- ** BoxId
newtype BoxId = BoxId { unBoxId :: Integer } deriving (P.Eq, P.Show)

-- ** BusinessId
newtype BusinessId = BusinessId { unBusinessId :: Integer } deriving (P.Eq, P.Show)

-- ** BuyerType
newtype BuyerType = BuyerType { unBuyerType :: OrderBuyerType } deriving (P.Eq, P.Show)

-- ** CampaignId
newtype CampaignId = CampaignId { unCampaignId :: Integer } deriving (P.Eq, P.Show)

-- ** CancelledOrders
newtype CancelledOrders = CancelledOrders { unCancelledOrders :: Bool } deriving (P.Eq, P.Show)

-- ** CategoryId2
newtype CategoryId2 = CategoryId2 { unCategoryId2 :: [Int] } deriving (P.Eq, P.Show)

-- ** CategoryId3
newtype CategoryId3 = CategoryId3 { unCategoryId3 :: Integer } deriving (P.Eq, P.Show)

-- ** ChatId
newtype ChatId = ChatId { unChatId :: Integer } deriving (P.Eq, P.Show)

-- ** Chunk
newtype Chunk = Chunk { unChunk :: Int } deriving (P.Eq, P.Show)

-- ** Count
newtype Count = Count { unCount :: Int } deriving (P.Eq, P.Show)

-- ** Currency
newtype Currency = Currency { unCurrency :: CurrencyType } deriving (P.Eq, P.Show)

-- ** DispatchType
newtype DispatchType = DispatchType { unDispatchType :: OrderDeliveryDispatchType } deriving (P.Eq, P.Show)

-- ** Fake
newtype Fake = Fake { unFake :: Bool } deriving (P.Eq, P.Show)

-- ** FeedId
newtype FeedId = FeedId { unFeedId :: Integer } deriving (P.Eq, P.Show)

-- ** File
newtype File = File { unFile :: FilePath } deriving (P.Eq, P.Show)

-- ** Format
newtype Format = Format { unFormat :: PageFormatType } deriving (P.Eq, P.Show)

-- ** Format2
newtype Format2 = Format2 { unFormat2 :: ShipmentPalletLabelPageFormatType } deriving (P.Eq, P.Show)

-- ** Format3
newtype Format3 = Format3 { unFormat3 :: ReportFormatType } deriving (P.Eq, P.Show)

-- ** FromDate
newtype FromDate = FromDate { unFromDate :: Date } deriving (P.Eq, P.Show)

-- ** FromDate2
newtype FromDate2 = FromDate2 { unFromDate2 :: Date } deriving (P.Eq, P.Show)

-- ** HasCis
newtype HasCis = HasCis { unHasCis :: Bool } deriving (P.Eq, P.Show)

-- ** Ids
newtype Ids = Ids { unIds :: [Integer] } deriving (P.Eq, P.Show)

-- ** ImageHash
newtype ImageHash = ImageHash { unImageHash :: Text } deriving (P.Eq, P.Show)

-- ** ItemId
newtype ItemId = ItemId { unItemId :: Integer } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** Login
newtype Login = Login { unLogin :: Text } deriving (P.Eq, P.Show)

-- ** MappingKind
newtype MappingKind = MappingKind { unMappingKind :: OfferMappingKindType } deriving (P.Eq, P.Show)

-- ** Matched
newtype Matched = Matched { unMatched :: Bool } deriving (P.Eq, P.Show)

-- ** ModelId
newtype ModelId = ModelId { unModelId :: Integer } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** OfferId
newtype OfferId = OfferId { unOfferId :: [Text] } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** OnlyEstimatedDelivery
newtype OnlyEstimatedDelivery = OnlyEstimatedDelivery { unOnlyEstimatedDelivery :: Bool } deriving (P.Eq, P.Show)

-- ** OnlyWaitingForCancellationApprove
newtype OnlyWaitingForCancellationApprove = OnlyWaitingForCancellationApprove { unOnlyWaitingForCancellationApprove :: Bool } deriving (P.Eq, P.Show)

-- ** OrderByPrice
newtype OrderByPrice = OrderByPrice { unOrderByPrice :: SortOrderType } deriving (P.Eq, P.Show)

-- ** OrderId
newtype OrderId = OrderId { unOrderId :: Integer } deriving (P.Eq, P.Show)

-- ** OrderIds
newtype OrderIds = OrderIds { unOrderIds :: [Integer] } deriving (P.Eq, P.Show)

-- ** OutletId
newtype OutletId = OutletId { unOutletId :: Integer } deriving (P.Eq, P.Show)

-- ** OutletIds
newtype OutletIds = OutletIds { unOutletIds :: [Integer] } deriving (P.Eq, P.Show)

-- ** Page
newtype Page = Page { unPage :: Int } deriving (P.Eq, P.Show)

-- ** PageSize
newtype PageSize = PageSize { unPageSize :: Int } deriving (P.Eq, P.Show)

-- ** PageToken
newtype PageToken = PageToken { unPageToken :: Text } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: ReturnType } deriving (P.Eq, P.Show)

-- ** PublishedTimeFrom
newtype PublishedTimeFrom = PublishedTimeFrom { unPublishedTimeFrom :: DateTime } deriving (P.Eq, P.Show)

-- ** PublishedTimeTo
newtype PublishedTimeTo = PublishedTimeTo { unPublishedTimeTo :: DateTime } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** RegionId
newtype RegionId = RegionId { unRegionId :: Integer } deriving (P.Eq, P.Show)

-- ** RegionId2
newtype RegionId2 = RegionId2 { unRegionId2 :: Integer } deriving (P.Eq, P.Show)

-- ** ReportId
newtype ReportId = ReportId { unReportId :: Text } deriving (P.Eq, P.Show)

-- ** ReturnId
newtype ReturnId = ReturnId { unReturnId :: Integer } deriving (P.Eq, P.Show)

-- ** ShipmentId
newtype ShipmentId = ShipmentId { unShipmentId :: Integer } deriving (P.Eq, P.Show)

-- ** ShopCategoryId
newtype ShopCategoryId = ShopCategoryId { unShopCategoryId :: Text } deriving (P.Eq, P.Show)

-- ** ShopOutletCode
newtype ShopOutletCode = ShopOutletCode { unShopOutletCode :: Text } deriving (P.Eq, P.Show)

-- ** ShopSku2
newtype ShopSku2 = ShopSku2 { unShopSku2 :: [Text] } deriving (P.Eq, P.Show)

-- ** Status
newtype Status = Status { unStatus :: [OrderStatusType] } deriving (P.Eq, P.Show)

-- ** Status2
newtype Status2 = Status2 { unStatus2 :: FeedIndexLogsStatusType } deriving (P.Eq, P.Show)

-- ** StatusOfferProcessingStatusType
newtype StatusOfferProcessingStatusType = StatusOfferProcessingStatusType { unStatusOfferProcessingStatusType :: [OfferProcessingStatusType] } deriving (P.Eq, P.Show)

-- ** Statuses
newtype Statuses = Statuses { unStatuses :: [RefundStatusType] } deriving (P.Eq, P.Show)

-- ** Substatus
newtype Substatus = Substatus { unSubstatus :: [OrderSubstatusType] } deriving (P.Eq, P.Show)

-- ** SupplierShipmentDateFrom
newtype SupplierShipmentDateFrom = SupplierShipmentDateFrom { unSupplierShipmentDateFrom :: Date } deriving (P.Eq, P.Show)

-- ** SupplierShipmentDateTo
newtype SupplierShipmentDateTo = SupplierShipmentDateTo { unSupplierShipmentDateTo :: Date } deriving (P.Eq, P.Show)

-- ** ToDate
newtype ToDate = ToDate { unToDate :: Date } deriving (P.Eq, P.Show)

-- ** ToDate2
newtype ToDate2 = ToDate2 { unToDate2 :: Date } deriving (P.Eq, P.Show)

-- ** UpdatedAtFrom
newtype UpdatedAtFrom = UpdatedAtFrom { unUpdatedAtFrom :: DateTime } deriving (P.Eq, P.Show)

-- ** UpdatedAtTo
newtype UpdatedAtTo = UpdatedAtTo { unUpdatedAtTo :: DateTime } deriving (P.Eq, P.Show)

-- ** Vendor
newtype Vendor = Vendor { unVendor :: [Text] } deriving (P.Eq, P.Show)

-- ** WarehouseId
newtype WarehouseId = WarehouseId { unWarehouseId :: Int } deriving (P.Eq, P.Show)

-- * Models


-- ** AcceptOrderCancellationRequest
-- | AcceptOrderCancellationRequest
data AcceptOrderCancellationRequest = AcceptOrderCancellationRequest
  { acceptOrderCancellationRequestAccepted :: !(Bool) -- ^ /Required/ "accepted" - Решение об отмене заказа:  * &#x60;true&#x60; — заказ отменяется, служба доставки узнала об отмене до передачи заказа покупателю. * &#x60;false&#x60; — заказ не отменяется, так как он уже доставлен покупателю курьером или передан в пункт выдачи заказов. 
  , acceptOrderCancellationRequestReason :: !(Maybe OrderCancellationReasonType) -- ^ "reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AcceptOrderCancellationRequest
instance A.FromJSON AcceptOrderCancellationRequest where
  parseJSON = A.withObject "AcceptOrderCancellationRequest" $ \o ->
    AcceptOrderCancellationRequest
      <$> (o .:  "accepted")
      <*> (o .:? "reason")

-- | ToJSON AcceptOrderCancellationRequest
instance A.ToJSON AcceptOrderCancellationRequest where
  toJSON AcceptOrderCancellationRequest {..} =
   _omitNulls
      [ "accepted" .= acceptOrderCancellationRequestAccepted
      , "reason" .= acceptOrderCancellationRequestReason
      ]


-- | Construct a value of type 'AcceptOrderCancellationRequest' (by applying it's required fields, if any)
mkAcceptOrderCancellationRequest
  :: Bool -- ^ 'acceptOrderCancellationRequestAccepted': Решение об отмене заказа:  * `true` — заказ отменяется, служба доставки узнала об отмене до передачи заказа покупателю. * `false` — заказ не отменяется, так как он уже доставлен покупателю курьером или передан в пункт выдачи заказов. 
  -> AcceptOrderCancellationRequest
mkAcceptOrderCancellationRequest acceptOrderCancellationRequestAccepted =
  AcceptOrderCancellationRequest
  { acceptOrderCancellationRequestAccepted
  , acceptOrderCancellationRequestReason = Nothing
  }

-- ** AddHiddenOffersRequest
-- | AddHiddenOffersRequest
-- Запрос на скрытие оферов.
data AddHiddenOffersRequest = AddHiddenOffersRequest
  { addHiddenOffersRequestHiddenOffers :: !([HiddenOfferDTO]) -- ^ /Required/ "hiddenOffers" - Список скрытых товаров. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddHiddenOffersRequest
instance A.FromJSON AddHiddenOffersRequest where
  parseJSON = A.withObject "AddHiddenOffersRequest" $ \o ->
    AddHiddenOffersRequest
      <$> (o .:  "hiddenOffers")

-- | ToJSON AddHiddenOffersRequest
instance A.ToJSON AddHiddenOffersRequest where
  toJSON AddHiddenOffersRequest {..} =
   _omitNulls
      [ "hiddenOffers" .= addHiddenOffersRequestHiddenOffers
      ]


-- | Construct a value of type 'AddHiddenOffersRequest' (by applying it's required fields, if any)
mkAddHiddenOffersRequest
  :: [HiddenOfferDTO] -- ^ 'addHiddenOffersRequestHiddenOffers': Список скрытых товаров. 
  -> AddHiddenOffersRequest
mkAddHiddenOffersRequest addHiddenOffersRequestHiddenOffers =
  AddHiddenOffersRequest
  { addHiddenOffersRequestHiddenOffers
  }

-- ** AddOffersToArchiveDTO
-- | AddOffersToArchiveDTO
-- Товары, которые не удалось поместить в архив.
data AddOffersToArchiveDTO = AddOffersToArchiveDTO
  { addOffersToArchiveDTONotArchivedOffers :: !(Maybe [AddOffersToArchiveErrorDTO]) -- ^ "notArchivedOffers" - Список товаров, которые не удалось поместить в архив.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddOffersToArchiveDTO
instance A.FromJSON AddOffersToArchiveDTO where
  parseJSON = A.withObject "AddOffersToArchiveDTO" $ \o ->
    AddOffersToArchiveDTO
      <$> (o .:? "notArchivedOffers")

-- | ToJSON AddOffersToArchiveDTO
instance A.ToJSON AddOffersToArchiveDTO where
  toJSON AddOffersToArchiveDTO {..} =
   _omitNulls
      [ "notArchivedOffers" .= addOffersToArchiveDTONotArchivedOffers
      ]


-- | Construct a value of type 'AddOffersToArchiveDTO' (by applying it's required fields, if any)
mkAddOffersToArchiveDTO
  :: AddOffersToArchiveDTO
mkAddOffersToArchiveDTO =
  AddOffersToArchiveDTO
  { addOffersToArchiveDTONotArchivedOffers = Nothing
  }

-- ** AddOffersToArchiveErrorDTO
-- | AddOffersToArchiveErrorDTO
-- Товар, который не удалось поместить в архив.
data AddOffersToArchiveErrorDTO = AddOffersToArchiveErrorDTO
  { addOffersToArchiveErrorDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , addOffersToArchiveErrorDTOError :: !(AddOffersToArchiveErrorType) -- ^ /Required/ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddOffersToArchiveErrorDTO
instance A.FromJSON AddOffersToArchiveErrorDTO where
  parseJSON = A.withObject "AddOffersToArchiveErrorDTO" $ \o ->
    AddOffersToArchiveErrorDTO
      <$> (o .:  "offerId")
      <*> (o .:  "error")

-- | ToJSON AddOffersToArchiveErrorDTO
instance A.ToJSON AddOffersToArchiveErrorDTO where
  toJSON AddOffersToArchiveErrorDTO {..} =
   _omitNulls
      [ "offerId" .= addOffersToArchiveErrorDTOOfferId
      , "error" .= addOffersToArchiveErrorDTOError
      ]


-- | Construct a value of type 'AddOffersToArchiveErrorDTO' (by applying it's required fields, if any)
mkAddOffersToArchiveErrorDTO
  :: Text -- ^ 'addOffersToArchiveErrorDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> AddOffersToArchiveErrorType -- ^ 'addOffersToArchiveErrorDTOError' 
  -> AddOffersToArchiveErrorDTO
mkAddOffersToArchiveErrorDTO addOffersToArchiveErrorDTOOfferId addOffersToArchiveErrorDTOError =
  AddOffersToArchiveErrorDTO
  { addOffersToArchiveErrorDTOOfferId
  , addOffersToArchiveErrorDTOError
  }

-- ** AddOffersToArchiveRequest
-- | AddOffersToArchiveRequest
-- Товары, которые нужно поместить в архив. 
data AddOffersToArchiveRequest = AddOffersToArchiveRequest
  { addOffersToArchiveRequestOfferIds :: !([Text]) -- ^ /Required/ "offerIds" - Список товаров, которые нужно поместить в архив.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddOffersToArchiveRequest
instance A.FromJSON AddOffersToArchiveRequest where
  parseJSON = A.withObject "AddOffersToArchiveRequest" $ \o ->
    AddOffersToArchiveRequest
      <$> (o .:  "offerIds")

-- | ToJSON AddOffersToArchiveRequest
instance A.ToJSON AddOffersToArchiveRequest where
  toJSON AddOffersToArchiveRequest {..} =
   _omitNulls
      [ "offerIds" .= addOffersToArchiveRequestOfferIds
      ]


-- | Construct a value of type 'AddOffersToArchiveRequest' (by applying it's required fields, if any)
mkAddOffersToArchiveRequest
  :: [Text] -- ^ 'addOffersToArchiveRequestOfferIds': Список товаров, которые нужно поместить в архив.
  -> AddOffersToArchiveRequest
mkAddOffersToArchiveRequest addOffersToArchiveRequestOfferIds =
  AddOffersToArchiveRequest
  { addOffersToArchiveRequestOfferIds
  }

-- ** AddOffersToArchiveResponse
-- | AddOffersToArchiveResponse
-- Результат архивации товаров.
data AddOffersToArchiveResponse = AddOffersToArchiveResponse
  { addOffersToArchiveResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , addOffersToArchiveResponseResult :: !(Maybe AddOffersToArchiveDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddOffersToArchiveResponse
instance A.FromJSON AddOffersToArchiveResponse where
  parseJSON = A.withObject "AddOffersToArchiveResponse" $ \o ->
    AddOffersToArchiveResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON AddOffersToArchiveResponse
instance A.ToJSON AddOffersToArchiveResponse where
  toJSON AddOffersToArchiveResponse {..} =
   _omitNulls
      [ "status" .= addOffersToArchiveResponseStatus
      , "result" .= addOffersToArchiveResponseResult
      ]


-- | Construct a value of type 'AddOffersToArchiveResponse' (by applying it's required fields, if any)
mkAddOffersToArchiveResponse
  :: AddOffersToArchiveResponse
mkAddOffersToArchiveResponse =
  AddOffersToArchiveResponse
  { addOffersToArchiveResponseStatus = Nothing
  , addOffersToArchiveResponseResult = Nothing
  }

-- ** AgeDTO
-- | AgeDTO
-- Возраст в заданных единицах измерения.
data AgeDTO = AgeDTO
  { ageDTOValue :: !(Double) -- ^ /Required/ "value" - Значение. 
  , ageDTOAgeUnit :: !(AgeUnitType) -- ^ /Required/ "ageUnit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AgeDTO
instance A.FromJSON AgeDTO where
  parseJSON = A.withObject "AgeDTO" $ \o ->
    AgeDTO
      <$> (o .:  "value")
      <*> (o .:  "ageUnit")

-- | ToJSON AgeDTO
instance A.ToJSON AgeDTO where
  toJSON AgeDTO {..} =
   _omitNulls
      [ "value" .= ageDTOValue
      , "ageUnit" .= ageDTOAgeUnit
      ]


-- | Construct a value of type 'AgeDTO' (by applying it's required fields, if any)
mkAgeDTO
  :: Double -- ^ 'ageDTOValue': Значение. 
  -> AgeUnitType -- ^ 'ageDTOAgeUnit' 
  -> AgeDTO
mkAgeDTO ageDTOValue ageDTOAgeUnit =
  AgeDTO
  { ageDTOValue
  , ageDTOAgeUnit
  }

-- ** ApiClientDataErrorResponse
-- | ApiClientDataErrorResponse
-- Ошибка в данных переданных от клиента.
data ApiClientDataErrorResponse = ApiClientDataErrorResponse
  { apiClientDataErrorResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , apiClientDataErrorResponseErrors :: !(Maybe [ApiErrorDTO]) -- ^ "errors" - Список ошибок.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiClientDataErrorResponse
instance A.FromJSON ApiClientDataErrorResponse where
  parseJSON = A.withObject "ApiClientDataErrorResponse" $ \o ->
    ApiClientDataErrorResponse
      <$> (o .:? "status")
      <*> (o .:? "errors")

-- | ToJSON ApiClientDataErrorResponse
instance A.ToJSON ApiClientDataErrorResponse where
  toJSON ApiClientDataErrorResponse {..} =
   _omitNulls
      [ "status" .= apiClientDataErrorResponseStatus
      , "errors" .= apiClientDataErrorResponseErrors
      ]


-- | Construct a value of type 'ApiClientDataErrorResponse' (by applying it's required fields, if any)
mkApiClientDataErrorResponse
  :: ApiClientDataErrorResponse
mkApiClientDataErrorResponse =
  ApiClientDataErrorResponse
  { apiClientDataErrorResponseStatus = Nothing
  , apiClientDataErrorResponseErrors = Nothing
  }

-- ** ApiErrorDTO
-- | ApiErrorDTO
-- Общий формат ошибки.
data ApiErrorDTO = ApiErrorDTO
  { apiErrorDTOCode :: !(Text) -- ^ /Required/ "code" - Код ошибки.
  , apiErrorDTOMessage :: !(Maybe Text) -- ^ "message" - Описание ошибки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiErrorDTO
instance A.FromJSON ApiErrorDTO where
  parseJSON = A.withObject "ApiErrorDTO" $ \o ->
    ApiErrorDTO
      <$> (o .:  "code")
      <*> (o .:? "message")

-- | ToJSON ApiErrorDTO
instance A.ToJSON ApiErrorDTO where
  toJSON ApiErrorDTO {..} =
   _omitNulls
      [ "code" .= apiErrorDTOCode
      , "message" .= apiErrorDTOMessage
      ]


-- | Construct a value of type 'ApiErrorDTO' (by applying it's required fields, if any)
mkApiErrorDTO
  :: Text -- ^ 'apiErrorDTOCode': Код ошибки.
  -> ApiErrorDTO
mkApiErrorDTO apiErrorDTOCode =
  ApiErrorDTO
  { apiErrorDTOCode
  , apiErrorDTOMessage = Nothing
  }

-- ** ApiErrorResponse
-- | ApiErrorResponse
-- Стандартная обертка для ошибок сервера.
data ApiErrorResponse = ApiErrorResponse
  { apiErrorResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , apiErrorResponseErrors :: !(Maybe [ApiErrorDTO]) -- ^ "errors" - Список ошибок.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiErrorResponse
instance A.FromJSON ApiErrorResponse where
  parseJSON = A.withObject "ApiErrorResponse" $ \o ->
    ApiErrorResponse
      <$> (o .:? "status")
      <*> (o .:? "errors")

-- | ToJSON ApiErrorResponse
instance A.ToJSON ApiErrorResponse where
  toJSON ApiErrorResponse {..} =
   _omitNulls
      [ "status" .= apiErrorResponseStatus
      , "errors" .= apiErrorResponseErrors
      ]


-- | Construct a value of type 'ApiErrorResponse' (by applying it's required fields, if any)
mkApiErrorResponse
  :: ApiErrorResponse
mkApiErrorResponse =
  ApiErrorResponse
  { apiErrorResponseStatus = Nothing
  , apiErrorResponseErrors = Nothing
  }

-- ** ApiForbiddenErrorResponse
-- | ApiForbiddenErrorResponse
-- Неверны авторизационные данные, указанные в запросе, или запрещен доступ к запрашиваемому ресурсу.
data ApiForbiddenErrorResponse = ApiForbiddenErrorResponse
  { apiForbiddenErrorResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , apiForbiddenErrorResponseErrors :: !(Maybe [ApiErrorDTO]) -- ^ "errors" - Список ошибок.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiForbiddenErrorResponse
instance A.FromJSON ApiForbiddenErrorResponse where
  parseJSON = A.withObject "ApiForbiddenErrorResponse" $ \o ->
    ApiForbiddenErrorResponse
      <$> (o .:? "status")
      <*> (o .:? "errors")

-- | ToJSON ApiForbiddenErrorResponse
instance A.ToJSON ApiForbiddenErrorResponse where
  toJSON ApiForbiddenErrorResponse {..} =
   _omitNulls
      [ "status" .= apiForbiddenErrorResponseStatus
      , "errors" .= apiForbiddenErrorResponseErrors
      ]


-- | Construct a value of type 'ApiForbiddenErrorResponse' (by applying it's required fields, if any)
mkApiForbiddenErrorResponse
  :: ApiForbiddenErrorResponse
mkApiForbiddenErrorResponse =
  ApiForbiddenErrorResponse
  { apiForbiddenErrorResponseStatus = Nothing
  , apiForbiddenErrorResponseErrors = Nothing
  }

-- ** ApiLimitErrorResponse
-- | ApiLimitErrorResponse
-- Превышено ограничение на доступ к ресурсу.
data ApiLimitErrorResponse = ApiLimitErrorResponse
  { apiLimitErrorResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , apiLimitErrorResponseErrors :: !(Maybe [ApiErrorDTO]) -- ^ "errors" - Список ошибок.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiLimitErrorResponse
instance A.FromJSON ApiLimitErrorResponse where
  parseJSON = A.withObject "ApiLimitErrorResponse" $ \o ->
    ApiLimitErrorResponse
      <$> (o .:? "status")
      <*> (o .:? "errors")

-- | ToJSON ApiLimitErrorResponse
instance A.ToJSON ApiLimitErrorResponse where
  toJSON ApiLimitErrorResponse {..} =
   _omitNulls
      [ "status" .= apiLimitErrorResponseStatus
      , "errors" .= apiLimitErrorResponseErrors
      ]


-- | Construct a value of type 'ApiLimitErrorResponse' (by applying it's required fields, if any)
mkApiLimitErrorResponse
  :: ApiLimitErrorResponse
mkApiLimitErrorResponse =
  ApiLimitErrorResponse
  { apiLimitErrorResponseStatus = Nothing
  , apiLimitErrorResponseErrors = Nothing
  }

-- ** ApiLockedErrorResponse
-- | ApiLockedErrorResponse
-- Ресурс из запроса заблокирован от применения к нему указанного метода.
data ApiLockedErrorResponse = ApiLockedErrorResponse
  { apiLockedErrorResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , apiLockedErrorResponseErrors :: !(Maybe [ApiErrorDTO]) -- ^ "errors" - Список ошибок.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiLockedErrorResponse
instance A.FromJSON ApiLockedErrorResponse where
  parseJSON = A.withObject "ApiLockedErrorResponse" $ \o ->
    ApiLockedErrorResponse
      <$> (o .:? "status")
      <*> (o .:? "errors")

-- | ToJSON ApiLockedErrorResponse
instance A.ToJSON ApiLockedErrorResponse where
  toJSON ApiLockedErrorResponse {..} =
   _omitNulls
      [ "status" .= apiLockedErrorResponseStatus
      , "errors" .= apiLockedErrorResponseErrors
      ]


-- | Construct a value of type 'ApiLockedErrorResponse' (by applying it's required fields, if any)
mkApiLockedErrorResponse
  :: ApiLockedErrorResponse
mkApiLockedErrorResponse =
  ApiLockedErrorResponse
  { apiLockedErrorResponseStatus = Nothing
  , apiLockedErrorResponseErrors = Nothing
  }

-- ** ApiNotFoundErrorResponse
-- | ApiNotFoundErrorResponse
-- Запрашиваемый ресурс не найден.
data ApiNotFoundErrorResponse = ApiNotFoundErrorResponse
  { apiNotFoundErrorResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , apiNotFoundErrorResponseErrors :: !(Maybe [ApiErrorDTO]) -- ^ "errors" - Список ошибок.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiNotFoundErrorResponse
instance A.FromJSON ApiNotFoundErrorResponse where
  parseJSON = A.withObject "ApiNotFoundErrorResponse" $ \o ->
    ApiNotFoundErrorResponse
      <$> (o .:? "status")
      <*> (o .:? "errors")

-- | ToJSON ApiNotFoundErrorResponse
instance A.ToJSON ApiNotFoundErrorResponse where
  toJSON ApiNotFoundErrorResponse {..} =
   _omitNulls
      [ "status" .= apiNotFoundErrorResponseStatus
      , "errors" .= apiNotFoundErrorResponseErrors
      ]


-- | Construct a value of type 'ApiNotFoundErrorResponse' (by applying it's required fields, if any)
mkApiNotFoundErrorResponse
  :: ApiNotFoundErrorResponse
mkApiNotFoundErrorResponse =
  ApiNotFoundErrorResponse
  { apiNotFoundErrorResponseStatus = Nothing
  , apiNotFoundErrorResponseErrors = Nothing
  }

-- ** ApiResponse
-- | ApiResponse
-- Стандартная обертка для ответов сервера.
data ApiResponse = ApiResponse
  { apiResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiResponse
instance A.FromJSON ApiResponse where
  parseJSON = A.withObject "ApiResponse" $ \o ->
    ApiResponse
      <$> (o .:? "status")

-- | ToJSON ApiResponse
instance A.ToJSON ApiResponse where
  toJSON ApiResponse {..} =
   _omitNulls
      [ "status" .= apiResponseStatus
      ]


-- | Construct a value of type 'ApiResponse' (by applying it's required fields, if any)
mkApiResponse
  :: ApiResponse
mkApiResponse =
  ApiResponse
  { apiResponseStatus = Nothing
  }

-- ** ApiServerErrorResponse
-- | ApiServerErrorResponse
-- Внутренняя ошибка сервера.
data ApiServerErrorResponse = ApiServerErrorResponse
  { apiServerErrorResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , apiServerErrorResponseErrors :: !(Maybe [ApiErrorDTO]) -- ^ "errors" - Список ошибок.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiServerErrorResponse
instance A.FromJSON ApiServerErrorResponse where
  parseJSON = A.withObject "ApiServerErrorResponse" $ \o ->
    ApiServerErrorResponse
      <$> (o .:? "status")
      <*> (o .:? "errors")

-- | ToJSON ApiServerErrorResponse
instance A.ToJSON ApiServerErrorResponse where
  toJSON ApiServerErrorResponse {..} =
   _omitNulls
      [ "status" .= apiServerErrorResponseStatus
      , "errors" .= apiServerErrorResponseErrors
      ]


-- | Construct a value of type 'ApiServerErrorResponse' (by applying it's required fields, if any)
mkApiServerErrorResponse
  :: ApiServerErrorResponse
mkApiServerErrorResponse =
  ApiServerErrorResponse
  { apiServerErrorResponseStatus = Nothing
  , apiServerErrorResponseErrors = Nothing
  }

-- ** ApiUnauthorizedErrorResponse
-- | ApiUnauthorizedErrorResponse
-- В запросе не указаны авторизационные данные.
data ApiUnauthorizedErrorResponse = ApiUnauthorizedErrorResponse
  { apiUnauthorizedErrorResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , apiUnauthorizedErrorResponseErrors :: !(Maybe [ApiErrorDTO]) -- ^ "errors" - Список ошибок.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiUnauthorizedErrorResponse
instance A.FromJSON ApiUnauthorizedErrorResponse where
  parseJSON = A.withObject "ApiUnauthorizedErrorResponse" $ \o ->
    ApiUnauthorizedErrorResponse
      <$> (o .:? "status")
      <*> (o .:? "errors")

-- | ToJSON ApiUnauthorizedErrorResponse
instance A.ToJSON ApiUnauthorizedErrorResponse where
  toJSON ApiUnauthorizedErrorResponse {..} =
   _omitNulls
      [ "status" .= apiUnauthorizedErrorResponseStatus
      , "errors" .= apiUnauthorizedErrorResponseErrors
      ]


-- | Construct a value of type 'ApiUnauthorizedErrorResponse' (by applying it's required fields, if any)
mkApiUnauthorizedErrorResponse
  :: ApiUnauthorizedErrorResponse
mkApiUnauthorizedErrorResponse =
  ApiUnauthorizedErrorResponse
  { apiUnauthorizedErrorResponseStatus = Nothing
  , apiUnauthorizedErrorResponseErrors = Nothing
  }

-- ** BaseCampaignOfferDTO
-- | BaseCampaignOfferDTO
-- Информация о новой цене на товар.
data BaseCampaignOfferDTO = BaseCampaignOfferDTO
  { baseCampaignOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , baseCampaignOfferDTOQuantum :: !(Maybe QuantumDTO) -- ^ "quantum"
  , baseCampaignOfferDTOAvailable :: !(Maybe Bool) -- ^ "available" - Есть ли товар в продаже. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BaseCampaignOfferDTO
instance A.FromJSON BaseCampaignOfferDTO where
  parseJSON = A.withObject "BaseCampaignOfferDTO" $ \o ->
    BaseCampaignOfferDTO
      <$> (o .:  "offerId")
      <*> (o .:? "quantum")
      <*> (o .:? "available")

-- | ToJSON BaseCampaignOfferDTO
instance A.ToJSON BaseCampaignOfferDTO where
  toJSON BaseCampaignOfferDTO {..} =
   _omitNulls
      [ "offerId" .= baseCampaignOfferDTOOfferId
      , "quantum" .= baseCampaignOfferDTOQuantum
      , "available" .= baseCampaignOfferDTOAvailable
      ]


-- | Construct a value of type 'BaseCampaignOfferDTO' (by applying it's required fields, if any)
mkBaseCampaignOfferDTO
  :: Text -- ^ 'baseCampaignOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> BaseCampaignOfferDTO
mkBaseCampaignOfferDTO baseCampaignOfferDTOOfferId =
  BaseCampaignOfferDTO
  { baseCampaignOfferDTOOfferId
  , baseCampaignOfferDTOQuantum = Nothing
  , baseCampaignOfferDTOAvailable = Nothing
  }

-- ** BaseOfferDTO
-- | BaseOfferDTO
-- Основные параметры товара.
data BaseOfferDTO = BaseOfferDTO
  { baseOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , baseOfferDTOName :: !(Maybe Text) -- ^ "name" - Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
  , baseOfferDTOMarketCategoryId :: !(Maybe Integer) -- ^ "marketCategoryId" - Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать &#x60;marketCategoryId&#x60;, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
  , baseOfferDTOCategory :: !(Maybe Text) -- ^ "category" - Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;. 
  , baseOfferDTOPictures :: !(Maybe [Text]) -- ^ "pictures" - Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ &#x60;https://example-shop.ru/images/sku12345.jpg&#x60;  ✅ &#x60;https://yadi.sk/i/NaBoRsimVOLov&#x60;  ❌ &#x60;/images/sku12345.jpg&#x60;  ❌ &#x60;https://www.dropbox.com/s/818f/tovar.jpg&#x60;  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html) 
  , baseOfferDTOVideos :: !(Maybe [Text]) -- ^ "videos" - Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ &#x60;https://example-shop.ru/video/sku12345.avi&#x60;  ✅ &#x60;https://yadi.sk/i/NaBoRsimVOLov&#x60;  ❌ &#x60;/video/sku12345.avi&#x60;  ❌ &#x60;https://www.dropbox.com/s/818f/super-tovar.avi&#x60;  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html) 
  , baseOfferDTOManuals :: !(Maybe [OfferManualDTO]) -- ^ "manuals" - Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле &#x60;manuals&#x60;, загруженные ранее инструкции удалятся. 
  , baseOfferDTOVendor :: !(Maybe Text) -- ^ "vendor" - Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
  , baseOfferDTOBarcodes :: !(Maybe [Text]) -- ^ "barcodes" - Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
  , baseOfferDTODescription :: !(Maybe Text) -- ^ "description" - Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\&lt;h&gt;, \\&lt;h1&gt;, \\&lt;h2&gt; и так далее — для заголовков; * \\&lt;br&gt; и \\&lt;p&gt; — для переноса строки; * \\&lt;ol&gt; — для нумерованного списка; * \\&lt;ul&gt; — для маркированного списка; * \\&lt;li&gt; — для создания элементов списка (должен находиться внутри \\&lt;ol&gt; или \\&lt;ul&gt;); * \\&lt;div&gt; — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
  , baseOfferDTOManufacturerCountries :: !(Maybe [Text]) -- ^ "manufacturerCountries" - Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx). 
  , baseOfferDTOWeightDimensions :: !(Maybe OfferWeightDimensionsDTO) -- ^ "weightDimensions"
  , baseOfferDTOVendorCode :: !(Maybe Text) -- ^ "vendorCode" - Артикул товара от производителя.
  , baseOfferDTOTags :: !(Maybe [Text]) -- ^ "tags" - Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов. 
  , baseOfferDTOShelfLife :: !(Maybe TimePeriodDTO) -- ^ "shelfLife"
  , baseOfferDTOLifeTime :: !(Maybe TimePeriodDTO) -- ^ "lifeTime"
  , baseOfferDTOGuaranteePeriod :: !(Maybe TimePeriodDTO) -- ^ "guaranteePeriod"
  , baseOfferDTOCustomsCommodityCode :: !(Maybe Text) -- ^ "customsCommodityCode" - Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть. 
  , baseOfferDTOCertificates :: !(Maybe [Text]) -- ^ "certificates" - Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html). 
  , baseOfferDTOBoxCount :: !(Maybe Int) -- ^ "boxCount" - Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр. 
  , baseOfferDTOCondition :: !(Maybe OfferConditionDTO) -- ^ "condition"
  , baseOfferDTOType :: !(Maybe OfferType) -- ^ "type"
  , baseOfferDTODownloadable :: !(Maybe Bool) -- ^ "downloadable" - Признак цифрового товара. Укажите &#x60;true&#x60;, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md) 
  , baseOfferDTOAdult :: !(Maybe Bool) -- ^ "adult" - Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей. 
  , baseOfferDTOAge :: !(Maybe AgeDTO) -- ^ "age"
  , baseOfferDTOParams :: !(Maybe [OfferParamDTO]) -- ^ "params" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. При передаче характеристик используйте &#x60;parameterValues&#x60;.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BaseOfferDTO
instance A.FromJSON BaseOfferDTO where
  parseJSON = A.withObject "BaseOfferDTO" $ \o ->
    BaseOfferDTO
      <$> (o .:  "offerId")
      <*> (o .:? "name")
      <*> (o .:? "marketCategoryId")
      <*> (o .:? "category")
      <*> (o .:? "pictures")
      <*> (o .:? "videos")
      <*> (o .:? "manuals")
      <*> (o .:? "vendor")
      <*> (o .:? "barcodes")
      <*> (o .:? "description")
      <*> (o .:? "manufacturerCountries")
      <*> (o .:? "weightDimensions")
      <*> (o .:? "vendorCode")
      <*> (o .:? "tags")
      <*> (o .:? "shelfLife")
      <*> (o .:? "lifeTime")
      <*> (o .:? "guaranteePeriod")
      <*> (o .:? "customsCommodityCode")
      <*> (o .:? "certificates")
      <*> (o .:? "boxCount")
      <*> (o .:? "condition")
      <*> (o .:? "type")
      <*> (o .:? "downloadable")
      <*> (o .:? "adult")
      <*> (o .:? "age")
      <*> (o .:? "params")

-- | ToJSON BaseOfferDTO
instance A.ToJSON BaseOfferDTO where
  toJSON BaseOfferDTO {..} =
   _omitNulls
      [ "offerId" .= baseOfferDTOOfferId
      , "name" .= baseOfferDTOName
      , "marketCategoryId" .= baseOfferDTOMarketCategoryId
      , "category" .= baseOfferDTOCategory
      , "pictures" .= baseOfferDTOPictures
      , "videos" .= baseOfferDTOVideos
      , "manuals" .= baseOfferDTOManuals
      , "vendor" .= baseOfferDTOVendor
      , "barcodes" .= baseOfferDTOBarcodes
      , "description" .= baseOfferDTODescription
      , "manufacturerCountries" .= baseOfferDTOManufacturerCountries
      , "weightDimensions" .= baseOfferDTOWeightDimensions
      , "vendorCode" .= baseOfferDTOVendorCode
      , "tags" .= baseOfferDTOTags
      , "shelfLife" .= baseOfferDTOShelfLife
      , "lifeTime" .= baseOfferDTOLifeTime
      , "guaranteePeriod" .= baseOfferDTOGuaranteePeriod
      , "customsCommodityCode" .= baseOfferDTOCustomsCommodityCode
      , "certificates" .= baseOfferDTOCertificates
      , "boxCount" .= baseOfferDTOBoxCount
      , "condition" .= baseOfferDTOCondition
      , "type" .= baseOfferDTOType
      , "downloadable" .= baseOfferDTODownloadable
      , "adult" .= baseOfferDTOAdult
      , "age" .= baseOfferDTOAge
      , "params" .= baseOfferDTOParams
      ]


-- | Construct a value of type 'BaseOfferDTO' (by applying it's required fields, if any)
mkBaseOfferDTO
  :: Text -- ^ 'baseOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> BaseOfferDTO
mkBaseOfferDTO baseOfferDTOOfferId =
  BaseOfferDTO
  { baseOfferDTOOfferId
  , baseOfferDTOName = Nothing
  , baseOfferDTOMarketCategoryId = Nothing
  , baseOfferDTOCategory = Nothing
  , baseOfferDTOPictures = Nothing
  , baseOfferDTOVideos = Nothing
  , baseOfferDTOManuals = Nothing
  , baseOfferDTOVendor = Nothing
  , baseOfferDTOBarcodes = Nothing
  , baseOfferDTODescription = Nothing
  , baseOfferDTOManufacturerCountries = Nothing
  , baseOfferDTOWeightDimensions = Nothing
  , baseOfferDTOVendorCode = Nothing
  , baseOfferDTOTags = Nothing
  , baseOfferDTOShelfLife = Nothing
  , baseOfferDTOLifeTime = Nothing
  , baseOfferDTOGuaranteePeriod = Nothing
  , baseOfferDTOCustomsCommodityCode = Nothing
  , baseOfferDTOCertificates = Nothing
  , baseOfferDTOBoxCount = Nothing
  , baseOfferDTOCondition = Nothing
  , baseOfferDTOType = Nothing
  , baseOfferDTODownloadable = Nothing
  , baseOfferDTOAdult = Nothing
  , baseOfferDTOAge = Nothing
  , baseOfferDTOParams = Nothing
  }

-- ** BasePriceDTO
-- | BasePriceDTO
-- Цена на товар.
data BasePriceDTO = BasePriceDTO
  { basePriceDTOValue :: !(Double) -- ^ /Required/ "value" - Значение.
  , basePriceDTOCurrencyId :: !(CurrencyType) -- ^ /Required/ "currencyId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasePriceDTO
instance A.FromJSON BasePriceDTO where
  parseJSON = A.withObject "BasePriceDTO" $ \o ->
    BasePriceDTO
      <$> (o .:  "value")
      <*> (o .:  "currencyId")

-- | ToJSON BasePriceDTO
instance A.ToJSON BasePriceDTO where
  toJSON BasePriceDTO {..} =
   _omitNulls
      [ "value" .= basePriceDTOValue
      , "currencyId" .= basePriceDTOCurrencyId
      ]


-- | Construct a value of type 'BasePriceDTO' (by applying it's required fields, if any)
mkBasePriceDTO
  :: Double -- ^ 'basePriceDTOValue': Значение.
  -> CurrencyType -- ^ 'basePriceDTOCurrencyId' 
  -> BasePriceDTO
mkBasePriceDTO basePriceDTOValue basePriceDTOCurrencyId =
  BasePriceDTO
  { basePriceDTOValue
  , basePriceDTOCurrencyId
  }

-- ** BaseShipmentDTO
-- | BaseShipmentDTO
-- Информация об отгрузке.
data BaseShipmentDTO = BaseShipmentDTO
  { baseShipmentDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор отгрузки.
  , baseShipmentDTOPlanIntervalFrom :: !(Maybe DateTime) -- ^ "planIntervalFrom" - Начало планового интервала отгрузки.
  , baseShipmentDTOPlanIntervalTo :: !(Maybe DateTime) -- ^ "planIntervalTo" - Конец планового интервала отгрузки.
  , baseShipmentDTOShipmentType :: !(Maybe ShipmentType) -- ^ "shipmentType"
  , baseShipmentDTOWarehouse :: !(Maybe PartnerShipmentWarehouseDTO) -- ^ "warehouse"
  , baseShipmentDTOWarehouseTo :: !(Maybe PartnerShipmentWarehouseDTO) -- ^ "warehouseTo"
  , baseShipmentDTOExternalId :: !(Maybe Text) -- ^ "externalId" - Идентификатор отгрузки в вашей системе. Если вы еще не передавали идентификатор, вернется идентификатор из параметра &#x60;id&#x60;.
  , baseShipmentDTODeliveryService :: !(Maybe DeliveryServiceDTO) -- ^ "deliveryService"
  , baseShipmentDTOPalletsCount :: !(Maybe PalletsCountDTO) -- ^ "palletsCount"
  , baseShipmentDTOOrderIds :: !([Integer]) -- ^ /Required/ "orderIds" - Идентификаторы заказов в отгрузке.
  , baseShipmentDTODraftCount :: !(Maybe Int) -- ^ "draftCount" - Количество заказов, которое Маркет запланировал к отгрузке.
  , baseShipmentDTOPlannedCount :: !(Maybe Int) -- ^ "plannedCount" - Количество заказов, которое Маркет подтвердил к отгрузке.
  , baseShipmentDTOFactCount :: !(Maybe Int) -- ^ "factCount" - Количество заказов, принятых в сортировочном центре или пункте приема.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BaseShipmentDTO
instance A.FromJSON BaseShipmentDTO where
  parseJSON = A.withObject "BaseShipmentDTO" $ \o ->
    BaseShipmentDTO
      <$> (o .:? "id")
      <*> (o .:? "planIntervalFrom")
      <*> (o .:? "planIntervalTo")
      <*> (o .:? "shipmentType")
      <*> (o .:? "warehouse")
      <*> (o .:? "warehouseTo")
      <*> (o .:? "externalId")
      <*> (o .:? "deliveryService")
      <*> (o .:? "palletsCount")
      <*> (o .:  "orderIds")
      <*> (o .:? "draftCount")
      <*> (o .:? "plannedCount")
      <*> (o .:? "factCount")

-- | ToJSON BaseShipmentDTO
instance A.ToJSON BaseShipmentDTO where
  toJSON BaseShipmentDTO {..} =
   _omitNulls
      [ "id" .= baseShipmentDTOId
      , "planIntervalFrom" .= baseShipmentDTOPlanIntervalFrom
      , "planIntervalTo" .= baseShipmentDTOPlanIntervalTo
      , "shipmentType" .= baseShipmentDTOShipmentType
      , "warehouse" .= baseShipmentDTOWarehouse
      , "warehouseTo" .= baseShipmentDTOWarehouseTo
      , "externalId" .= baseShipmentDTOExternalId
      , "deliveryService" .= baseShipmentDTODeliveryService
      , "palletsCount" .= baseShipmentDTOPalletsCount
      , "orderIds" .= baseShipmentDTOOrderIds
      , "draftCount" .= baseShipmentDTODraftCount
      , "plannedCount" .= baseShipmentDTOPlannedCount
      , "factCount" .= baseShipmentDTOFactCount
      ]


-- | Construct a value of type 'BaseShipmentDTO' (by applying it's required fields, if any)
mkBaseShipmentDTO
  :: [Integer] -- ^ 'baseShipmentDTOOrderIds': Идентификаторы заказов в отгрузке.
  -> BaseShipmentDTO
mkBaseShipmentDTO baseShipmentDTOOrderIds =
  BaseShipmentDTO
  { baseShipmentDTOId = Nothing
  , baseShipmentDTOPlanIntervalFrom = Nothing
  , baseShipmentDTOPlanIntervalTo = Nothing
  , baseShipmentDTOShipmentType = Nothing
  , baseShipmentDTOWarehouse = Nothing
  , baseShipmentDTOWarehouseTo = Nothing
  , baseShipmentDTOExternalId = Nothing
  , baseShipmentDTODeliveryService = Nothing
  , baseShipmentDTOPalletsCount = Nothing
  , baseShipmentDTOOrderIds
  , baseShipmentDTODraftCount = Nothing
  , baseShipmentDTOPlannedCount = Nothing
  , baseShipmentDTOFactCount = Nothing
  }

-- ** BidRecommendationItemDTO
-- | BidRecommendationItemDTO
-- Рекомендованная ставка и возможная доля показов.
data BidRecommendationItemDTO = BidRecommendationItemDTO
  { bidRecommendationItemDTOBid :: !(Int) -- ^ /Required/ "bid" - Значение ставки.
  , bidRecommendationItemDTOShowPercent :: !(Integer) -- ^ /Required/ "showPercent" - Доля показов. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BidRecommendationItemDTO
instance A.FromJSON BidRecommendationItemDTO where
  parseJSON = A.withObject "BidRecommendationItemDTO" $ \o ->
    BidRecommendationItemDTO
      <$> (o .:  "bid")
      <*> (o .:  "showPercent")

-- | ToJSON BidRecommendationItemDTO
instance A.ToJSON BidRecommendationItemDTO where
  toJSON BidRecommendationItemDTO {..} =
   _omitNulls
      [ "bid" .= bidRecommendationItemDTOBid
      , "showPercent" .= bidRecommendationItemDTOShowPercent
      ]


-- | Construct a value of type 'BidRecommendationItemDTO' (by applying it's required fields, if any)
mkBidRecommendationItemDTO
  :: Int -- ^ 'bidRecommendationItemDTOBid': Значение ставки.
  -> Integer -- ^ 'bidRecommendationItemDTOShowPercent': Доля показов. 
  -> BidRecommendationItemDTO
mkBidRecommendationItemDTO bidRecommendationItemDTOBid bidRecommendationItemDTOShowPercent =
  BidRecommendationItemDTO
  { bidRecommendationItemDTOBid
  , bidRecommendationItemDTOShowPercent
  }

-- ** BriefOrderItemDTO
-- | BriefOrderItemDTO
-- Информация о маркированном товаре.
data BriefOrderItemDTO = BriefOrderItemDTO
  { briefOrderItemDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор товара в заказе.  Позволяет идентифицировать товар в рамках данного заказа. 
  , briefOrderItemDTOVat :: !(Maybe OrderVatType) -- ^ "vat"
  , briefOrderItemDTOCount :: !(Maybe Int) -- ^ "count" - Количество единиц товара.
  , briefOrderItemDTOPrice :: !(Maybe Double) -- ^ "price" - Цена на товар. Указана в той валюте, которая была задана в каталоге. Разделитель целой и дробной части — точка. 
  , briefOrderItemDTOOfferName :: !(Maybe Text) -- ^ "offerName" - Название товара.
  , briefOrderItemDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , briefOrderItemDTOInstances :: !(Maybe [OrderItemInstanceDTO]) -- ^ "instances" - Переданные вами коды маркировки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BriefOrderItemDTO
instance A.FromJSON BriefOrderItemDTO where
  parseJSON = A.withObject "BriefOrderItemDTO" $ \o ->
    BriefOrderItemDTO
      <$> (o .:? "id")
      <*> (o .:? "vat")
      <*> (o .:? "count")
      <*> (o .:? "price")
      <*> (o .:? "offerName")
      <*> (o .:? "offerId")
      <*> (o .:? "instances")

-- | ToJSON BriefOrderItemDTO
instance A.ToJSON BriefOrderItemDTO where
  toJSON BriefOrderItemDTO {..} =
   _omitNulls
      [ "id" .= briefOrderItemDTOId
      , "vat" .= briefOrderItemDTOVat
      , "count" .= briefOrderItemDTOCount
      , "price" .= briefOrderItemDTOPrice
      , "offerName" .= briefOrderItemDTOOfferName
      , "offerId" .= briefOrderItemDTOOfferId
      , "instances" .= briefOrderItemDTOInstances
      ]


-- | Construct a value of type 'BriefOrderItemDTO' (by applying it's required fields, if any)
mkBriefOrderItemDTO
  :: BriefOrderItemDTO
mkBriefOrderItemDTO =
  BriefOrderItemDTO
  { briefOrderItemDTOId = Nothing
  , briefOrderItemDTOVat = Nothing
  , briefOrderItemDTOCount = Nothing
  , briefOrderItemDTOPrice = Nothing
  , briefOrderItemDTOOfferName = Nothing
  , briefOrderItemDTOOfferId = Nothing
  , briefOrderItemDTOInstances = Nothing
  }

-- ** BriefOrderItemInstanceDTO
-- | BriefOrderItemInstanceDTO
-- Идентификатор единицы товара.  Заполните только одно поле в зависимости от того, в какой системе маркирован товар.  Подробно о работе с маркируемыми товарами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/cz.html). 
data BriefOrderItemInstanceDTO = BriefOrderItemInstanceDTO
  { briefOrderItemInstanceDTOCis :: !(Maybe Text) -- ^ "cis" - Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).  {% note warning %}  Не экранируйте косую черту в коде символа-разделителя &#x60;\\u001d&#x60;!  ✅ &#x60;01030410947874432155Qbag!\\u001d93Zjqw&#x60;  ❌ &#x60;01030410947874432155Qbag!\\\\u001d93Zjqw&#x60;  Косые черты и кавычки в других местах экранируйте по правилам JSON: &#x60;\\\\&#x60; и &#x60;\\\&quot;&#x60;  {% endnote %} 
  , briefOrderItemInstanceDTOUin :: !(Maybe Text) -- ^ "uin" - Уникальный идентификационный номер ювелирного изделия.  Представляет собой число из 16 цифр. 
  , briefOrderItemInstanceDTORnpt :: !(Maybe Text) -- ^ "rnpt" - Регистрационный номер партии товара.  Представляет собой строку из четырех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ/ХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на партию товара. Далее — дата, номер декларации и номер маркированного товара в декларации. 
  , briefOrderItemInstanceDTOGtd :: !(Maybe Text) -- ^ "gtd" - Грузовая таможенная декларация.  Представляет собой строку из трех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на ввезенные товары. Далее — дата и номер декларации. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BriefOrderItemInstanceDTO
instance A.FromJSON BriefOrderItemInstanceDTO where
  parseJSON = A.withObject "BriefOrderItemInstanceDTO" $ \o ->
    BriefOrderItemInstanceDTO
      <$> (o .:? "cis")
      <*> (o .:? "uin")
      <*> (o .:? "rnpt")
      <*> (o .:? "gtd")

-- | ToJSON BriefOrderItemInstanceDTO
instance A.ToJSON BriefOrderItemInstanceDTO where
  toJSON BriefOrderItemInstanceDTO {..} =
   _omitNulls
      [ "cis" .= briefOrderItemInstanceDTOCis
      , "uin" .= briefOrderItemInstanceDTOUin
      , "rnpt" .= briefOrderItemInstanceDTORnpt
      , "gtd" .= briefOrderItemInstanceDTOGtd
      ]


-- | Construct a value of type 'BriefOrderItemInstanceDTO' (by applying it's required fields, if any)
mkBriefOrderItemInstanceDTO
  :: BriefOrderItemInstanceDTO
mkBriefOrderItemInstanceDTO =
  BriefOrderItemInstanceDTO
  { briefOrderItemInstanceDTOCis = Nothing
  , briefOrderItemInstanceDTOUin = Nothing
  , briefOrderItemInstanceDTORnpt = Nothing
  , briefOrderItemInstanceDTOGtd = Nothing
  }

-- ** BusinessDTO
-- | BusinessDTO
-- Информация о кабинете.
data BusinessDTO = BusinessDTO
  { businessDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор кабинета.
  , businessDTOName :: !(Maybe Text) -- ^ "name" - Название бизнеса.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BusinessDTO
instance A.FromJSON BusinessDTO where
  parseJSON = A.withObject "BusinessDTO" $ \o ->
    BusinessDTO
      <$> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON BusinessDTO
instance A.ToJSON BusinessDTO where
  toJSON BusinessDTO {..} =
   _omitNulls
      [ "id" .= businessDTOId
      , "name" .= businessDTOName
      ]


-- | Construct a value of type 'BusinessDTO' (by applying it's required fields, if any)
mkBusinessDTO
  :: BusinessDTO
mkBusinessDTO =
  BusinessDTO
  { businessDTOId = Nothing
  , businessDTOName = Nothing
  }

-- ** BusinessSettingsDTO
-- | BusinessSettingsDTO
-- Настройки кабинета.
data BusinessSettingsDTO = BusinessSettingsDTO
  { businessSettingsDTOOnlyDefaultPrice :: !(Maybe Bool) -- ^ "onlyDefaultPrice" - Можно ли установить только [базовую цену](*rule): * &#x60;false&#x60; — можно задать и базовую цену, и цены в конкретных магазинах. * &#x60;true&#x60; — можно задать только базовую цену. 
  , businessSettingsDTOCurrency :: !(Maybe CurrencyType) -- ^ "currency"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BusinessSettingsDTO
instance A.FromJSON BusinessSettingsDTO where
  parseJSON = A.withObject "BusinessSettingsDTO" $ \o ->
    BusinessSettingsDTO
      <$> (o .:? "onlyDefaultPrice")
      <*> (o .:? "currency")

-- | ToJSON BusinessSettingsDTO
instance A.ToJSON BusinessSettingsDTO where
  toJSON BusinessSettingsDTO {..} =
   _omitNulls
      [ "onlyDefaultPrice" .= businessSettingsDTOOnlyDefaultPrice
      , "currency" .= businessSettingsDTOCurrency
      ]


-- | Construct a value of type 'BusinessSettingsDTO' (by applying it's required fields, if any)
mkBusinessSettingsDTO
  :: BusinessSettingsDTO
mkBusinessSettingsDTO =
  BusinessSettingsDTO
  { businessSettingsDTOOnlyDefaultPrice = Nothing
  , businessSettingsDTOCurrency = Nothing
  }

-- ** CalculateTariffsOfferDTO
-- | CalculateTariffsOfferDTO
-- Параметры товара, для которого нужно рассчитать стоимость услуг.
data CalculateTariffsOfferDTO = CalculateTariffsOfferDTO
  { calculateTariffsOfferDTOCategoryId :: !(Integer) -- ^ /Required/ "categoryId" - Идентификатор категории товара на Маркете.  Для расчета стоимости услуг необходимо указать идентификатор листовой категории товара — той, которая не имеет дочерних категорий.  Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
  , calculateTariffsOfferDTOPrice :: !(Double) -- ^ /Required/ "price" - Цена на товар в рублях.
  , calculateTariffsOfferDTOLength :: !(Double) -- ^ /Required/ "length" - Длина товара в сантиметрах.
  , calculateTariffsOfferDTOWidth :: !(Double) -- ^ /Required/ "width" - Ширина товара в сантиметрах.
  , calculateTariffsOfferDTOHeight :: !(Double) -- ^ /Required/ "height" - Высота товара в сантиметрах.
  , calculateTariffsOfferDTOWeight :: !(Double) -- ^ /Required/ "weight" - Вес товара в килограммах.
  , calculateTariffsOfferDTOQuantity :: !(Maybe Int) -- ^ "quantity" - Квант продажи — количество единиц товара в одном товарном предложении.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CalculateTariffsOfferDTO
instance A.FromJSON CalculateTariffsOfferDTO where
  parseJSON = A.withObject "CalculateTariffsOfferDTO" $ \o ->
    CalculateTariffsOfferDTO
      <$> (o .:  "categoryId")
      <*> (o .:  "price")
      <*> (o .:  "length")
      <*> (o .:  "width")
      <*> (o .:  "height")
      <*> (o .:  "weight")
      <*> (o .:? "quantity")

-- | ToJSON CalculateTariffsOfferDTO
instance A.ToJSON CalculateTariffsOfferDTO where
  toJSON CalculateTariffsOfferDTO {..} =
   _omitNulls
      [ "categoryId" .= calculateTariffsOfferDTOCategoryId
      , "price" .= calculateTariffsOfferDTOPrice
      , "length" .= calculateTariffsOfferDTOLength
      , "width" .= calculateTariffsOfferDTOWidth
      , "height" .= calculateTariffsOfferDTOHeight
      , "weight" .= calculateTariffsOfferDTOWeight
      , "quantity" .= calculateTariffsOfferDTOQuantity
      ]


-- | Construct a value of type 'CalculateTariffsOfferDTO' (by applying it's required fields, if any)
mkCalculateTariffsOfferDTO
  :: Integer -- ^ 'calculateTariffsOfferDTOCategoryId': Идентификатор категории товара на Маркете.  Для расчета стоимости услуг необходимо указать идентификатор листовой категории товара — той, которая не имеет дочерних категорий.  Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
  -> Double -- ^ 'calculateTariffsOfferDTOPrice': Цена на товар в рублях.
  -> Double -- ^ 'calculateTariffsOfferDTOLength': Длина товара в сантиметрах.
  -> Double -- ^ 'calculateTariffsOfferDTOWidth': Ширина товара в сантиметрах.
  -> Double -- ^ 'calculateTariffsOfferDTOHeight': Высота товара в сантиметрах.
  -> Double -- ^ 'calculateTariffsOfferDTOWeight': Вес товара в килограммах.
  -> CalculateTariffsOfferDTO
mkCalculateTariffsOfferDTO calculateTariffsOfferDTOCategoryId calculateTariffsOfferDTOPrice calculateTariffsOfferDTOLength calculateTariffsOfferDTOWidth calculateTariffsOfferDTOHeight calculateTariffsOfferDTOWeight =
  CalculateTariffsOfferDTO
  { calculateTariffsOfferDTOCategoryId
  , calculateTariffsOfferDTOPrice
  , calculateTariffsOfferDTOLength
  , calculateTariffsOfferDTOWidth
  , calculateTariffsOfferDTOHeight
  , calculateTariffsOfferDTOWeight
  , calculateTariffsOfferDTOQuantity = Nothing
  }

-- ** CalculateTariffsOfferInfoDTO
-- | CalculateTariffsOfferInfoDTO
-- Стоимость услуг.
data CalculateTariffsOfferInfoDTO = CalculateTariffsOfferInfoDTO
  { calculateTariffsOfferInfoDTOOffer :: !(CalculateTariffsOfferDTO) -- ^ /Required/ "offer"
  , calculateTariffsOfferInfoDTOTariffs :: !([CalculatedTariffDTO]) -- ^ /Required/ "tariffs" - Список услуг и их стоимость.  По некоторым услугам могут возвращаться несколько разных стоимостей. Например, в модели FBS стоимость услуги &#x60;SORTING&#x60; (обработка заказа) зависит от способа отгрузки и количества заказов в отгрузке. Подробнее о тарифах на услуги читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/introduction/rates/models/). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CalculateTariffsOfferInfoDTO
instance A.FromJSON CalculateTariffsOfferInfoDTO where
  parseJSON = A.withObject "CalculateTariffsOfferInfoDTO" $ \o ->
    CalculateTariffsOfferInfoDTO
      <$> (o .:  "offer")
      <*> (o .:  "tariffs")

-- | ToJSON CalculateTariffsOfferInfoDTO
instance A.ToJSON CalculateTariffsOfferInfoDTO where
  toJSON CalculateTariffsOfferInfoDTO {..} =
   _omitNulls
      [ "offer" .= calculateTariffsOfferInfoDTOOffer
      , "tariffs" .= calculateTariffsOfferInfoDTOTariffs
      ]


-- | Construct a value of type 'CalculateTariffsOfferInfoDTO' (by applying it's required fields, if any)
mkCalculateTariffsOfferInfoDTO
  :: CalculateTariffsOfferDTO -- ^ 'calculateTariffsOfferInfoDTOOffer' 
  -> [CalculatedTariffDTO] -- ^ 'calculateTariffsOfferInfoDTOTariffs': Список услуг и их стоимость.  По некоторым услугам могут возвращаться несколько разных стоимостей. Например, в модели FBS стоимость услуги `SORTING` (обработка заказа) зависит от способа отгрузки и количества заказов в отгрузке. Подробнее о тарифах на услуги читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/introduction/rates/models/). 
  -> CalculateTariffsOfferInfoDTO
mkCalculateTariffsOfferInfoDTO calculateTariffsOfferInfoDTOOffer calculateTariffsOfferInfoDTOTariffs =
  CalculateTariffsOfferInfoDTO
  { calculateTariffsOfferInfoDTOOffer
  , calculateTariffsOfferInfoDTOTariffs
  }

-- ** CalculateTariffsParametersDTO
-- | CalculateTariffsParametersDTO
-- Параметры для расчета стоимости услуг.
data CalculateTariffsParametersDTO = CalculateTariffsParametersDTO
  { calculateTariffsParametersDTOCampaignId :: !(Maybe Integer) -- ^ "campaignId" - Идентификатор кампании. У пользователя, который выполняет запрос, должен быть доступ к этой кампании.  Используйте параметр &#x60;campaignId&#x60;, если уже завершили подключение магазина на Маркете. Иначе вернется пустой список.  Обязательный параметр, если не указан параметр &#x60;sellingProgram&#x60;. Совместное использование параметров приведет к ошибке. 
  , calculateTariffsParametersDTOSellingProgram :: !(Maybe SellingProgramType) -- ^ "sellingProgram"
  , calculateTariffsParametersDTOFrequency :: !(Maybe PaymentFrequencyType) -- ^ "frequency"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CalculateTariffsParametersDTO
instance A.FromJSON CalculateTariffsParametersDTO where
  parseJSON = A.withObject "CalculateTariffsParametersDTO" $ \o ->
    CalculateTariffsParametersDTO
      <$> (o .:? "campaignId")
      <*> (o .:? "sellingProgram")
      <*> (o .:? "frequency")

-- | ToJSON CalculateTariffsParametersDTO
instance A.ToJSON CalculateTariffsParametersDTO where
  toJSON CalculateTariffsParametersDTO {..} =
   _omitNulls
      [ "campaignId" .= calculateTariffsParametersDTOCampaignId
      , "sellingProgram" .= calculateTariffsParametersDTOSellingProgram
      , "frequency" .= calculateTariffsParametersDTOFrequency
      ]


-- | Construct a value of type 'CalculateTariffsParametersDTO' (by applying it's required fields, if any)
mkCalculateTariffsParametersDTO
  :: CalculateTariffsParametersDTO
mkCalculateTariffsParametersDTO =
  CalculateTariffsParametersDTO
  { calculateTariffsParametersDTOCampaignId = Nothing
  , calculateTariffsParametersDTOSellingProgram = Nothing
  , calculateTariffsParametersDTOFrequency = Nothing
  }

-- ** CalculateTariffsRequest
-- | CalculateTariffsRequest
data CalculateTariffsRequest = CalculateTariffsRequest
  { calculateTariffsRequestParameters :: !(CalculateTariffsParametersDTO) -- ^ /Required/ "parameters"
  , calculateTariffsRequestOffers :: !([CalculateTariffsOfferDTO]) -- ^ /Required/ "offers" - Товары, для которых нужно рассчитать стоимость услуг.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CalculateTariffsRequest
instance A.FromJSON CalculateTariffsRequest where
  parseJSON = A.withObject "CalculateTariffsRequest" $ \o ->
    CalculateTariffsRequest
      <$> (o .:  "parameters")
      <*> (o .:  "offers")

-- | ToJSON CalculateTariffsRequest
instance A.ToJSON CalculateTariffsRequest where
  toJSON CalculateTariffsRequest {..} =
   _omitNulls
      [ "parameters" .= calculateTariffsRequestParameters
      , "offers" .= calculateTariffsRequestOffers
      ]


-- | Construct a value of type 'CalculateTariffsRequest' (by applying it's required fields, if any)
mkCalculateTariffsRequest
  :: CalculateTariffsParametersDTO -- ^ 'calculateTariffsRequestParameters' 
  -> [CalculateTariffsOfferDTO] -- ^ 'calculateTariffsRequestOffers': Товары, для которых нужно рассчитать стоимость услуг.
  -> CalculateTariffsRequest
mkCalculateTariffsRequest calculateTariffsRequestParameters calculateTariffsRequestOffers =
  CalculateTariffsRequest
  { calculateTariffsRequestParameters
  , calculateTariffsRequestOffers
  }

-- ** CalculateTariffsResponse
-- | CalculateTariffsResponse
data CalculateTariffsResponse = CalculateTariffsResponse
  { calculateTariffsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , calculateTariffsResponseResult :: !(Maybe CalculateTariffsResponseDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CalculateTariffsResponse
instance A.FromJSON CalculateTariffsResponse where
  parseJSON = A.withObject "CalculateTariffsResponse" $ \o ->
    CalculateTariffsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON CalculateTariffsResponse
instance A.ToJSON CalculateTariffsResponse where
  toJSON CalculateTariffsResponse {..} =
   _omitNulls
      [ "status" .= calculateTariffsResponseStatus
      , "result" .= calculateTariffsResponseResult
      ]


-- | Construct a value of type 'CalculateTariffsResponse' (by applying it's required fields, if any)
mkCalculateTariffsResponse
  :: CalculateTariffsResponse
mkCalculateTariffsResponse =
  CalculateTariffsResponse
  { calculateTariffsResponseStatus = Nothing
  , calculateTariffsResponseResult = Nothing
  }

-- ** CalculateTariffsResponseDTO
-- | CalculateTariffsResponseDTO
-- Расчет стоимости услуг.
data CalculateTariffsResponseDTO = CalculateTariffsResponseDTO
  { calculateTariffsResponseDTOOffers :: !([CalculateTariffsOfferInfoDTO]) -- ^ /Required/ "offers" - Стоимость услуг.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CalculateTariffsResponseDTO
instance A.FromJSON CalculateTariffsResponseDTO where
  parseJSON = A.withObject "CalculateTariffsResponseDTO" $ \o ->
    CalculateTariffsResponseDTO
      <$> (o .:  "offers")

-- | ToJSON CalculateTariffsResponseDTO
instance A.ToJSON CalculateTariffsResponseDTO where
  toJSON CalculateTariffsResponseDTO {..} =
   _omitNulls
      [ "offers" .= calculateTariffsResponseDTOOffers
      ]


-- | Construct a value of type 'CalculateTariffsResponseDTO' (by applying it's required fields, if any)
mkCalculateTariffsResponseDTO
  :: [CalculateTariffsOfferInfoDTO] -- ^ 'calculateTariffsResponseDTOOffers': Стоимость услуг.
  -> CalculateTariffsResponseDTO
mkCalculateTariffsResponseDTO calculateTariffsResponseDTOOffers =
  CalculateTariffsResponseDTO
  { calculateTariffsResponseDTOOffers
  }

-- ** CalculatedTariffDTO
-- | CalculatedTariffDTO
-- Информация об услугах Маркета.
data CalculatedTariffDTO = CalculatedTariffDTO
  { calculatedTariffDTOType :: !(CalculatedTariffType) -- ^ /Required/ "type"
  , calculatedTariffDTOAmount :: !(Maybe Double) -- ^ "amount" - Стоимость услуги в рублях.
  , calculatedTariffDTOParameters :: !([TariffParameterDTO]) -- ^ /Required/ "parameters" - Параметры расчета тарифа.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CalculatedTariffDTO
instance A.FromJSON CalculatedTariffDTO where
  parseJSON = A.withObject "CalculatedTariffDTO" $ \o ->
    CalculatedTariffDTO
      <$> (o .:  "type")
      <*> (o .:? "amount")
      <*> (o .:  "parameters")

-- | ToJSON CalculatedTariffDTO
instance A.ToJSON CalculatedTariffDTO where
  toJSON CalculatedTariffDTO {..} =
   _omitNulls
      [ "type" .= calculatedTariffDTOType
      , "amount" .= calculatedTariffDTOAmount
      , "parameters" .= calculatedTariffDTOParameters
      ]


-- | Construct a value of type 'CalculatedTariffDTO' (by applying it's required fields, if any)
mkCalculatedTariffDTO
  :: CalculatedTariffType -- ^ 'calculatedTariffDTOType' 
  -> [TariffParameterDTO] -- ^ 'calculatedTariffDTOParameters': Параметры расчета тарифа.
  -> CalculatedTariffDTO
mkCalculatedTariffDTO calculatedTariffDTOType calculatedTariffDTOParameters =
  CalculatedTariffDTO
  { calculatedTariffDTOType
  , calculatedTariffDTOAmount = Nothing
  , calculatedTariffDTOParameters
  }

-- ** CampaignDTO
-- | CampaignDTO
-- Информация о магазине.
data CampaignDTO = CampaignDTO
  { campaignDTODomain :: !(Maybe Text) -- ^ "domain" - URL магазина.
  , campaignDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор кампании.
  , campaignDTOClientId :: !(Maybe Integer) -- ^ "clientId" - Идентификатор плательщика в Яндекс Балансе.
  , campaignDTOBusiness :: !(Maybe BusinessDTO) -- ^ "business"
  , campaignDTOPlacementType :: !(Maybe PlacementType) -- ^ "placementType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CampaignDTO
instance A.FromJSON CampaignDTO where
  parseJSON = A.withObject "CampaignDTO" $ \o ->
    CampaignDTO
      <$> (o .:? "domain")
      <*> (o .:? "id")
      <*> (o .:? "clientId")
      <*> (o .:? "business")
      <*> (o .:? "placementType")

-- | ToJSON CampaignDTO
instance A.ToJSON CampaignDTO where
  toJSON CampaignDTO {..} =
   _omitNulls
      [ "domain" .= campaignDTODomain
      , "id" .= campaignDTOId
      , "clientId" .= campaignDTOClientId
      , "business" .= campaignDTOBusiness
      , "placementType" .= campaignDTOPlacementType
      ]


-- | Construct a value of type 'CampaignDTO' (by applying it's required fields, if any)
mkCampaignDTO
  :: CampaignDTO
mkCampaignDTO =
  CampaignDTO
  { campaignDTODomain = Nothing
  , campaignDTOId = Nothing
  , campaignDTOClientId = Nothing
  , campaignDTOBusiness = Nothing
  , campaignDTOPlacementType = Nothing
  }

-- ** CampaignQualityRatingDTO
-- | CampaignQualityRatingDTO
-- Информация об индексе качества магазина.
data CampaignQualityRatingDTO = CampaignQualityRatingDTO
  { campaignQualityRatingDTOCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - Идентификатор магазина.
  , campaignQualityRatingDTORatings :: !([QualityRatingDTO]) -- ^ /Required/ "ratings" - Список значений индекса качества.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CampaignQualityRatingDTO
instance A.FromJSON CampaignQualityRatingDTO where
  parseJSON = A.withObject "CampaignQualityRatingDTO" $ \o ->
    CampaignQualityRatingDTO
      <$> (o .:  "campaignId")
      <*> (o .:  "ratings")

-- | ToJSON CampaignQualityRatingDTO
instance A.ToJSON CampaignQualityRatingDTO where
  toJSON CampaignQualityRatingDTO {..} =
   _omitNulls
      [ "campaignId" .= campaignQualityRatingDTOCampaignId
      , "ratings" .= campaignQualityRatingDTORatings
      ]


-- | Construct a value of type 'CampaignQualityRatingDTO' (by applying it's required fields, if any)
mkCampaignQualityRatingDTO
  :: Integer -- ^ 'campaignQualityRatingDTOCampaignId': Идентификатор магазина.
  -> [QualityRatingDTO] -- ^ 'campaignQualityRatingDTORatings': Список значений индекса качества.
  -> CampaignQualityRatingDTO
mkCampaignQualityRatingDTO campaignQualityRatingDTOCampaignId campaignQualityRatingDTORatings =
  CampaignQualityRatingDTO
  { campaignQualityRatingDTOCampaignId
  , campaignQualityRatingDTORatings
  }

-- ** CampaignSettingsDTO
-- | CampaignSettingsDTO
-- Настройки магазина.
data CampaignSettingsDTO = CampaignSettingsDTO
  { campaignSettingsDTOCountryRegion :: !(Maybe Integer) -- ^ "countryRegion" - Идентификатор региона, в котором находится магазин.
  , campaignSettingsDTOShopName :: !(Maybe Text) -- ^ "shopName" - Наименование магазина на Яндекс Маркете. Если наименование отсутствует, значение параметра выводится — &#x60;null&#x60;. 
  , campaignSettingsDTOShowInContext :: !(Maybe Bool) -- ^ "showInContext" - Признак размещения магазина на сайтах партнеров Яндекс Дистрибуции. Возможные значения: * &#x60;false&#x60; — магазин не размещен на сайтах партнеров Яндекс Дистрибуции. * &#x60;true&#x60; — магазин размещен на сайтах партнеров Яндекс Дистрибуции. 
  , campaignSettingsDTOShowInPremium :: !(Maybe Bool) -- ^ "showInPremium" - Признак показа предложений магазина в рекламном блоке над результатами поиска (cпецразмещение). Возможные значения: * &#x60;false&#x60; — предложения не показываются в блоке cпецразмещения. * &#x60;true&#x60; — предложения показываются в блоке cпецразмещения. 
  , campaignSettingsDTOUseOpenStat :: !(Maybe Bool) -- ^ "useOpenStat" - Признак использования внешней интернет-статистики. Возможные значения: * &#x60;false&#x60; — внешняя интернет-статистика не используется. * &#x60;true&#x60; — внешняя интернет-статистика используется. 
  , campaignSettingsDTOLocalRegion :: !(Maybe CampaignSettingsLocalRegionDTO) -- ^ "localRegion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CampaignSettingsDTO
instance A.FromJSON CampaignSettingsDTO where
  parseJSON = A.withObject "CampaignSettingsDTO" $ \o ->
    CampaignSettingsDTO
      <$> (o .:? "countryRegion")
      <*> (o .:? "shopName")
      <*> (o .:? "showInContext")
      <*> (o .:? "showInPremium")
      <*> (o .:? "useOpenStat")
      <*> (o .:? "localRegion")

-- | ToJSON CampaignSettingsDTO
instance A.ToJSON CampaignSettingsDTO where
  toJSON CampaignSettingsDTO {..} =
   _omitNulls
      [ "countryRegion" .= campaignSettingsDTOCountryRegion
      , "shopName" .= campaignSettingsDTOShopName
      , "showInContext" .= campaignSettingsDTOShowInContext
      , "showInPremium" .= campaignSettingsDTOShowInPremium
      , "useOpenStat" .= campaignSettingsDTOUseOpenStat
      , "localRegion" .= campaignSettingsDTOLocalRegion
      ]


-- | Construct a value of type 'CampaignSettingsDTO' (by applying it's required fields, if any)
mkCampaignSettingsDTO
  :: CampaignSettingsDTO
mkCampaignSettingsDTO =
  CampaignSettingsDTO
  { campaignSettingsDTOCountryRegion = Nothing
  , campaignSettingsDTOShopName = Nothing
  , campaignSettingsDTOShowInContext = Nothing
  , campaignSettingsDTOShowInPremium = Nothing
  , campaignSettingsDTOUseOpenStat = Nothing
  , campaignSettingsDTOLocalRegion = Nothing
  }

-- ** CampaignSettingsDeliveryDTO
-- | CampaignSettingsDeliveryDTO
-- Информация о доставке в своем регионе магазина.
data CampaignSettingsDeliveryDTO = CampaignSettingsDeliveryDTO
  { campaignSettingsDeliveryDTOSchedule :: !(Maybe CampaignSettingsScheduleDTO) -- ^ "schedule"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CampaignSettingsDeliveryDTO
instance A.FromJSON CampaignSettingsDeliveryDTO where
  parseJSON = A.withObject "CampaignSettingsDeliveryDTO" $ \o ->
    CampaignSettingsDeliveryDTO
      <$> (o .:? "schedule")

-- | ToJSON CampaignSettingsDeliveryDTO
instance A.ToJSON CampaignSettingsDeliveryDTO where
  toJSON CampaignSettingsDeliveryDTO {..} =
   _omitNulls
      [ "schedule" .= campaignSettingsDeliveryDTOSchedule
      ]


-- | Construct a value of type 'CampaignSettingsDeliveryDTO' (by applying it's required fields, if any)
mkCampaignSettingsDeliveryDTO
  :: CampaignSettingsDeliveryDTO
mkCampaignSettingsDeliveryDTO =
  CampaignSettingsDeliveryDTO
  { campaignSettingsDeliveryDTOSchedule = Nothing
  }

-- ** CampaignSettingsLocalRegionDTO
-- | CampaignSettingsLocalRegionDTO
-- Информация о своем регионе магазина.
data CampaignSettingsLocalRegionDTO = CampaignSettingsLocalRegionDTO
  { campaignSettingsLocalRegionDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор региона.
  , campaignSettingsLocalRegionDTOName :: !(Maybe Text) -- ^ "name" - Название региона.
  , campaignSettingsLocalRegionDTOType :: !(Maybe RegionType) -- ^ "type"
  , campaignSettingsLocalRegionDTODeliveryOptionsSource :: !(Maybe CampaignSettingsScheduleSourceType) -- ^ "deliveryOptionsSource"
  , campaignSettingsLocalRegionDTODelivery :: !(Maybe CampaignSettingsDeliveryDTO) -- ^ "delivery"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CampaignSettingsLocalRegionDTO
instance A.FromJSON CampaignSettingsLocalRegionDTO where
  parseJSON = A.withObject "CampaignSettingsLocalRegionDTO" $ \o ->
    CampaignSettingsLocalRegionDTO
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "type")
      <*> (o .:? "deliveryOptionsSource")
      <*> (o .:? "delivery")

-- | ToJSON CampaignSettingsLocalRegionDTO
instance A.ToJSON CampaignSettingsLocalRegionDTO where
  toJSON CampaignSettingsLocalRegionDTO {..} =
   _omitNulls
      [ "id" .= campaignSettingsLocalRegionDTOId
      , "name" .= campaignSettingsLocalRegionDTOName
      , "type" .= campaignSettingsLocalRegionDTOType
      , "deliveryOptionsSource" .= campaignSettingsLocalRegionDTODeliveryOptionsSource
      , "delivery" .= campaignSettingsLocalRegionDTODelivery
      ]


-- | Construct a value of type 'CampaignSettingsLocalRegionDTO' (by applying it's required fields, if any)
mkCampaignSettingsLocalRegionDTO
  :: CampaignSettingsLocalRegionDTO
mkCampaignSettingsLocalRegionDTO =
  CampaignSettingsLocalRegionDTO
  { campaignSettingsLocalRegionDTOId = Nothing
  , campaignSettingsLocalRegionDTOName = Nothing
  , campaignSettingsLocalRegionDTOType = Nothing
  , campaignSettingsLocalRegionDTODeliveryOptionsSource = Nothing
  , campaignSettingsLocalRegionDTODelivery = Nothing
  }

-- ** CampaignSettingsScheduleDTO
-- | CampaignSettingsScheduleDTO
-- Расписание работы службы доставки в своем регионе.
data CampaignSettingsScheduleDTO = CampaignSettingsScheduleDTO
  { campaignSettingsScheduleDTOAvailableOnHolidays :: !(Maybe Bool) -- ^ "availableOnHolidays" - Признак работы службы доставки в государственные праздники. Возможные значения. * &#x60;false&#x60; — служба доставки не работает в праздничные дни. * &#x60;true&#x60; — служба доставки работает в праздничные дни. 
  , campaignSettingsScheduleDTOCustomHolidays :: !([Text]) -- ^ /Required/ "customHolidays" - Список дней, в которые служба доставки не работает. Дни магазин указал в кабинете продавца на Маркете.
  , campaignSettingsScheduleDTOCustomWorkingDays :: !([Text]) -- ^ /Required/ "customWorkingDays" - Список выходных и праздничных дней, в которые служба доставки работает. Дни магазин указал в кабинете продавца на Маркете.
  , campaignSettingsScheduleDTOPeriod :: !(Maybe CampaignSettingsTimePeriodDTO) -- ^ "period"
  , campaignSettingsScheduleDTOTotalHolidays :: !([Text]) -- ^ /Required/ "totalHolidays" - Итоговый список нерабочих дней службы доставки. Список рассчитывается с учетом выходных, нерабочих дней и государственных праздников. Информацию по ним магазин указывает в кабинете продавца на Маркете.
  , campaignSettingsScheduleDTOWeeklyHolidays :: !([Int]) -- ^ /Required/ "weeklyHolidays" - Список выходных дней недели и государственных праздников.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CampaignSettingsScheduleDTO
instance A.FromJSON CampaignSettingsScheduleDTO where
  parseJSON = A.withObject "CampaignSettingsScheduleDTO" $ \o ->
    CampaignSettingsScheduleDTO
      <$> (o .:? "availableOnHolidays")
      <*> (o .:  "customHolidays")
      <*> (o .:  "customWorkingDays")
      <*> (o .:? "period")
      <*> (o .:  "totalHolidays")
      <*> (o .:  "weeklyHolidays")

-- | ToJSON CampaignSettingsScheduleDTO
instance A.ToJSON CampaignSettingsScheduleDTO where
  toJSON CampaignSettingsScheduleDTO {..} =
   _omitNulls
      [ "availableOnHolidays" .= campaignSettingsScheduleDTOAvailableOnHolidays
      , "customHolidays" .= campaignSettingsScheduleDTOCustomHolidays
      , "customWorkingDays" .= campaignSettingsScheduleDTOCustomWorkingDays
      , "period" .= campaignSettingsScheduleDTOPeriod
      , "totalHolidays" .= campaignSettingsScheduleDTOTotalHolidays
      , "weeklyHolidays" .= campaignSettingsScheduleDTOWeeklyHolidays
      ]


-- | Construct a value of type 'CampaignSettingsScheduleDTO' (by applying it's required fields, if any)
mkCampaignSettingsScheduleDTO
  :: [Text] -- ^ 'campaignSettingsScheduleDTOCustomHolidays': Список дней, в которые служба доставки не работает. Дни магазин указал в кабинете продавца на Маркете.
  -> [Text] -- ^ 'campaignSettingsScheduleDTOCustomWorkingDays': Список выходных и праздничных дней, в которые служба доставки работает. Дни магазин указал в кабинете продавца на Маркете.
  -> [Text] -- ^ 'campaignSettingsScheduleDTOTotalHolidays': Итоговый список нерабочих дней службы доставки. Список рассчитывается с учетом выходных, нерабочих дней и государственных праздников. Информацию по ним магазин указывает в кабинете продавца на Маркете.
  -> [Int] -- ^ 'campaignSettingsScheduleDTOWeeklyHolidays': Список выходных дней недели и государственных праздников.
  -> CampaignSettingsScheduleDTO
mkCampaignSettingsScheduleDTO campaignSettingsScheduleDTOCustomHolidays campaignSettingsScheduleDTOCustomWorkingDays campaignSettingsScheduleDTOTotalHolidays campaignSettingsScheduleDTOWeeklyHolidays =
  CampaignSettingsScheduleDTO
  { campaignSettingsScheduleDTOAvailableOnHolidays = Nothing
  , campaignSettingsScheduleDTOCustomHolidays
  , campaignSettingsScheduleDTOCustomWorkingDays
  , campaignSettingsScheduleDTOPeriod = Nothing
  , campaignSettingsScheduleDTOTotalHolidays
  , campaignSettingsScheduleDTOWeeklyHolidays
  }

-- ** CampaignSettingsTimePeriodDTO
-- | CampaignSettingsTimePeriodDTO
-- Период, за который рассчитывается итоговый список нерабочих дней службы доставки.
data CampaignSettingsTimePeriodDTO = CampaignSettingsTimePeriodDTO
  { campaignSettingsTimePeriodDTOFromDate :: !(Maybe Text) -- ^ "fromDate" - Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  , campaignSettingsTimePeriodDTOToDate :: !(Maybe Text) -- ^ "toDate" - Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CampaignSettingsTimePeriodDTO
instance A.FromJSON CampaignSettingsTimePeriodDTO where
  parseJSON = A.withObject "CampaignSettingsTimePeriodDTO" $ \o ->
    CampaignSettingsTimePeriodDTO
      <$> (o .:? "fromDate")
      <*> (o .:? "toDate")

-- | ToJSON CampaignSettingsTimePeriodDTO
instance A.ToJSON CampaignSettingsTimePeriodDTO where
  toJSON CampaignSettingsTimePeriodDTO {..} =
   _omitNulls
      [ "fromDate" .= campaignSettingsTimePeriodDTOFromDate
      , "toDate" .= campaignSettingsTimePeriodDTOToDate
      ]


-- | Construct a value of type 'CampaignSettingsTimePeriodDTO' (by applying it's required fields, if any)
mkCampaignSettingsTimePeriodDTO
  :: CampaignSettingsTimePeriodDTO
mkCampaignSettingsTimePeriodDTO =
  CampaignSettingsTimePeriodDTO
  { campaignSettingsTimePeriodDTOFromDate = Nothing
  , campaignSettingsTimePeriodDTOToDate = Nothing
  }

-- ** CampaignsQualityRatingDTO
-- | CampaignsQualityRatingDTO
-- Информация об индексе качества магазинов.
data CampaignsQualityRatingDTO = CampaignsQualityRatingDTO
  { campaignsQualityRatingDTOCampaignRatings :: !([CampaignQualityRatingDTO]) -- ^ /Required/ "campaignRatings" - Список магазинов c информацией об их индексе качества.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CampaignsQualityRatingDTO
instance A.FromJSON CampaignsQualityRatingDTO where
  parseJSON = A.withObject "CampaignsQualityRatingDTO" $ \o ->
    CampaignsQualityRatingDTO
      <$> (o .:  "campaignRatings")

-- | ToJSON CampaignsQualityRatingDTO
instance A.ToJSON CampaignsQualityRatingDTO where
  toJSON CampaignsQualityRatingDTO {..} =
   _omitNulls
      [ "campaignRatings" .= campaignsQualityRatingDTOCampaignRatings
      ]


-- | Construct a value of type 'CampaignsQualityRatingDTO' (by applying it's required fields, if any)
mkCampaignsQualityRatingDTO
  :: [CampaignQualityRatingDTO] -- ^ 'campaignsQualityRatingDTOCampaignRatings': Список магазинов c информацией об их индексе качества.
  -> CampaignsQualityRatingDTO
mkCampaignsQualityRatingDTO campaignsQualityRatingDTOCampaignRatings =
  CampaignsQualityRatingDTO
  { campaignsQualityRatingDTOCampaignRatings
  }

-- ** CategoryContentParametersDTO
-- | CategoryContentParametersDTO
-- Информация о параметрах категории.
data CategoryContentParametersDTO = CategoryContentParametersDTO
  { categoryContentParametersDTOCategoryId :: !(Int) -- ^ /Required/ "categoryId" - Идентификатор категории на Маркете. Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).
  , categoryContentParametersDTOParameters :: !(Maybe [CategoryParameterDTO]) -- ^ "parameters" - Список характеристик.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CategoryContentParametersDTO
instance A.FromJSON CategoryContentParametersDTO where
  parseJSON = A.withObject "CategoryContentParametersDTO" $ \o ->
    CategoryContentParametersDTO
      <$> (o .:  "categoryId")
      <*> (o .:? "parameters")

-- | ToJSON CategoryContentParametersDTO
instance A.ToJSON CategoryContentParametersDTO where
  toJSON CategoryContentParametersDTO {..} =
   _omitNulls
      [ "categoryId" .= categoryContentParametersDTOCategoryId
      , "parameters" .= categoryContentParametersDTOParameters
      ]


-- | Construct a value of type 'CategoryContentParametersDTO' (by applying it's required fields, if any)
mkCategoryContentParametersDTO
  :: Int -- ^ 'categoryContentParametersDTOCategoryId': Идентификатор категории на Маркете. Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).
  -> CategoryContentParametersDTO
mkCategoryContentParametersDTO categoryContentParametersDTOCategoryId =
  CategoryContentParametersDTO
  { categoryContentParametersDTOCategoryId
  , categoryContentParametersDTOParameters = Nothing
  }

-- ** CategoryDTO
-- | CategoryDTO
-- Информация о категории.  Категория считается листовой, если у нее нет дочерних категорий. 
data CategoryDTO = CategoryDTO
  { categoryDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор категории.
  , categoryDTOName :: !(Text) -- ^ /Required/ "name" - Название категории.
  , categoryDTOChildren :: !(Maybe [CategoryDTO]) -- ^ "children" - Дочерние категории.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CategoryDTO
instance A.FromJSON CategoryDTO where
  parseJSON = A.withObject "CategoryDTO" $ \o ->
    CategoryDTO
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "children")

-- | ToJSON CategoryDTO
instance A.ToJSON CategoryDTO where
  toJSON CategoryDTO {..} =
   _omitNulls
      [ "id" .= categoryDTOId
      , "name" .= categoryDTOName
      , "children" .= categoryDTOChildren
      ]


-- | Construct a value of type 'CategoryDTO' (by applying it's required fields, if any)
mkCategoryDTO
  :: Integer -- ^ 'categoryDTOId': Идентификатор категории.
  -> Text -- ^ 'categoryDTOName': Название категории.
  -> CategoryDTO
mkCategoryDTO categoryDTOId categoryDTOName =
  CategoryDTO
  { categoryDTOId
  , categoryDTOName
  , categoryDTOChildren = Nothing
  }

-- ** CategoryErrorDTO
-- | CategoryErrorDTO
-- Текст ошибки.
data CategoryErrorDTO = CategoryErrorDTO
  { categoryErrorDTOCategoryId :: !(Maybe Integer) -- ^ "categoryId" - Идентификатор категории.
  , categoryErrorDTOType :: !(Maybe CategoryErrorType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CategoryErrorDTO
instance A.FromJSON CategoryErrorDTO where
  parseJSON = A.withObject "CategoryErrorDTO" $ \o ->
    CategoryErrorDTO
      <$> (o .:? "categoryId")
      <*> (o .:? "type")

-- | ToJSON CategoryErrorDTO
instance A.ToJSON CategoryErrorDTO where
  toJSON CategoryErrorDTO {..} =
   _omitNulls
      [ "categoryId" .= categoryErrorDTOCategoryId
      , "type" .= categoryErrorDTOType
      ]


-- | Construct a value of type 'CategoryErrorDTO' (by applying it's required fields, if any)
mkCategoryErrorDTO
  :: CategoryErrorDTO
mkCategoryErrorDTO =
  CategoryErrorDTO
  { categoryErrorDTOCategoryId = Nothing
  , categoryErrorDTOType = Nothing
  }

-- ** CategoryParameterDTO
-- | CategoryParameterDTO
-- Характеристика товара.
data CategoryParameterDTO = CategoryParameterDTO
  { categoryParameterDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор характеристики.
  , categoryParameterDTOName :: !(Maybe Text) -- ^ "name" - Название характеристики.
  , categoryParameterDTOType :: !(ParameterType) -- ^ /Required/ "type"
  , categoryParameterDTOUnit :: !(Maybe CategoryParameterUnitDTO) -- ^ "unit"
  , categoryParameterDTODescription :: !(Maybe Text) -- ^ "description" - Описание характеристики.
  , categoryParameterDTORecommendationTypes :: !(Maybe [OfferCardRecommendationType]) -- ^ "recommendationTypes" - Перечень возможных рекомендаций по заполнению карточки, к которым относится данная характеристика.
  , categoryParameterDTORequired :: !(Bool) -- ^ /Required/ "required" - Обязательность характеристики.
  , categoryParameterDTOFiltering :: !(Bool) -- ^ /Required/ "filtering" - Используется ли характеристика в фильтре.
  , categoryParameterDTODistinctive :: !(Bool) -- ^ /Required/ "distinctive" - Является ли характеристика особенностью варианта.
  , categoryParameterDTOMultivalue :: !(Bool) -- ^ /Required/ "multivalue" - Можно ли передать сразу несколько значений.
  , categoryParameterDTOAllowCustomValues :: !(Bool) -- ^ /Required/ "allowCustomValues" - Можно ли передавать собственное значение, которого нет в списке вариантов Маркета. Только для характеристик типа &#x60;ENUM&#x60;.
  , categoryParameterDTOValues :: !(Maybe [ParameterValueOptionDTO]) -- ^ "values" - Список допустимых значений параметра. Только для характеристик типа &#x60;ENUM&#x60;.
  , categoryParameterDTOConstraints :: !(Maybe ParameterValueConstraintsDTO) -- ^ "constraints"
  , categoryParameterDTOValueRestrictions :: !(Maybe [ValueRestrictionDTO]) -- ^ "valueRestrictions" - Ограничения на значения, накладываемые другими характеристиками. Только для характеристик типа &#x60;ENUM&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CategoryParameterDTO
instance A.FromJSON CategoryParameterDTO where
  parseJSON = A.withObject "CategoryParameterDTO" $ \o ->
    CategoryParameterDTO
      <$> (o .:  "id")
      <*> (o .:? "name")
      <*> (o .:  "type")
      <*> (o .:? "unit")
      <*> (o .:? "description")
      <*> (o .:? "recommendationTypes")
      <*> (o .:  "required")
      <*> (o .:  "filtering")
      <*> (o .:  "distinctive")
      <*> (o .:  "multivalue")
      <*> (o .:  "allowCustomValues")
      <*> (o .:? "values")
      <*> (o .:? "constraints")
      <*> (o .:? "valueRestrictions")

-- | ToJSON CategoryParameterDTO
instance A.ToJSON CategoryParameterDTO where
  toJSON CategoryParameterDTO {..} =
   _omitNulls
      [ "id" .= categoryParameterDTOId
      , "name" .= categoryParameterDTOName
      , "type" .= categoryParameterDTOType
      , "unit" .= categoryParameterDTOUnit
      , "description" .= categoryParameterDTODescription
      , "recommendationTypes" .= categoryParameterDTORecommendationTypes
      , "required" .= categoryParameterDTORequired
      , "filtering" .= categoryParameterDTOFiltering
      , "distinctive" .= categoryParameterDTODistinctive
      , "multivalue" .= categoryParameterDTOMultivalue
      , "allowCustomValues" .= categoryParameterDTOAllowCustomValues
      , "values" .= categoryParameterDTOValues
      , "constraints" .= categoryParameterDTOConstraints
      , "valueRestrictions" .= categoryParameterDTOValueRestrictions
      ]


-- | Construct a value of type 'CategoryParameterDTO' (by applying it's required fields, if any)
mkCategoryParameterDTO
  :: Integer -- ^ 'categoryParameterDTOId': Идентификатор характеристики.
  -> ParameterType -- ^ 'categoryParameterDTOType' 
  -> Bool -- ^ 'categoryParameterDTORequired': Обязательность характеристики.
  -> Bool -- ^ 'categoryParameterDTOFiltering': Используется ли характеристика в фильтре.
  -> Bool -- ^ 'categoryParameterDTODistinctive': Является ли характеристика особенностью варианта.
  -> Bool -- ^ 'categoryParameterDTOMultivalue': Можно ли передать сразу несколько значений.
  -> Bool -- ^ 'categoryParameterDTOAllowCustomValues': Можно ли передавать собственное значение, которого нет в списке вариантов Маркета. Только для характеристик типа `ENUM`.
  -> CategoryParameterDTO
mkCategoryParameterDTO categoryParameterDTOId categoryParameterDTOType categoryParameterDTORequired categoryParameterDTOFiltering categoryParameterDTODistinctive categoryParameterDTOMultivalue categoryParameterDTOAllowCustomValues =
  CategoryParameterDTO
  { categoryParameterDTOId
  , categoryParameterDTOName = Nothing
  , categoryParameterDTOType
  , categoryParameterDTOUnit = Nothing
  , categoryParameterDTODescription = Nothing
  , categoryParameterDTORecommendationTypes = Nothing
  , categoryParameterDTORequired
  , categoryParameterDTOFiltering
  , categoryParameterDTODistinctive
  , categoryParameterDTOMultivalue
  , categoryParameterDTOAllowCustomValues
  , categoryParameterDTOValues = Nothing
  , categoryParameterDTOConstraints = Nothing
  , categoryParameterDTOValueRestrictions = Nothing
  }

-- ** CategoryParameterUnitDTO
-- | CategoryParameterUnitDTO
-- Единицы измерения характеристики товара.
data CategoryParameterUnitDTO = CategoryParameterUnitDTO
  { categoryParameterUnitDTODefaultUnitId :: !(Integer) -- ^ /Required/ "defaultUnitId" - Единица измерения по умолчанию.
  , categoryParameterUnitDTOUnits :: !([UnitDTO]) -- ^ /Required/ "units" - Допустимые единицы измерения.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CategoryParameterUnitDTO
instance A.FromJSON CategoryParameterUnitDTO where
  parseJSON = A.withObject "CategoryParameterUnitDTO" $ \o ->
    CategoryParameterUnitDTO
      <$> (o .:  "defaultUnitId")
      <*> (o .:  "units")

-- | ToJSON CategoryParameterUnitDTO
instance A.ToJSON CategoryParameterUnitDTO where
  toJSON CategoryParameterUnitDTO {..} =
   _omitNulls
      [ "defaultUnitId" .= categoryParameterUnitDTODefaultUnitId
      , "units" .= categoryParameterUnitDTOUnits
      ]


-- | Construct a value of type 'CategoryParameterUnitDTO' (by applying it's required fields, if any)
mkCategoryParameterUnitDTO
  :: Integer -- ^ 'categoryParameterUnitDTODefaultUnitId': Единица измерения по умолчанию.
  -> [UnitDTO] -- ^ 'categoryParameterUnitDTOUnits': Допустимые единицы измерения.
  -> CategoryParameterUnitDTO
mkCategoryParameterUnitDTO categoryParameterUnitDTODefaultUnitId categoryParameterUnitDTOUnits =
  CategoryParameterUnitDTO
  { categoryParameterUnitDTODefaultUnitId
  , categoryParameterUnitDTOUnits
  }

-- ** ChangeOutletRequest
-- | ChangeOutletRequest
data ChangeOutletRequest = ChangeOutletRequest
  { changeOutletRequestName :: !(Text) -- ^ /Required/ "name" - Название точки продаж. 
  , changeOutletRequestType :: !(OutletType) -- ^ /Required/ "type"
  , changeOutletRequestCoords :: !(Maybe Text) -- ^ "coords" - Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, &#x60;20.4522144, 54.7104264&#x60;.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в &#x60;address&#x60;. 
  , changeOutletRequestIsMain :: !(Maybe Bool) -- ^ "isMain" - Признак основной точки продаж.  Возможные значения:  * &#x60;false&#x60; — неосновная точка продаж. * &#x60;true&#x60; — основная точка продаж. 
  , changeOutletRequestShopOutletCode :: !(Maybe Text) -- ^ "shopOutletCode" - Идентификатор точки продаж, присвоенный магазином.
  , changeOutletRequestVisibility :: !(Maybe OutletVisibilityType) -- ^ "visibility"
  , changeOutletRequestAddress :: !(OutletAddressDTO) -- ^ /Required/ "address"
  , changeOutletRequestPhones :: !([Text]) -- ^ /Required/ "phones" - Номера телефонов точки продаж. Передавайте в формате: &#x60;+7 (999) 999-99-99&#x60;. 
  , changeOutletRequestWorkingSchedule :: !(OutletWorkingScheduleDTO) -- ^ /Required/ "workingSchedule"
  , changeOutletRequestDeliveryRules :: !(Maybe [OutletDeliveryRuleDTO]) -- ^ "deliveryRules" - Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр &#x60;type&#x3D;DEPOT&#x60; или &#x60;type&#x3D;MIXED&#x60;. 
  , changeOutletRequestStoragePeriod :: !(Maybe Integer) -- ^ "storagePeriod" - Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChangeOutletRequest
instance A.FromJSON ChangeOutletRequest where
  parseJSON = A.withObject "ChangeOutletRequest" $ \o ->
    ChangeOutletRequest
      <$> (o .:  "name")
      <*> (o .:  "type")
      <*> (o .:? "coords")
      <*> (o .:? "isMain")
      <*> (o .:? "shopOutletCode")
      <*> (o .:? "visibility")
      <*> (o .:  "address")
      <*> (o .:  "phones")
      <*> (o .:  "workingSchedule")
      <*> (o .:? "deliveryRules")
      <*> (o .:? "storagePeriod")

-- | ToJSON ChangeOutletRequest
instance A.ToJSON ChangeOutletRequest where
  toJSON ChangeOutletRequest {..} =
   _omitNulls
      [ "name" .= changeOutletRequestName
      , "type" .= changeOutletRequestType
      , "coords" .= changeOutletRequestCoords
      , "isMain" .= changeOutletRequestIsMain
      , "shopOutletCode" .= changeOutletRequestShopOutletCode
      , "visibility" .= changeOutletRequestVisibility
      , "address" .= changeOutletRequestAddress
      , "phones" .= changeOutletRequestPhones
      , "workingSchedule" .= changeOutletRequestWorkingSchedule
      , "deliveryRules" .= changeOutletRequestDeliveryRules
      , "storagePeriod" .= changeOutletRequestStoragePeriod
      ]


-- | Construct a value of type 'ChangeOutletRequest' (by applying it's required fields, if any)
mkChangeOutletRequest
  :: Text -- ^ 'changeOutletRequestName': Название точки продаж. 
  -> OutletType -- ^ 'changeOutletRequestType' 
  -> OutletAddressDTO -- ^ 'changeOutletRequestAddress' 
  -> [Text] -- ^ 'changeOutletRequestPhones': Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`. 
  -> OutletWorkingScheduleDTO -- ^ 'changeOutletRequestWorkingSchedule' 
  -> ChangeOutletRequest
mkChangeOutletRequest changeOutletRequestName changeOutletRequestType changeOutletRequestAddress changeOutletRequestPhones changeOutletRequestWorkingSchedule =
  ChangeOutletRequest
  { changeOutletRequestName
  , changeOutletRequestType
  , changeOutletRequestCoords = Nothing
  , changeOutletRequestIsMain = Nothing
  , changeOutletRequestShopOutletCode = Nothing
  , changeOutletRequestVisibility = Nothing
  , changeOutletRequestAddress
  , changeOutletRequestPhones
  , changeOutletRequestWorkingSchedule
  , changeOutletRequestDeliveryRules = Nothing
  , changeOutletRequestStoragePeriod = Nothing
  }

-- ** ChannelType
-- | ChannelType
-- Каналы продвижения товаров:  * `PUSH` — пуш-уведомление из приложения Яндекс Маркет.  * `STRETCH_MAIN` — верхний баннер-растяжка на главной странице Яндекс Маркета.  * `MAIN_PAGE_CAROUSEL` — карусель акций на главной странице Яндекс Маркета.  * `PRODUCT_RETAIL_PAGE` — товар на странице ритейл-повода.  * `MAIN_PAGE_CAROUSEL_WEB` — карусель акций на главной странице веб версии Яндекс Маркета.  * `PRODUCT_SEPARATE_LANDING` — товар на лендинге акции.  * `SUPER_SHELF_CATEGORY` — полка в категориях.  * `CAROUSEL_RETAIL_PAGE` — карусель на лендинге ритейл-повода.  * `POPUP_APPLICATION` — всплывающее окно в приложении Яндекс Маркет.  * `POST_TELEGRAM` — пост в Телеграм-канале Яндекс Маркета.  * `CPA` — реклама в партнерской сети Яндекс Маркета.  * `WEB_PERFORMANCE_DIRECT` — реклама в Яндекс Директе.  * `APP_PERFORMANCE` — реклама в AppStore и Google Play.  * `BANNER_PICKUP_POINT` — баннер в ПВЗ Маркета.  * `BLOGGER_PERFORMANCE` — рекламная интеграция у блогеров.  * `DIGITAL_CHANNEL_BANNER` — баннер в digital-каналах и социальных сетях VK, Одноклассники.  * `YANDEX_ECOSYSTEM_CHANNELS` — реклама в других сервисах Яндекса: GO, Delivery, Еда.  * `PARTNERS_MAIN_BANNER` — баннер на главной странице mail.ru, auto.ru, ya.ru.  * `OTHER` — прочее. 
data ChannelType = ChannelType
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChannelType
instance A.FromJSON ChannelType where
  parseJSON = A.withObject "ChannelType" $ \o ->
    pure ChannelType
      

-- | ToJSON ChannelType
instance A.ToJSON ChannelType where
  toJSON ChannelType  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'ChannelType' (by applying it's required fields, if any)
mkChannelType
  :: ChannelType
mkChannelType =
  ChannelType
  { 
  }

-- ** ChatMessageDTO
-- | ChatMessageDTO
-- Информация о сообщениях.
data ChatMessageDTO = ChatMessageDTO
  { chatMessageDTOMessageId :: !(Integer) -- ^ /Required/ "messageId" - Идентификатор сообщения.
  , chatMessageDTOCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Дата и время создания сообщения.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:00:00+03:00&#x60;. 
  , chatMessageDTOSender :: !(ChatMessageSenderType) -- ^ /Required/ "sender"
  , chatMessageDTOMessage :: !(Maybe Text) -- ^ "message" - Текст сообщения.  Необязательный параметр, если возвращается параметр &#x60;payload&#x60;. 
  , chatMessageDTOPayload :: !(Maybe [ChatMessagePayloadDTO]) -- ^ "payload" - Информация о приложенных к сообщению файлах.  Необязательный параметр, если возвращается параметр &#x60;message&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatMessageDTO
instance A.FromJSON ChatMessageDTO where
  parseJSON = A.withObject "ChatMessageDTO" $ \o ->
    ChatMessageDTO
      <$> (o .:  "messageId")
      <*> (o .:  "createdAt")
      <*> (o .:  "sender")
      <*> (o .:? "message")
      <*> (o .:? "payload")

-- | ToJSON ChatMessageDTO
instance A.ToJSON ChatMessageDTO where
  toJSON ChatMessageDTO {..} =
   _omitNulls
      [ "messageId" .= chatMessageDTOMessageId
      , "createdAt" .= chatMessageDTOCreatedAt
      , "sender" .= chatMessageDTOSender
      , "message" .= chatMessageDTOMessage
      , "payload" .= chatMessageDTOPayload
      ]


-- | Construct a value of type 'ChatMessageDTO' (by applying it's required fields, if any)
mkChatMessageDTO
  :: Integer -- ^ 'chatMessageDTOMessageId': Идентификатор сообщения.
  -> DateTime -- ^ 'chatMessageDTOCreatedAt': Дата и время создания сообщения.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
  -> ChatMessageSenderType -- ^ 'chatMessageDTOSender' 
  -> ChatMessageDTO
mkChatMessageDTO chatMessageDTOMessageId chatMessageDTOCreatedAt chatMessageDTOSender =
  ChatMessageDTO
  { chatMessageDTOMessageId
  , chatMessageDTOCreatedAt
  , chatMessageDTOSender
  , chatMessageDTOMessage = Nothing
  , chatMessageDTOPayload = Nothing
  }

-- ** ChatMessagePayloadDTO
-- | ChatMessagePayloadDTO
-- Информация о приложенных к сообщению файлах.
data ChatMessagePayloadDTO = ChatMessagePayloadDTO
  { chatMessagePayloadDTOName :: !(Text) -- ^ /Required/ "name" - Имя файла.
  , chatMessagePayloadDTOUrl :: !(Text) -- ^ /Required/ "url" - Ссылка для скачивания файла.
  , chatMessagePayloadDTOSize :: !(Int) -- ^ /Required/ "size" - Размер файла в байтах.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatMessagePayloadDTO
instance A.FromJSON ChatMessagePayloadDTO where
  parseJSON = A.withObject "ChatMessagePayloadDTO" $ \o ->
    ChatMessagePayloadDTO
      <$> (o .:  "name")
      <*> (o .:  "url")
      <*> (o .:  "size")

-- | ToJSON ChatMessagePayloadDTO
instance A.ToJSON ChatMessagePayloadDTO where
  toJSON ChatMessagePayloadDTO {..} =
   _omitNulls
      [ "name" .= chatMessagePayloadDTOName
      , "url" .= chatMessagePayloadDTOUrl
      , "size" .= chatMessagePayloadDTOSize
      ]


-- | Construct a value of type 'ChatMessagePayloadDTO' (by applying it's required fields, if any)
mkChatMessagePayloadDTO
  :: Text -- ^ 'chatMessagePayloadDTOName': Имя файла.
  -> Text -- ^ 'chatMessagePayloadDTOUrl': Ссылка для скачивания файла.
  -> Int -- ^ 'chatMessagePayloadDTOSize': Размер файла в байтах.
  -> ChatMessagePayloadDTO
mkChatMessagePayloadDTO chatMessagePayloadDTOName chatMessagePayloadDTOUrl chatMessagePayloadDTOSize =
  ChatMessagePayloadDTO
  { chatMessagePayloadDTOName
  , chatMessagePayloadDTOUrl
  , chatMessagePayloadDTOSize
  }

-- ** ChatMessagesResultDTO
-- | ChatMessagesResultDTO
-- Информация о сообщениях.
data ChatMessagesResultDTO = ChatMessagesResultDTO
  { chatMessagesResultDTOOrderId :: !(Integer) -- ^ /Required/ "orderId" - Идентификатор заказа.
  , chatMessagesResultDTOMessages :: !([ChatMessageDTO]) -- ^ /Required/ "messages" - Информация о сообщениях.
  , chatMessagesResultDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatMessagesResultDTO
instance A.FromJSON ChatMessagesResultDTO where
  parseJSON = A.withObject "ChatMessagesResultDTO" $ \o ->
    ChatMessagesResultDTO
      <$> (o .:  "orderId")
      <*> (o .:  "messages")
      <*> (o .:? "paging")

-- | ToJSON ChatMessagesResultDTO
instance A.ToJSON ChatMessagesResultDTO where
  toJSON ChatMessagesResultDTO {..} =
   _omitNulls
      [ "orderId" .= chatMessagesResultDTOOrderId
      , "messages" .= chatMessagesResultDTOMessages
      , "paging" .= chatMessagesResultDTOPaging
      ]


-- | Construct a value of type 'ChatMessagesResultDTO' (by applying it's required fields, if any)
mkChatMessagesResultDTO
  :: Integer -- ^ 'chatMessagesResultDTOOrderId': Идентификатор заказа.
  -> [ChatMessageDTO] -- ^ 'chatMessagesResultDTOMessages': Информация о сообщениях.
  -> ChatMessagesResultDTO
mkChatMessagesResultDTO chatMessagesResultDTOOrderId chatMessagesResultDTOMessages =
  ChatMessagesResultDTO
  { chatMessagesResultDTOOrderId
  , chatMessagesResultDTOMessages
  , chatMessagesResultDTOPaging = Nothing
  }

-- ** ConfirmPricesRequest
-- | ConfirmPricesRequest
-- Запрос на подтверждение цены. 
data ConfirmPricesRequest = ConfirmPricesRequest
  { confirmPricesRequestOfferIds :: !([Text]) -- ^ /Required/ "offerIds" - Идентификаторы товаров, у которых подтверждается цена.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConfirmPricesRequest
instance A.FromJSON ConfirmPricesRequest where
  parseJSON = A.withObject "ConfirmPricesRequest" $ \o ->
    ConfirmPricesRequest
      <$> (o .:  "offerIds")

-- | ToJSON ConfirmPricesRequest
instance A.ToJSON ConfirmPricesRequest where
  toJSON ConfirmPricesRequest {..} =
   _omitNulls
      [ "offerIds" .= confirmPricesRequestOfferIds
      ]


-- | Construct a value of type 'ConfirmPricesRequest' (by applying it's required fields, if any)
mkConfirmPricesRequest
  :: [Text] -- ^ 'confirmPricesRequestOfferIds': Идентификаторы товаров, у которых подтверждается цена.
  -> ConfirmPricesRequest
mkConfirmPricesRequest confirmPricesRequestOfferIds =
  ConfirmPricesRequest
  { confirmPricesRequestOfferIds
  }

-- ** ConfirmShipmentRequest
-- | ConfirmShipmentRequest
-- Запрос для подтверждения отгрузки.
data ConfirmShipmentRequest = ConfirmShipmentRequest
  { confirmShipmentRequestExternalShipmentId :: !(Maybe Text) -- ^ "externalShipmentId" - Идентификатор отгрузки в системе поставщика.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConfirmShipmentRequest
instance A.FromJSON ConfirmShipmentRequest where
  parseJSON = A.withObject "ConfirmShipmentRequest" $ \o ->
    ConfirmShipmentRequest
      <$> (o .:? "externalShipmentId")

-- | ToJSON ConfirmShipmentRequest
instance A.ToJSON ConfirmShipmentRequest where
  toJSON ConfirmShipmentRequest {..} =
   _omitNulls
      [ "externalShipmentId" .= confirmShipmentRequestExternalShipmentId
      ]


-- | Construct a value of type 'ConfirmShipmentRequest' (by applying it's required fields, if any)
mkConfirmShipmentRequest
  :: ConfirmShipmentRequest
mkConfirmShipmentRequest =
  ConfirmShipmentRequest
  { confirmShipmentRequestExternalShipmentId = Nothing
  }

-- ** CreateChatRequest
-- | CreateChatRequest
-- Заказ, для которого нужно создать чат. 
data CreateChatRequest = CreateChatRequest
  { createChatRequestOrderId :: !(Integer) -- ^ /Required/ "orderId" - Идентификатор заказа на Маркете.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatRequest
instance A.FromJSON CreateChatRequest where
  parseJSON = A.withObject "CreateChatRequest" $ \o ->
    CreateChatRequest
      <$> (o .:  "orderId")

-- | ToJSON CreateChatRequest
instance A.ToJSON CreateChatRequest where
  toJSON CreateChatRequest {..} =
   _omitNulls
      [ "orderId" .= createChatRequestOrderId
      ]


-- | Construct a value of type 'CreateChatRequest' (by applying it's required fields, if any)
mkCreateChatRequest
  :: Integer -- ^ 'createChatRequestOrderId': Идентификатор заказа на Маркете.
  -> CreateChatRequest
mkCreateChatRequest createChatRequestOrderId =
  CreateChatRequest
  { createChatRequestOrderId
  }

-- ** CreateChatResponse
-- | CreateChatResponse
-- Результат создания чата.
data CreateChatResponse = CreateChatResponse
  { createChatResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , createChatResponseResult :: !(Maybe CreateChatResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatResponse
instance A.FromJSON CreateChatResponse where
  parseJSON = A.withObject "CreateChatResponse" $ \o ->
    CreateChatResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON CreateChatResponse
instance A.ToJSON CreateChatResponse where
  toJSON CreateChatResponse {..} =
   _omitNulls
      [ "status" .= createChatResponseStatus
      , "result" .= createChatResponseResult
      ]


-- | Construct a value of type 'CreateChatResponse' (by applying it's required fields, if any)
mkCreateChatResponse
  :: CreateChatResponse
mkCreateChatResponse =
  CreateChatResponse
  { createChatResponseStatus = Nothing
  , createChatResponseResult = Nothing
  }

-- ** CreateChatResultDTO
-- | CreateChatResultDTO
-- Информация о созданном чате.
data CreateChatResultDTO = CreateChatResultDTO
  { createChatResultDTOChatId :: !(Integer) -- ^ /Required/ "chatId" - Идентификатор чата.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatResultDTO
instance A.FromJSON CreateChatResultDTO where
  parseJSON = A.withObject "CreateChatResultDTO" $ \o ->
    CreateChatResultDTO
      <$> (o .:  "chatId")

-- | ToJSON CreateChatResultDTO
instance A.ToJSON CreateChatResultDTO where
  toJSON CreateChatResultDTO {..} =
   _omitNulls
      [ "chatId" .= createChatResultDTOChatId
      ]


-- | Construct a value of type 'CreateChatResultDTO' (by applying it's required fields, if any)
mkCreateChatResultDTO
  :: Integer -- ^ 'createChatResultDTOChatId': Идентификатор чата.
  -> CreateChatResultDTO
mkCreateChatResultDTO createChatResultDTOChatId =
  CreateChatResultDTO
  { createChatResultDTOChatId
  }

-- ** CreateOutletResponse
-- | CreateOutletResponse
-- Ответ на запрос о создании точки продаж.
data CreateOutletResponse = CreateOutletResponse
  { createOutletResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , createOutletResponseResult :: !(Maybe OutletResponseDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateOutletResponse
instance A.FromJSON CreateOutletResponse where
  parseJSON = A.withObject "CreateOutletResponse" $ \o ->
    CreateOutletResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON CreateOutletResponse
instance A.ToJSON CreateOutletResponse where
  toJSON CreateOutletResponse {..} =
   _omitNulls
      [ "status" .= createOutletResponseStatus
      , "result" .= createOutletResponseResult
      ]


-- | Construct a value of type 'CreateOutletResponse' (by applying it's required fields, if any)
mkCreateOutletResponse
  :: CreateOutletResponse
mkCreateOutletResponse =
  CreateOutletResponse
  { createOutletResponseStatus = Nothing
  , createOutletResponseResult = Nothing
  }

-- ** DeleteCampaignOffersDTO
-- | DeleteCampaignOffersDTO
-- Список товаров, которые не удалось удалить, потому что они не найдены или хранятся на складе Маркета.
data DeleteCampaignOffersDTO = DeleteCampaignOffersDTO
  { deleteCampaignOffersDTONotDeletedOfferIds :: !(Maybe [Text]) -- ^ "notDeletedOfferIds" - Список SKU.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteCampaignOffersDTO
instance A.FromJSON DeleteCampaignOffersDTO where
  parseJSON = A.withObject "DeleteCampaignOffersDTO" $ \o ->
    DeleteCampaignOffersDTO
      <$> (o .:? "notDeletedOfferIds")

-- | ToJSON DeleteCampaignOffersDTO
instance A.ToJSON DeleteCampaignOffersDTO where
  toJSON DeleteCampaignOffersDTO {..} =
   _omitNulls
      [ "notDeletedOfferIds" .= deleteCampaignOffersDTONotDeletedOfferIds
      ]


-- | Construct a value of type 'DeleteCampaignOffersDTO' (by applying it's required fields, if any)
mkDeleteCampaignOffersDTO
  :: DeleteCampaignOffersDTO
mkDeleteCampaignOffersDTO =
  DeleteCampaignOffersDTO
  { deleteCampaignOffersDTONotDeletedOfferIds = Nothing
  }

-- ** DeleteCampaignOffersRequest
-- | DeleteCampaignOffersRequest
-- Фильтрации удаляемых товаров по offerIds. 
data DeleteCampaignOffersRequest = DeleteCampaignOffersRequest
  { deleteCampaignOffersRequestOfferIds :: !([Text]) -- ^ /Required/ "offerIds" - Идентификаторы товаров в каталоге.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteCampaignOffersRequest
instance A.FromJSON DeleteCampaignOffersRequest where
  parseJSON = A.withObject "DeleteCampaignOffersRequest" $ \o ->
    DeleteCampaignOffersRequest
      <$> (o .:  "offerIds")

-- | ToJSON DeleteCampaignOffersRequest
instance A.ToJSON DeleteCampaignOffersRequest where
  toJSON DeleteCampaignOffersRequest {..} =
   _omitNulls
      [ "offerIds" .= deleteCampaignOffersRequestOfferIds
      ]


-- | Construct a value of type 'DeleteCampaignOffersRequest' (by applying it's required fields, if any)
mkDeleteCampaignOffersRequest
  :: [Text] -- ^ 'deleteCampaignOffersRequestOfferIds': Идентификаторы товаров в каталоге.
  -> DeleteCampaignOffersRequest
mkDeleteCampaignOffersRequest deleteCampaignOffersRequestOfferIds =
  DeleteCampaignOffersRequest
  { deleteCampaignOffersRequestOfferIds
  }

-- ** DeleteCampaignOffersResponse
-- | DeleteCampaignOffersResponse
-- Результат удаления товаров.
data DeleteCampaignOffersResponse = DeleteCampaignOffersResponse
  { deleteCampaignOffersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , deleteCampaignOffersResponseResult :: !(Maybe DeleteCampaignOffersDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteCampaignOffersResponse
instance A.FromJSON DeleteCampaignOffersResponse where
  parseJSON = A.withObject "DeleteCampaignOffersResponse" $ \o ->
    DeleteCampaignOffersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON DeleteCampaignOffersResponse
instance A.ToJSON DeleteCampaignOffersResponse where
  toJSON DeleteCampaignOffersResponse {..} =
   _omitNulls
      [ "status" .= deleteCampaignOffersResponseStatus
      , "result" .= deleteCampaignOffersResponseResult
      ]


-- | Construct a value of type 'DeleteCampaignOffersResponse' (by applying it's required fields, if any)
mkDeleteCampaignOffersResponse
  :: DeleteCampaignOffersResponse
mkDeleteCampaignOffersResponse =
  DeleteCampaignOffersResponse
  { deleteCampaignOffersResponseStatus = Nothing
  , deleteCampaignOffersResponseResult = Nothing
  }

-- ** DeleteGoodsFeedbackCommentRequest
-- | DeleteGoodsFeedbackCommentRequest
-- Фильтр запроса отзывов по бизнесу. 
data DeleteGoodsFeedbackCommentRequest = DeleteGoodsFeedbackCommentRequest
  { deleteGoodsFeedbackCommentRequestId :: !(Integer) -- ^ /Required/ "id" - Идентификатор комментария к отзыву. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteGoodsFeedbackCommentRequest
instance A.FromJSON DeleteGoodsFeedbackCommentRequest where
  parseJSON = A.withObject "DeleteGoodsFeedbackCommentRequest" $ \o ->
    DeleteGoodsFeedbackCommentRequest
      <$> (o .:  "id")

-- | ToJSON DeleteGoodsFeedbackCommentRequest
instance A.ToJSON DeleteGoodsFeedbackCommentRequest where
  toJSON DeleteGoodsFeedbackCommentRequest {..} =
   _omitNulls
      [ "id" .= deleteGoodsFeedbackCommentRequestId
      ]


-- | Construct a value of type 'DeleteGoodsFeedbackCommentRequest' (by applying it's required fields, if any)
mkDeleteGoodsFeedbackCommentRequest
  :: Integer -- ^ 'deleteGoodsFeedbackCommentRequestId': Идентификатор комментария к отзыву. 
  -> DeleteGoodsFeedbackCommentRequest
mkDeleteGoodsFeedbackCommentRequest deleteGoodsFeedbackCommentRequestId =
  DeleteGoodsFeedbackCommentRequest
  { deleteGoodsFeedbackCommentRequestId
  }

-- ** DeleteHiddenOffersRequest
-- | DeleteHiddenOffersRequest
-- Запрос на возобновление показа оферов.
data DeleteHiddenOffersRequest = DeleteHiddenOffersRequest
  { deleteHiddenOffersRequestHiddenOffers :: !([HiddenOfferDTO]) -- ^ /Required/ "hiddenOffers" - Список скрытых товаров. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteHiddenOffersRequest
instance A.FromJSON DeleteHiddenOffersRequest where
  parseJSON = A.withObject "DeleteHiddenOffersRequest" $ \o ->
    DeleteHiddenOffersRequest
      <$> (o .:  "hiddenOffers")

-- | ToJSON DeleteHiddenOffersRequest
instance A.ToJSON DeleteHiddenOffersRequest where
  toJSON DeleteHiddenOffersRequest {..} =
   _omitNulls
      [ "hiddenOffers" .= deleteHiddenOffersRequestHiddenOffers
      ]


-- | Construct a value of type 'DeleteHiddenOffersRequest' (by applying it's required fields, if any)
mkDeleteHiddenOffersRequest
  :: [HiddenOfferDTO] -- ^ 'deleteHiddenOffersRequestHiddenOffers': Список скрытых товаров. 
  -> DeleteHiddenOffersRequest
mkDeleteHiddenOffersRequest deleteHiddenOffersRequestHiddenOffers =
  DeleteHiddenOffersRequest
  { deleteHiddenOffersRequestHiddenOffers
  }

-- ** DeleteOffersDTO
-- | DeleteOffersDTO
-- Список товаров, которые не удалось удалить, потому что они хранятся на складе Маркета.
data DeleteOffersDTO = DeleteOffersDTO
  { deleteOffersDTONotDeletedOfferIds :: !(Maybe [Text]) -- ^ "notDeletedOfferIds" - Список SKU товаров, которые не удалось удалить.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteOffersDTO
instance A.FromJSON DeleteOffersDTO where
  parseJSON = A.withObject "DeleteOffersDTO" $ \o ->
    DeleteOffersDTO
      <$> (o .:? "notDeletedOfferIds")

-- | ToJSON DeleteOffersDTO
instance A.ToJSON DeleteOffersDTO where
  toJSON DeleteOffersDTO {..} =
   _omitNulls
      [ "notDeletedOfferIds" .= deleteOffersDTONotDeletedOfferIds
      ]


-- | Construct a value of type 'DeleteOffersDTO' (by applying it's required fields, if any)
mkDeleteOffersDTO
  :: DeleteOffersDTO
mkDeleteOffersDTO =
  DeleteOffersDTO
  { deleteOffersDTONotDeletedOfferIds = Nothing
  }

-- ** DeleteOffersFromArchiveDTO
-- | DeleteOffersFromArchiveDTO
-- Товары, которые не удалось восстановить из архива.
data DeleteOffersFromArchiveDTO = DeleteOffersFromArchiveDTO
  { deleteOffersFromArchiveDTONotUnarchivedOfferIds :: !(Maybe [Text]) -- ^ "notUnarchivedOfferIds" - Список товаров, которые не удалось восстановить из архива.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteOffersFromArchiveDTO
instance A.FromJSON DeleteOffersFromArchiveDTO where
  parseJSON = A.withObject "DeleteOffersFromArchiveDTO" $ \o ->
    DeleteOffersFromArchiveDTO
      <$> (o .:? "notUnarchivedOfferIds")

-- | ToJSON DeleteOffersFromArchiveDTO
instance A.ToJSON DeleteOffersFromArchiveDTO where
  toJSON DeleteOffersFromArchiveDTO {..} =
   _omitNulls
      [ "notUnarchivedOfferIds" .= deleteOffersFromArchiveDTONotUnarchivedOfferIds
      ]


-- | Construct a value of type 'DeleteOffersFromArchiveDTO' (by applying it's required fields, if any)
mkDeleteOffersFromArchiveDTO
  :: DeleteOffersFromArchiveDTO
mkDeleteOffersFromArchiveDTO =
  DeleteOffersFromArchiveDTO
  { deleteOffersFromArchiveDTONotUnarchivedOfferIds = Nothing
  }

-- ** DeleteOffersFromArchiveRequest
-- | DeleteOffersFromArchiveRequest
-- Товары, которые нужно восстановить из архива. 
data DeleteOffersFromArchiveRequest = DeleteOffersFromArchiveRequest
  { deleteOffersFromArchiveRequestOfferIds :: !([Text]) -- ^ /Required/ "offerIds" - Список товаров, которые нужно восстановить из архива.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteOffersFromArchiveRequest
instance A.FromJSON DeleteOffersFromArchiveRequest where
  parseJSON = A.withObject "DeleteOffersFromArchiveRequest" $ \o ->
    DeleteOffersFromArchiveRequest
      <$> (o .:  "offerIds")

-- | ToJSON DeleteOffersFromArchiveRequest
instance A.ToJSON DeleteOffersFromArchiveRequest where
  toJSON DeleteOffersFromArchiveRequest {..} =
   _omitNulls
      [ "offerIds" .= deleteOffersFromArchiveRequestOfferIds
      ]


-- | Construct a value of type 'DeleteOffersFromArchiveRequest' (by applying it's required fields, if any)
mkDeleteOffersFromArchiveRequest
  :: [Text] -- ^ 'deleteOffersFromArchiveRequestOfferIds': Список товаров, которые нужно восстановить из архива.
  -> DeleteOffersFromArchiveRequest
mkDeleteOffersFromArchiveRequest deleteOffersFromArchiveRequestOfferIds =
  DeleteOffersFromArchiveRequest
  { deleteOffersFromArchiveRequestOfferIds
  }

-- ** DeleteOffersFromArchiveResponse
-- | DeleteOffersFromArchiveResponse
-- Результат разархивации товаров.
data DeleteOffersFromArchiveResponse = DeleteOffersFromArchiveResponse
  { deleteOffersFromArchiveResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , deleteOffersFromArchiveResponseResult :: !(Maybe DeleteOffersFromArchiveDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteOffersFromArchiveResponse
instance A.FromJSON DeleteOffersFromArchiveResponse where
  parseJSON = A.withObject "DeleteOffersFromArchiveResponse" $ \o ->
    DeleteOffersFromArchiveResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON DeleteOffersFromArchiveResponse
instance A.ToJSON DeleteOffersFromArchiveResponse where
  toJSON DeleteOffersFromArchiveResponse {..} =
   _omitNulls
      [ "status" .= deleteOffersFromArchiveResponseStatus
      , "result" .= deleteOffersFromArchiveResponseResult
      ]


-- | Construct a value of type 'DeleteOffersFromArchiveResponse' (by applying it's required fields, if any)
mkDeleteOffersFromArchiveResponse
  :: DeleteOffersFromArchiveResponse
mkDeleteOffersFromArchiveResponse =
  DeleteOffersFromArchiveResponse
  { deleteOffersFromArchiveResponseStatus = Nothing
  , deleteOffersFromArchiveResponseResult = Nothing
  }

-- ** DeleteOffersRequest
-- | DeleteOffersRequest
-- Фильтрации удаляемых товаров по offerIds. 
data DeleteOffersRequest = DeleteOffersRequest
  { deleteOffersRequestOfferIds :: !([Text]) -- ^ /Required/ "offerIds" - Список SKU товаров, которые нужно удалить.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteOffersRequest
instance A.FromJSON DeleteOffersRequest where
  parseJSON = A.withObject "DeleteOffersRequest" $ \o ->
    DeleteOffersRequest
      <$> (o .:  "offerIds")

-- | ToJSON DeleteOffersRequest
instance A.ToJSON DeleteOffersRequest where
  toJSON DeleteOffersRequest {..} =
   _omitNulls
      [ "offerIds" .= deleteOffersRequestOfferIds
      ]


-- | Construct a value of type 'DeleteOffersRequest' (by applying it's required fields, if any)
mkDeleteOffersRequest
  :: [Text] -- ^ 'deleteOffersRequestOfferIds': Список SKU товаров, которые нужно удалить.
  -> DeleteOffersRequest
mkDeleteOffersRequest deleteOffersRequestOfferIds =
  DeleteOffersRequest
  { deleteOffersRequestOfferIds
  }

-- ** DeleteOffersResponse
-- | DeleteOffersResponse
-- Результат удаления товаров.
data DeleteOffersResponse = DeleteOffersResponse
  { deleteOffersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , deleteOffersResponseResult :: !(Maybe DeleteOffersDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteOffersResponse
instance A.FromJSON DeleteOffersResponse where
  parseJSON = A.withObject "DeleteOffersResponse" $ \o ->
    DeleteOffersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON DeleteOffersResponse
instance A.ToJSON DeleteOffersResponse where
  toJSON DeleteOffersResponse {..} =
   _omitNulls
      [ "status" .= deleteOffersResponseStatus
      , "result" .= deleteOffersResponseResult
      ]


-- | Construct a value of type 'DeleteOffersResponse' (by applying it's required fields, if any)
mkDeleteOffersResponse
  :: DeleteOffersResponse
mkDeleteOffersResponse =
  DeleteOffersResponse
  { deleteOffersResponseStatus = Nothing
  , deleteOffersResponseResult = Nothing
  }

-- ** DeletePromoOffersRequest
-- | DeletePromoOffersRequest
-- Удаление товаров из акции.  Чтобы убрать:  * все товары из акции и больше не участвовать в ней, передайте значение `true` в параметре `deleteAllOffers`;  * часть товаров, передайте их идентификаторы в параметре `offersIds`. 
data DeletePromoOffersRequest = DeletePromoOffersRequest
  { deletePromoOffersRequestPromoId :: !(Text) -- ^ /Required/ "promoId" - Идентификатор акции.
  , deletePromoOffersRequestDeleteAllOffers :: !(Maybe Bool) -- ^ "deleteAllOffers" - Чтобы убрать все товары из акции и больше не участвовать в ней, передайте значение &#x60;true&#x60; и не передавайте параметр &#x60;offerIds&#x60;.
  , deletePromoOffersRequestOfferIds :: !(Maybe [Text]) -- ^ "offerIds" - Товары, которые нужно убрать из акции.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeletePromoOffersRequest
instance A.FromJSON DeletePromoOffersRequest where
  parseJSON = A.withObject "DeletePromoOffersRequest" $ \o ->
    DeletePromoOffersRequest
      <$> (o .:  "promoId")
      <*> (o .:? "deleteAllOffers")
      <*> (o .:? "offerIds")

-- | ToJSON DeletePromoOffersRequest
instance A.ToJSON DeletePromoOffersRequest where
  toJSON DeletePromoOffersRequest {..} =
   _omitNulls
      [ "promoId" .= deletePromoOffersRequestPromoId
      , "deleteAllOffers" .= deletePromoOffersRequestDeleteAllOffers
      , "offerIds" .= deletePromoOffersRequestOfferIds
      ]


-- | Construct a value of type 'DeletePromoOffersRequest' (by applying it's required fields, if any)
mkDeletePromoOffersRequest
  :: Text -- ^ 'deletePromoOffersRequestPromoId': Идентификатор акции.
  -> DeletePromoOffersRequest
mkDeletePromoOffersRequest deletePromoOffersRequestPromoId =
  DeletePromoOffersRequest
  { deletePromoOffersRequestPromoId
  , deletePromoOffersRequestDeleteAllOffers = Nothing
  , deletePromoOffersRequestOfferIds = Nothing
  }

-- ** DeletePromoOffersResponse
-- | DeletePromoOffersResponse
-- Результат удаления товаров из акции.
data DeletePromoOffersResponse = DeletePromoOffersResponse
  { deletePromoOffersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , deletePromoOffersResponseResult :: !(Maybe DeletePromoOffersResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeletePromoOffersResponse
instance A.FromJSON DeletePromoOffersResponse where
  parseJSON = A.withObject "DeletePromoOffersResponse" $ \o ->
    DeletePromoOffersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON DeletePromoOffersResponse
instance A.ToJSON DeletePromoOffersResponse where
  toJSON DeletePromoOffersResponse {..} =
   _omitNulls
      [ "status" .= deletePromoOffersResponseStatus
      , "result" .= deletePromoOffersResponseResult
      ]


-- | Construct a value of type 'DeletePromoOffersResponse' (by applying it's required fields, if any)
mkDeletePromoOffersResponse
  :: DeletePromoOffersResponse
mkDeletePromoOffersResponse =
  DeletePromoOffersResponse
  { deletePromoOffersResponseStatus = Nothing
  , deletePromoOffersResponseResult = Nothing
  }

-- ** DeletePromoOffersResultDTO
-- | DeletePromoOffersResultDTO
-- Результат удаления товаров из акции.  Возвращается, только если в запросе был передан параметр `offerIds`. 
data DeletePromoOffersResultDTO = DeletePromoOffersResultDTO
  { deletePromoOffersResultDTORejectedOffers :: !(Maybe [RejectedPromoOfferDeleteDTO]) -- ^ "rejectedOffers" - Товары, при удалении которых появились ошибки.  Возвращается, только если есть такие товары. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeletePromoOffersResultDTO
instance A.FromJSON DeletePromoOffersResultDTO where
  parseJSON = A.withObject "DeletePromoOffersResultDTO" $ \o ->
    DeletePromoOffersResultDTO
      <$> (o .:? "rejectedOffers")

-- | ToJSON DeletePromoOffersResultDTO
instance A.ToJSON DeletePromoOffersResultDTO where
  toJSON DeletePromoOffersResultDTO {..} =
   _omitNulls
      [ "rejectedOffers" .= deletePromoOffersResultDTORejectedOffers
      ]


-- | Construct a value of type 'DeletePromoOffersResultDTO' (by applying it's required fields, if any)
mkDeletePromoOffersResultDTO
  :: DeletePromoOffersResultDTO
mkDeletePromoOffersResultDTO =
  DeletePromoOffersResultDTO
  { deletePromoOffersResultDTORejectedOffers = Nothing
  }

-- ** DeliveryServiceDTO
-- | DeliveryServiceDTO
-- Служба доставки.
data DeliveryServiceDTO = DeliveryServiceDTO
  { deliveryServiceDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор службы доставки.
  , deliveryServiceDTOName :: !(Maybe Text) -- ^ "name" - Наименование службы доставки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeliveryServiceDTO
instance A.FromJSON DeliveryServiceDTO where
  parseJSON = A.withObject "DeliveryServiceDTO" $ \o ->
    DeliveryServiceDTO
      <$> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON DeliveryServiceDTO
instance A.ToJSON DeliveryServiceDTO where
  toJSON DeliveryServiceDTO {..} =
   _omitNulls
      [ "id" .= deliveryServiceDTOId
      , "name" .= deliveryServiceDTOName
      ]


-- | Construct a value of type 'DeliveryServiceDTO' (by applying it's required fields, if any)
mkDeliveryServiceDTO
  :: DeliveryServiceDTO
mkDeliveryServiceDTO =
  DeliveryServiceDTO
  { deliveryServiceDTOId = Nothing
  , deliveryServiceDTOName = Nothing
  }

-- ** DeliveryServiceInfoDTO
-- | DeliveryServiceInfoDTO
-- Информация о службе доставки.
data DeliveryServiceInfoDTO = DeliveryServiceInfoDTO
  { deliveryServiceInfoDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор службы доставки.
  , deliveryServiceInfoDTOName :: !(Text) -- ^ /Required/ "name" - Наименование службы доставки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeliveryServiceInfoDTO
instance A.FromJSON DeliveryServiceInfoDTO where
  parseJSON = A.withObject "DeliveryServiceInfoDTO" $ \o ->
    DeliveryServiceInfoDTO
      <$> (o .:  "id")
      <*> (o .:  "name")

-- | ToJSON DeliveryServiceInfoDTO
instance A.ToJSON DeliveryServiceInfoDTO where
  toJSON DeliveryServiceInfoDTO {..} =
   _omitNulls
      [ "id" .= deliveryServiceInfoDTOId
      , "name" .= deliveryServiceInfoDTOName
      ]


-- | Construct a value of type 'DeliveryServiceInfoDTO' (by applying it's required fields, if any)
mkDeliveryServiceInfoDTO
  :: Integer -- ^ 'deliveryServiceInfoDTOId': Идентификатор службы доставки.
  -> Text -- ^ 'deliveryServiceInfoDTOName': Наименование службы доставки.
  -> DeliveryServiceInfoDTO
mkDeliveryServiceInfoDTO deliveryServiceInfoDTOId deliveryServiceInfoDTOName =
  DeliveryServiceInfoDTO
  { deliveryServiceInfoDTOId
  , deliveryServiceInfoDTOName
  }

-- ** DeliveryServicesDTO
-- | DeliveryServicesDTO
-- Информация о службах доставки.
data DeliveryServicesDTO = DeliveryServicesDTO
  { deliveryServicesDTODeliveryService :: !([DeliveryServiceInfoDTO]) -- ^ /Required/ "deliveryService" - Информация о службе доставки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeliveryServicesDTO
instance A.FromJSON DeliveryServicesDTO where
  parseJSON = A.withObject "DeliveryServicesDTO" $ \o ->
    DeliveryServicesDTO
      <$> (o .:  "deliveryService")

-- | ToJSON DeliveryServicesDTO
instance A.ToJSON DeliveryServicesDTO where
  toJSON DeliveryServicesDTO {..} =
   _omitNulls
      [ "deliveryService" .= deliveryServicesDTODeliveryService
      ]


-- | Construct a value of type 'DeliveryServicesDTO' (by applying it's required fields, if any)
mkDeliveryServicesDTO
  :: [DeliveryServiceInfoDTO] -- ^ 'deliveryServicesDTODeliveryService': Информация о службе доставки.
  -> DeliveryServicesDTO
mkDeliveryServicesDTO deliveryServicesDTODeliveryService =
  DeliveryServicesDTO
  { deliveryServicesDTODeliveryService
  }

-- ** DocumentDTO
-- | DocumentDTO
-- Информация о документе.
data DocumentDTO = DocumentDTO
  { documentDTOStatus :: !(Maybe OrderDocumentStatusType) -- ^ "status"
  , documentDTONumber :: !(Maybe Text) -- ^ "number" - Номер документа.
  , documentDTODate :: !(Maybe Date) -- ^ "date" - Дата создания документа.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DocumentDTO
instance A.FromJSON DocumentDTO where
  parseJSON = A.withObject "DocumentDTO" $ \o ->
    DocumentDTO
      <$> (o .:? "status")
      <*> (o .:? "number")
      <*> (o .:? "date")

-- | ToJSON DocumentDTO
instance A.ToJSON DocumentDTO where
  toJSON DocumentDTO {..} =
   _omitNulls
      [ "status" .= documentDTOStatus
      , "number" .= documentDTONumber
      , "date" .= documentDTODate
      ]


-- | Construct a value of type 'DocumentDTO' (by applying it's required fields, if any)
mkDocumentDTO
  :: DocumentDTO
mkDocumentDTO =
  DocumentDTO
  { documentDTOStatus = Nothing
  , documentDTONumber = Nothing
  , documentDTODate = Nothing
  }

-- ** EacVerificationResultDTO
-- | EacVerificationResultDTO
-- Результат выполнения запроса.
data EacVerificationResultDTO = EacVerificationResultDTO
  { eacVerificationResultDTOVerificationResult :: !(Maybe EacVerificationStatusType) -- ^ "verificationResult"
  , eacVerificationResultDTOAttemptsLeft :: !(Maybe Int) -- ^ "attemptsLeft" - Количество оставшихся попыток проверки кода.  Возвращается, если магазин отправил некорректный код.  Когда все попытки будут исчерпаны, код обновится. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EacVerificationResultDTO
instance A.FromJSON EacVerificationResultDTO where
  parseJSON = A.withObject "EacVerificationResultDTO" $ \o ->
    EacVerificationResultDTO
      <$> (o .:? "verificationResult")
      <*> (o .:? "attemptsLeft")

-- | ToJSON EacVerificationResultDTO
instance A.ToJSON EacVerificationResultDTO where
  toJSON EacVerificationResultDTO {..} =
   _omitNulls
      [ "verificationResult" .= eacVerificationResultDTOVerificationResult
      , "attemptsLeft" .= eacVerificationResultDTOAttemptsLeft
      ]


-- | Construct a value of type 'EacVerificationResultDTO' (by applying it's required fields, if any)
mkEacVerificationResultDTO
  :: EacVerificationResultDTO
mkEacVerificationResultDTO =
  EacVerificationResultDTO
  { eacVerificationResultDTOVerificationResult = Nothing
  , eacVerificationResultDTOAttemptsLeft = Nothing
  }

-- ** EmptyApiResponse
-- | EmptyApiResponse
-- Пустой ответ сервера.
data EmptyApiResponse = EmptyApiResponse
  { emptyApiResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmptyApiResponse
instance A.FromJSON EmptyApiResponse where
  parseJSON = A.withObject "EmptyApiResponse" $ \o ->
    EmptyApiResponse
      <$> (o .:? "status")

-- | ToJSON EmptyApiResponse
instance A.ToJSON EmptyApiResponse where
  toJSON EmptyApiResponse {..} =
   _omitNulls
      [ "status" .= emptyApiResponseStatus
      ]


-- | Construct a value of type 'EmptyApiResponse' (by applying it's required fields, if any)
mkEmptyApiResponse
  :: EmptyApiResponse
mkEmptyApiResponse =
  EmptyApiResponse
  { emptyApiResponseStatus = Nothing
  }

-- ** EnrichedMappingsOfferDTO
-- | EnrichedMappingsOfferDTO
-- Информация о рекомендованных карточках товаров.
data EnrichedMappingsOfferDTO = EnrichedMappingsOfferDTO
  { enrichedMappingsOfferDTOName :: !(Maybe Text) -- ^ "name" - Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
  , enrichedMappingsOfferDTOShopSku :: !(Maybe Text) -- ^ "shopSku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , enrichedMappingsOfferDTOCategory :: !(Maybe Text) -- ^ "category" - Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;. 
  , enrichedMappingsOfferDTOVendor :: !(Maybe Text) -- ^ "vendor" - Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
  , enrichedMappingsOfferDTOVendorCode :: !(Maybe Text) -- ^ "vendorCode" - Артикул товара от производителя.
  , enrichedMappingsOfferDTODescription :: !(Maybe Text) -- ^ "description" - Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\&lt;h&gt;, \\&lt;h1&gt;, \\&lt;h2&gt; и так далее — для заголовков; * \\&lt;br&gt; и \\&lt;p&gt; — для переноса строки; * \\&lt;ol&gt; — для нумерованного списка; * \\&lt;ul&gt; — для маркированного списка; * \\&lt;li&gt; — для создания элементов списка (должен находиться внутри \\&lt;ol&gt; или \\&lt;ul&gt;); * \\&lt;div&gt; — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
  , enrichedMappingsOfferDTOId :: !(Maybe Text) -- ^ "id" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , enrichedMappingsOfferDTOFeedId :: !(Maybe Integer) -- ^ "feedId" - Идентификатор фида.
  , enrichedMappingsOfferDTOBarcodes :: !(Maybe [Text]) -- ^ "barcodes" - Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
  , enrichedMappingsOfferDTOUrls :: !(Maybe [Text]) -- ^ "urls" - URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
  , enrichedMappingsOfferDTOPictures :: !(Maybe [Text]) -- ^ "pictures" - Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр &#x60;picture&#x60;. 
  , enrichedMappingsOfferDTOManufacturer :: !(Maybe Text) -- ^ "manufacturer" - Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
  , enrichedMappingsOfferDTOManufacturerCountries :: !(Maybe [Text]) -- ^ "manufacturerCountries" - Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
  , enrichedMappingsOfferDTOMinShipment :: !(Maybe Int) -- ^ "minShipment" - Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
  , enrichedMappingsOfferDTOTransportUnitSize :: !(Maybe Int) -- ^ "transportUnitSize" - Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
  , enrichedMappingsOfferDTOQuantumOfSupply :: !(Maybe Int) -- ^ "quantumOfSupply" - Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
  , enrichedMappingsOfferDTODeliveryDurationDays :: !(Maybe Int) -- ^ "deliveryDurationDays" - Срок, за который продавец поставляет товары на склад, в днях.
  , enrichedMappingsOfferDTOBoxCount :: !(Maybe Int) -- ^ "boxCount" - Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
  , enrichedMappingsOfferDTOCustomsCommodityCodes :: !(Maybe [Text]) -- ^ "customsCommodityCodes" - Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
  , enrichedMappingsOfferDTOWeightDimensions :: !(Maybe OfferWeightDimensionsDTO) -- ^ "weightDimensions"
  , enrichedMappingsOfferDTOSupplyScheduleDays :: !(Maybe [DayOfWeekType]) -- ^ "supplyScheduleDays" - Дни недели, в которые продавец поставляет товары на склад.
  , enrichedMappingsOfferDTOShelfLifeDays :: !(Maybe Int) -- ^ "shelfLifeDays" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Вместо него используйте &#x60;shelfLife&#x60;. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
  , enrichedMappingsOfferDTOLifeTimeDays :: !(Maybe Int) -- ^ "lifeTimeDays" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Вместо него используйте &#x60;lifeTime&#x60;. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
  , enrichedMappingsOfferDTOGuaranteePeriodDays :: !(Maybe Int) -- ^ "guaranteePeriodDays" - Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
  , enrichedMappingsOfferDTOProcessingState :: !(Maybe OfferProcessingStateDTO) -- ^ "processingState"
  , enrichedMappingsOfferDTOAvailability :: !(Maybe OfferAvailabilityStatusType) -- ^ "availability"
  , enrichedMappingsOfferDTOShelfLife :: !(Maybe TimePeriodDTO) -- ^ "shelfLife"
  , enrichedMappingsOfferDTOLifeTime :: !(Maybe TimePeriodDTO) -- ^ "lifeTime"
  , enrichedMappingsOfferDTOGuaranteePeriod :: !(Maybe TimePeriodDTO) -- ^ "guaranteePeriod"
  , enrichedMappingsOfferDTOCertificate :: !(Maybe Text) -- ^ "certificate" - Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
  , enrichedMappingsOfferDTOPrice :: !(Maybe Double) -- ^ "price" - Цена на товар в рублях.
  , enrichedMappingsOfferDTOMarketCategoryId :: !(Maybe Integer) -- ^ "marketCategoryId" - Идентификатор категории для рекомендованной карточки товара на Маркете.  Возвращается только вместе с параметром ##marketSku##. 
  , enrichedMappingsOfferDTOMarketCategoryName :: !(Maybe Text) -- ^ "marketCategoryName" - Название категории для рекомендованной карточки товара на Маркете.  Может отсутствовать в ответе. 
  , enrichedMappingsOfferDTOMarketModelId :: !(Maybe Integer) -- ^ "marketModelId" - Идентификатор модели для рекомендованной карточки товара на Маркете.  Может отсутствовать в ответе. 
  , enrichedMappingsOfferDTOMarketModelName :: !(Maybe Text) -- ^ "marketModelName" - Название модели для рекомендованной карточки товара на Маркете.  Возвращается только вместе с параметром ##marketSku##. 
  , enrichedMappingsOfferDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  , enrichedMappingsOfferDTOMarketSkuName :: !(Maybe Text) -- ^ "marketSkuName" - Название товара с рекомендованной карточки на Маркете.  Может отсутствовать в ответе. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnrichedMappingsOfferDTO
instance A.FromJSON EnrichedMappingsOfferDTO where
  parseJSON = A.withObject "EnrichedMappingsOfferDTO" $ \o ->
    EnrichedMappingsOfferDTO
      <$> (o .:? "name")
      <*> (o .:? "shopSku")
      <*> (o .:? "category")
      <*> (o .:? "vendor")
      <*> (o .:? "vendorCode")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "feedId")
      <*> (o .:? "barcodes")
      <*> (o .:? "urls")
      <*> (o .:? "pictures")
      <*> (o .:? "manufacturer")
      <*> (o .:? "manufacturerCountries")
      <*> (o .:? "minShipment")
      <*> (o .:? "transportUnitSize")
      <*> (o .:? "quantumOfSupply")
      <*> (o .:? "deliveryDurationDays")
      <*> (o .:? "boxCount")
      <*> (o .:? "customsCommodityCodes")
      <*> (o .:? "weightDimensions")
      <*> (o .:? "supplyScheduleDays")
      <*> (o .:? "shelfLifeDays")
      <*> (o .:? "lifeTimeDays")
      <*> (o .:? "guaranteePeriodDays")
      <*> (o .:? "processingState")
      <*> (o .:? "availability")
      <*> (o .:? "shelfLife")
      <*> (o .:? "lifeTime")
      <*> (o .:? "guaranteePeriod")
      <*> (o .:? "certificate")
      <*> (o .:? "price")
      <*> (o .:? "marketCategoryId")
      <*> (o .:? "marketCategoryName")
      <*> (o .:? "marketModelId")
      <*> (o .:? "marketModelName")
      <*> (o .:? "marketSku")
      <*> (o .:? "marketSkuName")

-- | ToJSON EnrichedMappingsOfferDTO
instance A.ToJSON EnrichedMappingsOfferDTO where
  toJSON EnrichedMappingsOfferDTO {..} =
   _omitNulls
      [ "name" .= enrichedMappingsOfferDTOName
      , "shopSku" .= enrichedMappingsOfferDTOShopSku
      , "category" .= enrichedMappingsOfferDTOCategory
      , "vendor" .= enrichedMappingsOfferDTOVendor
      , "vendorCode" .= enrichedMappingsOfferDTOVendorCode
      , "description" .= enrichedMappingsOfferDTODescription
      , "id" .= enrichedMappingsOfferDTOId
      , "feedId" .= enrichedMappingsOfferDTOFeedId
      , "barcodes" .= enrichedMappingsOfferDTOBarcodes
      , "urls" .= enrichedMappingsOfferDTOUrls
      , "pictures" .= enrichedMappingsOfferDTOPictures
      , "manufacturer" .= enrichedMappingsOfferDTOManufacturer
      , "manufacturerCountries" .= enrichedMappingsOfferDTOManufacturerCountries
      , "minShipment" .= enrichedMappingsOfferDTOMinShipment
      , "transportUnitSize" .= enrichedMappingsOfferDTOTransportUnitSize
      , "quantumOfSupply" .= enrichedMappingsOfferDTOQuantumOfSupply
      , "deliveryDurationDays" .= enrichedMappingsOfferDTODeliveryDurationDays
      , "boxCount" .= enrichedMappingsOfferDTOBoxCount
      , "customsCommodityCodes" .= enrichedMappingsOfferDTOCustomsCommodityCodes
      , "weightDimensions" .= enrichedMappingsOfferDTOWeightDimensions
      , "supplyScheduleDays" .= enrichedMappingsOfferDTOSupplyScheduleDays
      , "shelfLifeDays" .= enrichedMappingsOfferDTOShelfLifeDays
      , "lifeTimeDays" .= enrichedMappingsOfferDTOLifeTimeDays
      , "guaranteePeriodDays" .= enrichedMappingsOfferDTOGuaranteePeriodDays
      , "processingState" .= enrichedMappingsOfferDTOProcessingState
      , "availability" .= enrichedMappingsOfferDTOAvailability
      , "shelfLife" .= enrichedMappingsOfferDTOShelfLife
      , "lifeTime" .= enrichedMappingsOfferDTOLifeTime
      , "guaranteePeriod" .= enrichedMappingsOfferDTOGuaranteePeriod
      , "certificate" .= enrichedMappingsOfferDTOCertificate
      , "price" .= enrichedMappingsOfferDTOPrice
      , "marketCategoryId" .= enrichedMappingsOfferDTOMarketCategoryId
      , "marketCategoryName" .= enrichedMappingsOfferDTOMarketCategoryName
      , "marketModelId" .= enrichedMappingsOfferDTOMarketModelId
      , "marketModelName" .= enrichedMappingsOfferDTOMarketModelName
      , "marketSku" .= enrichedMappingsOfferDTOMarketSku
      , "marketSkuName" .= enrichedMappingsOfferDTOMarketSkuName
      ]


-- | Construct a value of type 'EnrichedMappingsOfferDTO' (by applying it's required fields, if any)
mkEnrichedMappingsOfferDTO
  :: EnrichedMappingsOfferDTO
mkEnrichedMappingsOfferDTO =
  EnrichedMappingsOfferDTO
  { enrichedMappingsOfferDTOName = Nothing
  , enrichedMappingsOfferDTOShopSku = Nothing
  , enrichedMappingsOfferDTOCategory = Nothing
  , enrichedMappingsOfferDTOVendor = Nothing
  , enrichedMappingsOfferDTOVendorCode = Nothing
  , enrichedMappingsOfferDTODescription = Nothing
  , enrichedMappingsOfferDTOId = Nothing
  , enrichedMappingsOfferDTOFeedId = Nothing
  , enrichedMappingsOfferDTOBarcodes = Nothing
  , enrichedMappingsOfferDTOUrls = Nothing
  , enrichedMappingsOfferDTOPictures = Nothing
  , enrichedMappingsOfferDTOManufacturer = Nothing
  , enrichedMappingsOfferDTOManufacturerCountries = Nothing
  , enrichedMappingsOfferDTOMinShipment = Nothing
  , enrichedMappingsOfferDTOTransportUnitSize = Nothing
  , enrichedMappingsOfferDTOQuantumOfSupply = Nothing
  , enrichedMappingsOfferDTODeliveryDurationDays = Nothing
  , enrichedMappingsOfferDTOBoxCount = Nothing
  , enrichedMappingsOfferDTOCustomsCommodityCodes = Nothing
  , enrichedMappingsOfferDTOWeightDimensions = Nothing
  , enrichedMappingsOfferDTOSupplyScheduleDays = Nothing
  , enrichedMappingsOfferDTOShelfLifeDays = Nothing
  , enrichedMappingsOfferDTOLifeTimeDays = Nothing
  , enrichedMappingsOfferDTOGuaranteePeriodDays = Nothing
  , enrichedMappingsOfferDTOProcessingState = Nothing
  , enrichedMappingsOfferDTOAvailability = Nothing
  , enrichedMappingsOfferDTOShelfLife = Nothing
  , enrichedMappingsOfferDTOLifeTime = Nothing
  , enrichedMappingsOfferDTOGuaranteePeriod = Nothing
  , enrichedMappingsOfferDTOCertificate = Nothing
  , enrichedMappingsOfferDTOPrice = Nothing
  , enrichedMappingsOfferDTOMarketCategoryId = Nothing
  , enrichedMappingsOfferDTOMarketCategoryName = Nothing
  , enrichedMappingsOfferDTOMarketModelId = Nothing
  , enrichedMappingsOfferDTOMarketModelName = Nothing
  , enrichedMappingsOfferDTOMarketSku = Nothing
  , enrichedMappingsOfferDTOMarketSkuName = Nothing
  }

-- ** EnrichedModelDTO
-- | EnrichedModelDTO
-- Модель товара.
data EnrichedModelDTO = EnrichedModelDTO
  { enrichedModelDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор модели товара.
  , enrichedModelDTOName :: !(Maybe Text) -- ^ "name" - Название модели товара.
  , enrichedModelDTOPrices :: !(Maybe ModelPriceDTO) -- ^ "prices"
  , enrichedModelDTOOffers :: !(Maybe [ModelOfferDTO]) -- ^ "offers" - Список первых десяти предложений, расположенных на карточке модели.  В ответе на запрос возвращаются предложения различных магазинов. Если есть несколько предложений от одного магазина, в ответе отображается только одно, наиболее релевантное из них. 
  , enrichedModelDTOOfflineOffers :: !(Maybe Int) -- ^ "offlineOffers" - Суммарное количество предложений в розничных магазинах в регионе. Учитываются все предложения от каждого магазина.
  , enrichedModelDTOOnlineOffers :: !(Maybe Int) -- ^ "onlineOffers" - Суммарное количество предложений в интернет-магазинах в регионе. Учитываются все предложения от каждого магазина.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnrichedModelDTO
instance A.FromJSON EnrichedModelDTO where
  parseJSON = A.withObject "EnrichedModelDTO" $ \o ->
    EnrichedModelDTO
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "prices")
      <*> (o .:? "offers")
      <*> (o .:? "offlineOffers")
      <*> (o .:? "onlineOffers")

-- | ToJSON EnrichedModelDTO
instance A.ToJSON EnrichedModelDTO where
  toJSON EnrichedModelDTO {..} =
   _omitNulls
      [ "id" .= enrichedModelDTOId
      , "name" .= enrichedModelDTOName
      , "prices" .= enrichedModelDTOPrices
      , "offers" .= enrichedModelDTOOffers
      , "offlineOffers" .= enrichedModelDTOOfflineOffers
      , "onlineOffers" .= enrichedModelDTOOnlineOffers
      ]


-- | Construct a value of type 'EnrichedModelDTO' (by applying it's required fields, if any)
mkEnrichedModelDTO
  :: EnrichedModelDTO
mkEnrichedModelDTO =
  EnrichedModelDTO
  { enrichedModelDTOId = Nothing
  , enrichedModelDTOName = Nothing
  , enrichedModelDTOPrices = Nothing
  , enrichedModelDTOOffers = Nothing
  , enrichedModelDTOOfflineOffers = Nothing
  , enrichedModelDTOOnlineOffers = Nothing
  }

-- ** EnrichedModelsDTO
-- | EnrichedModelsDTO
-- Список моделей товаров.
data EnrichedModelsDTO = EnrichedModelsDTO
  { enrichedModelsDTOModels :: !([EnrichedModelDTO]) -- ^ /Required/ "models" - Список моделей товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnrichedModelsDTO
instance A.FromJSON EnrichedModelsDTO where
  parseJSON = A.withObject "EnrichedModelsDTO" $ \o ->
    EnrichedModelsDTO
      <$> (o .:  "models")

-- | ToJSON EnrichedModelsDTO
instance A.ToJSON EnrichedModelsDTO where
  toJSON EnrichedModelsDTO {..} =
   _omitNulls
      [ "models" .= enrichedModelsDTOModels
      ]


-- | Construct a value of type 'EnrichedModelsDTO' (by applying it's required fields, if any)
mkEnrichedModelsDTO
  :: [EnrichedModelDTO] -- ^ 'enrichedModelsDTOModels': Список моделей товаров.
  -> EnrichedModelsDTO
mkEnrichedModelsDTO enrichedModelsDTOModels =
  EnrichedModelsDTO
  { enrichedModelsDTOModels
  }

-- ** EnrichedOrderBoxLayoutDTO
-- | EnrichedOrderBoxLayoutDTO
-- Информация о коробке.
data EnrichedOrderBoxLayoutDTO = EnrichedOrderBoxLayoutDTO
  { enrichedOrderBoxLayoutDTOItems :: !([OrderBoxLayoutItemDTO]) -- ^ /Required/ "items" - Список товаров в коробке.  Если в коробке едет часть большого товара, в списке может быть только один пункт. 
  , enrichedOrderBoxLayoutDTOBoxId :: !(Maybe Integer) -- ^ "boxId" - Идентификатор коробки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnrichedOrderBoxLayoutDTO
instance A.FromJSON EnrichedOrderBoxLayoutDTO where
  parseJSON = A.withObject "EnrichedOrderBoxLayoutDTO" $ \o ->
    EnrichedOrderBoxLayoutDTO
      <$> (o .:  "items")
      <*> (o .:? "boxId")

-- | ToJSON EnrichedOrderBoxLayoutDTO
instance A.ToJSON EnrichedOrderBoxLayoutDTO where
  toJSON EnrichedOrderBoxLayoutDTO {..} =
   _omitNulls
      [ "items" .= enrichedOrderBoxLayoutDTOItems
      , "boxId" .= enrichedOrderBoxLayoutDTOBoxId
      ]


-- | Construct a value of type 'EnrichedOrderBoxLayoutDTO' (by applying it's required fields, if any)
mkEnrichedOrderBoxLayoutDTO
  :: [OrderBoxLayoutItemDTO] -- ^ 'enrichedOrderBoxLayoutDTOItems': Список товаров в коробке.  Если в коробке едет часть большого товара, в списке может быть только один пункт. 
  -> EnrichedOrderBoxLayoutDTO
mkEnrichedOrderBoxLayoutDTO enrichedOrderBoxLayoutDTOItems =
  EnrichedOrderBoxLayoutDTO
  { enrichedOrderBoxLayoutDTOItems
  , enrichedOrderBoxLayoutDTOBoxId = Nothing
  }

-- ** ExtensionShipmentDTO
-- | ExtensionShipmentDTO
-- Информация об отгрузке.
data ExtensionShipmentDTO = ExtensionShipmentDTO
  { extensionShipmentDTOCurrentStatus :: !(Maybe ShipmentStatusChangeDTO) -- ^ "currentStatus"
  , extensionShipmentDTOAvailableActions :: !([ShipmentActionType]) -- ^ /Required/ "availableActions" - Доступные действия над отгрузкой.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtensionShipmentDTO
instance A.FromJSON ExtensionShipmentDTO where
  parseJSON = A.withObject "ExtensionShipmentDTO" $ \o ->
    ExtensionShipmentDTO
      <$> (o .:? "currentStatus")
      <*> (o .:  "availableActions")

-- | ToJSON ExtensionShipmentDTO
instance A.ToJSON ExtensionShipmentDTO where
  toJSON ExtensionShipmentDTO {..} =
   _omitNulls
      [ "currentStatus" .= extensionShipmentDTOCurrentStatus
      , "availableActions" .= extensionShipmentDTOAvailableActions
      ]


-- | Construct a value of type 'ExtensionShipmentDTO' (by applying it's required fields, if any)
mkExtensionShipmentDTO
  :: [ShipmentActionType] -- ^ 'extensionShipmentDTOAvailableActions': Доступные действия над отгрузкой.
  -> ExtensionShipmentDTO
mkExtensionShipmentDTO extensionShipmentDTOAvailableActions =
  ExtensionShipmentDTO
  { extensionShipmentDTOCurrentStatus = Nothing
  , extensionShipmentDTOAvailableActions
  }

-- ** FeedContentDTO
-- | FeedContentDTO
-- Информация о проверке содержимого прайс-листа, загруженного на Маркет.
data FeedContentDTO = FeedContentDTO
  { feedContentDTORejectedOffersCount :: !(Maybe Integer) -- ^ "rejectedOffersCount" - Количество предложений, в которых найдены ошибки на этапе загрузки прайс-листа. Выводится, если параметр &#x60;content status&#x3D;OK&#x60;. 
  , feedContentDTOStatus :: !(Maybe FeedStatusType) -- ^ "status"
  , feedContentDTOTotalOffersCount :: !(Maybe Integer) -- ^ "totalOffersCount" - Количество предложений в прайс-листе. Выводится, если параметр &#x60;content status&#x3D;OK&#x60;. 
  , feedContentDTOError :: !(Maybe FeedContentErrorDTO) -- ^ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedContentDTO
instance A.FromJSON FeedContentDTO where
  parseJSON = A.withObject "FeedContentDTO" $ \o ->
    FeedContentDTO
      <$> (o .:? "rejectedOffersCount")
      <*> (o .:? "status")
      <*> (o .:? "totalOffersCount")
      <*> (o .:? "error")

-- | ToJSON FeedContentDTO
instance A.ToJSON FeedContentDTO where
  toJSON FeedContentDTO {..} =
   _omitNulls
      [ "rejectedOffersCount" .= feedContentDTORejectedOffersCount
      , "status" .= feedContentDTOStatus
      , "totalOffersCount" .= feedContentDTOTotalOffersCount
      , "error" .= feedContentDTOError
      ]


-- | Construct a value of type 'FeedContentDTO' (by applying it's required fields, if any)
mkFeedContentDTO
  :: FeedContentDTO
mkFeedContentDTO =
  FeedContentDTO
  { feedContentDTORejectedOffersCount = Nothing
  , feedContentDTOStatus = Nothing
  , feedContentDTOTotalOffersCount = Nothing
  , feedContentDTOError = Nothing
  }

-- ** FeedContentErrorDTO
-- | FeedContentErrorDTO
-- Информация об ошибке в содержимом прайс-листа. Выводится, если параметр `content status=ERROR`. 
data FeedContentErrorDTO = FeedContentErrorDTO
  { feedContentErrorDTOType :: !(Maybe FeedContentErrorType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedContentErrorDTO
instance A.FromJSON FeedContentErrorDTO where
  parseJSON = A.withObject "FeedContentErrorDTO" $ \o ->
    FeedContentErrorDTO
      <$> (o .:? "type")

-- | ToJSON FeedContentErrorDTO
instance A.ToJSON FeedContentErrorDTO where
  toJSON FeedContentErrorDTO {..} =
   _omitNulls
      [ "type" .= feedContentErrorDTOType
      ]


-- | Construct a value of type 'FeedContentErrorDTO' (by applying it's required fields, if any)
mkFeedContentErrorDTO
  :: FeedContentErrorDTO
mkFeedContentErrorDTO =
  FeedContentErrorDTO
  { feedContentErrorDTOType = Nothing
  }

-- ** FeedDTO
-- | FeedDTO
-- Информация о прайс-листе.
data FeedDTO = FeedDTO
  { feedDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор прайс-листа.
  , feedDTOLogin :: !(Maybe Text) -- ^ "login" - Логин для авторизации при скачивании прайс-листа. Параметр выводится при размещении прайс-листа на сайте магазина и в случае ограничения доступа к нему. 
  , feedDTOName :: !(Maybe Text) -- ^ "name" - Имя файла, содержащего прайс-лист. Параметр выводится при размещении прайс-листа на сервере Маркета. 
  , feedDTOPassword :: !(Maybe Text) -- ^ "password" - Пароль для авторизации при скачивании прайс-листа. Параметр выводится при размещении прайс-листа на сайте магазина и в случае ограничения доступа к нему. 
  , feedDTOUploadDate :: !(Maybe DateTime) -- ^ "uploadDate" - Дата загрузки прайс-листа на Маркет.  Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;.  Параметр выводится при размещении прайс-листа на сервере Маркета. 
  , feedDTOUrl :: !(Maybe Text) -- ^ "url" - URL прайс-листа. Параметр выводится при размещении прайс-листа на сайте магазина. 
  , feedDTOContent :: !(Maybe FeedContentDTO) -- ^ "content"
  , feedDTODownload :: !(Maybe FeedDownloadDTO) -- ^ "download"
  , feedDTOPlacement :: !(Maybe FeedPlacementDTO) -- ^ "placement"
  , feedDTOPublication :: !(Maybe FeedPublicationDTO) -- ^ "publication"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedDTO
instance A.FromJSON FeedDTO where
  parseJSON = A.withObject "FeedDTO" $ \o ->
    FeedDTO
      <$> (o .:? "id")
      <*> (o .:? "login")
      <*> (o .:? "name")
      <*> (o .:? "password")
      <*> (o .:? "uploadDate")
      <*> (o .:? "url")
      <*> (o .:? "content")
      <*> (o .:? "download")
      <*> (o .:? "placement")
      <*> (o .:? "publication")

-- | ToJSON FeedDTO
instance A.ToJSON FeedDTO where
  toJSON FeedDTO {..} =
   _omitNulls
      [ "id" .= feedDTOId
      , "login" .= feedDTOLogin
      , "name" .= feedDTOName
      , "password" .= feedDTOPassword
      , "uploadDate" .= feedDTOUploadDate
      , "url" .= feedDTOUrl
      , "content" .= feedDTOContent
      , "download" .= feedDTODownload
      , "placement" .= feedDTOPlacement
      , "publication" .= feedDTOPublication
      ]


-- | Construct a value of type 'FeedDTO' (by applying it's required fields, if any)
mkFeedDTO
  :: FeedDTO
mkFeedDTO =
  FeedDTO
  { feedDTOId = Nothing
  , feedDTOLogin = Nothing
  , feedDTOName = Nothing
  , feedDTOPassword = Nothing
  , feedDTOUploadDate = Nothing
  , feedDTOUrl = Nothing
  , feedDTOContent = Nothing
  , feedDTODownload = Nothing
  , feedDTOPlacement = Nothing
  , feedDTOPublication = Nothing
  }

-- ** FeedDownloadDTO
-- | FeedDownloadDTO
-- Информация о последней загрузке прайс-листа.
data FeedDownloadDTO = FeedDownloadDTO
  { feedDownloadDTOStatus :: !(Maybe FeedStatusType) -- ^ "status"
  , feedDownloadDTOError :: !(Maybe FeedDownloadErrorDTO) -- ^ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedDownloadDTO
instance A.FromJSON FeedDownloadDTO where
  parseJSON = A.withObject "FeedDownloadDTO" $ \o ->
    FeedDownloadDTO
      <$> (o .:? "status")
      <*> (o .:? "error")

-- | ToJSON FeedDownloadDTO
instance A.ToJSON FeedDownloadDTO where
  toJSON FeedDownloadDTO {..} =
   _omitNulls
      [ "status" .= feedDownloadDTOStatus
      , "error" .= feedDownloadDTOError
      ]


-- | Construct a value of type 'FeedDownloadDTO' (by applying it's required fields, if any)
mkFeedDownloadDTO
  :: FeedDownloadDTO
mkFeedDownloadDTO =
  FeedDownloadDTO
  { feedDownloadDTOStatus = Nothing
  , feedDownloadDTOError = Nothing
  }

-- ** FeedDownloadErrorDTO
-- | FeedDownloadErrorDTO
-- Информация об ошибке при загрузке прайс-листа. Выводится, если параметр `download status=ERROR`. 
data FeedDownloadErrorDTO = FeedDownloadErrorDTO
  { feedDownloadErrorDTOHttpStatusCode :: !(Maybe Int) -- ^ "httpStatusCode" - HTTP-код ошибки индексации прайс-листа. Выводится, если &#x60;type&#x3D;DOWNLOAD_HTTP_ERROR&#x60;. 
  , feedDownloadErrorDTOType :: !(Maybe FeedDownloadErrorType) -- ^ "type"
  , feedDownloadErrorDTODescription :: !(Maybe Text) -- ^ "description" - Описание ошибки. Выводится, если &#x60;type&#x3D;DOWNLOAD_ERROR&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedDownloadErrorDTO
instance A.FromJSON FeedDownloadErrorDTO where
  parseJSON = A.withObject "FeedDownloadErrorDTO" $ \o ->
    FeedDownloadErrorDTO
      <$> (o .:? "httpStatusCode")
      <*> (o .:? "type")
      <*> (o .:? "description")

-- | ToJSON FeedDownloadErrorDTO
instance A.ToJSON FeedDownloadErrorDTO where
  toJSON FeedDownloadErrorDTO {..} =
   _omitNulls
      [ "httpStatusCode" .= feedDownloadErrorDTOHttpStatusCode
      , "type" .= feedDownloadErrorDTOType
      , "description" .= feedDownloadErrorDTODescription
      ]


-- | Construct a value of type 'FeedDownloadErrorDTO' (by applying it's required fields, if any)
mkFeedDownloadErrorDTO
  :: FeedDownloadErrorDTO
mkFeedDownloadErrorDTO =
  FeedDownloadErrorDTO
  { feedDownloadErrorDTOHttpStatusCode = Nothing
  , feedDownloadErrorDTOType = Nothing
  , feedDownloadErrorDTODescription = Nothing
  }

-- ** FeedIndexLogsErrorDTO
-- | FeedIndexLogsErrorDTO
-- Информация об ошибке, произошедшей во время индексации прайс-листа.  Выводится, если во время индексации произошли ошибки (`index-log-record status=ERROR`). 
data FeedIndexLogsErrorDTO = FeedIndexLogsErrorDTO
  { feedIndexLogsErrorDTOHttpStatusCode :: !(Maybe Int) -- ^ "httpStatusCode" - HTTP-код ошибки индексации прайс-листа.  Выводится, если &#x60;type&#x3D;DOWNLOAD_HTTP_ERROR&#x60;. 
  , feedIndexLogsErrorDTOType :: !(Maybe FeedIndexLogsErrorType) -- ^ "type"
  , feedIndexLogsErrorDTODescription :: !(Maybe Text) -- ^ "description" - Описание ошибки.  Выводится, если &#x60;type&#x3D;DOWNLOAD_ERROR&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedIndexLogsErrorDTO
instance A.FromJSON FeedIndexLogsErrorDTO where
  parseJSON = A.withObject "FeedIndexLogsErrorDTO" $ \o ->
    FeedIndexLogsErrorDTO
      <$> (o .:? "httpStatusCode")
      <*> (o .:? "type")
      <*> (o .:? "description")

-- | ToJSON FeedIndexLogsErrorDTO
instance A.ToJSON FeedIndexLogsErrorDTO where
  toJSON FeedIndexLogsErrorDTO {..} =
   _omitNulls
      [ "httpStatusCode" .= feedIndexLogsErrorDTOHttpStatusCode
      , "type" .= feedIndexLogsErrorDTOType
      , "description" .= feedIndexLogsErrorDTODescription
      ]


-- | Construct a value of type 'FeedIndexLogsErrorDTO' (by applying it's required fields, if any)
mkFeedIndexLogsErrorDTO
  :: FeedIndexLogsErrorDTO
mkFeedIndexLogsErrorDTO =
  FeedIndexLogsErrorDTO
  { feedIndexLogsErrorDTOHttpStatusCode = Nothing
  , feedIndexLogsErrorDTOType = Nothing
  , feedIndexLogsErrorDTODescription = Nothing
  }

-- ** FeedIndexLogsFeedDTO
-- | FeedIndexLogsFeedDTO
-- Информация о прайс-листе.
data FeedIndexLogsFeedDTO = FeedIndexLogsFeedDTO
  { feedIndexLogsFeedDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор прайс-листа.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedIndexLogsFeedDTO
instance A.FromJSON FeedIndexLogsFeedDTO where
  parseJSON = A.withObject "FeedIndexLogsFeedDTO" $ \o ->
    FeedIndexLogsFeedDTO
      <$> (o .:? "id")

-- | ToJSON FeedIndexLogsFeedDTO
instance A.ToJSON FeedIndexLogsFeedDTO where
  toJSON FeedIndexLogsFeedDTO {..} =
   _omitNulls
      [ "id" .= feedIndexLogsFeedDTOId
      ]


-- | Construct a value of type 'FeedIndexLogsFeedDTO' (by applying it's required fields, if any)
mkFeedIndexLogsFeedDTO
  :: FeedIndexLogsFeedDTO
mkFeedIndexLogsFeedDTO =
  FeedIndexLogsFeedDTO
  { feedIndexLogsFeedDTOId = Nothing
  }

-- ** FeedIndexLogsOffersDTO
-- | FeedIndexLogsOffersDTO
-- Информация о предложениях прайс-листа.
data FeedIndexLogsOffersDTO = FeedIndexLogsOffersDTO
  { feedIndexLogsOffersDTORejectedCount :: !(Maybe Integer) -- ^ "rejectedCount" - Количество предложений, который не опубликованы на Маркете из-за найденных ошибок.
  , feedIndexLogsOffersDTOTotalCount :: !(Maybe Integer) -- ^ "totalCount" - Количество предложений в прайс-листе.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedIndexLogsOffersDTO
instance A.FromJSON FeedIndexLogsOffersDTO where
  parseJSON = A.withObject "FeedIndexLogsOffersDTO" $ \o ->
    FeedIndexLogsOffersDTO
      <$> (o .:? "rejectedCount")
      <*> (o .:? "totalCount")

-- | ToJSON FeedIndexLogsOffersDTO
instance A.ToJSON FeedIndexLogsOffersDTO where
  toJSON FeedIndexLogsOffersDTO {..} =
   _omitNulls
      [ "rejectedCount" .= feedIndexLogsOffersDTORejectedCount
      , "totalCount" .= feedIndexLogsOffersDTOTotalCount
      ]


-- | Construct a value of type 'FeedIndexLogsOffersDTO' (by applying it's required fields, if any)
mkFeedIndexLogsOffersDTO
  :: FeedIndexLogsOffersDTO
mkFeedIndexLogsOffersDTO =
  FeedIndexLogsOffersDTO
  { feedIndexLogsOffersDTORejectedCount = Nothing
  , feedIndexLogsOffersDTOTotalCount = Nothing
  }

-- ** FeedIndexLogsRecordDTO
-- | FeedIndexLogsRecordDTO
-- Список отчетов по индексации прайс-листа.
data FeedIndexLogsRecordDTO = FeedIndexLogsRecordDTO
  { feedIndexLogsRecordDTODownloadTime :: !(Maybe DateTime) -- ^ "downloadTime" - Дата и время загрузки прайс-листа.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:42:42+03:00&#x60;. 
  , feedIndexLogsRecordDTOFileTime :: !(Maybe DateTime) -- ^ "fileTime" - Дата и время, которые магазин указал в прайс-листе.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:42:42+03:00&#x60;. 
  , feedIndexLogsRecordDTOGenerationId :: !(Maybe Integer) -- ^ "generationId" - Идентификатор индексации.
  , feedIndexLogsRecordDTOIndexType :: !(Maybe FeedIndexLogsIndexType) -- ^ "indexType"
  , feedIndexLogsRecordDTOPublishedTime :: !(Maybe DateTime) -- ^ "publishedTime" - Дата и время публикации предложений из прайс-листа на Яндекс Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:42:42+03:00&#x60;. 
  , feedIndexLogsRecordDTOStatus :: !(Maybe FeedIndexLogsStatusType) -- ^ "status"
  , feedIndexLogsRecordDTOError :: !(Maybe FeedIndexLogsErrorDTO) -- ^ "error"
  , feedIndexLogsRecordDTOOffers :: !(Maybe FeedIndexLogsOffersDTO) -- ^ "offers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedIndexLogsRecordDTO
instance A.FromJSON FeedIndexLogsRecordDTO where
  parseJSON = A.withObject "FeedIndexLogsRecordDTO" $ \o ->
    FeedIndexLogsRecordDTO
      <$> (o .:? "downloadTime")
      <*> (o .:? "fileTime")
      <*> (o .:? "generationId")
      <*> (o .:? "indexType")
      <*> (o .:? "publishedTime")
      <*> (o .:? "status")
      <*> (o .:? "error")
      <*> (o .:? "offers")

-- | ToJSON FeedIndexLogsRecordDTO
instance A.ToJSON FeedIndexLogsRecordDTO where
  toJSON FeedIndexLogsRecordDTO {..} =
   _omitNulls
      [ "downloadTime" .= feedIndexLogsRecordDTODownloadTime
      , "fileTime" .= feedIndexLogsRecordDTOFileTime
      , "generationId" .= feedIndexLogsRecordDTOGenerationId
      , "indexType" .= feedIndexLogsRecordDTOIndexType
      , "publishedTime" .= feedIndexLogsRecordDTOPublishedTime
      , "status" .= feedIndexLogsRecordDTOStatus
      , "error" .= feedIndexLogsRecordDTOError
      , "offers" .= feedIndexLogsRecordDTOOffers
      ]


-- | Construct a value of type 'FeedIndexLogsRecordDTO' (by applying it's required fields, if any)
mkFeedIndexLogsRecordDTO
  :: FeedIndexLogsRecordDTO
mkFeedIndexLogsRecordDTO =
  FeedIndexLogsRecordDTO
  { feedIndexLogsRecordDTODownloadTime = Nothing
  , feedIndexLogsRecordDTOFileTime = Nothing
  , feedIndexLogsRecordDTOGenerationId = Nothing
  , feedIndexLogsRecordDTOIndexType = Nothing
  , feedIndexLogsRecordDTOPublishedTime = Nothing
  , feedIndexLogsRecordDTOStatus = Nothing
  , feedIndexLogsRecordDTOError = Nothing
  , feedIndexLogsRecordDTOOffers = Nothing
  }

-- ** FeedIndexLogsResultDTO
-- | FeedIndexLogsResultDTO
-- Результат выполнения запроса отчета по индексации прайс-листа.
data FeedIndexLogsResultDTO = FeedIndexLogsResultDTO
  { feedIndexLogsResultDTOFeed :: !(Maybe FeedIndexLogsFeedDTO) -- ^ "feed"
  , feedIndexLogsResultDTOIndexLogRecords :: !([FeedIndexLogsRecordDTO]) -- ^ /Required/ "indexLogRecords" - Список отчетов по индексации прайс-листа.
  , feedIndexLogsResultDTOTotal :: !(Maybe Integer) -- ^ "total" - Количество отчетов на всех страницах выходных данных.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedIndexLogsResultDTO
instance A.FromJSON FeedIndexLogsResultDTO where
  parseJSON = A.withObject "FeedIndexLogsResultDTO" $ \o ->
    FeedIndexLogsResultDTO
      <$> (o .:? "feed")
      <*> (o .:  "indexLogRecords")
      <*> (o .:? "total")

-- | ToJSON FeedIndexLogsResultDTO
instance A.ToJSON FeedIndexLogsResultDTO where
  toJSON FeedIndexLogsResultDTO {..} =
   _omitNulls
      [ "feed" .= feedIndexLogsResultDTOFeed
      , "indexLogRecords" .= feedIndexLogsResultDTOIndexLogRecords
      , "total" .= feedIndexLogsResultDTOTotal
      ]


-- | Construct a value of type 'FeedIndexLogsResultDTO' (by applying it's required fields, if any)
mkFeedIndexLogsResultDTO
  :: [FeedIndexLogsRecordDTO] -- ^ 'feedIndexLogsResultDTOIndexLogRecords': Список отчетов по индексации прайс-листа.
  -> FeedIndexLogsResultDTO
mkFeedIndexLogsResultDTO feedIndexLogsResultDTOIndexLogRecords =
  FeedIndexLogsResultDTO
  { feedIndexLogsResultDTOFeed = Nothing
  , feedIndexLogsResultDTOIndexLogRecords
  , feedIndexLogsResultDTOTotal = Nothing
  }

-- ** FeedParameterDTO
-- | FeedParameterDTO
-- Параметр прайс-листа.
data FeedParameterDTO = FeedParameterDTO
  { feedParameterDTODeleted :: !(Maybe Bool) -- ^ "deleted" - Удалить ли значение параметра.  Возможное значение: * &#x60;true&#x60; — удалить значение параметра.  Используется вместе с параметром &#x60;name&#x60;. 
  , feedParameterDTOName :: !(Text) -- ^ /Required/ "name" - Название параметра.  Возможное значение: - &#x60;reparseIntervalMinutes&#x60; — период скачивания прайс-листа. Маркет будет скачивать прайс-лист через количество минут, указанное в параметре &#x60;value&#x60;. Например, при &#x60;value&#x3D;1440&#x60;, Маркет будет скачивать прайс-лист один раз в сутки.  {% note alert %}  Несмотря на установленное значение, Маркет скачает прайс-лист один раз в сутки.  {% endnote %}  Обязательный параметр. 
  , feedParameterDTOValues :: !(Maybe [Int]) -- ^ "values" - Значения параметра.  Используется вместе с параметром &#x60;name&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedParameterDTO
instance A.FromJSON FeedParameterDTO where
  parseJSON = A.withObject "FeedParameterDTO" $ \o ->
    FeedParameterDTO
      <$> (o .:? "deleted")
      <*> (o .:  "name")
      <*> (o .:? "values")

-- | ToJSON FeedParameterDTO
instance A.ToJSON FeedParameterDTO where
  toJSON FeedParameterDTO {..} =
   _omitNulls
      [ "deleted" .= feedParameterDTODeleted
      , "name" .= feedParameterDTOName
      , "values" .= feedParameterDTOValues
      ]


-- | Construct a value of type 'FeedParameterDTO' (by applying it's required fields, if any)
mkFeedParameterDTO
  :: Text -- ^ 'feedParameterDTOName': Название параметра.  Возможное значение: - `reparseIntervalMinutes` — период скачивания прайс-листа. Маркет будет скачивать прайс-лист через количество минут, указанное в параметре `value`. Например, при `value=1440`, Маркет будет скачивать прайс-лист один раз в сутки.  {% note alert %}  Несмотря на установленное значение, Маркет скачает прайс-лист один раз в сутки.  {% endnote %}  Обязательный параметр. 
  -> FeedParameterDTO
mkFeedParameterDTO feedParameterDTOName =
  FeedParameterDTO
  { feedParameterDTODeleted = Nothing
  , feedParameterDTOName
  , feedParameterDTOValues = Nothing
  }

-- ** FeedPlacementDTO
-- | FeedPlacementDTO
-- Информация о размещении предложений из прайс-листа на Маркете на момент выполнения запроса.
data FeedPlacementDTO = FeedPlacementDTO
  { feedPlacementDTOStatus :: !(Maybe FeedStatusType) -- ^ "status"
  , feedPlacementDTOTotalOffersCount :: !(Maybe Int) -- ^ "totalOffersCount" - Количество предложений из прайс-листа, которые размещаются на Яндекс Маркете в момент выполнения запроса.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedPlacementDTO
instance A.FromJSON FeedPlacementDTO where
  parseJSON = A.withObject "FeedPlacementDTO" $ \o ->
    FeedPlacementDTO
      <$> (o .:? "status")
      <*> (o .:? "totalOffersCount")

-- | ToJSON FeedPlacementDTO
instance A.ToJSON FeedPlacementDTO where
  toJSON FeedPlacementDTO {..} =
   _omitNulls
      [ "status" .= feedPlacementDTOStatus
      , "totalOffersCount" .= feedPlacementDTOTotalOffersCount
      ]


-- | Construct a value of type 'FeedPlacementDTO' (by applying it's required fields, if any)
mkFeedPlacementDTO
  :: FeedPlacementDTO
mkFeedPlacementDTO =
  FeedPlacementDTO
  { feedPlacementDTOStatus = Nothing
  , feedPlacementDTOTotalOffersCount = Nothing
  }

-- ** FeedPublicationDTO
-- | FeedPublicationDTO
-- Информация о последней публикации предложений из прайс-листа на Маркете.
data FeedPublicationDTO = FeedPublicationDTO
  { feedPublicationDTOStatus :: !(Maybe FeedStatusType) -- ^ "status"
  , feedPublicationDTOFull :: !(Maybe FeedPublicationFullDTO) -- ^ "full"
  , feedPublicationDTOPriceAndStockUpdate :: !(Maybe FeedPublicationPriceAndStockUpdateDTO) -- ^ "priceAndStockUpdate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedPublicationDTO
instance A.FromJSON FeedPublicationDTO where
  parseJSON = A.withObject "FeedPublicationDTO" $ \o ->
    FeedPublicationDTO
      <$> (o .:? "status")
      <*> (o .:? "full")
      <*> (o .:? "priceAndStockUpdate")

-- | ToJSON FeedPublicationDTO
instance A.ToJSON FeedPublicationDTO where
  toJSON FeedPublicationDTO {..} =
   _omitNulls
      [ "status" .= feedPublicationDTOStatus
      , "full" .= feedPublicationDTOFull
      , "priceAndStockUpdate" .= feedPublicationDTOPriceAndStockUpdate
      ]


-- | Construct a value of type 'FeedPublicationDTO' (by applying it's required fields, if any)
mkFeedPublicationDTO
  :: FeedPublicationDTO
mkFeedPublicationDTO =
  FeedPublicationDTO
  { feedPublicationDTOStatus = Nothing
  , feedPublicationDTOFull = Nothing
  , feedPublicationDTOPriceAndStockUpdate = Nothing
  }

-- ** FeedPublicationFullDTO
-- | FeedPublicationFullDTO
-- Информация о последней публикации предложений из прайс-листа на Маркете. 
data FeedPublicationFullDTO = FeedPublicationFullDTO
  { feedPublicationFullDTOFileTime :: !(Maybe DateTime) -- ^ "fileTime" - Дата и время, которые магазин указал в прайс-листе.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:42:42+03:00&#x60;. 
  , feedPublicationFullDTOPublishedTime :: !(Maybe DateTime) -- ^ "publishedTime" - Дата и время публикации предложений из прайс-листа на Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:42:42+03:00&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedPublicationFullDTO
instance A.FromJSON FeedPublicationFullDTO where
  parseJSON = A.withObject "FeedPublicationFullDTO" $ \o ->
    FeedPublicationFullDTO
      <$> (o .:? "fileTime")
      <*> (o .:? "publishedTime")

-- | ToJSON FeedPublicationFullDTO
instance A.ToJSON FeedPublicationFullDTO where
  toJSON FeedPublicationFullDTO {..} =
   _omitNulls
      [ "fileTime" .= feedPublicationFullDTOFileTime
      , "publishedTime" .= feedPublicationFullDTOPublishedTime
      ]


-- | Construct a value of type 'FeedPublicationFullDTO' (by applying it's required fields, if any)
mkFeedPublicationFullDTO
  :: FeedPublicationFullDTO
mkFeedPublicationFullDTO =
  FeedPublicationFullDTO
  { feedPublicationFullDTOFileTime = Nothing
  , feedPublicationFullDTOPublishedTime = Nothing
  }

-- ** FeedPublicationPriceAndStockUpdateDTO
-- | FeedPublicationPriceAndStockUpdateDTO
-- Последнее обновление цен и наличия товаров на Маркете. Если последнее по времени обновление было полным, в параметре выводятся те же данные, что и в параметре `full`. Выводится, если параметр `publication status=OK`. 
data FeedPublicationPriceAndStockUpdateDTO = FeedPublicationPriceAndStockUpdateDTO
  { feedPublicationPriceAndStockUpdateDTOFileTime :: !(Maybe DateTime) -- ^ "fileTime" - Дата и время, которые магазин указал в прайс-листе.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:42:42+03:00&#x60;. 
  , feedPublicationPriceAndStockUpdateDTOPublishedTime :: !(Maybe DateTime) -- ^ "publishedTime" - Дата и время публикации предложений из прайс-листа на Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:42:42+03:00&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedPublicationPriceAndStockUpdateDTO
instance A.FromJSON FeedPublicationPriceAndStockUpdateDTO where
  parseJSON = A.withObject "FeedPublicationPriceAndStockUpdateDTO" $ \o ->
    FeedPublicationPriceAndStockUpdateDTO
      <$> (o .:? "fileTime")
      <*> (o .:? "publishedTime")

-- | ToJSON FeedPublicationPriceAndStockUpdateDTO
instance A.ToJSON FeedPublicationPriceAndStockUpdateDTO where
  toJSON FeedPublicationPriceAndStockUpdateDTO {..} =
   _omitNulls
      [ "fileTime" .= feedPublicationPriceAndStockUpdateDTOFileTime
      , "publishedTime" .= feedPublicationPriceAndStockUpdateDTOPublishedTime
      ]


-- | Construct a value of type 'FeedPublicationPriceAndStockUpdateDTO' (by applying it's required fields, if any)
mkFeedPublicationPriceAndStockUpdateDTO
  :: FeedPublicationPriceAndStockUpdateDTO
mkFeedPublicationPriceAndStockUpdateDTO =
  FeedPublicationPriceAndStockUpdateDTO
  { feedPublicationPriceAndStockUpdateDTOFileTime = Nothing
  , feedPublicationPriceAndStockUpdateDTOPublishedTime = Nothing
  }

-- ** FeedbackAuthorDTO
-- | FeedbackAuthorDTO
-- Информация об авторе отзыва.  Если отзыв оставлен анонимно, параметр не возвращается. 
data FeedbackAuthorDTO = FeedbackAuthorDTO
  { feedbackAuthorDTOName :: !(Maybe Text) -- ^ "name" - Имя автора отзыва.
  , feedbackAuthorDTORegion :: !(Maybe RegionDTO) -- ^ "region"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackAuthorDTO
instance A.FromJSON FeedbackAuthorDTO where
  parseJSON = A.withObject "FeedbackAuthorDTO" $ \o ->
    FeedbackAuthorDTO
      <$> (o .:? "name")
      <*> (o .:? "region")

-- | ToJSON FeedbackAuthorDTO
instance A.ToJSON FeedbackAuthorDTO where
  toJSON FeedbackAuthorDTO {..} =
   _omitNulls
      [ "name" .= feedbackAuthorDTOName
      , "region" .= feedbackAuthorDTORegion
      ]


-- | Construct a value of type 'FeedbackAuthorDTO' (by applying it's required fields, if any)
mkFeedbackAuthorDTO
  :: FeedbackAuthorDTO
mkFeedbackAuthorDTO =
  FeedbackAuthorDTO
  { feedbackAuthorDTOName = Nothing
  , feedbackAuthorDTORegion = Nothing
  }

-- ** FeedbackCommentAuthorDTO
-- | FeedbackCommentAuthorDTO
-- Информация об авторе комментария.
data FeedbackCommentAuthorDTO = FeedbackCommentAuthorDTO
  { feedbackCommentAuthorDTOType :: !(Maybe FeedbackCommentAuthorType) -- ^ "type"
  , feedbackCommentAuthorDTOName :: !(Maybe Text) -- ^ "name" - Имя автора отзыва или название магазина.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackCommentAuthorDTO
instance A.FromJSON FeedbackCommentAuthorDTO where
  parseJSON = A.withObject "FeedbackCommentAuthorDTO" $ \o ->
    FeedbackCommentAuthorDTO
      <$> (o .:? "type")
      <*> (o .:? "name")

-- | ToJSON FeedbackCommentAuthorDTO
instance A.ToJSON FeedbackCommentAuthorDTO where
  toJSON FeedbackCommentAuthorDTO {..} =
   _omitNulls
      [ "type" .= feedbackCommentAuthorDTOType
      , "name" .= feedbackCommentAuthorDTOName
      ]


-- | Construct a value of type 'FeedbackCommentAuthorDTO' (by applying it's required fields, if any)
mkFeedbackCommentAuthorDTO
  :: FeedbackCommentAuthorDTO
mkFeedbackCommentAuthorDTO =
  FeedbackCommentAuthorDTO
  { feedbackCommentAuthorDTOType = Nothing
  , feedbackCommentAuthorDTOName = Nothing
  }

-- ** FeedbackCommentDTO
-- | FeedbackCommentDTO
-- Комментарий к отзыву на магазин.
data FeedbackCommentDTO = FeedbackCommentDTO
  { feedbackCommentDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор ответа.
  , feedbackCommentDTOParentId :: !(Maybe Integer) -- ^ "parentId" - Идентификатор родительского ответа.
  , feedbackCommentDTOBody :: !(Maybe Text) -- ^ "body" - Текст ответа.
  , feedbackCommentDTOCreatedAt :: !(Maybe DateTime) -- ^ "createdAt" - Дата и время создания ответа.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:00:00+03:00&#x60;. 
  , feedbackCommentDTOUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt" - Дата и время изменения ответа.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:00:00+03:00&#x60;. 
  , feedbackCommentDTOAuthor :: !(Maybe FeedbackCommentAuthorDTO) -- ^ "author"
  , feedbackCommentDTOChildren :: !(Maybe [FeedbackCommentDTO]) -- ^ "children" - Дочерние ответы.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackCommentDTO
instance A.FromJSON FeedbackCommentDTO where
  parseJSON = A.withObject "FeedbackCommentDTO" $ \o ->
    FeedbackCommentDTO
      <$> (o .:? "id")
      <*> (o .:? "parentId")
      <*> (o .:? "body")
      <*> (o .:? "createdAt")
      <*> (o .:? "updatedAt")
      <*> (o .:? "author")
      <*> (o .:? "children")

-- | ToJSON FeedbackCommentDTO
instance A.ToJSON FeedbackCommentDTO where
  toJSON FeedbackCommentDTO {..} =
   _omitNulls
      [ "id" .= feedbackCommentDTOId
      , "parentId" .= feedbackCommentDTOParentId
      , "body" .= feedbackCommentDTOBody
      , "createdAt" .= feedbackCommentDTOCreatedAt
      , "updatedAt" .= feedbackCommentDTOUpdatedAt
      , "author" .= feedbackCommentDTOAuthor
      , "children" .= feedbackCommentDTOChildren
      ]


-- | Construct a value of type 'FeedbackCommentDTO' (by applying it's required fields, if any)
mkFeedbackCommentDTO
  :: FeedbackCommentDTO
mkFeedbackCommentDTO =
  FeedbackCommentDTO
  { feedbackCommentDTOId = Nothing
  , feedbackCommentDTOParentId = Nothing
  , feedbackCommentDTOBody = Nothing
  , feedbackCommentDTOCreatedAt = Nothing
  , feedbackCommentDTOUpdatedAt = Nothing
  , feedbackCommentDTOAuthor = Nothing
  , feedbackCommentDTOChildren = Nothing
  }

-- ** FeedbackDTO
-- | FeedbackDTO
-- Отзыв пользователя Яндекс Маркета об указанном магазине.
data FeedbackDTO = FeedbackDTO
  { feedbackDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор отзыва.
  , feedbackDTOCreatedAt :: !(Maybe DateTime) -- ^ "createdAt" - Дата и время создания отзыва.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:00:00+03:00&#x60;. 
  , feedbackDTOText :: !(Maybe Text) -- ^ "text" - Комментарий автора отзыва.
  , feedbackDTOState :: !(Maybe FeedbackStateType) -- ^ "state"
  , feedbackDTOAuthor :: !(Maybe FeedbackAuthorDTO) -- ^ "author"
  , feedbackDTOPro :: !(Maybe Text) -- ^ "pro" - Достоинства магазина, описанные в отзыве.
  , feedbackDTOContra :: !(Maybe Text) -- ^ "contra" - Недостатки магазина, описанные в отзыве.
  , feedbackDTOComments :: !([FeedbackCommentDTO]) -- ^ /Required/ "comments" - Переписка автора отзыва с магазином.
  , feedbackDTOShop :: !(Maybe FeedbackShopDTO) -- ^ "shop"
  , feedbackDTOResolved :: !(Maybe Bool) -- ^ "resolved" - Решена ли проблема автора отзыва:  * &#x60;true&#x60; — да. * &#x60;false&#x60; — нет.  Если проблема решена, около отзыва на странице магазина появляется соответствующая надпись. 
  , feedbackDTOVerified :: !(Maybe Bool) -- ^ "verified" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Является ли отзыв рекомендованным:  * &#x60;true&#x60; — да. * &#x60;false&#x60; — нет. 
  , feedbackDTORecommend :: !(Maybe Bool) -- ^ "recommend" - Купил бы автор отзыва в магазине снова:  * &#x60;true&#x60; — да. * &#x60;false&#x60; — нет. 
  , feedbackDTOGrades :: !(Maybe FeedbackGradesDTO) -- ^ "grades"
  , feedbackDTOOrder :: !(Maybe FeedbackOrderDTO) -- ^ "order"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackDTO
instance A.FromJSON FeedbackDTO where
  parseJSON = A.withObject "FeedbackDTO" $ \o ->
    FeedbackDTO
      <$> (o .:? "id")
      <*> (o .:? "createdAt")
      <*> (o .:? "text")
      <*> (o .:? "state")
      <*> (o .:? "author")
      <*> (o .:? "pro")
      <*> (o .:? "contra")
      <*> (o .:  "comments")
      <*> (o .:? "shop")
      <*> (o .:? "resolved")
      <*> (o .:? "verified")
      <*> (o .:? "recommend")
      <*> (o .:? "grades")
      <*> (o .:? "order")

-- | ToJSON FeedbackDTO
instance A.ToJSON FeedbackDTO where
  toJSON FeedbackDTO {..} =
   _omitNulls
      [ "id" .= feedbackDTOId
      , "createdAt" .= feedbackDTOCreatedAt
      , "text" .= feedbackDTOText
      , "state" .= feedbackDTOState
      , "author" .= feedbackDTOAuthor
      , "pro" .= feedbackDTOPro
      , "contra" .= feedbackDTOContra
      , "comments" .= feedbackDTOComments
      , "shop" .= feedbackDTOShop
      , "resolved" .= feedbackDTOResolved
      , "verified" .= feedbackDTOVerified
      , "recommend" .= feedbackDTORecommend
      , "grades" .= feedbackDTOGrades
      , "order" .= feedbackDTOOrder
      ]


-- | Construct a value of type 'FeedbackDTO' (by applying it's required fields, if any)
mkFeedbackDTO
  :: [FeedbackCommentDTO] -- ^ 'feedbackDTOComments': Переписка автора отзыва с магазином.
  -> FeedbackDTO
mkFeedbackDTO feedbackDTOComments =
  FeedbackDTO
  { feedbackDTOId = Nothing
  , feedbackDTOCreatedAt = Nothing
  , feedbackDTOText = Nothing
  , feedbackDTOState = Nothing
  , feedbackDTOAuthor = Nothing
  , feedbackDTOPro = Nothing
  , feedbackDTOContra = Nothing
  , feedbackDTOComments
  , feedbackDTOShop = Nothing
  , feedbackDTOResolved = Nothing
  , feedbackDTOVerified = Nothing
  , feedbackDTORecommend = Nothing
  , feedbackDTOGrades = Nothing
  , feedbackDTOOrder = Nothing
  }

-- ** FeedbackFactorDTO
-- | FeedbackFactorDTO
-- Информация об оценках по параметрам, указанных в отзыве.  При создании отзыва автору предлагается поставить оценки магазину по нескольким параметрам: например, за скорость обработки заказа или удобство самовывоза. Набор параметров зависит от того, какой способ покупки (параметр `delivery`) указал автор. 
data FeedbackFactorDTO = FeedbackFactorDTO
  { feedbackFactorDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор параметра.
  , feedbackFactorDTOTitle :: !(Maybe Text) -- ^ "title" - Название параметра. Например, &#x60;Скорость обработки заказа&#x60;.
  , feedbackFactorDTODescription :: !(Maybe Text) -- ^ "description" - Описание параметра. Например, &#x60;Как быстро с вами связались для подтверждения заказа?&#x60;.
  , feedbackFactorDTOValue :: !(Maybe Int) -- ^ "value" - Оценка по параметру, указанная в отзыве: от &#x60;1&#x60; (низшая оценка) до &#x60;5&#x60; (высшая оценка). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackFactorDTO
instance A.FromJSON FeedbackFactorDTO where
  parseJSON = A.withObject "FeedbackFactorDTO" $ \o ->
    FeedbackFactorDTO
      <$> (o .:? "id")
      <*> (o .:? "title")
      <*> (o .:? "description")
      <*> (o .:? "value")

-- | ToJSON FeedbackFactorDTO
instance A.ToJSON FeedbackFactorDTO where
  toJSON FeedbackFactorDTO {..} =
   _omitNulls
      [ "id" .= feedbackFactorDTOId
      , "title" .= feedbackFactorDTOTitle
      , "description" .= feedbackFactorDTODescription
      , "value" .= feedbackFactorDTOValue
      ]


-- | Construct a value of type 'FeedbackFactorDTO' (by applying it's required fields, if any)
mkFeedbackFactorDTO
  :: FeedbackFactorDTO
mkFeedbackFactorDTO =
  FeedbackFactorDTO
  { feedbackFactorDTOId = Nothing
  , feedbackFactorDTOTitle = Nothing
  , feedbackFactorDTODescription = Nothing
  , feedbackFactorDTOValue = Nothing
  }

-- ** FeedbackGradesDTO
-- | FeedbackGradesDTO
-- Информация об оценках, которые поставил автор отзыва магазину, и об оценках полезности отзыва от других пользователей Маркета.
data FeedbackGradesDTO = FeedbackGradesDTO
  { feedbackGradesDTOAverage :: !(Maybe Double) -- ^ "average" - Общая оценка, указанная в отзыве: от &#x60;1&#x60; («Ужасный магазин») до &#x60;5&#x60; («Отличный магазин»).
  , feedbackGradesDTOAgreeCount :: !(Maybe Integer) -- ^ "agreeCount" - Количество пользователей, считающих отзыв полезным.
  , feedbackGradesDTORejectCount :: !(Maybe Integer) -- ^ "rejectCount" - Количество пользователей, считающих отзыв бесполезным.
  , feedbackGradesDTOFactors :: !([FeedbackFactorDTO]) -- ^ /Required/ "factors" - Информация об оценках по параметрам, указанных в отзыве.  При создании отзыва автору предлагается поставить оценки магазину по нескольким параметрам: например, за скорость обработки заказа или удобство самовывоза. Набор параметров зависит от того, какой способ покупки (параметр &#x60;delivery&#x60;) указал автор. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackGradesDTO
instance A.FromJSON FeedbackGradesDTO where
  parseJSON = A.withObject "FeedbackGradesDTO" $ \o ->
    FeedbackGradesDTO
      <$> (o .:? "average")
      <*> (o .:? "agreeCount")
      <*> (o .:? "rejectCount")
      <*> (o .:  "factors")

-- | ToJSON FeedbackGradesDTO
instance A.ToJSON FeedbackGradesDTO where
  toJSON FeedbackGradesDTO {..} =
   _omitNulls
      [ "average" .= feedbackGradesDTOAverage
      , "agreeCount" .= feedbackGradesDTOAgreeCount
      , "rejectCount" .= feedbackGradesDTORejectCount
      , "factors" .= feedbackGradesDTOFactors
      ]


-- | Construct a value of type 'FeedbackGradesDTO' (by applying it's required fields, if any)
mkFeedbackGradesDTO
  :: [FeedbackFactorDTO] -- ^ 'feedbackGradesDTOFactors': Информация об оценках по параметрам, указанных в отзыве.  При создании отзыва автору предлагается поставить оценки магазину по нескольким параметрам: например, за скорость обработки заказа или удобство самовывоза. Набор параметров зависит от того, какой способ покупки (параметр `delivery`) указал автор. 
  -> FeedbackGradesDTO
mkFeedbackGradesDTO feedbackGradesDTOFactors =
  FeedbackGradesDTO
  { feedbackGradesDTOAverage = Nothing
  , feedbackGradesDTOAgreeCount = Nothing
  , feedbackGradesDTORejectCount = Nothing
  , feedbackGradesDTOFactors
  }

-- ** FeedbackListDTO
-- | FeedbackListDTO
-- Отзывы пользователей Яндекс Маркета об указанном магазине.
data FeedbackListDTO = FeedbackListDTO
  { feedbackListDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , feedbackListDTOFeedbackList :: !([FeedbackDTO]) -- ^ /Required/ "feedbackList" - Список отзывов.  Содержит не более 20 отзывов. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackListDTO
instance A.FromJSON FeedbackListDTO where
  parseJSON = A.withObject "FeedbackListDTO" $ \o ->
    FeedbackListDTO
      <$> (o .:? "paging")
      <*> (o .:  "feedbackList")

-- | ToJSON FeedbackListDTO
instance A.ToJSON FeedbackListDTO where
  toJSON FeedbackListDTO {..} =
   _omitNulls
      [ "paging" .= feedbackListDTOPaging
      , "feedbackList" .= feedbackListDTOFeedbackList
      ]


-- | Construct a value of type 'FeedbackListDTO' (by applying it's required fields, if any)
mkFeedbackListDTO
  :: [FeedbackDTO] -- ^ 'feedbackListDTOFeedbackList': Список отзывов.  Содержит не более 20 отзывов. 
  -> FeedbackListDTO
mkFeedbackListDTO feedbackListDTOFeedbackList =
  FeedbackListDTO
  { feedbackListDTOPaging = Nothing
  , feedbackListDTOFeedbackList
  }

-- ** FeedbackOrderDTO
-- | FeedbackOrderDTO
-- Информация о заказе, указанная в отзыве.
data FeedbackOrderDTO = FeedbackOrderDTO
  { feedbackOrderDTOShopOrderId :: !(Maybe Text) -- ^ "shopOrderId" - Номер заказа, указанный в отзыве.
  , feedbackOrderDTODelivery :: !(Maybe FeedbackDeliveryType) -- ^ "delivery"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackOrderDTO
instance A.FromJSON FeedbackOrderDTO where
  parseJSON = A.withObject "FeedbackOrderDTO" $ \o ->
    FeedbackOrderDTO
      <$> (o .:? "shopOrderId")
      <*> (o .:? "delivery")

-- | ToJSON FeedbackOrderDTO
instance A.ToJSON FeedbackOrderDTO where
  toJSON FeedbackOrderDTO {..} =
   _omitNulls
      [ "shopOrderId" .= feedbackOrderDTOShopOrderId
      , "delivery" .= feedbackOrderDTODelivery
      ]


-- | Construct a value of type 'FeedbackOrderDTO' (by applying it's required fields, if any)
mkFeedbackOrderDTO
  :: FeedbackOrderDTO
mkFeedbackOrderDTO =
  FeedbackOrderDTO
  { feedbackOrderDTOShopOrderId = Nothing
  , feedbackOrderDTODelivery = Nothing
  }

-- ** FeedbackShopDTO
-- | FeedbackShopDTO
-- Информация о магазине.
data FeedbackShopDTO = FeedbackShopDTO
  { feedbackShopDTOName :: !(Maybe Text) -- ^ "name" - Название магазина.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackShopDTO
instance A.FromJSON FeedbackShopDTO where
  parseJSON = A.withObject "FeedbackShopDTO" $ \o ->
    FeedbackShopDTO
      <$> (o .:? "name")

-- | ToJSON FeedbackShopDTO
instance A.ToJSON FeedbackShopDTO where
  toJSON FeedbackShopDTO {..} =
   _omitNulls
      [ "name" .= feedbackShopDTOName
      ]


-- | Construct a value of type 'FeedbackShopDTO' (by applying it's required fields, if any)
mkFeedbackShopDTO
  :: FeedbackShopDTO
mkFeedbackShopDTO =
  FeedbackShopDTO
  { feedbackShopDTOName = Nothing
  }

-- ** FlippingPagerDTO
-- | FlippingPagerDTO
-- Модель для пагинации.
data FlippingPagerDTO = FlippingPagerDTO
  { flippingPagerDTOTotal :: !(Maybe Int) -- ^ "total" - Сколько всего найдено элементов.
  , flippingPagerDTOFrom :: !(Maybe Int) -- ^ "from" - Начальный номер найденного элемента на странице.
  , flippingPagerDTOTo :: !(Maybe Int) -- ^ "to" - Конечный номер найденного элемента на странице.
  , flippingPagerDTOCurrentPage :: !(Maybe Int) -- ^ "currentPage" - Текущая страница.
  , flippingPagerDTOPagesCount :: !(Maybe Int) -- ^ "pagesCount" - Общее количество страниц.
  , flippingPagerDTOPageSize :: !(Maybe Int) -- ^ "pageSize" - Размер страницы.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FlippingPagerDTO
instance A.FromJSON FlippingPagerDTO where
  parseJSON = A.withObject "FlippingPagerDTO" $ \o ->
    FlippingPagerDTO
      <$> (o .:? "total")
      <*> (o .:? "from")
      <*> (o .:? "to")
      <*> (o .:? "currentPage")
      <*> (o .:? "pagesCount")
      <*> (o .:? "pageSize")

-- | ToJSON FlippingPagerDTO
instance A.ToJSON FlippingPagerDTO where
  toJSON FlippingPagerDTO {..} =
   _omitNulls
      [ "total" .= flippingPagerDTOTotal
      , "from" .= flippingPagerDTOFrom
      , "to" .= flippingPagerDTOTo
      , "currentPage" .= flippingPagerDTOCurrentPage
      , "pagesCount" .= flippingPagerDTOPagesCount
      , "pageSize" .= flippingPagerDTOPageSize
      ]


-- | Construct a value of type 'FlippingPagerDTO' (by applying it's required fields, if any)
mkFlippingPagerDTO
  :: FlippingPagerDTO
mkFlippingPagerDTO =
  FlippingPagerDTO
  { flippingPagerDTOTotal = Nothing
  , flippingPagerDTOFrom = Nothing
  , flippingPagerDTOTo = Nothing
  , flippingPagerDTOCurrentPage = Nothing
  , flippingPagerDTOPagesCount = Nothing
  , flippingPagerDTOPageSize = Nothing
  }

-- ** ForwardScrollingPagerDTO
-- | ForwardScrollingPagerDTO
-- Ссылка на следующую страницу. 
data ForwardScrollingPagerDTO = ForwardScrollingPagerDTO
  { forwardScrollingPagerDTONextPageToken :: !(Maybe Text) -- ^ "nextPageToken" - Идентификатор следующей страницы результатов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ForwardScrollingPagerDTO
instance A.FromJSON ForwardScrollingPagerDTO where
  parseJSON = A.withObject "ForwardScrollingPagerDTO" $ \o ->
    ForwardScrollingPagerDTO
      <$> (o .:? "nextPageToken")

-- | ToJSON ForwardScrollingPagerDTO
instance A.ToJSON ForwardScrollingPagerDTO where
  toJSON ForwardScrollingPagerDTO {..} =
   _omitNulls
      [ "nextPageToken" .= forwardScrollingPagerDTONextPageToken
      ]


-- | Construct a value of type 'ForwardScrollingPagerDTO' (by applying it's required fields, if any)
mkForwardScrollingPagerDTO
  :: ForwardScrollingPagerDTO
mkForwardScrollingPagerDTO =
  ForwardScrollingPagerDTO
  { forwardScrollingPagerDTONextPageToken = Nothing
  }

-- ** FulfillmentWarehouseDTO
-- | FulfillmentWarehouseDTO
-- Склад Маркета (FBY).
data FulfillmentWarehouseDTO = FulfillmentWarehouseDTO
  { fulfillmentWarehouseDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор склада.
  , fulfillmentWarehouseDTOName :: !(Text) -- ^ /Required/ "name" - Название склада.
  , fulfillmentWarehouseDTOAddress :: !(Maybe WarehouseAddressDTO) -- ^ "address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FulfillmentWarehouseDTO
instance A.FromJSON FulfillmentWarehouseDTO where
  parseJSON = A.withObject "FulfillmentWarehouseDTO" $ \o ->
    FulfillmentWarehouseDTO
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "address")

-- | ToJSON FulfillmentWarehouseDTO
instance A.ToJSON FulfillmentWarehouseDTO where
  toJSON FulfillmentWarehouseDTO {..} =
   _omitNulls
      [ "id" .= fulfillmentWarehouseDTOId
      , "name" .= fulfillmentWarehouseDTOName
      , "address" .= fulfillmentWarehouseDTOAddress
      ]


-- | Construct a value of type 'FulfillmentWarehouseDTO' (by applying it's required fields, if any)
mkFulfillmentWarehouseDTO
  :: Integer -- ^ 'fulfillmentWarehouseDTOId': Идентификатор склада.
  -> Text -- ^ 'fulfillmentWarehouseDTOName': Название склада.
  -> FulfillmentWarehouseDTO
mkFulfillmentWarehouseDTO fulfillmentWarehouseDTOId fulfillmentWarehouseDTOName =
  FulfillmentWarehouseDTO
  { fulfillmentWarehouseDTOId
  , fulfillmentWarehouseDTOName
  , fulfillmentWarehouseDTOAddress = Nothing
  }

-- ** FulfillmentWarehousesDTO
-- | FulfillmentWarehousesDTO
-- Список складов Маркета (FBY).
data FulfillmentWarehousesDTO = FulfillmentWarehousesDTO
  { fulfillmentWarehousesDTOWarehouses :: !([FulfillmentWarehouseDTO]) -- ^ /Required/ "warehouses" - Список складов Маркета (FBY).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FulfillmentWarehousesDTO
instance A.FromJSON FulfillmentWarehousesDTO where
  parseJSON = A.withObject "FulfillmentWarehousesDTO" $ \o ->
    FulfillmentWarehousesDTO
      <$> (o .:  "warehouses")

-- | ToJSON FulfillmentWarehousesDTO
instance A.ToJSON FulfillmentWarehousesDTO where
  toJSON FulfillmentWarehousesDTO {..} =
   _omitNulls
      [ "warehouses" .= fulfillmentWarehousesDTOWarehouses
      ]


-- | Construct a value of type 'FulfillmentWarehousesDTO' (by applying it's required fields, if any)
mkFulfillmentWarehousesDTO
  :: [FulfillmentWarehouseDTO] -- ^ 'fulfillmentWarehousesDTOWarehouses': Список складов Маркета (FBY).
  -> FulfillmentWarehousesDTO
mkFulfillmentWarehousesDTO fulfillmentWarehousesDTOWarehouses =
  FulfillmentWarehousesDTO
  { fulfillmentWarehousesDTOWarehouses
  }

-- ** FullOutletDTO
-- | FullOutletDTO
-- Информация о точке продаж.
data FullOutletDTO = FullOutletDTO
  { fullOutletDTOName :: !(Text) -- ^ /Required/ "name" - Название точки продаж. 
  , fullOutletDTOType :: !(OutletType) -- ^ /Required/ "type"
  , fullOutletDTOCoords :: !(Maybe Text) -- ^ "coords" - Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, &#x60;20.4522144, 54.7104264&#x60;.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в &#x60;address&#x60;. 
  , fullOutletDTOIsMain :: !(Maybe Bool) -- ^ "isMain" - Признак основной точки продаж.  Возможные значения:  * &#x60;false&#x60; — неосновная точка продаж. * &#x60;true&#x60; — основная точка продаж. 
  , fullOutletDTOShopOutletCode :: !(Maybe Text) -- ^ "shopOutletCode" - Идентификатор точки продаж, присвоенный магазином.
  , fullOutletDTOVisibility :: !(Maybe OutletVisibilityType) -- ^ "visibility"
  , fullOutletDTOAddress :: !(OutletAddressDTO) -- ^ /Required/ "address"
  , fullOutletDTOPhones :: !([Text]) -- ^ /Required/ "phones" - Номера телефонов точки продаж. Передавайте в формате: &#x60;+7 (999) 999-99-99&#x60;. 
  , fullOutletDTOWorkingSchedule :: !(OutletWorkingScheduleDTO) -- ^ /Required/ "workingSchedule"
  , fullOutletDTODeliveryRules :: !(Maybe [OutletDeliveryRuleDTO]) -- ^ "deliveryRules" - Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр &#x60;type&#x3D;DEPOT&#x60; или &#x60;type&#x3D;MIXED&#x60;. 
  , fullOutletDTOStoragePeriod :: !(Maybe Integer) -- ^ "storagePeriod" - Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях.
  , fullOutletDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор точки продаж, присвоенный Маркетом.
  , fullOutletDTOStatus :: !(Maybe OutletStatusType) -- ^ "status"
  , fullOutletDTORegion :: !(Maybe RegionDTO) -- ^ "region"
  , fullOutletDTOShopOutletId :: !(Maybe Text) -- ^ "shopOutletId" - Идентификатор точки продаж, заданный магазином.
  , fullOutletDTOWorkingTime :: !(Maybe Text) -- ^ "workingTime" - Рабочее время.
  , fullOutletDTOModerationReason :: !(Maybe Text) -- ^ "moderationReason" - Статус модерации.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FullOutletDTO
instance A.FromJSON FullOutletDTO where
  parseJSON = A.withObject "FullOutletDTO" $ \o ->
    FullOutletDTO
      <$> (o .:  "name")
      <*> (o .:  "type")
      <*> (o .:? "coords")
      <*> (o .:? "isMain")
      <*> (o .:? "shopOutletCode")
      <*> (o .:? "visibility")
      <*> (o .:  "address")
      <*> (o .:  "phones")
      <*> (o .:  "workingSchedule")
      <*> (o .:? "deliveryRules")
      <*> (o .:? "storagePeriod")
      <*> (o .:? "id")
      <*> (o .:? "status")
      <*> (o .:? "region")
      <*> (o .:? "shopOutletId")
      <*> (o .:? "workingTime")
      <*> (o .:? "moderationReason")

-- | ToJSON FullOutletDTO
instance A.ToJSON FullOutletDTO where
  toJSON FullOutletDTO {..} =
   _omitNulls
      [ "name" .= fullOutletDTOName
      , "type" .= fullOutletDTOType
      , "coords" .= fullOutletDTOCoords
      , "isMain" .= fullOutletDTOIsMain
      , "shopOutletCode" .= fullOutletDTOShopOutletCode
      , "visibility" .= fullOutletDTOVisibility
      , "address" .= fullOutletDTOAddress
      , "phones" .= fullOutletDTOPhones
      , "workingSchedule" .= fullOutletDTOWorkingSchedule
      , "deliveryRules" .= fullOutletDTODeliveryRules
      , "storagePeriod" .= fullOutletDTOStoragePeriod
      , "id" .= fullOutletDTOId
      , "status" .= fullOutletDTOStatus
      , "region" .= fullOutletDTORegion
      , "shopOutletId" .= fullOutletDTOShopOutletId
      , "workingTime" .= fullOutletDTOWorkingTime
      , "moderationReason" .= fullOutletDTOModerationReason
      ]


-- | Construct a value of type 'FullOutletDTO' (by applying it's required fields, if any)
mkFullOutletDTO
  :: Text -- ^ 'fullOutletDTOName': Название точки продаж. 
  -> OutletType -- ^ 'fullOutletDTOType' 
  -> OutletAddressDTO -- ^ 'fullOutletDTOAddress' 
  -> [Text] -- ^ 'fullOutletDTOPhones': Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`. 
  -> OutletWorkingScheduleDTO -- ^ 'fullOutletDTOWorkingSchedule' 
  -> FullOutletDTO
mkFullOutletDTO fullOutletDTOName fullOutletDTOType fullOutletDTOAddress fullOutletDTOPhones fullOutletDTOWorkingSchedule =
  FullOutletDTO
  { fullOutletDTOName
  , fullOutletDTOType
  , fullOutletDTOCoords = Nothing
  , fullOutletDTOIsMain = Nothing
  , fullOutletDTOShopOutletCode = Nothing
  , fullOutletDTOVisibility = Nothing
  , fullOutletDTOAddress
  , fullOutletDTOPhones
  , fullOutletDTOWorkingSchedule
  , fullOutletDTODeliveryRules = Nothing
  , fullOutletDTOStoragePeriod = Nothing
  , fullOutletDTOId = Nothing
  , fullOutletDTOStatus = Nothing
  , fullOutletDTORegion = Nothing
  , fullOutletDTOShopOutletId = Nothing
  , fullOutletDTOWorkingTime = Nothing
  , fullOutletDTOModerationReason = Nothing
  }

-- ** FullOutletLicenseDTO
-- | FullOutletLicenseDTO
-- Информация о лицензии.
data FullOutletLicenseDTO = FullOutletLicenseDTO
  { fullOutletLicenseDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор лицензии.  Параметр указывается, только если нужно изменить информацию о существующей лицензии. Ее идентификатор можно узнать с помощью запроса [GET campaigns/{campaignId}/outlets/licenses](../../reference/outlets/getOutletLicenses.md). При передаче информации о новой лицензии указывать идентификатор не нужно.  Идентификатор лицензии присваивается Маркетом. Не путайте его с номером, указанным на лицензии: он передается в параметре &#x60;number&#x60;. 
  , fullOutletLicenseDTOOutletId :: !(Maybe Integer) -- ^ "outletId" - Идентификатор точки продаж, для которой действительна лицензия.
  , fullOutletLicenseDTOLicenseType :: !(Maybe LicenseType) -- ^ "licenseType"
  , fullOutletLicenseDTONumber :: !(Maybe Text) -- ^ "number" - Номер лицензии.
  , fullOutletLicenseDTODateOfIssue :: !(Maybe DateTime) -- ^ "dateOfIssue" - Дата выдачи лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время &#x60;00:00:00&#x60; и часовой пояс, соответствующий региону точки продаж. Например, если лицензия для точки продаж в Москве выдана 13 ноября 2017 года, то параметр должен иметь значение &#x60;2017-11-13T00:00:00+03:00&#x60;.  Обязательный параметр.  Не может быть позже даты окончания срока действия, указанной в параметре &#x60;dateOfExpiry&#x60;. 
  , fullOutletLicenseDTODateOfExpiry :: !(Maybe DateTime) -- ^ "dateOfExpiry" - Дата окончания действия лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время &#x60;00:00:00&#x60; и часовой пояс, соответствующий региону точки продаж. Например, если действие лицензии для точки продаж в Москве заканчивается 20 ноября 2022 года, то параметр должен иметь значение &#x60;2022-11-20T00:00:00+03:00&#x60;.  Обязательный параметр.  Не может быть раньше даты выдачи, указанной в параметре &#x60;dateOfIssue&#x60;. 
  , fullOutletLicenseDTOCheckStatus :: !(Maybe LicenseCheckStatusType) -- ^ "checkStatus"
  , fullOutletLicenseDTOCheckComment :: !(Maybe Text) -- ^ "checkComment" - Причина, по которой лицензия не прошла проверку.  Параметр возвращается, только если параметр &#x60;checkStatus&#x60; имеет значение &#x60;FAIL&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FullOutletLicenseDTO
instance A.FromJSON FullOutletLicenseDTO where
  parseJSON = A.withObject "FullOutletLicenseDTO" $ \o ->
    FullOutletLicenseDTO
      <$> (o .:? "id")
      <*> (o .:? "outletId")
      <*> (o .:? "licenseType")
      <*> (o .:? "number")
      <*> (o .:? "dateOfIssue")
      <*> (o .:? "dateOfExpiry")
      <*> (o .:? "checkStatus")
      <*> (o .:? "checkComment")

-- | ToJSON FullOutletLicenseDTO
instance A.ToJSON FullOutletLicenseDTO where
  toJSON FullOutletLicenseDTO {..} =
   _omitNulls
      [ "id" .= fullOutletLicenseDTOId
      , "outletId" .= fullOutletLicenseDTOOutletId
      , "licenseType" .= fullOutletLicenseDTOLicenseType
      , "number" .= fullOutletLicenseDTONumber
      , "dateOfIssue" .= fullOutletLicenseDTODateOfIssue
      , "dateOfExpiry" .= fullOutletLicenseDTODateOfExpiry
      , "checkStatus" .= fullOutletLicenseDTOCheckStatus
      , "checkComment" .= fullOutletLicenseDTOCheckComment
      ]


-- | Construct a value of type 'FullOutletLicenseDTO' (by applying it's required fields, if any)
mkFullOutletLicenseDTO
  :: FullOutletLicenseDTO
mkFullOutletLicenseDTO =
  FullOutletLicenseDTO
  { fullOutletLicenseDTOId = Nothing
  , fullOutletLicenseDTOOutletId = Nothing
  , fullOutletLicenseDTOLicenseType = Nothing
  , fullOutletLicenseDTONumber = Nothing
  , fullOutletLicenseDTODateOfIssue = Nothing
  , fullOutletLicenseDTODateOfExpiry = Nothing
  , fullOutletLicenseDTOCheckStatus = Nothing
  , fullOutletLicenseDTOCheckComment = Nothing
  }

-- ** GenerateBoostConsolidatedRequest
-- | GenerateBoostConsolidatedRequest
-- Данные, необходимые для генерации отчета. 
data GenerateBoostConsolidatedRequest = GenerateBoostConsolidatedRequest
  { generateBoostConsolidatedRequestBusinessId :: !(Integer) -- ^ /Required/ "businessId" - Идентификатор бизнеса.
  , generateBoostConsolidatedRequestDateFrom :: !(Date) -- ^ /Required/ "dateFrom" - Начало периода, включительно.
  , generateBoostConsolidatedRequestDateTo :: !(Date) -- ^ /Required/ "dateTo" - Конец периода, включительно.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateBoostConsolidatedRequest
instance A.FromJSON GenerateBoostConsolidatedRequest where
  parseJSON = A.withObject "GenerateBoostConsolidatedRequest" $ \o ->
    GenerateBoostConsolidatedRequest
      <$> (o .:  "businessId")
      <*> (o .:  "dateFrom")
      <*> (o .:  "dateTo")

-- | ToJSON GenerateBoostConsolidatedRequest
instance A.ToJSON GenerateBoostConsolidatedRequest where
  toJSON GenerateBoostConsolidatedRequest {..} =
   _omitNulls
      [ "businessId" .= generateBoostConsolidatedRequestBusinessId
      , "dateFrom" .= generateBoostConsolidatedRequestDateFrom
      , "dateTo" .= generateBoostConsolidatedRequestDateTo
      ]


-- | Construct a value of type 'GenerateBoostConsolidatedRequest' (by applying it's required fields, if any)
mkGenerateBoostConsolidatedRequest
  :: Integer -- ^ 'generateBoostConsolidatedRequestBusinessId': Идентификатор бизнеса.
  -> Date -- ^ 'generateBoostConsolidatedRequestDateFrom': Начало периода, включительно.
  -> Date -- ^ 'generateBoostConsolidatedRequestDateTo': Конец периода, включительно.
  -> GenerateBoostConsolidatedRequest
mkGenerateBoostConsolidatedRequest generateBoostConsolidatedRequestBusinessId generateBoostConsolidatedRequestDateFrom generateBoostConsolidatedRequestDateTo =
  GenerateBoostConsolidatedRequest
  { generateBoostConsolidatedRequestBusinessId
  , generateBoostConsolidatedRequestDateFrom
  , generateBoostConsolidatedRequestDateTo
  }

-- ** GenerateCompetitorsPositionReportRequest
-- | GenerateCompetitorsPositionReportRequest
-- Данные, необходимые для генерации отчета.
data GenerateCompetitorsPositionReportRequest = GenerateCompetitorsPositionReportRequest
  { generateCompetitorsPositionReportRequestBusinessId :: !(Integer) -- ^ /Required/ "businessId" - Идентификатор бизнеса.
  , generateCompetitorsPositionReportRequestCategoryId :: !(Integer) -- ^ /Required/ "categoryId" - Идентификатор категории.
  , generateCompetitorsPositionReportRequestDateFrom :: !(Date) -- ^ /Required/ "dateFrom" - Начало периода, включительно.
  , generateCompetitorsPositionReportRequestDateTo :: !(Date) -- ^ /Required/ "dateTo" - Конец периода, включительно.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateCompetitorsPositionReportRequest
instance A.FromJSON GenerateCompetitorsPositionReportRequest where
  parseJSON = A.withObject "GenerateCompetitorsPositionReportRequest" $ \o ->
    GenerateCompetitorsPositionReportRequest
      <$> (o .:  "businessId")
      <*> (o .:  "categoryId")
      <*> (o .:  "dateFrom")
      <*> (o .:  "dateTo")

-- | ToJSON GenerateCompetitorsPositionReportRequest
instance A.ToJSON GenerateCompetitorsPositionReportRequest where
  toJSON GenerateCompetitorsPositionReportRequest {..} =
   _omitNulls
      [ "businessId" .= generateCompetitorsPositionReportRequestBusinessId
      , "categoryId" .= generateCompetitorsPositionReportRequestCategoryId
      , "dateFrom" .= generateCompetitorsPositionReportRequestDateFrom
      , "dateTo" .= generateCompetitorsPositionReportRequestDateTo
      ]


-- | Construct a value of type 'GenerateCompetitorsPositionReportRequest' (by applying it's required fields, if any)
mkGenerateCompetitorsPositionReportRequest
  :: Integer -- ^ 'generateCompetitorsPositionReportRequestBusinessId': Идентификатор бизнеса.
  -> Integer -- ^ 'generateCompetitorsPositionReportRequestCategoryId': Идентификатор категории.
  -> Date -- ^ 'generateCompetitorsPositionReportRequestDateFrom': Начало периода, включительно.
  -> Date -- ^ 'generateCompetitorsPositionReportRequestDateTo': Конец периода, включительно.
  -> GenerateCompetitorsPositionReportRequest
mkGenerateCompetitorsPositionReportRequest generateCompetitorsPositionReportRequestBusinessId generateCompetitorsPositionReportRequestCategoryId generateCompetitorsPositionReportRequestDateFrom generateCompetitorsPositionReportRequestDateTo =
  GenerateCompetitorsPositionReportRequest
  { generateCompetitorsPositionReportRequestBusinessId
  , generateCompetitorsPositionReportRequestCategoryId
  , generateCompetitorsPositionReportRequestDateFrom
  , generateCompetitorsPositionReportRequestDateTo
  }

-- ** GenerateGoodsFeedbackRequest
-- | GenerateGoodsFeedbackRequest
-- Данные, необходимые для генерации отчета. 
data GenerateGoodsFeedbackRequest = GenerateGoodsFeedbackRequest
  { generateGoodsFeedbackRequestBusinessId :: !(Integer) -- ^ /Required/ "businessId" - Идентификатор бизнеса.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateGoodsFeedbackRequest
instance A.FromJSON GenerateGoodsFeedbackRequest where
  parseJSON = A.withObject "GenerateGoodsFeedbackRequest" $ \o ->
    GenerateGoodsFeedbackRequest
      <$> (o .:  "businessId")

-- | ToJSON GenerateGoodsFeedbackRequest
instance A.ToJSON GenerateGoodsFeedbackRequest where
  toJSON GenerateGoodsFeedbackRequest {..} =
   _omitNulls
      [ "businessId" .= generateGoodsFeedbackRequestBusinessId
      ]


-- | Construct a value of type 'GenerateGoodsFeedbackRequest' (by applying it's required fields, if any)
mkGenerateGoodsFeedbackRequest
  :: Integer -- ^ 'generateGoodsFeedbackRequestBusinessId': Идентификатор бизнеса.
  -> GenerateGoodsFeedbackRequest
mkGenerateGoodsFeedbackRequest generateGoodsFeedbackRequestBusinessId =
  GenerateGoodsFeedbackRequest
  { generateGoodsFeedbackRequestBusinessId
  }

-- ** GenerateGoodsMovementReportRequest
-- | GenerateGoodsMovementReportRequest
-- Данные, необходимые для генерации отчета.
data GenerateGoodsMovementReportRequest = GenerateGoodsMovementReportRequest
  { generateGoodsMovementReportRequestCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - Идентификатор кампании.
  , generateGoodsMovementReportRequestDateFrom :: !(Date) -- ^ /Required/ "dateFrom" - Начало периода, включительно.
  , generateGoodsMovementReportRequestDateTo :: !(Date) -- ^ /Required/ "dateTo" - Конец периода, включительно.
  , generateGoodsMovementReportRequestShopSku :: !(Maybe Text) -- ^ "shopSku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateGoodsMovementReportRequest
instance A.FromJSON GenerateGoodsMovementReportRequest where
  parseJSON = A.withObject "GenerateGoodsMovementReportRequest" $ \o ->
    GenerateGoodsMovementReportRequest
      <$> (o .:  "campaignId")
      <*> (o .:  "dateFrom")
      <*> (o .:  "dateTo")
      <*> (o .:? "shopSku")

-- | ToJSON GenerateGoodsMovementReportRequest
instance A.ToJSON GenerateGoodsMovementReportRequest where
  toJSON GenerateGoodsMovementReportRequest {..} =
   _omitNulls
      [ "campaignId" .= generateGoodsMovementReportRequestCampaignId
      , "dateFrom" .= generateGoodsMovementReportRequestDateFrom
      , "dateTo" .= generateGoodsMovementReportRequestDateTo
      , "shopSku" .= generateGoodsMovementReportRequestShopSku
      ]


-- | Construct a value of type 'GenerateGoodsMovementReportRequest' (by applying it's required fields, if any)
mkGenerateGoodsMovementReportRequest
  :: Integer -- ^ 'generateGoodsMovementReportRequestCampaignId': Идентификатор кампании.
  -> Date -- ^ 'generateGoodsMovementReportRequestDateFrom': Начало периода, включительно.
  -> Date -- ^ 'generateGoodsMovementReportRequestDateTo': Конец периода, включительно.
  -> GenerateGoodsMovementReportRequest
mkGenerateGoodsMovementReportRequest generateGoodsMovementReportRequestCampaignId generateGoodsMovementReportRequestDateFrom generateGoodsMovementReportRequestDateTo =
  GenerateGoodsMovementReportRequest
  { generateGoodsMovementReportRequestCampaignId
  , generateGoodsMovementReportRequestDateFrom
  , generateGoodsMovementReportRequestDateTo
  , generateGoodsMovementReportRequestShopSku = Nothing
  }

-- ** GenerateGoodsRealizationReportRequest
-- | GenerateGoodsRealizationReportRequest
-- Данные, необходимые для генерации отчета: идентификатор магазина и период, за который нужен отчет. 
data GenerateGoodsRealizationReportRequest = GenerateGoodsRealizationReportRequest
  { generateGoodsRealizationReportRequestCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - Идентификатор кампании.
  , generateGoodsRealizationReportRequestYear :: !(Int) -- ^ /Required/ "year" - Год.
  , generateGoodsRealizationReportRequestMonth :: !(Int) -- ^ /Required/ "month" - Номер месяца.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateGoodsRealizationReportRequest
instance A.FromJSON GenerateGoodsRealizationReportRequest where
  parseJSON = A.withObject "GenerateGoodsRealizationReportRequest" $ \o ->
    GenerateGoodsRealizationReportRequest
      <$> (o .:  "campaignId")
      <*> (o .:  "year")
      <*> (o .:  "month")

-- | ToJSON GenerateGoodsRealizationReportRequest
instance A.ToJSON GenerateGoodsRealizationReportRequest where
  toJSON GenerateGoodsRealizationReportRequest {..} =
   _omitNulls
      [ "campaignId" .= generateGoodsRealizationReportRequestCampaignId
      , "year" .= generateGoodsRealizationReportRequestYear
      , "month" .= generateGoodsRealizationReportRequestMonth
      ]


-- | Construct a value of type 'GenerateGoodsRealizationReportRequest' (by applying it's required fields, if any)
mkGenerateGoodsRealizationReportRequest
  :: Integer -- ^ 'generateGoodsRealizationReportRequestCampaignId': Идентификатор кампании.
  -> Int -- ^ 'generateGoodsRealizationReportRequestYear': Год.
  -> Int -- ^ 'generateGoodsRealizationReportRequestMonth': Номер месяца.
  -> GenerateGoodsRealizationReportRequest
mkGenerateGoodsRealizationReportRequest generateGoodsRealizationReportRequestCampaignId generateGoodsRealizationReportRequestYear generateGoodsRealizationReportRequestMonth =
  GenerateGoodsRealizationReportRequest
  { generateGoodsRealizationReportRequestCampaignId
  , generateGoodsRealizationReportRequestYear
  , generateGoodsRealizationReportRequestMonth
  }

-- ** GenerateGoodsTurnoverRequest
-- | GenerateGoodsTurnoverRequest
-- Данные, необходимые для генерации отчета. 
data GenerateGoodsTurnoverRequest = GenerateGoodsTurnoverRequest
  { generateGoodsTurnoverRequestCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - Идентификатор кампании.
  , generateGoodsTurnoverRequestDate :: !(Maybe Date) -- ^ "date" - Дата, за которую нужно рассчитать оборачиваемость. Если параметр не указан, используется текущая дата.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateGoodsTurnoverRequest
instance A.FromJSON GenerateGoodsTurnoverRequest where
  parseJSON = A.withObject "GenerateGoodsTurnoverRequest" $ \o ->
    GenerateGoodsTurnoverRequest
      <$> (o .:  "campaignId")
      <*> (o .:? "date")

-- | ToJSON GenerateGoodsTurnoverRequest
instance A.ToJSON GenerateGoodsTurnoverRequest where
  toJSON GenerateGoodsTurnoverRequest {..} =
   _omitNulls
      [ "campaignId" .= generateGoodsTurnoverRequestCampaignId
      , "date" .= generateGoodsTurnoverRequestDate
      ]


-- | Construct a value of type 'GenerateGoodsTurnoverRequest' (by applying it's required fields, if any)
mkGenerateGoodsTurnoverRequest
  :: Integer -- ^ 'generateGoodsTurnoverRequestCampaignId': Идентификатор кампании.
  -> GenerateGoodsTurnoverRequest
mkGenerateGoodsTurnoverRequest generateGoodsTurnoverRequestCampaignId =
  GenerateGoodsTurnoverRequest
  { generateGoodsTurnoverRequestCampaignId
  , generateGoodsTurnoverRequestDate = Nothing
  }

-- ** GenerateMassOrderLabelsRequest
-- | GenerateMassOrderLabelsRequest
-- Данные, необходимые для генерации файла. 
data GenerateMassOrderLabelsRequest = GenerateMassOrderLabelsRequest
  { generateMassOrderLabelsRequestBusinessId :: !(Integer) -- ^ /Required/ "businessId" - Идентификатор кабинета.
  , generateMassOrderLabelsRequestOrderIds :: !([Integer]) -- ^ /Required/ "orderIds" - Список идентификаторов заказов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateMassOrderLabelsRequest
instance A.FromJSON GenerateMassOrderLabelsRequest where
  parseJSON = A.withObject "GenerateMassOrderLabelsRequest" $ \o ->
    GenerateMassOrderLabelsRequest
      <$> (o .:  "businessId")
      <*> (o .:  "orderIds")

-- | ToJSON GenerateMassOrderLabelsRequest
instance A.ToJSON GenerateMassOrderLabelsRequest where
  toJSON GenerateMassOrderLabelsRequest {..} =
   _omitNulls
      [ "businessId" .= generateMassOrderLabelsRequestBusinessId
      , "orderIds" .= generateMassOrderLabelsRequestOrderIds
      ]


-- | Construct a value of type 'GenerateMassOrderLabelsRequest' (by applying it's required fields, if any)
mkGenerateMassOrderLabelsRequest
  :: Integer -- ^ 'generateMassOrderLabelsRequestBusinessId': Идентификатор кабинета.
  -> [Integer] -- ^ 'generateMassOrderLabelsRequestOrderIds': Список идентификаторов заказов.
  -> GenerateMassOrderLabelsRequest
mkGenerateMassOrderLabelsRequest generateMassOrderLabelsRequestBusinessId generateMassOrderLabelsRequestOrderIds =
  GenerateMassOrderLabelsRequest
  { generateMassOrderLabelsRequestBusinessId
  , generateMassOrderLabelsRequestOrderIds
  }

-- ** GeneratePricesReportRequest
-- | GeneratePricesReportRequest
-- Данные, необходимые для генерации отчета.
data GeneratePricesReportRequest = GeneratePricesReportRequest
  { generatePricesReportRequestBusinessId :: !(Maybe Integer) -- ^ "businessId" - Идентификатор бизнеса.  В большинстве случаев обязателен. Не указывается, если задан &#x60;campaignId&#x60;. 
  , generatePricesReportRequestCampaignId :: !(Maybe Integer) -- ^ "campaignId" - Идентификатор кампании.  Как правило, не используется. Передавайте только если в кабинете есть магазины с уникальными ценами и вы хотите получить отчет для них. В этом случае передавать &#x60;businessId&#x60; не нужно. 
  , generatePricesReportRequestCategoryIds :: !(Maybe [Integer]) -- ^ "categoryIds" - Фильтр по категориям на Маркете.
  , generatePricesReportRequestCreationDateFrom :: !(Maybe Date) -- ^ "creationDateFrom" - Фильтр по времени появления предложения — начало периода.  Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  , generatePricesReportRequestCreationDateTo :: !(Maybe Date) -- ^ "creationDateTo" - Фильтр по времени появления предложения — окончание периода.  Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GeneratePricesReportRequest
instance A.FromJSON GeneratePricesReportRequest where
  parseJSON = A.withObject "GeneratePricesReportRequest" $ \o ->
    GeneratePricesReportRequest
      <$> (o .:? "businessId")
      <*> (o .:? "campaignId")
      <*> (o .:? "categoryIds")
      <*> (o .:? "creationDateFrom")
      <*> (o .:? "creationDateTo")

-- | ToJSON GeneratePricesReportRequest
instance A.ToJSON GeneratePricesReportRequest where
  toJSON GeneratePricesReportRequest {..} =
   _omitNulls
      [ "businessId" .= generatePricesReportRequestBusinessId
      , "campaignId" .= generatePricesReportRequestCampaignId
      , "categoryIds" .= generatePricesReportRequestCategoryIds
      , "creationDateFrom" .= generatePricesReportRequestCreationDateFrom
      , "creationDateTo" .= generatePricesReportRequestCreationDateTo
      ]


-- | Construct a value of type 'GeneratePricesReportRequest' (by applying it's required fields, if any)
mkGeneratePricesReportRequest
  :: GeneratePricesReportRequest
mkGeneratePricesReportRequest =
  GeneratePricesReportRequest
  { generatePricesReportRequestBusinessId = Nothing
  , generatePricesReportRequestCampaignId = Nothing
  , generatePricesReportRequestCategoryIds = Nothing
  , generatePricesReportRequestCreationDateFrom = Nothing
  , generatePricesReportRequestCreationDateTo = Nothing
  }

-- ** GenerateReportDTO
-- | GenerateReportDTO
-- Идентификатор, который понадобится для отслеживания статуса генерации и получения готового отчета.
data GenerateReportDTO = GenerateReportDTO
  { generateReportDTOReportId :: !(Text) -- ^ /Required/ "reportId" - Идентификатор, который понадобится для отслеживания статуса генерации и получения готового отчета.
  , generateReportDTOEstimatedGenerationTime :: !(Integer) -- ^ /Required/ "estimatedGenerationTime" - Ожидаемая продолжительность генерации в миллисекундах.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateReportDTO
instance A.FromJSON GenerateReportDTO where
  parseJSON = A.withObject "GenerateReportDTO" $ \o ->
    GenerateReportDTO
      <$> (o .:  "reportId")
      <*> (o .:  "estimatedGenerationTime")

-- | ToJSON GenerateReportDTO
instance A.ToJSON GenerateReportDTO where
  toJSON GenerateReportDTO {..} =
   _omitNulls
      [ "reportId" .= generateReportDTOReportId
      , "estimatedGenerationTime" .= generateReportDTOEstimatedGenerationTime
      ]


-- | Construct a value of type 'GenerateReportDTO' (by applying it's required fields, if any)
mkGenerateReportDTO
  :: Text -- ^ 'generateReportDTOReportId': Идентификатор, который понадобится для отслеживания статуса генерации и получения готового отчета.
  -> Integer -- ^ 'generateReportDTOEstimatedGenerationTime': Ожидаемая продолжительность генерации в миллисекундах.
  -> GenerateReportDTO
mkGenerateReportDTO generateReportDTOReportId generateReportDTOEstimatedGenerationTime =
  GenerateReportDTO
  { generateReportDTOReportId
  , generateReportDTOEstimatedGenerationTime
  }

-- ** GenerateReportResponse
-- | GenerateReportResponse
-- Ответ на запрос генерации отчета.
data GenerateReportResponse = GenerateReportResponse
  { generateReportResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , generateReportResponseResult :: !(Maybe GenerateReportDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateReportResponse
instance A.FromJSON GenerateReportResponse where
  parseJSON = A.withObject "GenerateReportResponse" $ \o ->
    GenerateReportResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GenerateReportResponse
instance A.ToJSON GenerateReportResponse where
  toJSON GenerateReportResponse {..} =
   _omitNulls
      [ "status" .= generateReportResponseStatus
      , "result" .= generateReportResponseResult
      ]


-- | Construct a value of type 'GenerateReportResponse' (by applying it's required fields, if any)
mkGenerateReportResponse
  :: GenerateReportResponse
mkGenerateReportResponse =
  GenerateReportResponse
  { generateReportResponseStatus = Nothing
  , generateReportResponseResult = Nothing
  }

-- ** GenerateShelfsStatisticsRequest
-- | GenerateShelfsStatisticsRequest
-- Данные, необходимые для генерации отчета. 
data GenerateShelfsStatisticsRequest = GenerateShelfsStatisticsRequest
  { generateShelfsStatisticsRequestBusinessId :: !(Integer) -- ^ /Required/ "businessId" - Идентификатор бизнеса.
  , generateShelfsStatisticsRequestDateFrom :: !(Date) -- ^ /Required/ "dateFrom" - Начало периода, включительно.
  , generateShelfsStatisticsRequestDateTo :: !(Date) -- ^ /Required/ "dateTo" - Конец периода, включительно.
  , generateShelfsStatisticsRequestAttributionType :: !(ShelfsStatisticsAttributionType) -- ^ /Required/ "attributionType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateShelfsStatisticsRequest
instance A.FromJSON GenerateShelfsStatisticsRequest where
  parseJSON = A.withObject "GenerateShelfsStatisticsRequest" $ \o ->
    GenerateShelfsStatisticsRequest
      <$> (o .:  "businessId")
      <*> (o .:  "dateFrom")
      <*> (o .:  "dateTo")
      <*> (o .:  "attributionType")

-- | ToJSON GenerateShelfsStatisticsRequest
instance A.ToJSON GenerateShelfsStatisticsRequest where
  toJSON GenerateShelfsStatisticsRequest {..} =
   _omitNulls
      [ "businessId" .= generateShelfsStatisticsRequestBusinessId
      , "dateFrom" .= generateShelfsStatisticsRequestDateFrom
      , "dateTo" .= generateShelfsStatisticsRequestDateTo
      , "attributionType" .= generateShelfsStatisticsRequestAttributionType
      ]


-- | Construct a value of type 'GenerateShelfsStatisticsRequest' (by applying it's required fields, if any)
mkGenerateShelfsStatisticsRequest
  :: Integer -- ^ 'generateShelfsStatisticsRequestBusinessId': Идентификатор бизнеса.
  -> Date -- ^ 'generateShelfsStatisticsRequestDateFrom': Начало периода, включительно.
  -> Date -- ^ 'generateShelfsStatisticsRequestDateTo': Конец периода, включительно.
  -> ShelfsStatisticsAttributionType -- ^ 'generateShelfsStatisticsRequestAttributionType' 
  -> GenerateShelfsStatisticsRequest
mkGenerateShelfsStatisticsRequest generateShelfsStatisticsRequestBusinessId generateShelfsStatisticsRequestDateFrom generateShelfsStatisticsRequestDateTo generateShelfsStatisticsRequestAttributionType =
  GenerateShelfsStatisticsRequest
  { generateShelfsStatisticsRequestBusinessId
  , generateShelfsStatisticsRequestDateFrom
  , generateShelfsStatisticsRequestDateTo
  , generateShelfsStatisticsRequestAttributionType
  }

-- ** GenerateShipmentListDocumentReportRequest
-- | GenerateShipmentListDocumentReportRequest
-- Данные, необходимые для генерации документа. 
data GenerateShipmentListDocumentReportRequest = GenerateShipmentListDocumentReportRequest
  { generateShipmentListDocumentReportRequestCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - Идентификатор кампании.
  , generateShipmentListDocumentReportRequestShipmentId :: !(Maybe Integer) -- ^ "shipmentId" - Идентификатор отгрузки.
  , generateShipmentListDocumentReportRequestOrderIds :: !(Maybe [Integer]) -- ^ "orderIds" - Фильтр по идентификаторам заказа в отгрузке.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateShipmentListDocumentReportRequest
instance A.FromJSON GenerateShipmentListDocumentReportRequest where
  parseJSON = A.withObject "GenerateShipmentListDocumentReportRequest" $ \o ->
    GenerateShipmentListDocumentReportRequest
      <$> (o .:  "campaignId")
      <*> (o .:? "shipmentId")
      <*> (o .:? "orderIds")

-- | ToJSON GenerateShipmentListDocumentReportRequest
instance A.ToJSON GenerateShipmentListDocumentReportRequest where
  toJSON GenerateShipmentListDocumentReportRequest {..} =
   _omitNulls
      [ "campaignId" .= generateShipmentListDocumentReportRequestCampaignId
      , "shipmentId" .= generateShipmentListDocumentReportRequestShipmentId
      , "orderIds" .= generateShipmentListDocumentReportRequestOrderIds
      ]


-- | Construct a value of type 'GenerateShipmentListDocumentReportRequest' (by applying it's required fields, if any)
mkGenerateShipmentListDocumentReportRequest
  :: Integer -- ^ 'generateShipmentListDocumentReportRequestCampaignId': Идентификатор кампании.
  -> GenerateShipmentListDocumentReportRequest
mkGenerateShipmentListDocumentReportRequest generateShipmentListDocumentReportRequestCampaignId =
  GenerateShipmentListDocumentReportRequest
  { generateShipmentListDocumentReportRequestCampaignId
  , generateShipmentListDocumentReportRequestShipmentId = Nothing
  , generateShipmentListDocumentReportRequestOrderIds = Nothing
  }

-- ** GenerateShowsSalesReportRequest
-- | GenerateShowsSalesReportRequest
-- Данные, необходимые для генерации отчета.
data GenerateShowsSalesReportRequest = GenerateShowsSalesReportRequest
  { generateShowsSalesReportRequestBusinessId :: !(Maybe Integer) -- ^ "businessId" - Идентификатор бизнеса.  Указывается, если нужно составить отчет по всем магазинам бизнеса. В запросе обязательно должен быть либо &#x60;businessID&#x60;, либо &#x60;campaignId&#x60;, но не оба сразу. 
  , generateShowsSalesReportRequestCampaignId :: !(Maybe Integer) -- ^ "campaignId" - Идентификатор кампании.  Указывается, если нужно составить отчет по конкретному магазину. В запросе обязательно должен быть либо &#x60;businessID&#x60;, либо &#x60;campaignId&#x60;, но не оба сразу. 
  , generateShowsSalesReportRequestDateFrom :: !(Date) -- ^ /Required/ "dateFrom" - Начало периода, включительно.
  , generateShowsSalesReportRequestDateTo :: !(Date) -- ^ /Required/ "dateTo" - Конец периода, включительно.
  , generateShowsSalesReportRequestGrouping :: !(ShowsSalesGroupingType) -- ^ /Required/ "grouping"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateShowsSalesReportRequest
instance A.FromJSON GenerateShowsSalesReportRequest where
  parseJSON = A.withObject "GenerateShowsSalesReportRequest" $ \o ->
    GenerateShowsSalesReportRequest
      <$> (o .:? "businessId")
      <*> (o .:? "campaignId")
      <*> (o .:  "dateFrom")
      <*> (o .:  "dateTo")
      <*> (o .:  "grouping")

-- | ToJSON GenerateShowsSalesReportRequest
instance A.ToJSON GenerateShowsSalesReportRequest where
  toJSON GenerateShowsSalesReportRequest {..} =
   _omitNulls
      [ "businessId" .= generateShowsSalesReportRequestBusinessId
      , "campaignId" .= generateShowsSalesReportRequestCampaignId
      , "dateFrom" .= generateShowsSalesReportRequestDateFrom
      , "dateTo" .= generateShowsSalesReportRequestDateTo
      , "grouping" .= generateShowsSalesReportRequestGrouping
      ]


-- | Construct a value of type 'GenerateShowsSalesReportRequest' (by applying it's required fields, if any)
mkGenerateShowsSalesReportRequest
  :: Date -- ^ 'generateShowsSalesReportRequestDateFrom': Начало периода, включительно.
  -> Date -- ^ 'generateShowsSalesReportRequestDateTo': Конец периода, включительно.
  -> ShowsSalesGroupingType -- ^ 'generateShowsSalesReportRequestGrouping' 
  -> GenerateShowsSalesReportRequest
mkGenerateShowsSalesReportRequest generateShowsSalesReportRequestDateFrom generateShowsSalesReportRequestDateTo generateShowsSalesReportRequestGrouping =
  GenerateShowsSalesReportRequest
  { generateShowsSalesReportRequestBusinessId = Nothing
  , generateShowsSalesReportRequestCampaignId = Nothing
  , generateShowsSalesReportRequestDateFrom
  , generateShowsSalesReportRequestDateTo
  , generateShowsSalesReportRequestGrouping
  }

-- ** GenerateStocksOnWarehousesReportRequest
-- | GenerateStocksOnWarehousesReportRequest
-- Данные, необходимые для генерации отчета. 
data GenerateStocksOnWarehousesReportRequest = GenerateStocksOnWarehousesReportRequest
  { generateStocksOnWarehousesReportRequestCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - Идентификатор магазина.
  , generateStocksOnWarehousesReportRequestWarehouseIds :: !(Maybe [Integer]) -- ^ "warehouseIds" - Фильтр по идентификаторам складов (только модель FBY). Чтобы узнать идентификатор, воспользуйтесь запросом [GET warehouses](../../reference/warehouses/getFulfillmentWarehouses.md).
  , generateStocksOnWarehousesReportRequestReportDate :: !(Maybe Date) -- ^ "reportDate" - Фильтр по дате (для модели FBY). В отчет попадут данные за **предшествующий** дате день.
  , generateStocksOnWarehousesReportRequestCategoryIds :: !(Maybe [Integer]) -- ^ "categoryIds" - Фильтр по категориям на Маркете (кроме модели FBY).
  , generateStocksOnWarehousesReportRequestHasStocks :: !(Maybe Bool) -- ^ "hasStocks" - Фильтр по наличию остатков (кроме модели FBY).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateStocksOnWarehousesReportRequest
instance A.FromJSON GenerateStocksOnWarehousesReportRequest where
  parseJSON = A.withObject "GenerateStocksOnWarehousesReportRequest" $ \o ->
    GenerateStocksOnWarehousesReportRequest
      <$> (o .:  "campaignId")
      <*> (o .:? "warehouseIds")
      <*> (o .:? "reportDate")
      <*> (o .:? "categoryIds")
      <*> (o .:? "hasStocks")

-- | ToJSON GenerateStocksOnWarehousesReportRequest
instance A.ToJSON GenerateStocksOnWarehousesReportRequest where
  toJSON GenerateStocksOnWarehousesReportRequest {..} =
   _omitNulls
      [ "campaignId" .= generateStocksOnWarehousesReportRequestCampaignId
      , "warehouseIds" .= generateStocksOnWarehousesReportRequestWarehouseIds
      , "reportDate" .= generateStocksOnWarehousesReportRequestReportDate
      , "categoryIds" .= generateStocksOnWarehousesReportRequestCategoryIds
      , "hasStocks" .= generateStocksOnWarehousesReportRequestHasStocks
      ]


-- | Construct a value of type 'GenerateStocksOnWarehousesReportRequest' (by applying it's required fields, if any)
mkGenerateStocksOnWarehousesReportRequest
  :: Integer -- ^ 'generateStocksOnWarehousesReportRequestCampaignId': Идентификатор магазина.
  -> GenerateStocksOnWarehousesReportRequest
mkGenerateStocksOnWarehousesReportRequest generateStocksOnWarehousesReportRequestCampaignId =
  GenerateStocksOnWarehousesReportRequest
  { generateStocksOnWarehousesReportRequestCampaignId
  , generateStocksOnWarehousesReportRequestWarehouseIds = Nothing
  , generateStocksOnWarehousesReportRequestReportDate = Nothing
  , generateStocksOnWarehousesReportRequestCategoryIds = Nothing
  , generateStocksOnWarehousesReportRequestHasStocks = Nothing
  }

-- ** GenerateUnitedMarketplaceServicesReportRequest
-- | GenerateUnitedMarketplaceServicesReportRequest
-- Данные, необходимые для генерации отчета: идентификатор магазина, период, за который нужен отчет, а также фильтры. 
data GenerateUnitedMarketplaceServicesReportRequest = GenerateUnitedMarketplaceServicesReportRequest
  { generateUnitedMarketplaceServicesReportRequestBusinessId :: !(Integer) -- ^ /Required/ "businessId" - Идентификатор бизнеса.
  , generateUnitedMarketplaceServicesReportRequestDateTimeFrom :: !(Maybe DateTime) -- ^ "dateTimeFrom" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Начало периода, включительно. 
  , generateUnitedMarketplaceServicesReportRequestDateTimeTo :: !(Maybe DateTime) -- ^ "dateTimeTo" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Конец периода, включительно. Максимальный период — 1 год. 
  , generateUnitedMarketplaceServicesReportRequestDateFrom :: !(Maybe Date) -- ^ "dateFrom" - Начало периода, включительно.
  , generateUnitedMarketplaceServicesReportRequestDateTo :: !(Maybe Date) -- ^ "dateTo" - Конец периода, включительно. Максимальный период — 1 год.
  , generateUnitedMarketplaceServicesReportRequestYearFrom :: !(Maybe Int) -- ^ "yearFrom" - Начальный год формирования акта.
  , generateUnitedMarketplaceServicesReportRequestMonthFrom :: !(Maybe Int) -- ^ "monthFrom" - Начальный номер месяца формирования акта.
  , generateUnitedMarketplaceServicesReportRequestYearTo :: !(Maybe Int) -- ^ "yearTo" - Конечный год формирования акта.
  , generateUnitedMarketplaceServicesReportRequestMonthTo :: !(Maybe Int) -- ^ "monthTo" - Конечный номер месяца формирования акта.
  , generateUnitedMarketplaceServicesReportRequestPlacementPrograms :: !(Maybe [PlacementType]) -- ^ "placementPrograms" - Список моделей, которые нужны в отчете. 
  , generateUnitedMarketplaceServicesReportRequestInns :: !(Maybe [Text]) -- ^ "inns" - Список ИНН, которые нужны в отчете.
  , generateUnitedMarketplaceServicesReportRequestCampaignIds :: !(Maybe [Integer]) -- ^ "campaignIds" - Список магазинов, которые нужны в отчете.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateUnitedMarketplaceServicesReportRequest
instance A.FromJSON GenerateUnitedMarketplaceServicesReportRequest where
  parseJSON = A.withObject "GenerateUnitedMarketplaceServicesReportRequest" $ \o ->
    GenerateUnitedMarketplaceServicesReportRequest
      <$> (o .:  "businessId")
      <*> (o .:? "dateTimeFrom")
      <*> (o .:? "dateTimeTo")
      <*> (o .:? "dateFrom")
      <*> (o .:? "dateTo")
      <*> (o .:? "yearFrom")
      <*> (o .:? "monthFrom")
      <*> (o .:? "yearTo")
      <*> (o .:? "monthTo")
      <*> (o .:? "placementPrograms")
      <*> (o .:? "inns")
      <*> (o .:? "campaignIds")

-- | ToJSON GenerateUnitedMarketplaceServicesReportRequest
instance A.ToJSON GenerateUnitedMarketplaceServicesReportRequest where
  toJSON GenerateUnitedMarketplaceServicesReportRequest {..} =
   _omitNulls
      [ "businessId" .= generateUnitedMarketplaceServicesReportRequestBusinessId
      , "dateTimeFrom" .= generateUnitedMarketplaceServicesReportRequestDateTimeFrom
      , "dateTimeTo" .= generateUnitedMarketplaceServicesReportRequestDateTimeTo
      , "dateFrom" .= generateUnitedMarketplaceServicesReportRequestDateFrom
      , "dateTo" .= generateUnitedMarketplaceServicesReportRequestDateTo
      , "yearFrom" .= generateUnitedMarketplaceServicesReportRequestYearFrom
      , "monthFrom" .= generateUnitedMarketplaceServicesReportRequestMonthFrom
      , "yearTo" .= generateUnitedMarketplaceServicesReportRequestYearTo
      , "monthTo" .= generateUnitedMarketplaceServicesReportRequestMonthTo
      , "placementPrograms" .= generateUnitedMarketplaceServicesReportRequestPlacementPrograms
      , "inns" .= generateUnitedMarketplaceServicesReportRequestInns
      , "campaignIds" .= generateUnitedMarketplaceServicesReportRequestCampaignIds
      ]


-- | Construct a value of type 'GenerateUnitedMarketplaceServicesReportRequest' (by applying it's required fields, if any)
mkGenerateUnitedMarketplaceServicesReportRequest
  :: Integer -- ^ 'generateUnitedMarketplaceServicesReportRequestBusinessId': Идентификатор бизнеса.
  -> GenerateUnitedMarketplaceServicesReportRequest
mkGenerateUnitedMarketplaceServicesReportRequest generateUnitedMarketplaceServicesReportRequestBusinessId =
  GenerateUnitedMarketplaceServicesReportRequest
  { generateUnitedMarketplaceServicesReportRequestBusinessId
  , generateUnitedMarketplaceServicesReportRequestDateTimeFrom = Nothing
  , generateUnitedMarketplaceServicesReportRequestDateTimeTo = Nothing
  , generateUnitedMarketplaceServicesReportRequestDateFrom = Nothing
  , generateUnitedMarketplaceServicesReportRequestDateTo = Nothing
  , generateUnitedMarketplaceServicesReportRequestYearFrom = Nothing
  , generateUnitedMarketplaceServicesReportRequestMonthFrom = Nothing
  , generateUnitedMarketplaceServicesReportRequestYearTo = Nothing
  , generateUnitedMarketplaceServicesReportRequestMonthTo = Nothing
  , generateUnitedMarketplaceServicesReportRequestPlacementPrograms = Nothing
  , generateUnitedMarketplaceServicesReportRequestInns = Nothing
  , generateUnitedMarketplaceServicesReportRequestCampaignIds = Nothing
  }

-- ** GenerateUnitedNettingReportRequest
-- | GenerateUnitedNettingReportRequest
-- Данные, необходимые для генерации отчета: идентификатор магазина, период, за который нужен отчет, а также фильтры. 
data GenerateUnitedNettingReportRequest = GenerateUnitedNettingReportRequest
  { generateUnitedNettingReportRequestBusinessId :: !(Integer) -- ^ /Required/ "businessId" - Идентификатор бизнеса.
  , generateUnitedNettingReportRequestDateTimeFrom :: !(Maybe DateTime) -- ^ "dateTimeFrom" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Начало периода, включительно. 
  , generateUnitedNettingReportRequestDateTimeTo :: !(Maybe DateTime) -- ^ "dateTimeTo" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Конец периода, включительно. Максимальный период — 1 год. 
  , generateUnitedNettingReportRequestDateFrom :: !(Maybe Date) -- ^ "dateFrom" - Начало периода, включительно.
  , generateUnitedNettingReportRequestDateTo :: !(Maybe Date) -- ^ "dateTo" - Конец периода, включительно. Максимальный период — 1 год.
  , generateUnitedNettingReportRequestBankOrderId :: !(Maybe Integer) -- ^ "bankOrderId" - Номер платежного поручения.
  , generateUnitedNettingReportRequestBankOrderDateTime :: !(Maybe DateTime) -- ^ "bankOrderDateTime" - Дата платежного поручения.
  , generateUnitedNettingReportRequestPlacementPrograms :: !(Maybe [PlacementType]) -- ^ "placementPrograms" - Список моделей, которые нужны в отчете. 
  , generateUnitedNettingReportRequestInns :: !(Maybe [Text]) -- ^ "inns" - Список ИНН, которые нужны в отчете.
  , generateUnitedNettingReportRequestCampaignIds :: !(Maybe [Integer]) -- ^ "campaignIds" - Список магазинов, которые нужны в отчете.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateUnitedNettingReportRequest
instance A.FromJSON GenerateUnitedNettingReportRequest where
  parseJSON = A.withObject "GenerateUnitedNettingReportRequest" $ \o ->
    GenerateUnitedNettingReportRequest
      <$> (o .:  "businessId")
      <*> (o .:? "dateTimeFrom")
      <*> (o .:? "dateTimeTo")
      <*> (o .:? "dateFrom")
      <*> (o .:? "dateTo")
      <*> (o .:? "bankOrderId")
      <*> (o .:? "bankOrderDateTime")
      <*> (o .:? "placementPrograms")
      <*> (o .:? "inns")
      <*> (o .:? "campaignIds")

-- | ToJSON GenerateUnitedNettingReportRequest
instance A.ToJSON GenerateUnitedNettingReportRequest where
  toJSON GenerateUnitedNettingReportRequest {..} =
   _omitNulls
      [ "businessId" .= generateUnitedNettingReportRequestBusinessId
      , "dateTimeFrom" .= generateUnitedNettingReportRequestDateTimeFrom
      , "dateTimeTo" .= generateUnitedNettingReportRequestDateTimeTo
      , "dateFrom" .= generateUnitedNettingReportRequestDateFrom
      , "dateTo" .= generateUnitedNettingReportRequestDateTo
      , "bankOrderId" .= generateUnitedNettingReportRequestBankOrderId
      , "bankOrderDateTime" .= generateUnitedNettingReportRequestBankOrderDateTime
      , "placementPrograms" .= generateUnitedNettingReportRequestPlacementPrograms
      , "inns" .= generateUnitedNettingReportRequestInns
      , "campaignIds" .= generateUnitedNettingReportRequestCampaignIds
      ]


-- | Construct a value of type 'GenerateUnitedNettingReportRequest' (by applying it's required fields, if any)
mkGenerateUnitedNettingReportRequest
  :: Integer -- ^ 'generateUnitedNettingReportRequestBusinessId': Идентификатор бизнеса.
  -> GenerateUnitedNettingReportRequest
mkGenerateUnitedNettingReportRequest generateUnitedNettingReportRequestBusinessId =
  GenerateUnitedNettingReportRequest
  { generateUnitedNettingReportRequestBusinessId
  , generateUnitedNettingReportRequestDateTimeFrom = Nothing
  , generateUnitedNettingReportRequestDateTimeTo = Nothing
  , generateUnitedNettingReportRequestDateFrom = Nothing
  , generateUnitedNettingReportRequestDateTo = Nothing
  , generateUnitedNettingReportRequestBankOrderId = Nothing
  , generateUnitedNettingReportRequestBankOrderDateTime = Nothing
  , generateUnitedNettingReportRequestPlacementPrograms = Nothing
  , generateUnitedNettingReportRequestInns = Nothing
  , generateUnitedNettingReportRequestCampaignIds = Nothing
  }

-- ** GenerateUnitedOrdersRequest
-- | GenerateUnitedOrdersRequest
-- Данные, необходимые для генерации отчета. 
data GenerateUnitedOrdersRequest = GenerateUnitedOrdersRequest
  { generateUnitedOrdersRequestBusinessId :: !(Integer) -- ^ /Required/ "businessId" - Идентификатор бизнеса.
  , generateUnitedOrdersRequestDateFrom :: !(Date) -- ^ /Required/ "dateFrom" - Начало периода, включительно.
  , generateUnitedOrdersRequestDateTo :: !(Date) -- ^ /Required/ "dateTo" - Конец периода, включительно. Максимальный период — 1 год.
  , generateUnitedOrdersRequestCampaignIds :: !(Maybe [Integer]) -- ^ "campaignIds" - Список магазинов, которые нужны в отчете.
  , generateUnitedOrdersRequestPromoId :: !(Maybe Text) -- ^ "promoId" - Идентификатор акции, товары из которой нужны в отчете.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateUnitedOrdersRequest
instance A.FromJSON GenerateUnitedOrdersRequest where
  parseJSON = A.withObject "GenerateUnitedOrdersRequest" $ \o ->
    GenerateUnitedOrdersRequest
      <$> (o .:  "businessId")
      <*> (o .:  "dateFrom")
      <*> (o .:  "dateTo")
      <*> (o .:? "campaignIds")
      <*> (o .:? "promoId")

-- | ToJSON GenerateUnitedOrdersRequest
instance A.ToJSON GenerateUnitedOrdersRequest where
  toJSON GenerateUnitedOrdersRequest {..} =
   _omitNulls
      [ "businessId" .= generateUnitedOrdersRequestBusinessId
      , "dateFrom" .= generateUnitedOrdersRequestDateFrom
      , "dateTo" .= generateUnitedOrdersRequestDateTo
      , "campaignIds" .= generateUnitedOrdersRequestCampaignIds
      , "promoId" .= generateUnitedOrdersRequestPromoId
      ]


-- | Construct a value of type 'GenerateUnitedOrdersRequest' (by applying it's required fields, if any)
mkGenerateUnitedOrdersRequest
  :: Integer -- ^ 'generateUnitedOrdersRequestBusinessId': Идентификатор бизнеса.
  -> Date -- ^ 'generateUnitedOrdersRequestDateFrom': Начало периода, включительно.
  -> Date -- ^ 'generateUnitedOrdersRequestDateTo': Конец периода, включительно. Максимальный период — 1 год.
  -> GenerateUnitedOrdersRequest
mkGenerateUnitedOrdersRequest generateUnitedOrdersRequestBusinessId generateUnitedOrdersRequestDateFrom generateUnitedOrdersRequestDateTo =
  GenerateUnitedOrdersRequest
  { generateUnitedOrdersRequestBusinessId
  , generateUnitedOrdersRequestDateFrom
  , generateUnitedOrdersRequestDateTo
  , generateUnitedOrdersRequestCampaignIds = Nothing
  , generateUnitedOrdersRequestPromoId = Nothing
  }

-- ** GetAllOffersResponse
-- | GetAllOffersResponse
-- Список предложений.
data GetAllOffersResponse = GetAllOffersResponse
  { getAllOffersResponseOffers :: !([OfferDTO]) -- ^ /Required/ "offers" - Список предложений магазина.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAllOffersResponse
instance A.FromJSON GetAllOffersResponse where
  parseJSON = A.withObject "GetAllOffersResponse" $ \o ->
    GetAllOffersResponse
      <$> (o .:  "offers")

-- | ToJSON GetAllOffersResponse
instance A.ToJSON GetAllOffersResponse where
  toJSON GetAllOffersResponse {..} =
   _omitNulls
      [ "offers" .= getAllOffersResponseOffers
      ]


-- | Construct a value of type 'GetAllOffersResponse' (by applying it's required fields, if any)
mkGetAllOffersResponse
  :: [OfferDTO] -- ^ 'getAllOffersResponseOffers': Список предложений магазина.
  -> GetAllOffersResponse
mkGetAllOffersResponse getAllOffersResponseOffers =
  GetAllOffersResponse
  { getAllOffersResponseOffers
  }

-- ** GetBidsInfoRequest
-- | GetBidsInfoRequest
-- description.
data GetBidsInfoRequest = GetBidsInfoRequest
  { getBidsInfoRequestSkus :: !(Maybe [Text]) -- ^ "skus" - Список товаров, для которых нужно получить значения ставок.  Если список не задан, постранично возвращаются все товары со ставками.  Если список задан, результаты возвращаются одной страницей, а параметры &#x60;page_token&#x60; и &#x60;limit&#x60; игнорируются. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBidsInfoRequest
instance A.FromJSON GetBidsInfoRequest where
  parseJSON = A.withObject "GetBidsInfoRequest" $ \o ->
    GetBidsInfoRequest
      <$> (o .:? "skus")

-- | ToJSON GetBidsInfoRequest
instance A.ToJSON GetBidsInfoRequest where
  toJSON GetBidsInfoRequest {..} =
   _omitNulls
      [ "skus" .= getBidsInfoRequestSkus
      ]


-- | Construct a value of type 'GetBidsInfoRequest' (by applying it's required fields, if any)
mkGetBidsInfoRequest
  :: GetBidsInfoRequest
mkGetBidsInfoRequest =
  GetBidsInfoRequest
  { getBidsInfoRequestSkus = Nothing
  }

-- ** GetBidsInfoResponse
-- | GetBidsInfoResponse
-- description.
data GetBidsInfoResponse = GetBidsInfoResponse
  { getBidsInfoResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getBidsInfoResponseResult :: !(Maybe GetBidsInfoResponseDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBidsInfoResponse
instance A.FromJSON GetBidsInfoResponse where
  parseJSON = A.withObject "GetBidsInfoResponse" $ \o ->
    GetBidsInfoResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetBidsInfoResponse
instance A.ToJSON GetBidsInfoResponse where
  toJSON GetBidsInfoResponse {..} =
   _omitNulls
      [ "status" .= getBidsInfoResponseStatus
      , "result" .= getBidsInfoResponseResult
      ]


-- | Construct a value of type 'GetBidsInfoResponse' (by applying it's required fields, if any)
mkGetBidsInfoResponse
  :: GetBidsInfoResponse
mkGetBidsInfoResponse =
  GetBidsInfoResponse
  { getBidsInfoResponseStatus = Nothing
  , getBidsInfoResponseResult = Nothing
  }

-- ** GetBidsInfoResponseDTO
-- | GetBidsInfoResponseDTO
-- Список товаров с указанными ставками.
data GetBidsInfoResponseDTO = GetBidsInfoResponseDTO
  { getBidsInfoResponseDTOBids :: !([SkuBidItemDTO]) -- ^ /Required/ "bids" - Страница списка товаров.
  , getBidsInfoResponseDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBidsInfoResponseDTO
instance A.FromJSON GetBidsInfoResponseDTO where
  parseJSON = A.withObject "GetBidsInfoResponseDTO" $ \o ->
    GetBidsInfoResponseDTO
      <$> (o .:  "bids")
      <*> (o .:? "paging")

-- | ToJSON GetBidsInfoResponseDTO
instance A.ToJSON GetBidsInfoResponseDTO where
  toJSON GetBidsInfoResponseDTO {..} =
   _omitNulls
      [ "bids" .= getBidsInfoResponseDTOBids
      , "paging" .= getBidsInfoResponseDTOPaging
      ]


-- | Construct a value of type 'GetBidsInfoResponseDTO' (by applying it's required fields, if any)
mkGetBidsInfoResponseDTO
  :: [SkuBidItemDTO] -- ^ 'getBidsInfoResponseDTOBids': Страница списка товаров.
  -> GetBidsInfoResponseDTO
mkGetBidsInfoResponseDTO getBidsInfoResponseDTOBids =
  GetBidsInfoResponseDTO
  { getBidsInfoResponseDTOBids
  , getBidsInfoResponseDTOPaging = Nothing
  }

-- ** GetBidsRecommendationsRequest
-- | GetBidsRecommendationsRequest
-- description.
data GetBidsRecommendationsRequest = GetBidsRecommendationsRequest
  { getBidsRecommendationsRequestSkus :: !([Text]) -- ^ /Required/ "skus" - Список товаров, для которых нужно получить рекомендации по ставкам. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBidsRecommendationsRequest
instance A.FromJSON GetBidsRecommendationsRequest where
  parseJSON = A.withObject "GetBidsRecommendationsRequest" $ \o ->
    GetBidsRecommendationsRequest
      <$> (o .:  "skus")

-- | ToJSON GetBidsRecommendationsRequest
instance A.ToJSON GetBidsRecommendationsRequest where
  toJSON GetBidsRecommendationsRequest {..} =
   _omitNulls
      [ "skus" .= getBidsRecommendationsRequestSkus
      ]


-- | Construct a value of type 'GetBidsRecommendationsRequest' (by applying it's required fields, if any)
mkGetBidsRecommendationsRequest
  :: [Text] -- ^ 'getBidsRecommendationsRequestSkus': Список товаров, для которых нужно получить рекомендации по ставкам. 
  -> GetBidsRecommendationsRequest
mkGetBidsRecommendationsRequest getBidsRecommendationsRequestSkus =
  GetBidsRecommendationsRequest
  { getBidsRecommendationsRequestSkus
  }

-- ** GetBidsRecommendationsResponse
-- | GetBidsRecommendationsResponse
-- description.
data GetBidsRecommendationsResponse = GetBidsRecommendationsResponse
  { getBidsRecommendationsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getBidsRecommendationsResponseResult :: !(Maybe GetBidsRecommendationsResponseDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBidsRecommendationsResponse
instance A.FromJSON GetBidsRecommendationsResponse where
  parseJSON = A.withObject "GetBidsRecommendationsResponse" $ \o ->
    GetBidsRecommendationsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetBidsRecommendationsResponse
instance A.ToJSON GetBidsRecommendationsResponse where
  toJSON GetBidsRecommendationsResponse {..} =
   _omitNulls
      [ "status" .= getBidsRecommendationsResponseStatus
      , "result" .= getBidsRecommendationsResponseResult
      ]


-- | Construct a value of type 'GetBidsRecommendationsResponse' (by applying it's required fields, if any)
mkGetBidsRecommendationsResponse
  :: GetBidsRecommendationsResponse
mkGetBidsRecommendationsResponse =
  GetBidsRecommendationsResponse
  { getBidsRecommendationsResponseStatus = Nothing
  , getBidsRecommendationsResponseResult = Nothing
  }

-- ** GetBidsRecommendationsResponseDTO
-- | GetBidsRecommendationsResponseDTO
-- Список товаров с рекомендованными ставками.
data GetBidsRecommendationsResponseDTO = GetBidsRecommendationsResponseDTO
  { getBidsRecommendationsResponseDTORecommendations :: !([SkuBidRecommendationItemDTO]) -- ^ /Required/ "recommendations" - Список товаров с рекомендованными ставками.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBidsRecommendationsResponseDTO
instance A.FromJSON GetBidsRecommendationsResponseDTO where
  parseJSON = A.withObject "GetBidsRecommendationsResponseDTO" $ \o ->
    GetBidsRecommendationsResponseDTO
      <$> (o .:  "recommendations")

-- | ToJSON GetBidsRecommendationsResponseDTO
instance A.ToJSON GetBidsRecommendationsResponseDTO where
  toJSON GetBidsRecommendationsResponseDTO {..} =
   _omitNulls
      [ "recommendations" .= getBidsRecommendationsResponseDTORecommendations
      ]


-- | Construct a value of type 'GetBidsRecommendationsResponseDTO' (by applying it's required fields, if any)
mkGetBidsRecommendationsResponseDTO
  :: [SkuBidRecommendationItemDTO] -- ^ 'getBidsRecommendationsResponseDTORecommendations': Список товаров с рекомендованными ставками.
  -> GetBidsRecommendationsResponseDTO
mkGetBidsRecommendationsResponseDTO getBidsRecommendationsResponseDTORecommendations =
  GetBidsRecommendationsResponseDTO
  { getBidsRecommendationsResponseDTORecommendations
  }

-- ** GetBusinessBuyerInfoResponse
-- | GetBusinessBuyerInfoResponse
data GetBusinessBuyerInfoResponse = GetBusinessBuyerInfoResponse
  { getBusinessBuyerInfoResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getBusinessBuyerInfoResponseResult :: !(Maybe OrderBusinessBuyerDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBusinessBuyerInfoResponse
instance A.FromJSON GetBusinessBuyerInfoResponse where
  parseJSON = A.withObject "GetBusinessBuyerInfoResponse" $ \o ->
    GetBusinessBuyerInfoResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetBusinessBuyerInfoResponse
instance A.ToJSON GetBusinessBuyerInfoResponse where
  toJSON GetBusinessBuyerInfoResponse {..} =
   _omitNulls
      [ "status" .= getBusinessBuyerInfoResponseStatus
      , "result" .= getBusinessBuyerInfoResponseResult
      ]


-- | Construct a value of type 'GetBusinessBuyerInfoResponse' (by applying it's required fields, if any)
mkGetBusinessBuyerInfoResponse
  :: GetBusinessBuyerInfoResponse
mkGetBusinessBuyerInfoResponse =
  GetBusinessBuyerInfoResponse
  { getBusinessBuyerInfoResponseStatus = Nothing
  , getBusinessBuyerInfoResponseResult = Nothing
  }

-- ** GetBusinessDocumentsInfoResponse
-- | GetBusinessDocumentsInfoResponse
data GetBusinessDocumentsInfoResponse = GetBusinessDocumentsInfoResponse
  { getBusinessDocumentsInfoResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getBusinessDocumentsInfoResponseResult :: !(Maybe OrderBusinessDocumentsDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBusinessDocumentsInfoResponse
instance A.FromJSON GetBusinessDocumentsInfoResponse where
  parseJSON = A.withObject "GetBusinessDocumentsInfoResponse" $ \o ->
    GetBusinessDocumentsInfoResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetBusinessDocumentsInfoResponse
instance A.ToJSON GetBusinessDocumentsInfoResponse where
  toJSON GetBusinessDocumentsInfoResponse {..} =
   _omitNulls
      [ "status" .= getBusinessDocumentsInfoResponseStatus
      , "result" .= getBusinessDocumentsInfoResponseResult
      ]


-- | Construct a value of type 'GetBusinessDocumentsInfoResponse' (by applying it's required fields, if any)
mkGetBusinessDocumentsInfoResponse
  :: GetBusinessDocumentsInfoResponse
mkGetBusinessDocumentsInfoResponse =
  GetBusinessDocumentsInfoResponse
  { getBusinessDocumentsInfoResponseStatus = Nothing
  , getBusinessDocumentsInfoResponseResult = Nothing
  }

-- ** GetBusinessSettingsInfoDTO
-- | GetBusinessSettingsInfoDTO
-- Информация о кабинете и его настройках.
data GetBusinessSettingsInfoDTO = GetBusinessSettingsInfoDTO
  { getBusinessSettingsInfoDTOInfo :: !(Maybe BusinessDTO) -- ^ "info"
  , getBusinessSettingsInfoDTOSettings :: !(Maybe BusinessSettingsDTO) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBusinessSettingsInfoDTO
instance A.FromJSON GetBusinessSettingsInfoDTO where
  parseJSON = A.withObject "GetBusinessSettingsInfoDTO" $ \o ->
    GetBusinessSettingsInfoDTO
      <$> (o .:? "info")
      <*> (o .:? "settings")

-- | ToJSON GetBusinessSettingsInfoDTO
instance A.ToJSON GetBusinessSettingsInfoDTO where
  toJSON GetBusinessSettingsInfoDTO {..} =
   _omitNulls
      [ "info" .= getBusinessSettingsInfoDTOInfo
      , "settings" .= getBusinessSettingsInfoDTOSettings
      ]


-- | Construct a value of type 'GetBusinessSettingsInfoDTO' (by applying it's required fields, if any)
mkGetBusinessSettingsInfoDTO
  :: GetBusinessSettingsInfoDTO
mkGetBusinessSettingsInfoDTO =
  GetBusinessSettingsInfoDTO
  { getBusinessSettingsInfoDTOInfo = Nothing
  , getBusinessSettingsInfoDTOSettings = Nothing
  }

-- ** GetBusinessSettingsResponse
-- | GetBusinessSettingsResponse
-- Ответ на запрос настроек кабинета.
data GetBusinessSettingsResponse = GetBusinessSettingsResponse
  { getBusinessSettingsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getBusinessSettingsResponseResult :: !(Maybe GetBusinessSettingsInfoDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetBusinessSettingsResponse
instance A.FromJSON GetBusinessSettingsResponse where
  parseJSON = A.withObject "GetBusinessSettingsResponse" $ \o ->
    GetBusinessSettingsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetBusinessSettingsResponse
instance A.ToJSON GetBusinessSettingsResponse where
  toJSON GetBusinessSettingsResponse {..} =
   _omitNulls
      [ "status" .= getBusinessSettingsResponseStatus
      , "result" .= getBusinessSettingsResponseResult
      ]


-- | Construct a value of type 'GetBusinessSettingsResponse' (by applying it's required fields, if any)
mkGetBusinessSettingsResponse
  :: GetBusinessSettingsResponse
mkGetBusinessSettingsResponse =
  GetBusinessSettingsResponse
  { getBusinessSettingsResponseStatus = Nothing
  , getBusinessSettingsResponseResult = Nothing
  }

-- ** GetCampaignLoginsResponse
-- | GetCampaignLoginsResponse
-- Ответ на запрос списка логинов, связанных с магазином.
data GetCampaignLoginsResponse = GetCampaignLoginsResponse
  { getCampaignLoginsResponseLogins :: !([Text]) -- ^ /Required/ "logins" - Список логинов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignLoginsResponse
instance A.FromJSON GetCampaignLoginsResponse where
  parseJSON = A.withObject "GetCampaignLoginsResponse" $ \o ->
    GetCampaignLoginsResponse
      <$> (o .:  "logins")

-- | ToJSON GetCampaignLoginsResponse
instance A.ToJSON GetCampaignLoginsResponse where
  toJSON GetCampaignLoginsResponse {..} =
   _omitNulls
      [ "logins" .= getCampaignLoginsResponseLogins
      ]


-- | Construct a value of type 'GetCampaignLoginsResponse' (by applying it's required fields, if any)
mkGetCampaignLoginsResponse
  :: [Text] -- ^ 'getCampaignLoginsResponseLogins': Список логинов.
  -> GetCampaignLoginsResponse
mkGetCampaignLoginsResponse getCampaignLoginsResponseLogins =
  GetCampaignLoginsResponse
  { getCampaignLoginsResponseLogins
  }

-- ** GetCampaignOfferDTO
-- | GetCampaignOfferDTO
-- Параметры размещения товара в магазине.
data GetCampaignOfferDTO = GetCampaignOfferDTO
  { getCampaignOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , getCampaignOfferDTOQuantum :: !(Maybe QuantumDTO) -- ^ "quantum"
  , getCampaignOfferDTOAvailable :: !(Maybe Bool) -- ^ "available" - Есть ли товар в продаже. 
  , getCampaignOfferDTOBasicPrice :: !(Maybe GetPriceWithDiscountDTO) -- ^ "basicPrice"
  , getCampaignOfferDTOCampaignPrice :: !(Maybe GetPriceWithVatDTO) -- ^ "campaignPrice"
  , getCampaignOfferDTOStatus :: !(Maybe OfferCampaignStatusType) -- ^ "status"
  , getCampaignOfferDTOErrors :: !(Maybe [OfferErrorDTO]) -- ^ "errors" - Ошибки, препятствующие размещению товара на витрине. 
  , getCampaignOfferDTOWarnings :: !(Maybe [OfferErrorDTO]) -- ^ "warnings" - Предупреждения, не препятствующие размещению товара на витрине. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignOfferDTO
instance A.FromJSON GetCampaignOfferDTO where
  parseJSON = A.withObject "GetCampaignOfferDTO" $ \o ->
    GetCampaignOfferDTO
      <$> (o .:  "offerId")
      <*> (o .:? "quantum")
      <*> (o .:? "available")
      <*> (o .:? "basicPrice")
      <*> (o .:? "campaignPrice")
      <*> (o .:? "status")
      <*> (o .:? "errors")
      <*> (o .:? "warnings")

-- | ToJSON GetCampaignOfferDTO
instance A.ToJSON GetCampaignOfferDTO where
  toJSON GetCampaignOfferDTO {..} =
   _omitNulls
      [ "offerId" .= getCampaignOfferDTOOfferId
      , "quantum" .= getCampaignOfferDTOQuantum
      , "available" .= getCampaignOfferDTOAvailable
      , "basicPrice" .= getCampaignOfferDTOBasicPrice
      , "campaignPrice" .= getCampaignOfferDTOCampaignPrice
      , "status" .= getCampaignOfferDTOStatus
      , "errors" .= getCampaignOfferDTOErrors
      , "warnings" .= getCampaignOfferDTOWarnings
      ]


-- | Construct a value of type 'GetCampaignOfferDTO' (by applying it's required fields, if any)
mkGetCampaignOfferDTO
  :: Text -- ^ 'getCampaignOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> GetCampaignOfferDTO
mkGetCampaignOfferDTO getCampaignOfferDTOOfferId =
  GetCampaignOfferDTO
  { getCampaignOfferDTOOfferId
  , getCampaignOfferDTOQuantum = Nothing
  , getCampaignOfferDTOAvailable = Nothing
  , getCampaignOfferDTOBasicPrice = Nothing
  , getCampaignOfferDTOCampaignPrice = Nothing
  , getCampaignOfferDTOStatus = Nothing
  , getCampaignOfferDTOErrors = Nothing
  , getCampaignOfferDTOWarnings = Nothing
  }

-- ** GetCampaignOffersRequest
-- | GetCampaignOffersRequest
-- Фильтрации товаров  В запросе можно указать либо фильтр offerIds, либо любые другие фильтры товаров. Совместное использование фильтра offerIds с другими фильтрациями приведет к ошибке. 
data GetCampaignOffersRequest = GetCampaignOffersRequest
  { getCampaignOffersRequestOfferIds :: !(Maybe [Text]) -- ^ "offerIds" - Идентификаторы товаров, информация о которых нужна.  {% note warning \&quot;Такой список возвращается только целиком\&quot; %}  Не используйте это поле одновременно с фильтрами по статусам карточек, категориям, брендам или тегам. Если вы хотите воспользоваться фильтрами, оставьте поле пустым.  Если вы запрашиваете информацию по конкретным SKU, не заполняйте:  * &#x60;page_token&#x60; * &#x60;limit&#x60;  {% endnote %}    
  , getCampaignOffersRequestStatuses :: !(Maybe [OfferCampaignStatusType]) -- ^ "statuses" - Фильтр по статусам товаров. 
  , getCampaignOffersRequestCategoryIds :: !(Maybe [Int]) -- ^ "categoryIds" - Фильтр по категориям на Маркете.
  , getCampaignOffersRequestVendorNames :: !(Maybe [Text]) -- ^ "vendorNames" - Фильтр по брендам.
  , getCampaignOffersRequestTags :: !(Maybe [Text]) -- ^ "tags" - Фильтр по тегам.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignOffersRequest
instance A.FromJSON GetCampaignOffersRequest where
  parseJSON = A.withObject "GetCampaignOffersRequest" $ \o ->
    GetCampaignOffersRequest
      <$> (o .:? "offerIds")
      <*> (o .:? "statuses")
      <*> (o .:? "categoryIds")
      <*> (o .:? "vendorNames")
      <*> (o .:? "tags")

-- | ToJSON GetCampaignOffersRequest
instance A.ToJSON GetCampaignOffersRequest where
  toJSON GetCampaignOffersRequest {..} =
   _omitNulls
      [ "offerIds" .= getCampaignOffersRequestOfferIds
      , "statuses" .= getCampaignOffersRequestStatuses
      , "categoryIds" .= getCampaignOffersRequestCategoryIds
      , "vendorNames" .= getCampaignOffersRequestVendorNames
      , "tags" .= getCampaignOffersRequestTags
      ]


-- | Construct a value of type 'GetCampaignOffersRequest' (by applying it's required fields, if any)
mkGetCampaignOffersRequest
  :: GetCampaignOffersRequest
mkGetCampaignOffersRequest =
  GetCampaignOffersRequest
  { getCampaignOffersRequestOfferIds = Nothing
  , getCampaignOffersRequestStatuses = Nothing
  , getCampaignOffersRequestCategoryIds = Nothing
  , getCampaignOffersRequestVendorNames = Nothing
  , getCampaignOffersRequestTags = Nothing
  }

-- ** GetCampaignOffersResponse
-- | GetCampaignOffersResponse
-- Ответ на запрос списка товаров в магазине.
data GetCampaignOffersResponse = GetCampaignOffersResponse
  { getCampaignOffersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getCampaignOffersResponseResult :: !(Maybe GetCampaignOffersResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignOffersResponse
instance A.FromJSON GetCampaignOffersResponse where
  parseJSON = A.withObject "GetCampaignOffersResponse" $ \o ->
    GetCampaignOffersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetCampaignOffersResponse
instance A.ToJSON GetCampaignOffersResponse where
  toJSON GetCampaignOffersResponse {..} =
   _omitNulls
      [ "status" .= getCampaignOffersResponseStatus
      , "result" .= getCampaignOffersResponseResult
      ]


-- | Construct a value of type 'GetCampaignOffersResponse' (by applying it's required fields, if any)
mkGetCampaignOffersResponse
  :: GetCampaignOffersResponse
mkGetCampaignOffersResponse =
  GetCampaignOffersResponse
  { getCampaignOffersResponseStatus = Nothing
  , getCampaignOffersResponseResult = Nothing
  }

-- ** GetCampaignOffersResultDTO
-- | GetCampaignOffersResultDTO
-- Список товаров в заданном магазине.
data GetCampaignOffersResultDTO = GetCampaignOffersResultDTO
  { getCampaignOffersResultDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , getCampaignOffersResultDTOOffers :: !([GetCampaignOfferDTO]) -- ^ /Required/ "offers" - Страница списка товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignOffersResultDTO
instance A.FromJSON GetCampaignOffersResultDTO where
  parseJSON = A.withObject "GetCampaignOffersResultDTO" $ \o ->
    GetCampaignOffersResultDTO
      <$> (o .:? "paging")
      <*> (o .:  "offers")

-- | ToJSON GetCampaignOffersResultDTO
instance A.ToJSON GetCampaignOffersResultDTO where
  toJSON GetCampaignOffersResultDTO {..} =
   _omitNulls
      [ "paging" .= getCampaignOffersResultDTOPaging
      , "offers" .= getCampaignOffersResultDTOOffers
      ]


-- | Construct a value of type 'GetCampaignOffersResultDTO' (by applying it's required fields, if any)
mkGetCampaignOffersResultDTO
  :: [GetCampaignOfferDTO] -- ^ 'getCampaignOffersResultDTOOffers': Страница списка товаров.
  -> GetCampaignOffersResultDTO
mkGetCampaignOffersResultDTO getCampaignOffersResultDTOOffers =
  GetCampaignOffersResultDTO
  { getCampaignOffersResultDTOPaging = Nothing
  , getCampaignOffersResultDTOOffers
  }

-- ** GetCampaignRegionResponse
-- | GetCampaignRegionResponse
-- Ответ на запрос региона магазина.
data GetCampaignRegionResponse = GetCampaignRegionResponse
  { getCampaignRegionResponseRegion :: !(Maybe RegionDTO) -- ^ "region"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignRegionResponse
instance A.FromJSON GetCampaignRegionResponse where
  parseJSON = A.withObject "GetCampaignRegionResponse" $ \o ->
    GetCampaignRegionResponse
      <$> (o .:? "region")

-- | ToJSON GetCampaignRegionResponse
instance A.ToJSON GetCampaignRegionResponse where
  toJSON GetCampaignRegionResponse {..} =
   _omitNulls
      [ "region" .= getCampaignRegionResponseRegion
      ]


-- | Construct a value of type 'GetCampaignRegionResponse' (by applying it's required fields, if any)
mkGetCampaignRegionResponse
  :: GetCampaignRegionResponse
mkGetCampaignRegionResponse =
  GetCampaignRegionResponse
  { getCampaignRegionResponseRegion = Nothing
  }

-- ** GetCampaignResponse
-- | GetCampaignResponse
-- Информация о магазине к данным идентификатора кампании.
data GetCampaignResponse = GetCampaignResponse
  { getCampaignResponseCampaign :: !(Maybe CampaignDTO) -- ^ "campaign"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignResponse
instance A.FromJSON GetCampaignResponse where
  parseJSON = A.withObject "GetCampaignResponse" $ \o ->
    GetCampaignResponse
      <$> (o .:? "campaign")

-- | ToJSON GetCampaignResponse
instance A.ToJSON GetCampaignResponse where
  toJSON GetCampaignResponse {..} =
   _omitNulls
      [ "campaign" .= getCampaignResponseCampaign
      ]


-- | Construct a value of type 'GetCampaignResponse' (by applying it's required fields, if any)
mkGetCampaignResponse
  :: GetCampaignResponse
mkGetCampaignResponse =
  GetCampaignResponse
  { getCampaignResponseCampaign = Nothing
  }

-- ** GetCampaignSettingsResponse
-- | GetCampaignSettingsResponse
-- Ответ на запрос настроек магазина.
data GetCampaignSettingsResponse = GetCampaignSettingsResponse
  { getCampaignSettingsResponseSettings :: !(Maybe CampaignSettingsDTO) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignSettingsResponse
instance A.FromJSON GetCampaignSettingsResponse where
  parseJSON = A.withObject "GetCampaignSettingsResponse" $ \o ->
    GetCampaignSettingsResponse
      <$> (o .:? "settings")

-- | ToJSON GetCampaignSettingsResponse
instance A.ToJSON GetCampaignSettingsResponse where
  toJSON GetCampaignSettingsResponse {..} =
   _omitNulls
      [ "settings" .= getCampaignSettingsResponseSettings
      ]


-- | Construct a value of type 'GetCampaignSettingsResponse' (by applying it's required fields, if any)
mkGetCampaignSettingsResponse
  :: GetCampaignSettingsResponse
mkGetCampaignSettingsResponse =
  GetCampaignSettingsResponse
  { getCampaignSettingsResponseSettings = Nothing
  }

-- ** GetCampaignsResponse
-- | GetCampaignsResponse
-- Результаты поиска магазинов.
data GetCampaignsResponse = GetCampaignsResponse
  { getCampaignsResponseCampaigns :: !([CampaignDTO]) -- ^ /Required/ "campaigns" - Список с информацией по каждому магазину.
  , getCampaignsResponsePager :: !(Maybe FlippingPagerDTO) -- ^ "pager"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCampaignsResponse
instance A.FromJSON GetCampaignsResponse where
  parseJSON = A.withObject "GetCampaignsResponse" $ \o ->
    GetCampaignsResponse
      <$> (o .:  "campaigns")
      <*> (o .:? "pager")

-- | ToJSON GetCampaignsResponse
instance A.ToJSON GetCampaignsResponse where
  toJSON GetCampaignsResponse {..} =
   _omitNulls
      [ "campaigns" .= getCampaignsResponseCampaigns
      , "pager" .= getCampaignsResponsePager
      ]


-- | Construct a value of type 'GetCampaignsResponse' (by applying it's required fields, if any)
mkGetCampaignsResponse
  :: [CampaignDTO] -- ^ 'getCampaignsResponseCampaigns': Список с информацией по каждому магазину.
  -> GetCampaignsResponse
mkGetCampaignsResponse getCampaignsResponseCampaigns =
  GetCampaignsResponse
  { getCampaignsResponseCampaigns
  , getCampaignsResponsePager = Nothing
  }

-- ** GetCategoriesMaxSaleQuantumDTO
-- | GetCategoriesMaxSaleQuantumDTO
-- Категории и лимит на установку кванта и минимального количества товаров.
data GetCategoriesMaxSaleQuantumDTO = GetCategoriesMaxSaleQuantumDTO
  { getCategoriesMaxSaleQuantumDTOResults :: !([MaxSaleQuantumDTO]) -- ^ /Required/ "results" - Категории и лимит на установку кванта и минимального количества товаров.
  , getCategoriesMaxSaleQuantumDTOErrors :: !(Maybe [CategoryErrorDTO]) -- ^ "errors" - Ошибки, которые появились из-за переданных категорий.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCategoriesMaxSaleQuantumDTO
instance A.FromJSON GetCategoriesMaxSaleQuantumDTO where
  parseJSON = A.withObject "GetCategoriesMaxSaleQuantumDTO" $ \o ->
    GetCategoriesMaxSaleQuantumDTO
      <$> (o .:  "results")
      <*> (o .:? "errors")

-- | ToJSON GetCategoriesMaxSaleQuantumDTO
instance A.ToJSON GetCategoriesMaxSaleQuantumDTO where
  toJSON GetCategoriesMaxSaleQuantumDTO {..} =
   _omitNulls
      [ "results" .= getCategoriesMaxSaleQuantumDTOResults
      , "errors" .= getCategoriesMaxSaleQuantumDTOErrors
      ]


-- | Construct a value of type 'GetCategoriesMaxSaleQuantumDTO' (by applying it's required fields, if any)
mkGetCategoriesMaxSaleQuantumDTO
  :: [MaxSaleQuantumDTO] -- ^ 'getCategoriesMaxSaleQuantumDTOResults': Категории и лимит на установку кванта и минимального количества товаров.
  -> GetCategoriesMaxSaleQuantumDTO
mkGetCategoriesMaxSaleQuantumDTO getCategoriesMaxSaleQuantumDTOResults =
  GetCategoriesMaxSaleQuantumDTO
  { getCategoriesMaxSaleQuantumDTOResults
  , getCategoriesMaxSaleQuantumDTOErrors = Nothing
  }

-- ** GetCategoriesMaxSaleQuantumRequest
-- | GetCategoriesMaxSaleQuantumRequest
-- Список категорий, для которых нужно вернуть лимит на установку кванта и минимального количества товаров. 
data GetCategoriesMaxSaleQuantumRequest = GetCategoriesMaxSaleQuantumRequest
  { getCategoriesMaxSaleQuantumRequestMarketCategoryIds :: !([Integer]) -- ^ /Required/ "marketCategoryIds" - Идентификаторы листовых категории на Маркете — тех, у которых нет дочерних категорий.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCategoriesMaxSaleQuantumRequest
instance A.FromJSON GetCategoriesMaxSaleQuantumRequest where
  parseJSON = A.withObject "GetCategoriesMaxSaleQuantumRequest" $ \o ->
    GetCategoriesMaxSaleQuantumRequest
      <$> (o .:  "marketCategoryIds")

-- | ToJSON GetCategoriesMaxSaleQuantumRequest
instance A.ToJSON GetCategoriesMaxSaleQuantumRequest where
  toJSON GetCategoriesMaxSaleQuantumRequest {..} =
   _omitNulls
      [ "marketCategoryIds" .= getCategoriesMaxSaleQuantumRequestMarketCategoryIds
      ]


-- | Construct a value of type 'GetCategoriesMaxSaleQuantumRequest' (by applying it's required fields, if any)
mkGetCategoriesMaxSaleQuantumRequest
  :: [Integer] -- ^ 'getCategoriesMaxSaleQuantumRequestMarketCategoryIds': Идентификаторы листовых категории на Маркете — тех, у которых нет дочерних категорий.
  -> GetCategoriesMaxSaleQuantumRequest
mkGetCategoriesMaxSaleQuantumRequest getCategoriesMaxSaleQuantumRequestMarketCategoryIds =
  GetCategoriesMaxSaleQuantumRequest
  { getCategoriesMaxSaleQuantumRequestMarketCategoryIds
  }

-- ** GetCategoriesMaxSaleQuantumResponse
-- | GetCategoriesMaxSaleQuantumResponse
data GetCategoriesMaxSaleQuantumResponse = GetCategoriesMaxSaleQuantumResponse
  { getCategoriesMaxSaleQuantumResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getCategoriesMaxSaleQuantumResponseResults :: !([MaxSaleQuantumDTO]) -- ^ /Required/ "results" - Категории и лимит на установку кванта и минимального количества товаров.
  , getCategoriesMaxSaleQuantumResponseErrors :: !(Maybe [CategoryErrorDTO]) -- ^ "errors" - Ошибки, которые появились из-за переданных категорий.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCategoriesMaxSaleQuantumResponse
instance A.FromJSON GetCategoriesMaxSaleQuantumResponse where
  parseJSON = A.withObject "GetCategoriesMaxSaleQuantumResponse" $ \o ->
    GetCategoriesMaxSaleQuantumResponse
      <$> (o .:? "status")
      <*> (o .:  "results")
      <*> (o .:? "errors")

-- | ToJSON GetCategoriesMaxSaleQuantumResponse
instance A.ToJSON GetCategoriesMaxSaleQuantumResponse where
  toJSON GetCategoriesMaxSaleQuantumResponse {..} =
   _omitNulls
      [ "status" .= getCategoriesMaxSaleQuantumResponseStatus
      , "results" .= getCategoriesMaxSaleQuantumResponseResults
      , "errors" .= getCategoriesMaxSaleQuantumResponseErrors
      ]


-- | Construct a value of type 'GetCategoriesMaxSaleQuantumResponse' (by applying it's required fields, if any)
mkGetCategoriesMaxSaleQuantumResponse
  :: [MaxSaleQuantumDTO] -- ^ 'getCategoriesMaxSaleQuantumResponseResults': Категории и лимит на установку кванта и минимального количества товаров.
  -> GetCategoriesMaxSaleQuantumResponse
mkGetCategoriesMaxSaleQuantumResponse getCategoriesMaxSaleQuantumResponseResults =
  GetCategoriesMaxSaleQuantumResponse
  { getCategoriesMaxSaleQuantumResponseStatus = Nothing
  , getCategoriesMaxSaleQuantumResponseResults
  , getCategoriesMaxSaleQuantumResponseErrors = Nothing
  }

-- ** GetCategoriesRequest
-- | GetCategoriesRequest
-- Параметры запроса категорий. 
data GetCategoriesRequest = GetCategoriesRequest
  { getCategoriesRequestLanguage :: !(Maybe LanguageType) -- ^ "language"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCategoriesRequest
instance A.FromJSON GetCategoriesRequest where
  parseJSON = A.withObject "GetCategoriesRequest" $ \o ->
    GetCategoriesRequest
      <$> (o .:? "language")

-- | ToJSON GetCategoriesRequest
instance A.ToJSON GetCategoriesRequest where
  toJSON GetCategoriesRequest {..} =
   _omitNulls
      [ "language" .= getCategoriesRequestLanguage
      ]


-- | Construct a value of type 'GetCategoriesRequest' (by applying it's required fields, if any)
mkGetCategoriesRequest
  :: GetCategoriesRequest
mkGetCategoriesRequest =
  GetCategoriesRequest
  { getCategoriesRequestLanguage = Nothing
  }

-- ** GetCategoriesResponse
-- | GetCategoriesResponse
data GetCategoriesResponse = GetCategoriesResponse
  { getCategoriesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getCategoriesResponseResult :: !(Maybe CategoryDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCategoriesResponse
instance A.FromJSON GetCategoriesResponse where
  parseJSON = A.withObject "GetCategoriesResponse" $ \o ->
    GetCategoriesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetCategoriesResponse
instance A.ToJSON GetCategoriesResponse where
  toJSON GetCategoriesResponse {..} =
   _omitNulls
      [ "status" .= getCategoriesResponseStatus
      , "result" .= getCategoriesResponseResult
      ]


-- | Construct a value of type 'GetCategoriesResponse' (by applying it's required fields, if any)
mkGetCategoriesResponse
  :: GetCategoriesResponse
mkGetCategoriesResponse =
  GetCategoriesResponse
  { getCategoriesResponseStatus = Nothing
  , getCategoriesResponseResult = Nothing
  }

-- ** GetCategoryContentParametersResponse
-- | GetCategoryContentParametersResponse
-- Ответ со списком характеристик для категории и их допустимыми значениями.
data GetCategoryContentParametersResponse = GetCategoryContentParametersResponse
  { getCategoryContentParametersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getCategoryContentParametersResponseResult :: !(Maybe CategoryContentParametersDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCategoryContentParametersResponse
instance A.FromJSON GetCategoryContentParametersResponse where
  parseJSON = A.withObject "GetCategoryContentParametersResponse" $ \o ->
    GetCategoryContentParametersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetCategoryContentParametersResponse
instance A.ToJSON GetCategoryContentParametersResponse where
  toJSON GetCategoryContentParametersResponse {..} =
   _omitNulls
      [ "status" .= getCategoryContentParametersResponseStatus
      , "result" .= getCategoryContentParametersResponseResult
      ]


-- | Construct a value of type 'GetCategoryContentParametersResponse' (by applying it's required fields, if any)
mkGetCategoryContentParametersResponse
  :: GetCategoryContentParametersResponse
mkGetCategoryContentParametersResponse =
  GetCategoryContentParametersResponse
  { getCategoryContentParametersResponseStatus = Nothing
  , getCategoryContentParametersResponseResult = Nothing
  }

-- ** GetChatHistoryRequest
-- | GetChatHistoryRequest
-- Историю какого чата нужно получить — и начиная с какого сообщения. 
data GetChatHistoryRequest = GetChatHistoryRequest
  { getChatHistoryRequestMessageIdFrom :: !(Maybe Integer) -- ^ "messageIdFrom" - Идентификатор сообщения, начиная с которого нужно получить все последующие сообщения.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChatHistoryRequest
instance A.FromJSON GetChatHistoryRequest where
  parseJSON = A.withObject "GetChatHistoryRequest" $ \o ->
    GetChatHistoryRequest
      <$> (o .:? "messageIdFrom")

-- | ToJSON GetChatHistoryRequest
instance A.ToJSON GetChatHistoryRequest where
  toJSON GetChatHistoryRequest {..} =
   _omitNulls
      [ "messageIdFrom" .= getChatHistoryRequestMessageIdFrom
      ]


-- | Construct a value of type 'GetChatHistoryRequest' (by applying it's required fields, if any)
mkGetChatHistoryRequest
  :: GetChatHistoryRequest
mkGetChatHistoryRequest =
  GetChatHistoryRequest
  { getChatHistoryRequestMessageIdFrom = Nothing
  }

-- ** GetChatHistoryResponse
-- | GetChatHistoryResponse
data GetChatHistoryResponse = GetChatHistoryResponse
  { getChatHistoryResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getChatHistoryResponseResult :: !(Maybe ChatMessagesResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChatHistoryResponse
instance A.FromJSON GetChatHistoryResponse where
  parseJSON = A.withObject "GetChatHistoryResponse" $ \o ->
    GetChatHistoryResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetChatHistoryResponse
instance A.ToJSON GetChatHistoryResponse where
  toJSON GetChatHistoryResponse {..} =
   _omitNulls
      [ "status" .= getChatHistoryResponseStatus
      , "result" .= getChatHistoryResponseResult
      ]


-- | Construct a value of type 'GetChatHistoryResponse' (by applying it's required fields, if any)
mkGetChatHistoryResponse
  :: GetChatHistoryResponse
mkGetChatHistoryResponse =
  GetChatHistoryResponse
  { getChatHistoryResponseStatus = Nothing
  , getChatHistoryResponseResult = Nothing
  }

-- ** GetChatInfoDTO
-- | GetChatInfoDTO
-- Информация о чатах.
data GetChatInfoDTO = GetChatInfoDTO
  { getChatInfoDTOChatId :: !(Integer) -- ^ /Required/ "chatId" - Идентификатор чата.
  , getChatInfoDTOOrderId :: !(Integer) -- ^ /Required/ "orderId" - Идентификатор заказа.
  , getChatInfoDTOType :: !(ChatType) -- ^ /Required/ "type"
  , getChatInfoDTOStatus :: !(ChatStatusType) -- ^ /Required/ "status"
  , getChatInfoDTOCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Дата и время создания чата.  Формат даты: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:00:00+03:00&#x60;. 
  , getChatInfoDTOUpdatedAt :: !(DateTime) -- ^ /Required/ "updatedAt" - Дата и время последнего сообщения в чате.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChatInfoDTO
instance A.FromJSON GetChatInfoDTO where
  parseJSON = A.withObject "GetChatInfoDTO" $ \o ->
    GetChatInfoDTO
      <$> (o .:  "chatId")
      <*> (o .:  "orderId")
      <*> (o .:  "type")
      <*> (o .:  "status")
      <*> (o .:  "createdAt")
      <*> (o .:  "updatedAt")

-- | ToJSON GetChatInfoDTO
instance A.ToJSON GetChatInfoDTO where
  toJSON GetChatInfoDTO {..} =
   _omitNulls
      [ "chatId" .= getChatInfoDTOChatId
      , "orderId" .= getChatInfoDTOOrderId
      , "type" .= getChatInfoDTOType
      , "status" .= getChatInfoDTOStatus
      , "createdAt" .= getChatInfoDTOCreatedAt
      , "updatedAt" .= getChatInfoDTOUpdatedAt
      ]


-- | Construct a value of type 'GetChatInfoDTO' (by applying it's required fields, if any)
mkGetChatInfoDTO
  :: Integer -- ^ 'getChatInfoDTOChatId': Идентификатор чата.
  -> Integer -- ^ 'getChatInfoDTOOrderId': Идентификатор заказа.
  -> ChatType -- ^ 'getChatInfoDTOType' 
  -> ChatStatusType -- ^ 'getChatInfoDTOStatus' 
  -> DateTime -- ^ 'getChatInfoDTOCreatedAt': Дата и время создания чата.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
  -> DateTime -- ^ 'getChatInfoDTOUpdatedAt': Дата и время последнего сообщения в чате.
  -> GetChatInfoDTO
mkGetChatInfoDTO getChatInfoDTOChatId getChatInfoDTOOrderId getChatInfoDTOType getChatInfoDTOStatus getChatInfoDTOCreatedAt getChatInfoDTOUpdatedAt =
  GetChatInfoDTO
  { getChatInfoDTOChatId
  , getChatInfoDTOOrderId
  , getChatInfoDTOType
  , getChatInfoDTOStatus
  , getChatInfoDTOCreatedAt
  , getChatInfoDTOUpdatedAt
  }

-- ** GetChatsInfoDTO
-- | GetChatsInfoDTO
-- Список чатов.
data GetChatsInfoDTO = GetChatsInfoDTO
  { getChatsInfoDTOChats :: !([GetChatInfoDTO]) -- ^ /Required/ "chats" - Информация о чатах.
  , getChatsInfoDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChatsInfoDTO
instance A.FromJSON GetChatsInfoDTO where
  parseJSON = A.withObject "GetChatsInfoDTO" $ \o ->
    GetChatsInfoDTO
      <$> (o .:  "chats")
      <*> (o .:? "paging")

-- | ToJSON GetChatsInfoDTO
instance A.ToJSON GetChatsInfoDTO where
  toJSON GetChatsInfoDTO {..} =
   _omitNulls
      [ "chats" .= getChatsInfoDTOChats
      , "paging" .= getChatsInfoDTOPaging
      ]


-- | Construct a value of type 'GetChatsInfoDTO' (by applying it's required fields, if any)
mkGetChatsInfoDTO
  :: [GetChatInfoDTO] -- ^ 'getChatsInfoDTOChats': Информация о чатах.
  -> GetChatsInfoDTO
mkGetChatsInfoDTO getChatsInfoDTOChats =
  GetChatsInfoDTO
  { getChatsInfoDTOChats
  , getChatsInfoDTOPaging = Nothing
  }

-- ** GetChatsRequest
-- | GetChatsRequest
-- Фильтры по чатам, которые нужно вернуть. 
data GetChatsRequest = GetChatsRequest
  { getChatsRequestOrderIds :: !(Maybe [Integer]) -- ^ "orderIds" - Фильтр по идентификаторам заказов на Маркете.
  , getChatsRequestTypes :: !(Maybe [ChatType]) -- ^ "types" - Фильтр по типам чатов.
  , getChatsRequestStatuses :: !(Maybe [ChatStatusType]) -- ^ "statuses" - Фильтр по статусам чатов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChatsRequest
instance A.FromJSON GetChatsRequest where
  parseJSON = A.withObject "GetChatsRequest" $ \o ->
    GetChatsRequest
      <$> (o .:? "orderIds")
      <*> (o .:? "types")
      <*> (o .:? "statuses")

-- | ToJSON GetChatsRequest
instance A.ToJSON GetChatsRequest where
  toJSON GetChatsRequest {..} =
   _omitNulls
      [ "orderIds" .= getChatsRequestOrderIds
      , "types" .= getChatsRequestTypes
      , "statuses" .= getChatsRequestStatuses
      ]


-- | Construct a value of type 'GetChatsRequest' (by applying it's required fields, if any)
mkGetChatsRequest
  :: GetChatsRequest
mkGetChatsRequest =
  GetChatsRequest
  { getChatsRequestOrderIds = Nothing
  , getChatsRequestTypes = Nothing
  , getChatsRequestStatuses = Nothing
  }

-- ** GetChatsResponse
-- | GetChatsResponse
data GetChatsResponse = GetChatsResponse
  { getChatsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getChatsResponseResult :: !(Maybe GetChatsInfoDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetChatsResponse
instance A.FromJSON GetChatsResponse where
  parseJSON = A.withObject "GetChatsResponse" $ \o ->
    GetChatsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetChatsResponse
instance A.ToJSON GetChatsResponse where
  toJSON GetChatsResponse {..} =
   _omitNulls
      [ "status" .= getChatsResponseStatus
      , "result" .= getChatsResponseResult
      ]


-- | Construct a value of type 'GetChatsResponse' (by applying it's required fields, if any)
mkGetChatsResponse
  :: GetChatsResponse
mkGetChatsResponse =
  GetChatsResponse
  { getChatsResponseStatus = Nothing
  , getChatsResponseResult = Nothing
  }

-- ** GetDeliveryServicesResponse
-- | GetDeliveryServicesResponse
-- Ответ на запрос списка служб доставки.
data GetDeliveryServicesResponse = GetDeliveryServicesResponse
  { getDeliveryServicesResponseResult :: !(Maybe DeliveryServicesDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetDeliveryServicesResponse
instance A.FromJSON GetDeliveryServicesResponse where
  parseJSON = A.withObject "GetDeliveryServicesResponse" $ \o ->
    GetDeliveryServicesResponse
      <$> (o .:? "result")

-- | ToJSON GetDeliveryServicesResponse
instance A.ToJSON GetDeliveryServicesResponse where
  toJSON GetDeliveryServicesResponse {..} =
   _omitNulls
      [ "result" .= getDeliveryServicesResponseResult
      ]


-- | Construct a value of type 'GetDeliveryServicesResponse' (by applying it's required fields, if any)
mkGetDeliveryServicesResponse
  :: GetDeliveryServicesResponse
mkGetDeliveryServicesResponse =
  GetDeliveryServicesResponse
  { getDeliveryServicesResponseResult = Nothing
  }

-- ** GetFeedIndexLogsResponse
-- | GetFeedIndexLogsResponse
data GetFeedIndexLogsResponse = GetFeedIndexLogsResponse
  { getFeedIndexLogsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getFeedIndexLogsResponseResult :: !(Maybe FeedIndexLogsResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetFeedIndexLogsResponse
instance A.FromJSON GetFeedIndexLogsResponse where
  parseJSON = A.withObject "GetFeedIndexLogsResponse" $ \o ->
    GetFeedIndexLogsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetFeedIndexLogsResponse
instance A.ToJSON GetFeedIndexLogsResponse where
  toJSON GetFeedIndexLogsResponse {..} =
   _omitNulls
      [ "status" .= getFeedIndexLogsResponseStatus
      , "result" .= getFeedIndexLogsResponseResult
      ]


-- | Construct a value of type 'GetFeedIndexLogsResponse' (by applying it's required fields, if any)
mkGetFeedIndexLogsResponse
  :: GetFeedIndexLogsResponse
mkGetFeedIndexLogsResponse =
  GetFeedIndexLogsResponse
  { getFeedIndexLogsResponseStatus = Nothing
  , getFeedIndexLogsResponseResult = Nothing
  }

-- ** GetFeedResponse
-- | GetFeedResponse
-- Ответ на запрос информации о прайс-листе.
data GetFeedResponse = GetFeedResponse
  { getFeedResponseFeed :: !(Maybe FeedDTO) -- ^ "feed"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetFeedResponse
instance A.FromJSON GetFeedResponse where
  parseJSON = A.withObject "GetFeedResponse" $ \o ->
    GetFeedResponse
      <$> (o .:? "feed")

-- | ToJSON GetFeedResponse
instance A.ToJSON GetFeedResponse where
  toJSON GetFeedResponse {..} =
   _omitNulls
      [ "feed" .= getFeedResponseFeed
      ]


-- | Construct a value of type 'GetFeedResponse' (by applying it's required fields, if any)
mkGetFeedResponse
  :: GetFeedResponse
mkGetFeedResponse =
  GetFeedResponse
  { getFeedResponseFeed = Nothing
  }

-- ** GetFeedbackListResponse
-- | GetFeedbackListResponse
data GetFeedbackListResponse = GetFeedbackListResponse
  { getFeedbackListResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getFeedbackListResponseResult :: !(Maybe FeedbackListDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetFeedbackListResponse
instance A.FromJSON GetFeedbackListResponse where
  parseJSON = A.withObject "GetFeedbackListResponse" $ \o ->
    GetFeedbackListResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetFeedbackListResponse
instance A.ToJSON GetFeedbackListResponse where
  toJSON GetFeedbackListResponse {..} =
   _omitNulls
      [ "status" .= getFeedbackListResponseStatus
      , "result" .= getFeedbackListResponseResult
      ]


-- | Construct a value of type 'GetFeedbackListResponse' (by applying it's required fields, if any)
mkGetFeedbackListResponse
  :: GetFeedbackListResponse
mkGetFeedbackListResponse =
  GetFeedbackListResponse
  { getFeedbackListResponseStatus = Nothing
  , getFeedbackListResponseResult = Nothing
  }

-- ** GetFeedsResponse
-- | GetFeedsResponse
-- Ответ на запрос списка прайс-листов.
data GetFeedsResponse = GetFeedsResponse
  { getFeedsResponseFeeds :: !([FeedDTO]) -- ^ /Required/ "feeds" - Список прайс-листов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetFeedsResponse
instance A.FromJSON GetFeedsResponse where
  parseJSON = A.withObject "GetFeedsResponse" $ \o ->
    GetFeedsResponse
      <$> (o .:  "feeds")

-- | ToJSON GetFeedsResponse
instance A.ToJSON GetFeedsResponse where
  toJSON GetFeedsResponse {..} =
   _omitNulls
      [ "feeds" .= getFeedsResponseFeeds
      ]


-- | Construct a value of type 'GetFeedsResponse' (by applying it's required fields, if any)
mkGetFeedsResponse
  :: [FeedDTO] -- ^ 'getFeedsResponseFeeds': Список прайс-листов.
  -> GetFeedsResponse
mkGetFeedsResponse getFeedsResponseFeeds =
  GetFeedsResponse
  { getFeedsResponseFeeds
  }

-- ** GetFulfillmentWarehousesResponse
-- | GetFulfillmentWarehousesResponse
data GetFulfillmentWarehousesResponse = GetFulfillmentWarehousesResponse
  { getFulfillmentWarehousesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getFulfillmentWarehousesResponseResult :: !(Maybe FulfillmentWarehousesDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetFulfillmentWarehousesResponse
instance A.FromJSON GetFulfillmentWarehousesResponse where
  parseJSON = A.withObject "GetFulfillmentWarehousesResponse" $ \o ->
    GetFulfillmentWarehousesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetFulfillmentWarehousesResponse
instance A.ToJSON GetFulfillmentWarehousesResponse where
  toJSON GetFulfillmentWarehousesResponse {..} =
   _omitNulls
      [ "status" .= getFulfillmentWarehousesResponseStatus
      , "result" .= getFulfillmentWarehousesResponseResult
      ]


-- | Construct a value of type 'GetFulfillmentWarehousesResponse' (by applying it's required fields, if any)
mkGetFulfillmentWarehousesResponse
  :: GetFulfillmentWarehousesResponse
mkGetFulfillmentWarehousesResponse =
  GetFulfillmentWarehousesResponse
  { getFulfillmentWarehousesResponseStatus = Nothing
  , getFulfillmentWarehousesResponseResult = Nothing
  }

-- ** GetGoodsFeedbackCommentsRequest
-- | GetGoodsFeedbackCommentsRequest
-- Фильтр запроса комментариев отзыва. 
data GetGoodsFeedbackCommentsRequest = GetGoodsFeedbackCommentsRequest
  { getGoodsFeedbackCommentsRequestFeedbackId :: !(Integer) -- ^ /Required/ "feedbackId" - Идентификатор отзыва. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetGoodsFeedbackCommentsRequest
instance A.FromJSON GetGoodsFeedbackCommentsRequest where
  parseJSON = A.withObject "GetGoodsFeedbackCommentsRequest" $ \o ->
    GetGoodsFeedbackCommentsRequest
      <$> (o .:  "feedbackId")

-- | ToJSON GetGoodsFeedbackCommentsRequest
instance A.ToJSON GetGoodsFeedbackCommentsRequest where
  toJSON GetGoodsFeedbackCommentsRequest {..} =
   _omitNulls
      [ "feedbackId" .= getGoodsFeedbackCommentsRequestFeedbackId
      ]


-- | Construct a value of type 'GetGoodsFeedbackCommentsRequest' (by applying it's required fields, if any)
mkGetGoodsFeedbackCommentsRequest
  :: Integer -- ^ 'getGoodsFeedbackCommentsRequestFeedbackId': Идентификатор отзыва. 
  -> GetGoodsFeedbackCommentsRequest
mkGetGoodsFeedbackCommentsRequest getGoodsFeedbackCommentsRequestFeedbackId =
  GetGoodsFeedbackCommentsRequest
  { getGoodsFeedbackCommentsRequestFeedbackId
  }

-- ** GetGoodsFeedbackCommentsResponse
-- | GetGoodsFeedbackCommentsResponse
data GetGoodsFeedbackCommentsResponse = GetGoodsFeedbackCommentsResponse
  { getGoodsFeedbackCommentsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getGoodsFeedbackCommentsResponseResult :: !(Maybe GoodsFeedbackCommentListDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetGoodsFeedbackCommentsResponse
instance A.FromJSON GetGoodsFeedbackCommentsResponse where
  parseJSON = A.withObject "GetGoodsFeedbackCommentsResponse" $ \o ->
    GetGoodsFeedbackCommentsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetGoodsFeedbackCommentsResponse
instance A.ToJSON GetGoodsFeedbackCommentsResponse where
  toJSON GetGoodsFeedbackCommentsResponse {..} =
   _omitNulls
      [ "status" .= getGoodsFeedbackCommentsResponseStatus
      , "result" .= getGoodsFeedbackCommentsResponseResult
      ]


-- | Construct a value of type 'GetGoodsFeedbackCommentsResponse' (by applying it's required fields, if any)
mkGetGoodsFeedbackCommentsResponse
  :: GetGoodsFeedbackCommentsResponse
mkGetGoodsFeedbackCommentsResponse =
  GetGoodsFeedbackCommentsResponse
  { getGoodsFeedbackCommentsResponseStatus = Nothing
  , getGoodsFeedbackCommentsResponseResult = Nothing
  }

-- ** GetGoodsFeedbackRequest
-- | GetGoodsFeedbackRequest
-- Фильтр запроса отзывов в кабинете. 
data GetGoodsFeedbackRequest = GetGoodsFeedbackRequest
  { getGoodsFeedbackRequestDateTimeFrom :: !(Maybe DateTime) -- ^ "dateTimeFrom" - Начало периода. Не включительно.  Если параметр не указан, возвращается информация за 6 месяцев до указанной в &#x60;dateTimeTo&#x60; даты. 
  , getGoodsFeedbackRequestDateTimeTo :: !(Maybe DateTime) -- ^ "dateTimeTo" - Конец периода. Не включительно.  Если параметр не указан, используется текущая дата. 
  , getGoodsFeedbackRequestReactionStatus :: !(Maybe FeedbackReactionStatusType) -- ^ "reactionStatus"
  , getGoodsFeedbackRequestRatingValues :: !(Maybe [Int]) -- ^ "ratingValues" - Оценка товара.
  , getGoodsFeedbackRequestModelIds :: !(Maybe [Integer]) -- ^ "modelIds" - Фильтр по идентификатору модели товара.  Получить идентификатор модели можно с помощью одного из запросов:  * [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md);  * [POST businesses/{businessId}/offer-cards](../../reference/content/getOfferCardsContentStatus.md);  * [POST models](../../reference/models/getModels.md). 
  , getGoodsFeedbackRequestPaid :: !(Maybe Bool) -- ^ "paid" - Фильтр отзывов за баллы Плюса.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetGoodsFeedbackRequest
instance A.FromJSON GetGoodsFeedbackRequest where
  parseJSON = A.withObject "GetGoodsFeedbackRequest" $ \o ->
    GetGoodsFeedbackRequest
      <$> (o .:? "dateTimeFrom")
      <*> (o .:? "dateTimeTo")
      <*> (o .:? "reactionStatus")
      <*> (o .:? "ratingValues")
      <*> (o .:? "modelIds")
      <*> (o .:? "paid")

-- | ToJSON GetGoodsFeedbackRequest
instance A.ToJSON GetGoodsFeedbackRequest where
  toJSON GetGoodsFeedbackRequest {..} =
   _omitNulls
      [ "dateTimeFrom" .= getGoodsFeedbackRequestDateTimeFrom
      , "dateTimeTo" .= getGoodsFeedbackRequestDateTimeTo
      , "reactionStatus" .= getGoodsFeedbackRequestReactionStatus
      , "ratingValues" .= getGoodsFeedbackRequestRatingValues
      , "modelIds" .= getGoodsFeedbackRequestModelIds
      , "paid" .= getGoodsFeedbackRequestPaid
      ]


-- | Construct a value of type 'GetGoodsFeedbackRequest' (by applying it's required fields, if any)
mkGetGoodsFeedbackRequest
  :: GetGoodsFeedbackRequest
mkGetGoodsFeedbackRequest =
  GetGoodsFeedbackRequest
  { getGoodsFeedbackRequestDateTimeFrom = Nothing
  , getGoodsFeedbackRequestDateTimeTo = Nothing
  , getGoodsFeedbackRequestReactionStatus = Nothing
  , getGoodsFeedbackRequestRatingValues = Nothing
  , getGoodsFeedbackRequestModelIds = Nothing
  , getGoodsFeedbackRequestPaid = Nothing
  }

-- ** GetGoodsFeedbackResponse
-- | GetGoodsFeedbackResponse
data GetGoodsFeedbackResponse = GetGoodsFeedbackResponse
  { getGoodsFeedbackResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getGoodsFeedbackResponseResult :: !(Maybe GoodsFeedbackListDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetGoodsFeedbackResponse
instance A.FromJSON GetGoodsFeedbackResponse where
  parseJSON = A.withObject "GetGoodsFeedbackResponse" $ \o ->
    GetGoodsFeedbackResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetGoodsFeedbackResponse
instance A.ToJSON GetGoodsFeedbackResponse where
  toJSON GetGoodsFeedbackResponse {..} =
   _omitNulls
      [ "status" .= getGoodsFeedbackResponseStatus
      , "result" .= getGoodsFeedbackResponseResult
      ]


-- | Construct a value of type 'GetGoodsFeedbackResponse' (by applying it's required fields, if any)
mkGetGoodsFeedbackResponse
  :: GetGoodsFeedbackResponse
mkGetGoodsFeedbackResponse =
  GetGoodsFeedbackResponse
  { getGoodsFeedbackResponseStatus = Nothing
  , getGoodsFeedbackResponseResult = Nothing
  }

-- ** GetGoodsStatsRequest
-- | GetGoodsStatsRequest
-- Запрос отчета по товарам.
data GetGoodsStatsRequest = GetGoodsStatsRequest
  { getGoodsStatsRequestShopSkus :: !([Text]) -- ^ /Required/ "shopSkus" - Список ваших идентификаторов SKU. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetGoodsStatsRequest
instance A.FromJSON GetGoodsStatsRequest where
  parseJSON = A.withObject "GetGoodsStatsRequest" $ \o ->
    GetGoodsStatsRequest
      <$> (o .:  "shopSkus")

-- | ToJSON GetGoodsStatsRequest
instance A.ToJSON GetGoodsStatsRequest where
  toJSON GetGoodsStatsRequest {..} =
   _omitNulls
      [ "shopSkus" .= getGoodsStatsRequestShopSkus
      ]


-- | Construct a value of type 'GetGoodsStatsRequest' (by applying it's required fields, if any)
mkGetGoodsStatsRequest
  :: [Text] -- ^ 'getGoodsStatsRequestShopSkus': Список ваших идентификаторов SKU. 
  -> GetGoodsStatsRequest
mkGetGoodsStatsRequest getGoodsStatsRequestShopSkus =
  GetGoodsStatsRequest
  { getGoodsStatsRequestShopSkus
  }

-- ** GetGoodsStatsResponse
-- | GetGoodsStatsResponse
-- Ответ на запрос отчета по товарам.
data GetGoodsStatsResponse = GetGoodsStatsResponse
  { getGoodsStatsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getGoodsStatsResponseResult :: !(Maybe GoodsStatsDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetGoodsStatsResponse
instance A.FromJSON GetGoodsStatsResponse where
  parseJSON = A.withObject "GetGoodsStatsResponse" $ \o ->
    GetGoodsStatsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetGoodsStatsResponse
instance A.ToJSON GetGoodsStatsResponse where
  toJSON GetGoodsStatsResponse {..} =
   _omitNulls
      [ "status" .= getGoodsStatsResponseStatus
      , "result" .= getGoodsStatsResponseResult
      ]


-- | Construct a value of type 'GetGoodsStatsResponse' (by applying it's required fields, if any)
mkGetGoodsStatsResponse
  :: GetGoodsStatsResponse
mkGetGoodsStatsResponse =
  GetGoodsStatsResponse
  { getGoodsStatsResponseStatus = Nothing
  , getGoodsStatsResponseResult = Nothing
  }

-- ** GetHiddenOffersResponse
-- | GetHiddenOffersResponse
-- Ответ на запрос списка скрытий.
data GetHiddenOffersResponse = GetHiddenOffersResponse
  { getHiddenOffersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getHiddenOffersResponseResult :: !(Maybe GetHiddenOffersResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetHiddenOffersResponse
instance A.FromJSON GetHiddenOffersResponse where
  parseJSON = A.withObject "GetHiddenOffersResponse" $ \o ->
    GetHiddenOffersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetHiddenOffersResponse
instance A.ToJSON GetHiddenOffersResponse where
  toJSON GetHiddenOffersResponse {..} =
   _omitNulls
      [ "status" .= getHiddenOffersResponseStatus
      , "result" .= getHiddenOffersResponseResult
      ]


-- | Construct a value of type 'GetHiddenOffersResponse' (by applying it's required fields, if any)
mkGetHiddenOffersResponse
  :: GetHiddenOffersResponse
mkGetHiddenOffersResponse =
  GetHiddenOffersResponse
  { getHiddenOffersResponseStatus = Nothing
  , getHiddenOffersResponseResult = Nothing
  }

-- ** GetHiddenOffersResultDTO
-- | GetHiddenOffersResultDTO
-- Список скрытых вами товаров. 
data GetHiddenOffersResultDTO = GetHiddenOffersResultDTO
  { getHiddenOffersResultDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , getHiddenOffersResultDTOHiddenOffers :: !([HiddenOfferDTO]) -- ^ /Required/ "hiddenOffers" - Список скрытых товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetHiddenOffersResultDTO
instance A.FromJSON GetHiddenOffersResultDTO where
  parseJSON = A.withObject "GetHiddenOffersResultDTO" $ \o ->
    GetHiddenOffersResultDTO
      <$> (o .:? "paging")
      <*> (o .:  "hiddenOffers")

-- | ToJSON GetHiddenOffersResultDTO
instance A.ToJSON GetHiddenOffersResultDTO where
  toJSON GetHiddenOffersResultDTO {..} =
   _omitNulls
      [ "paging" .= getHiddenOffersResultDTOPaging
      , "hiddenOffers" .= getHiddenOffersResultDTOHiddenOffers
      ]


-- | Construct a value of type 'GetHiddenOffersResultDTO' (by applying it's required fields, if any)
mkGetHiddenOffersResultDTO
  :: [HiddenOfferDTO] -- ^ 'getHiddenOffersResultDTOHiddenOffers': Список скрытых товаров.
  -> GetHiddenOffersResultDTO
mkGetHiddenOffersResultDTO getHiddenOffersResultDTOHiddenOffers =
  GetHiddenOffersResultDTO
  { getHiddenOffersResultDTOPaging = Nothing
  , getHiddenOffersResultDTOHiddenOffers
  }

-- ** GetMappingDTO
-- | GetMappingDTO
-- Информация о товарах в каталоге. 
data GetMappingDTO = GetMappingDTO
  { getMappingDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  , getMappingDTOMarketSkuName :: !(Maybe Text) -- ^ "marketSkuName" - Название карточки товара.  Может отсутствовать в ответе, если товар еще не привязан к карточке. 
  , getMappingDTOMarketModelId :: !(Maybe Integer) -- ^ "marketModelId" - Идентификатор модели на Маркете.  Может отсутствовать в ответе, если товар еще не привязан к карточке. 
  , getMappingDTOMarketModelName :: !(Maybe Text) -- ^ "marketModelName" - Название модели на Маркете.  Может отсутствовать в ответе, если товар еще не привязан к карточке. 
  , getMappingDTOMarketCategoryId :: !(Maybe Integer) -- ^ "marketCategoryId" - Идентификатор категории на Маркете, в которую попал товар.  Может отсутствовать в ответе, если Маркет еще не определил категорию товара. 
  , getMappingDTOMarketCategoryName :: !(Maybe Text) -- ^ "marketCategoryName" - Название категории карточки на Маркете.  Может отсутствовать в ответе, если Маркет еще не определил категорию товара. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMappingDTO
instance A.FromJSON GetMappingDTO where
  parseJSON = A.withObject "GetMappingDTO" $ \o ->
    GetMappingDTO
      <$> (o .:? "marketSku")
      <*> (o .:? "marketSkuName")
      <*> (o .:? "marketModelId")
      <*> (o .:? "marketModelName")
      <*> (o .:? "marketCategoryId")
      <*> (o .:? "marketCategoryName")

-- | ToJSON GetMappingDTO
instance A.ToJSON GetMappingDTO where
  toJSON GetMappingDTO {..} =
   _omitNulls
      [ "marketSku" .= getMappingDTOMarketSku
      , "marketSkuName" .= getMappingDTOMarketSkuName
      , "marketModelId" .= getMappingDTOMarketModelId
      , "marketModelName" .= getMappingDTOMarketModelName
      , "marketCategoryId" .= getMappingDTOMarketCategoryId
      , "marketCategoryName" .= getMappingDTOMarketCategoryName
      ]


-- | Construct a value of type 'GetMappingDTO' (by applying it's required fields, if any)
mkGetMappingDTO
  :: GetMappingDTO
mkGetMappingDTO =
  GetMappingDTO
  { getMappingDTOMarketSku = Nothing
  , getMappingDTOMarketSkuName = Nothing
  , getMappingDTOMarketModelId = Nothing
  , getMappingDTOMarketModelName = Nothing
  , getMappingDTOMarketCategoryId = Nothing
  , getMappingDTOMarketCategoryName = Nothing
  }

-- ** GetModelsOffersResponse
-- | GetModelsOffersResponse
-- Ответ на запрос списка предложений для моделей.
data GetModelsOffersResponse = GetModelsOffersResponse
  { getModelsOffersResponseModels :: !([EnrichedModelDTO]) -- ^ /Required/ "models" - Список моделей товаров.
  , getModelsOffersResponseCurrency :: !(Maybe CurrencyType) -- ^ "currency"
  , getModelsOffersResponseRegionId :: !(Maybe Integer) -- ^ "regionId" - Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetModelsOffersResponse
instance A.FromJSON GetModelsOffersResponse where
  parseJSON = A.withObject "GetModelsOffersResponse" $ \o ->
    GetModelsOffersResponse
      <$> (o .:  "models")
      <*> (o .:? "currency")
      <*> (o .:? "regionId")

-- | ToJSON GetModelsOffersResponse
instance A.ToJSON GetModelsOffersResponse where
  toJSON GetModelsOffersResponse {..} =
   _omitNulls
      [ "models" .= getModelsOffersResponseModels
      , "currency" .= getModelsOffersResponseCurrency
      , "regionId" .= getModelsOffersResponseRegionId
      ]


-- | Construct a value of type 'GetModelsOffersResponse' (by applying it's required fields, if any)
mkGetModelsOffersResponse
  :: [EnrichedModelDTO] -- ^ 'getModelsOffersResponseModels': Список моделей товаров.
  -> GetModelsOffersResponse
mkGetModelsOffersResponse getModelsOffersResponseModels =
  GetModelsOffersResponse
  { getModelsOffersResponseModels
  , getModelsOffersResponseCurrency = Nothing
  , getModelsOffersResponseRegionId = Nothing
  }

-- ** GetModelsRequest
-- | GetModelsRequest
-- Запрос информации о моделях.
data GetModelsRequest = GetModelsRequest
  { getModelsRequestModels :: !([Integer]) -- ^ /Required/ "models" - Список моделей.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetModelsRequest
instance A.FromJSON GetModelsRequest where
  parseJSON = A.withObject "GetModelsRequest" $ \o ->
    GetModelsRequest
      <$> (o .:  "models")

-- | ToJSON GetModelsRequest
instance A.ToJSON GetModelsRequest where
  toJSON GetModelsRequest {..} =
   _omitNulls
      [ "models" .= getModelsRequestModels
      ]


-- | Construct a value of type 'GetModelsRequest' (by applying it's required fields, if any)
mkGetModelsRequest
  :: [Integer] -- ^ 'getModelsRequestModels': Список моделей.
  -> GetModelsRequest
mkGetModelsRequest getModelsRequestModels =
  GetModelsRequest
  { getModelsRequestModels
  }

-- ** GetModelsResponse
-- | GetModelsResponse
-- Ответ на запрос информации о моделях.
data GetModelsResponse = GetModelsResponse
  { getModelsResponseModels :: !([ModelDTO]) -- ^ /Required/ "models" - Список моделей товаров.
  , getModelsResponseCurrency :: !(Maybe CurrencyType) -- ^ "currency"
  , getModelsResponseRegionId :: !(Maybe Integer) -- ^ "regionId" - Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetModelsResponse
instance A.FromJSON GetModelsResponse where
  parseJSON = A.withObject "GetModelsResponse" $ \o ->
    GetModelsResponse
      <$> (o .:  "models")
      <*> (o .:? "currency")
      <*> (o .:? "regionId")

-- | ToJSON GetModelsResponse
instance A.ToJSON GetModelsResponse where
  toJSON GetModelsResponse {..} =
   _omitNulls
      [ "models" .= getModelsResponseModels
      , "currency" .= getModelsResponseCurrency
      , "regionId" .= getModelsResponseRegionId
      ]


-- | Construct a value of type 'GetModelsResponse' (by applying it's required fields, if any)
mkGetModelsResponse
  :: [ModelDTO] -- ^ 'getModelsResponseModels': Список моделей товаров.
  -> GetModelsResponse
mkGetModelsResponse getModelsResponseModels =
  GetModelsResponse
  { getModelsResponseModels
  , getModelsResponseCurrency = Nothing
  , getModelsResponseRegionId = Nothing
  }

-- ** GetOfferCardsContentStatusRequest
-- | GetOfferCardsContentStatusRequest
data GetOfferCardsContentStatusRequest = GetOfferCardsContentStatusRequest
  { getOfferCardsContentStatusRequestOfferIds :: !(Maybe [Text]) -- ^ "offerIds" - Идентификаторы товаров, информация о которых нужна. &lt;br&gt;&lt;br&gt; ⚠️ Не используйте это поле одновременно с фильтрами по статусам карточек, категориям, брендам или тегам. Если вы хотите воспользоваться фильтрами, оставьте поле пустым. 
  , getOfferCardsContentStatusRequestCardStatuses :: !(Maybe [OfferCardStatusType]) -- ^ "cardStatuses" - Фильтр по статусам карточек.  [Что такое карточка товара](https://yandex.ru/support/marketplace/assortment/content/index.html) 
  , getOfferCardsContentStatusRequestCategoryIds :: !(Maybe [Int]) -- ^ "categoryIds" - Фильтр по категориям на Маркете.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferCardsContentStatusRequest
instance A.FromJSON GetOfferCardsContentStatusRequest where
  parseJSON = A.withObject "GetOfferCardsContentStatusRequest" $ \o ->
    GetOfferCardsContentStatusRequest
      <$> (o .:? "offerIds")
      <*> (o .:? "cardStatuses")
      <*> (o .:? "categoryIds")

-- | ToJSON GetOfferCardsContentStatusRequest
instance A.ToJSON GetOfferCardsContentStatusRequest where
  toJSON GetOfferCardsContentStatusRequest {..} =
   _omitNulls
      [ "offerIds" .= getOfferCardsContentStatusRequestOfferIds
      , "cardStatuses" .= getOfferCardsContentStatusRequestCardStatuses
      , "categoryIds" .= getOfferCardsContentStatusRequestCategoryIds
      ]


-- | Construct a value of type 'GetOfferCardsContentStatusRequest' (by applying it's required fields, if any)
mkGetOfferCardsContentStatusRequest
  :: GetOfferCardsContentStatusRequest
mkGetOfferCardsContentStatusRequest =
  GetOfferCardsContentStatusRequest
  { getOfferCardsContentStatusRequestOfferIds = Nothing
  , getOfferCardsContentStatusRequestCardStatuses = Nothing
  , getOfferCardsContentStatusRequestCategoryIds = Nothing
  }

-- ** GetOfferCardsContentStatusResponse
-- | GetOfferCardsContentStatusResponse
-- Ответ со списком состояний товаров и пагинацией.
data GetOfferCardsContentStatusResponse = GetOfferCardsContentStatusResponse
  { getOfferCardsContentStatusResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getOfferCardsContentStatusResponseResult :: !(Maybe OfferCardsContentStatusDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferCardsContentStatusResponse
instance A.FromJSON GetOfferCardsContentStatusResponse where
  parseJSON = A.withObject "GetOfferCardsContentStatusResponse" $ \o ->
    GetOfferCardsContentStatusResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetOfferCardsContentStatusResponse
instance A.ToJSON GetOfferCardsContentStatusResponse where
  toJSON GetOfferCardsContentStatusResponse {..} =
   _omitNulls
      [ "status" .= getOfferCardsContentStatusResponseStatus
      , "result" .= getOfferCardsContentStatusResponseResult
      ]


-- | Construct a value of type 'GetOfferCardsContentStatusResponse' (by applying it's required fields, if any)
mkGetOfferCardsContentStatusResponse
  :: GetOfferCardsContentStatusResponse
mkGetOfferCardsContentStatusResponse =
  GetOfferCardsContentStatusResponse
  { getOfferCardsContentStatusResponseStatus = Nothing
  , getOfferCardsContentStatusResponseResult = Nothing
  }

-- ** GetOfferDTO
-- | GetOfferDTO
-- Параметры товара.
data GetOfferDTO = GetOfferDTO
  { getOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , getOfferDTOName :: !(Maybe Text) -- ^ "name" - Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
  , getOfferDTOMarketCategoryId :: !(Maybe Integer) -- ^ "marketCategoryId" - Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать &#x60;marketCategoryId&#x60;, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
  , getOfferDTOCategory :: !(Maybe Text) -- ^ "category" - Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;. 
  , getOfferDTOPictures :: !(Maybe [Text]) -- ^ "pictures" - Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ &#x60;https://example-shop.ru/images/sku12345.jpg&#x60;  ✅ &#x60;https://yadi.sk/i/NaBoRsimVOLov&#x60;  ❌ &#x60;/images/sku12345.jpg&#x60;  ❌ &#x60;https://www.dropbox.com/s/818f/tovar.jpg&#x60;  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html) 
  , getOfferDTOVideos :: !(Maybe [Text]) -- ^ "videos" - Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ &#x60;https://example-shop.ru/video/sku12345.avi&#x60;  ✅ &#x60;https://yadi.sk/i/NaBoRsimVOLov&#x60;  ❌ &#x60;/video/sku12345.avi&#x60;  ❌ &#x60;https://www.dropbox.com/s/818f/super-tovar.avi&#x60;  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html) 
  , getOfferDTOManuals :: !(Maybe [OfferManualDTO]) -- ^ "manuals" - Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле &#x60;manuals&#x60;, загруженные ранее инструкции удалятся. 
  , getOfferDTOVendor :: !(Maybe Text) -- ^ "vendor" - Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
  , getOfferDTOBarcodes :: !(Maybe [Text]) -- ^ "barcodes" - Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
  , getOfferDTODescription :: !(Maybe Text) -- ^ "description" - Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\&lt;h&gt;, \\&lt;h1&gt;, \\&lt;h2&gt; и так далее — для заголовков; * \\&lt;br&gt; и \\&lt;p&gt; — для переноса строки; * \\&lt;ol&gt; — для нумерованного списка; * \\&lt;ul&gt; — для маркированного списка; * \\&lt;li&gt; — для создания элементов списка (должен находиться внутри \\&lt;ol&gt; или \\&lt;ul&gt;); * \\&lt;div&gt; — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
  , getOfferDTOManufacturerCountries :: !(Maybe [Text]) -- ^ "manufacturerCountries" - Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx). 
  , getOfferDTOWeightDimensions :: !(Maybe OfferWeightDimensionsDTO) -- ^ "weightDimensions"
  , getOfferDTOVendorCode :: !(Maybe Text) -- ^ "vendorCode" - Артикул товара от производителя.
  , getOfferDTOTags :: !(Maybe [Text]) -- ^ "tags" - Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов. 
  , getOfferDTOShelfLife :: !(Maybe TimePeriodDTO) -- ^ "shelfLife"
  , getOfferDTOLifeTime :: !(Maybe TimePeriodDTO) -- ^ "lifeTime"
  , getOfferDTOGuaranteePeriod :: !(Maybe TimePeriodDTO) -- ^ "guaranteePeriod"
  , getOfferDTOCustomsCommodityCode :: !(Maybe Text) -- ^ "customsCommodityCode" - Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть. 
  , getOfferDTOCertificates :: !(Maybe [Text]) -- ^ "certificates" - Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html). 
  , getOfferDTOBoxCount :: !(Maybe Int) -- ^ "boxCount" - Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр. 
  , getOfferDTOCondition :: !(Maybe OfferConditionDTO) -- ^ "condition"
  , getOfferDTOType :: !(Maybe OfferType) -- ^ "type"
  , getOfferDTODownloadable :: !(Maybe Bool) -- ^ "downloadable" - Признак цифрового товара. Укажите &#x60;true&#x60;, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md) 
  , getOfferDTOAdult :: !(Maybe Bool) -- ^ "adult" - Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей. 
  , getOfferDTOAge :: !(Maybe AgeDTO) -- ^ "age"
  , getOfferDTOParams :: !(Maybe [OfferParamDTO]) -- ^ "params" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. При передаче характеристик используйте &#x60;parameterValues&#x60;.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви. 
  , getOfferDTOBasicPrice :: !(Maybe GetPriceWithDiscountDTO) -- ^ "basicPrice"
  , getOfferDTOPurchasePrice :: !(Maybe GetPriceDTO) -- ^ "purchasePrice"
  , getOfferDTOAdditionalExpenses :: !(Maybe GetPriceDTO) -- ^ "additionalExpenses"
  , getOfferDTOCofinancePrice :: !(Maybe GetPriceDTO) -- ^ "cofinancePrice"
  , getOfferDTOCardStatus :: !(Maybe OfferCardStatusType) -- ^ "cardStatus"
  , getOfferDTOCampaigns :: !(Maybe [OfferCampaignStatusDTO]) -- ^ "campaigns" - Список магазинов, в которых размещен товар. 
  , getOfferDTOSellingPrograms :: !(Maybe [OfferSellingProgramDTO]) -- ^ "sellingPrograms" - Информация о том, какие для товара доступны модели размещения. 
  , getOfferDTOArchived :: !(Maybe Bool) -- ^ "archived" - Товар помещен в архив. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferDTO
instance A.FromJSON GetOfferDTO where
  parseJSON = A.withObject "GetOfferDTO" $ \o ->
    GetOfferDTO
      <$> (o .:  "offerId")
      <*> (o .:? "name")
      <*> (o .:? "marketCategoryId")
      <*> (o .:? "category")
      <*> (o .:? "pictures")
      <*> (o .:? "videos")
      <*> (o .:? "manuals")
      <*> (o .:? "vendor")
      <*> (o .:? "barcodes")
      <*> (o .:? "description")
      <*> (o .:? "manufacturerCountries")
      <*> (o .:? "weightDimensions")
      <*> (o .:? "vendorCode")
      <*> (o .:? "tags")
      <*> (o .:? "shelfLife")
      <*> (o .:? "lifeTime")
      <*> (o .:? "guaranteePeriod")
      <*> (o .:? "customsCommodityCode")
      <*> (o .:? "certificates")
      <*> (o .:? "boxCount")
      <*> (o .:? "condition")
      <*> (o .:? "type")
      <*> (o .:? "downloadable")
      <*> (o .:? "adult")
      <*> (o .:? "age")
      <*> (o .:? "params")
      <*> (o .:? "basicPrice")
      <*> (o .:? "purchasePrice")
      <*> (o .:? "additionalExpenses")
      <*> (o .:? "cofinancePrice")
      <*> (o .:? "cardStatus")
      <*> (o .:? "campaigns")
      <*> (o .:? "sellingPrograms")
      <*> (o .:? "archived")

-- | ToJSON GetOfferDTO
instance A.ToJSON GetOfferDTO where
  toJSON GetOfferDTO {..} =
   _omitNulls
      [ "offerId" .= getOfferDTOOfferId
      , "name" .= getOfferDTOName
      , "marketCategoryId" .= getOfferDTOMarketCategoryId
      , "category" .= getOfferDTOCategory
      , "pictures" .= getOfferDTOPictures
      , "videos" .= getOfferDTOVideos
      , "manuals" .= getOfferDTOManuals
      , "vendor" .= getOfferDTOVendor
      , "barcodes" .= getOfferDTOBarcodes
      , "description" .= getOfferDTODescription
      , "manufacturerCountries" .= getOfferDTOManufacturerCountries
      , "weightDimensions" .= getOfferDTOWeightDimensions
      , "vendorCode" .= getOfferDTOVendorCode
      , "tags" .= getOfferDTOTags
      , "shelfLife" .= getOfferDTOShelfLife
      , "lifeTime" .= getOfferDTOLifeTime
      , "guaranteePeriod" .= getOfferDTOGuaranteePeriod
      , "customsCommodityCode" .= getOfferDTOCustomsCommodityCode
      , "certificates" .= getOfferDTOCertificates
      , "boxCount" .= getOfferDTOBoxCount
      , "condition" .= getOfferDTOCondition
      , "type" .= getOfferDTOType
      , "downloadable" .= getOfferDTODownloadable
      , "adult" .= getOfferDTOAdult
      , "age" .= getOfferDTOAge
      , "params" .= getOfferDTOParams
      , "basicPrice" .= getOfferDTOBasicPrice
      , "purchasePrice" .= getOfferDTOPurchasePrice
      , "additionalExpenses" .= getOfferDTOAdditionalExpenses
      , "cofinancePrice" .= getOfferDTOCofinancePrice
      , "cardStatus" .= getOfferDTOCardStatus
      , "campaigns" .= getOfferDTOCampaigns
      , "sellingPrograms" .= getOfferDTOSellingPrograms
      , "archived" .= getOfferDTOArchived
      ]


-- | Construct a value of type 'GetOfferDTO' (by applying it's required fields, if any)
mkGetOfferDTO
  :: Text -- ^ 'getOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> GetOfferDTO
mkGetOfferDTO getOfferDTOOfferId =
  GetOfferDTO
  { getOfferDTOOfferId
  , getOfferDTOName = Nothing
  , getOfferDTOMarketCategoryId = Nothing
  , getOfferDTOCategory = Nothing
  , getOfferDTOPictures = Nothing
  , getOfferDTOVideos = Nothing
  , getOfferDTOManuals = Nothing
  , getOfferDTOVendor = Nothing
  , getOfferDTOBarcodes = Nothing
  , getOfferDTODescription = Nothing
  , getOfferDTOManufacturerCountries = Nothing
  , getOfferDTOWeightDimensions = Nothing
  , getOfferDTOVendorCode = Nothing
  , getOfferDTOTags = Nothing
  , getOfferDTOShelfLife = Nothing
  , getOfferDTOLifeTime = Nothing
  , getOfferDTOGuaranteePeriod = Nothing
  , getOfferDTOCustomsCommodityCode = Nothing
  , getOfferDTOCertificates = Nothing
  , getOfferDTOBoxCount = Nothing
  , getOfferDTOCondition = Nothing
  , getOfferDTOType = Nothing
  , getOfferDTODownloadable = Nothing
  , getOfferDTOAdult = Nothing
  , getOfferDTOAge = Nothing
  , getOfferDTOParams = Nothing
  , getOfferDTOBasicPrice = Nothing
  , getOfferDTOPurchasePrice = Nothing
  , getOfferDTOAdditionalExpenses = Nothing
  , getOfferDTOCofinancePrice = Nothing
  , getOfferDTOCardStatus = Nothing
  , getOfferDTOCampaigns = Nothing
  , getOfferDTOSellingPrograms = Nothing
  , getOfferDTOArchived = Nothing
  }

-- ** GetOfferMappingDTO
-- | GetOfferMappingDTO
-- Информация о товаре.
data GetOfferMappingDTO = GetOfferMappingDTO
  { getOfferMappingDTOOffer :: !(Maybe GetOfferDTO) -- ^ "offer"
  , getOfferMappingDTOMapping :: !(Maybe GetMappingDTO) -- ^ "mapping"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferMappingDTO
instance A.FromJSON GetOfferMappingDTO where
  parseJSON = A.withObject "GetOfferMappingDTO" $ \o ->
    GetOfferMappingDTO
      <$> (o .:? "offer")
      <*> (o .:? "mapping")

-- | ToJSON GetOfferMappingDTO
instance A.ToJSON GetOfferMappingDTO where
  toJSON GetOfferMappingDTO {..} =
   _omitNulls
      [ "offer" .= getOfferMappingDTOOffer
      , "mapping" .= getOfferMappingDTOMapping
      ]


-- | Construct a value of type 'GetOfferMappingDTO' (by applying it's required fields, if any)
mkGetOfferMappingDTO
  :: GetOfferMappingDTO
mkGetOfferMappingDTO =
  GetOfferMappingDTO
  { getOfferMappingDTOOffer = Nothing
  , getOfferMappingDTOMapping = Nothing
  }

-- ** GetOfferMappingEntriesResponse
-- | GetOfferMappingEntriesResponse
-- Ответ на запрос списка товаров в каталоге.
data GetOfferMappingEntriesResponse = GetOfferMappingEntriesResponse
  { getOfferMappingEntriesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getOfferMappingEntriesResponseResult :: !(Maybe OfferMappingEntriesDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferMappingEntriesResponse
instance A.FromJSON GetOfferMappingEntriesResponse where
  parseJSON = A.withObject "GetOfferMappingEntriesResponse" $ \o ->
    GetOfferMappingEntriesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetOfferMappingEntriesResponse
instance A.ToJSON GetOfferMappingEntriesResponse where
  toJSON GetOfferMappingEntriesResponse {..} =
   _omitNulls
      [ "status" .= getOfferMappingEntriesResponseStatus
      , "result" .= getOfferMappingEntriesResponseResult
      ]


-- | Construct a value of type 'GetOfferMappingEntriesResponse' (by applying it's required fields, if any)
mkGetOfferMappingEntriesResponse
  :: GetOfferMappingEntriesResponse
mkGetOfferMappingEntriesResponse =
  GetOfferMappingEntriesResponse
  { getOfferMappingEntriesResponseStatus = Nothing
  , getOfferMappingEntriesResponseResult = Nothing
  }

-- ** GetOfferMappingsRequest
-- | GetOfferMappingsRequest
data GetOfferMappingsRequest = GetOfferMappingsRequest
  { getOfferMappingsRequestOfferIds :: !(Maybe [Text]) -- ^ "offerIds" - Идентификаторы товаров, информация о которых нужна.  {% note warning \&quot;Такой список возвращается только целиком\&quot; %}  Если вы запрашиваете информацию по конкретным SKU, не заполняйте: * &#x60;page_token&#x60;; * &#x60;limit&#x60;; * &#x60;cardStatuses&#x60;; * &#x60;categoryIds&#x60;; * &#x60;vendorNames&#x60;; * &#x60;tags&#x60;; * &#x60;archived&#x60;.  {% endnote %}    
  , getOfferMappingsRequestCardStatuses :: !(Maybe [OfferCardStatusType]) -- ^ "cardStatuses" - Фильтр по статусам карточек.  [Что такое карточка товара](https://yandex.ru/support/marketplace/assortment/content/index.html) 
  , getOfferMappingsRequestCategoryIds :: !(Maybe [Int]) -- ^ "categoryIds" - Фильтр по категориям на Маркете.
  , getOfferMappingsRequestVendorNames :: !(Maybe [Text]) -- ^ "vendorNames" - Фильтр по брендам.
  , getOfferMappingsRequestTags :: !(Maybe [Text]) -- ^ "tags" - Фильтр по тегам.
  , getOfferMappingsRequestArchived :: !(Maybe Bool) -- ^ "archived" - Фильтр по нахождению в архиве.  Передайте &#x60;true&#x60;, чтобы получить товары, находящиеся в архиве. Если фильтр не заполнен или передано &#x60;false&#x60;, в ответе возвращаются товары, не находящиеся в архиве. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferMappingsRequest
instance A.FromJSON GetOfferMappingsRequest where
  parseJSON = A.withObject "GetOfferMappingsRequest" $ \o ->
    GetOfferMappingsRequest
      <$> (o .:? "offerIds")
      <*> (o .:? "cardStatuses")
      <*> (o .:? "categoryIds")
      <*> (o .:? "vendorNames")
      <*> (o .:? "tags")
      <*> (o .:? "archived")

-- | ToJSON GetOfferMappingsRequest
instance A.ToJSON GetOfferMappingsRequest where
  toJSON GetOfferMappingsRequest {..} =
   _omitNulls
      [ "offerIds" .= getOfferMappingsRequestOfferIds
      , "cardStatuses" .= getOfferMappingsRequestCardStatuses
      , "categoryIds" .= getOfferMappingsRequestCategoryIds
      , "vendorNames" .= getOfferMappingsRequestVendorNames
      , "tags" .= getOfferMappingsRequestTags
      , "archived" .= getOfferMappingsRequestArchived
      ]


-- | Construct a value of type 'GetOfferMappingsRequest' (by applying it's required fields, if any)
mkGetOfferMappingsRequest
  :: GetOfferMappingsRequest
mkGetOfferMappingsRequest =
  GetOfferMappingsRequest
  { getOfferMappingsRequestOfferIds = Nothing
  , getOfferMappingsRequestCardStatuses = Nothing
  , getOfferMappingsRequestCategoryIds = Nothing
  , getOfferMappingsRequestVendorNames = Nothing
  , getOfferMappingsRequestTags = Nothing
  , getOfferMappingsRequestArchived = Nothing
  }

-- ** GetOfferMappingsResponse
-- | GetOfferMappingsResponse
data GetOfferMappingsResponse = GetOfferMappingsResponse
  { getOfferMappingsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getOfferMappingsResponseResult :: !(Maybe GetOfferMappingsResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferMappingsResponse
instance A.FromJSON GetOfferMappingsResponse where
  parseJSON = A.withObject "GetOfferMappingsResponse" $ \o ->
    GetOfferMappingsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetOfferMappingsResponse
instance A.ToJSON GetOfferMappingsResponse where
  toJSON GetOfferMappingsResponse {..} =
   _omitNulls
      [ "status" .= getOfferMappingsResponseStatus
      , "result" .= getOfferMappingsResponseResult
      ]


-- | Construct a value of type 'GetOfferMappingsResponse' (by applying it's required fields, if any)
mkGetOfferMappingsResponse
  :: GetOfferMappingsResponse
mkGetOfferMappingsResponse =
  GetOfferMappingsResponse
  { getOfferMappingsResponseStatus = Nothing
  , getOfferMappingsResponseResult = Nothing
  }

-- ** GetOfferMappingsResultDTO
-- | GetOfferMappingsResultDTO
-- Информация о товарах.
data GetOfferMappingsResultDTO = GetOfferMappingsResultDTO
  { getOfferMappingsResultDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , getOfferMappingsResultDTOOfferMappings :: !([GetOfferMappingDTO]) -- ^ /Required/ "offerMappings" - Информация о товарах.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferMappingsResultDTO
instance A.FromJSON GetOfferMappingsResultDTO where
  parseJSON = A.withObject "GetOfferMappingsResultDTO" $ \o ->
    GetOfferMappingsResultDTO
      <$> (o .:? "paging")
      <*> (o .:  "offerMappings")

-- | ToJSON GetOfferMappingsResultDTO
instance A.ToJSON GetOfferMappingsResultDTO where
  toJSON GetOfferMappingsResultDTO {..} =
   _omitNulls
      [ "paging" .= getOfferMappingsResultDTOPaging
      , "offerMappings" .= getOfferMappingsResultDTOOfferMappings
      ]


-- | Construct a value of type 'GetOfferMappingsResultDTO' (by applying it's required fields, if any)
mkGetOfferMappingsResultDTO
  :: [GetOfferMappingDTO] -- ^ 'getOfferMappingsResultDTOOfferMappings': Информация о товарах.
  -> GetOfferMappingsResultDTO
mkGetOfferMappingsResultDTO getOfferMappingsResultDTOOfferMappings =
  GetOfferMappingsResultDTO
  { getOfferMappingsResultDTOPaging = Nothing
  , getOfferMappingsResultDTOOfferMappings
  }

-- ** GetOfferRecommendationsRequest
-- | GetOfferRecommendationsRequest
data GetOfferRecommendationsRequest = GetOfferRecommendationsRequest
  { getOfferRecommendationsRequestOfferIds :: !(Maybe [Text]) -- ^ "offerIds" - Идентификаторы товаров, информация о которых нужна. ⚠️ Не используйте это поле одновременно с остальными фильтрами. Если вы хотите воспользоваться фильтрами, оставьте поле пустым.
  , getOfferRecommendationsRequestCofinancePriceFilter :: !(Maybe FieldStateType) -- ^ "cofinancePriceFilter"
  , getOfferRecommendationsRequestRecommendedCofinancePriceFilter :: !(Maybe FieldStateType) -- ^ "recommendedCofinancePriceFilter"
  , getOfferRecommendationsRequestCompetitivenessFilter :: !(Maybe PriceCompetitivenessType) -- ^ "competitivenessFilter"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferRecommendationsRequest
instance A.FromJSON GetOfferRecommendationsRequest where
  parseJSON = A.withObject "GetOfferRecommendationsRequest" $ \o ->
    GetOfferRecommendationsRequest
      <$> (o .:? "offerIds")
      <*> (o .:? "cofinancePriceFilter")
      <*> (o .:? "recommendedCofinancePriceFilter")
      <*> (o .:? "competitivenessFilter")

-- | ToJSON GetOfferRecommendationsRequest
instance A.ToJSON GetOfferRecommendationsRequest where
  toJSON GetOfferRecommendationsRequest {..} =
   _omitNulls
      [ "offerIds" .= getOfferRecommendationsRequestOfferIds
      , "cofinancePriceFilter" .= getOfferRecommendationsRequestCofinancePriceFilter
      , "recommendedCofinancePriceFilter" .= getOfferRecommendationsRequestRecommendedCofinancePriceFilter
      , "competitivenessFilter" .= getOfferRecommendationsRequestCompetitivenessFilter
      ]


-- | Construct a value of type 'GetOfferRecommendationsRequest' (by applying it's required fields, if any)
mkGetOfferRecommendationsRequest
  :: GetOfferRecommendationsRequest
mkGetOfferRecommendationsRequest =
  GetOfferRecommendationsRequest
  { getOfferRecommendationsRequestOfferIds = Nothing
  , getOfferRecommendationsRequestCofinancePriceFilter = Nothing
  , getOfferRecommendationsRequestRecommendedCofinancePriceFilter = Nothing
  , getOfferRecommendationsRequestCompetitivenessFilter = Nothing
  }

-- ** GetOfferRecommendationsResponse
-- | GetOfferRecommendationsResponse
data GetOfferRecommendationsResponse = GetOfferRecommendationsResponse
  { getOfferRecommendationsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getOfferRecommendationsResponseResult :: !(Maybe OfferRecommendationsResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOfferRecommendationsResponse
instance A.FromJSON GetOfferRecommendationsResponse where
  parseJSON = A.withObject "GetOfferRecommendationsResponse" $ \o ->
    GetOfferRecommendationsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetOfferRecommendationsResponse
instance A.ToJSON GetOfferRecommendationsResponse where
  toJSON GetOfferRecommendationsResponse {..} =
   _omitNulls
      [ "status" .= getOfferRecommendationsResponseStatus
      , "result" .= getOfferRecommendationsResponseResult
      ]


-- | Construct a value of type 'GetOfferRecommendationsResponse' (by applying it's required fields, if any)
mkGetOfferRecommendationsResponse
  :: GetOfferRecommendationsResponse
mkGetOfferRecommendationsResponse =
  GetOfferRecommendationsResponse
  { getOfferRecommendationsResponseStatus = Nothing
  , getOfferRecommendationsResponseResult = Nothing
  }

-- ** GetOffersResponse
-- | GetOffersResponse
-- Список предложений с пагинатором.
data GetOffersResponse = GetOffersResponse
  { getOffersResponseOffers :: !([OfferDTO]) -- ^ /Required/ "offers" - Список предложений магазина.
  , getOffersResponsePager :: !(Maybe FlippingPagerDTO) -- ^ "pager"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOffersResponse
instance A.FromJSON GetOffersResponse where
  parseJSON = A.withObject "GetOffersResponse" $ \o ->
    GetOffersResponse
      <$> (o .:  "offers")
      <*> (o .:? "pager")

-- | ToJSON GetOffersResponse
instance A.ToJSON GetOffersResponse where
  toJSON GetOffersResponse {..} =
   _omitNulls
      [ "offers" .= getOffersResponseOffers
      , "pager" .= getOffersResponsePager
      ]


-- | Construct a value of type 'GetOffersResponse' (by applying it's required fields, if any)
mkGetOffersResponse
  :: [OfferDTO] -- ^ 'getOffersResponseOffers': Список предложений магазина.
  -> GetOffersResponse
mkGetOffersResponse getOffersResponseOffers =
  GetOffersResponse
  { getOffersResponseOffers
  , getOffersResponsePager = Nothing
  }

-- ** GetOrderBuyerInfoResponse
-- | GetOrderBuyerInfoResponse
data GetOrderBuyerInfoResponse = GetOrderBuyerInfoResponse
  { getOrderBuyerInfoResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getOrderBuyerInfoResponseResult :: !(Maybe OrderBuyerInfoDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOrderBuyerInfoResponse
instance A.FromJSON GetOrderBuyerInfoResponse where
  parseJSON = A.withObject "GetOrderBuyerInfoResponse" $ \o ->
    GetOrderBuyerInfoResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetOrderBuyerInfoResponse
instance A.ToJSON GetOrderBuyerInfoResponse where
  toJSON GetOrderBuyerInfoResponse {..} =
   _omitNulls
      [ "status" .= getOrderBuyerInfoResponseStatus
      , "result" .= getOrderBuyerInfoResponseResult
      ]


-- | Construct a value of type 'GetOrderBuyerInfoResponse' (by applying it's required fields, if any)
mkGetOrderBuyerInfoResponse
  :: GetOrderBuyerInfoResponse
mkGetOrderBuyerInfoResponse =
  GetOrderBuyerInfoResponse
  { getOrderBuyerInfoResponseStatus = Nothing
  , getOrderBuyerInfoResponseResult = Nothing
  }

-- ** GetOrderLabelsDataResponse
-- | GetOrderLabelsDataResponse
-- Ответ с информацией для печати ярлыков.
data GetOrderLabelsDataResponse = GetOrderLabelsDataResponse
  { getOrderLabelsDataResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getOrderLabelsDataResponseResult :: !(Maybe OrderLabelDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOrderLabelsDataResponse
instance A.FromJSON GetOrderLabelsDataResponse where
  parseJSON = A.withObject "GetOrderLabelsDataResponse" $ \o ->
    GetOrderLabelsDataResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetOrderLabelsDataResponse
instance A.ToJSON GetOrderLabelsDataResponse where
  toJSON GetOrderLabelsDataResponse {..} =
   _omitNulls
      [ "status" .= getOrderLabelsDataResponseStatus
      , "result" .= getOrderLabelsDataResponseResult
      ]


-- | Construct a value of type 'GetOrderLabelsDataResponse' (by applying it's required fields, if any)
mkGetOrderLabelsDataResponse
  :: GetOrderLabelsDataResponse
mkGetOrderLabelsDataResponse =
  GetOrderLabelsDataResponse
  { getOrderLabelsDataResponseStatus = Nothing
  , getOrderLabelsDataResponseResult = Nothing
  }

-- ** GetOrderResponse
-- | GetOrderResponse
data GetOrderResponse = GetOrderResponse
  { getOrderResponseOrder :: !(Maybe OrderDTO) -- ^ "order"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOrderResponse
instance A.FromJSON GetOrderResponse where
  parseJSON = A.withObject "GetOrderResponse" $ \o ->
    GetOrderResponse
      <$> (o .:? "order")

-- | ToJSON GetOrderResponse
instance A.ToJSON GetOrderResponse where
  toJSON GetOrderResponse {..} =
   _omitNulls
      [ "order" .= getOrderResponseOrder
      ]


-- | Construct a value of type 'GetOrderResponse' (by applying it's required fields, if any)
mkGetOrderResponse
  :: GetOrderResponse
mkGetOrderResponse =
  GetOrderResponse
  { getOrderResponseOrder = Nothing
  }

-- ** GetOrdersResponse
-- | GetOrdersResponse
-- Модель для ответа API списка информации по заказам.
data GetOrdersResponse = GetOrdersResponse
  { getOrdersResponsePager :: !(Maybe FlippingPagerDTO) -- ^ "pager"
  , getOrdersResponseOrders :: !([OrderDTO]) -- ^ /Required/ "orders" - Модель заказа. 
  , getOrdersResponsePaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOrdersResponse
instance A.FromJSON GetOrdersResponse where
  parseJSON = A.withObject "GetOrdersResponse" $ \o ->
    GetOrdersResponse
      <$> (o .:? "pager")
      <*> (o .:  "orders")
      <*> (o .:? "paging")

-- | ToJSON GetOrdersResponse
instance A.ToJSON GetOrdersResponse where
  toJSON GetOrdersResponse {..} =
   _omitNulls
      [ "pager" .= getOrdersResponsePager
      , "orders" .= getOrdersResponseOrders
      , "paging" .= getOrdersResponsePaging
      ]


-- | Construct a value of type 'GetOrdersResponse' (by applying it's required fields, if any)
mkGetOrdersResponse
  :: [OrderDTO] -- ^ 'getOrdersResponseOrders': Модель заказа. 
  -> GetOrdersResponse
mkGetOrdersResponse getOrdersResponseOrders =
  GetOrdersResponse
  { getOrdersResponsePager = Nothing
  , getOrdersResponseOrders
  , getOrdersResponsePaging = Nothing
  }

-- ** GetOrdersStatsRequest
-- | GetOrdersStatsRequest
-- Запрос информации по заказам.
data GetOrdersStatsRequest = GetOrdersStatsRequest
  { getOrdersStatsRequestDateFrom :: !(Maybe Date) -- ^ "dateFrom" - Начальная дата, когда заказ был сформирован.  Формат даты: &#x60;ГГГГ‑ММ‑ДД&#x60;.  Нельзя использовать вместе с параметрами &#x60;updateFrom&#x60; и &#x60;updateTo&#x60;. 
  , getOrdersStatsRequestDateTo :: !(Maybe Date) -- ^ "dateTo" - Конечная дата, когда заказ был сформирован.  Формат даты: &#x60;ГГГГ‑ММ‑ДД&#x60;.  Нельзя использовать вместе с параметрами &#x60;updateFrom&#x60; и &#x60;updateTo&#x60;. 
  , getOrdersStatsRequestUpdateFrom :: !(Maybe Date) -- ^ "updateFrom" - Начальная дата периода, за который были изменения статуса заказа.  Формат даты: &#x60;ГГГГ‑ММ‑ДД&#x60;.  Нельзя использовать вместе с параметрами &#x60;dateFrom&#x60; и &#x60;dateTo&#x60;. 
  , getOrdersStatsRequestUpdateTo :: !(Maybe Date) -- ^ "updateTo" - Конечная дата периода, за который были изменения статуса заказа.  Формат даты: &#x60;ГГГГ‑ММ‑ДД&#x60;.  Нельзя использовать вместе с параметрами &#x60;dateFrom&#x60; и &#x60;dateTo&#x60;. 
  , getOrdersStatsRequestOrders :: !(Maybe [Integer]) -- ^ "orders" - Список идентификаторов заказов.
  , getOrdersStatsRequestStatuses :: !(Maybe [OrderStatsStatusType]) -- ^ "statuses" - Список статусов заказов.
  , getOrdersStatsRequestHasCis :: !(Maybe Bool) -- ^ "hasCis" - Нужно ли вернуть только те заказы, в составе которых есть хотя бы один товар с кодом идентификации [в системе «Честный ЗНАК»](https://честныйзнак.рф/):  * &#x60;true&#x60; — да. * &#x60;false&#x60; — нет. Такие коды присваиваются товарам, которые подлежат маркировке и относятся к определенным категориям. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOrdersStatsRequest
instance A.FromJSON GetOrdersStatsRequest where
  parseJSON = A.withObject "GetOrdersStatsRequest" $ \o ->
    GetOrdersStatsRequest
      <$> (o .:? "dateFrom")
      <*> (o .:? "dateTo")
      <*> (o .:? "updateFrom")
      <*> (o .:? "updateTo")
      <*> (o .:? "orders")
      <*> (o .:? "statuses")
      <*> (o .:? "hasCis")

-- | ToJSON GetOrdersStatsRequest
instance A.ToJSON GetOrdersStatsRequest where
  toJSON GetOrdersStatsRequest {..} =
   _omitNulls
      [ "dateFrom" .= getOrdersStatsRequestDateFrom
      , "dateTo" .= getOrdersStatsRequestDateTo
      , "updateFrom" .= getOrdersStatsRequestUpdateFrom
      , "updateTo" .= getOrdersStatsRequestUpdateTo
      , "orders" .= getOrdersStatsRequestOrders
      , "statuses" .= getOrdersStatsRequestStatuses
      , "hasCis" .= getOrdersStatsRequestHasCis
      ]


-- | Construct a value of type 'GetOrdersStatsRequest' (by applying it's required fields, if any)
mkGetOrdersStatsRequest
  :: GetOrdersStatsRequest
mkGetOrdersStatsRequest =
  GetOrdersStatsRequest
  { getOrdersStatsRequestDateFrom = Nothing
  , getOrdersStatsRequestDateTo = Nothing
  , getOrdersStatsRequestUpdateFrom = Nothing
  , getOrdersStatsRequestUpdateTo = Nothing
  , getOrdersStatsRequestOrders = Nothing
  , getOrdersStatsRequestStatuses = Nothing
  , getOrdersStatsRequestHasCis = Nothing
  }

-- ** GetOrdersStatsResponse
-- | GetOrdersStatsResponse
-- Ответ на запрос информации по заказам.
data GetOrdersStatsResponse = GetOrdersStatsResponse
  { getOrdersStatsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getOrdersStatsResponseResult :: !(Maybe OrdersStatsDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOrdersStatsResponse
instance A.FromJSON GetOrdersStatsResponse where
  parseJSON = A.withObject "GetOrdersStatsResponse" $ \o ->
    GetOrdersStatsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetOrdersStatsResponse
instance A.ToJSON GetOrdersStatsResponse where
  toJSON GetOrdersStatsResponse {..} =
   _omitNulls
      [ "status" .= getOrdersStatsResponseStatus
      , "result" .= getOrdersStatsResponseResult
      ]


-- | Construct a value of type 'GetOrdersStatsResponse' (by applying it's required fields, if any)
mkGetOrdersStatsResponse
  :: GetOrdersStatsResponse
mkGetOrdersStatsResponse =
  GetOrdersStatsResponse
  { getOrdersStatsResponseStatus = Nothing
  , getOrdersStatsResponseResult = Nothing
  }

-- ** GetOutletLicensesResponse
-- | GetOutletLicensesResponse
data GetOutletLicensesResponse = GetOutletLicensesResponse
  { getOutletLicensesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getOutletLicensesResponseResult :: !(Maybe OutletLicensesResponseDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOutletLicensesResponse
instance A.FromJSON GetOutletLicensesResponse where
  parseJSON = A.withObject "GetOutletLicensesResponse" $ \o ->
    GetOutletLicensesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetOutletLicensesResponse
instance A.ToJSON GetOutletLicensesResponse where
  toJSON GetOutletLicensesResponse {..} =
   _omitNulls
      [ "status" .= getOutletLicensesResponseStatus
      , "result" .= getOutletLicensesResponseResult
      ]


-- | Construct a value of type 'GetOutletLicensesResponse' (by applying it's required fields, if any)
mkGetOutletLicensesResponse
  :: GetOutletLicensesResponse
mkGetOutletLicensesResponse =
  GetOutletLicensesResponse
  { getOutletLicensesResponseStatus = Nothing
  , getOutletLicensesResponseResult = Nothing
  }

-- ** GetOutletResponse
-- | GetOutletResponse
-- Ответ на запрос информации о точке продаж.
data GetOutletResponse = GetOutletResponse
  { getOutletResponseOutlet :: !(Maybe FullOutletDTO) -- ^ "outlet"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOutletResponse
instance A.FromJSON GetOutletResponse where
  parseJSON = A.withObject "GetOutletResponse" $ \o ->
    GetOutletResponse
      <$> (o .:? "outlet")

-- | ToJSON GetOutletResponse
instance A.ToJSON GetOutletResponse where
  toJSON GetOutletResponse {..} =
   _omitNulls
      [ "outlet" .= getOutletResponseOutlet
      ]


-- | Construct a value of type 'GetOutletResponse' (by applying it's required fields, if any)
mkGetOutletResponse
  :: GetOutletResponse
mkGetOutletResponse =
  GetOutletResponse
  { getOutletResponseOutlet = Nothing
  }

-- ** GetOutletsResponse
-- | GetOutletsResponse
-- Ответ на запрос информации о точках продаж.
data GetOutletsResponse = GetOutletsResponse
  { getOutletsResponseOutlets :: !([FullOutletDTO]) -- ^ /Required/ "outlets" - Информация о точках продаж.
  , getOutletsResponsePaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , getOutletsResponsePager :: !(Maybe FlippingPagerDTO) -- ^ "pager"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetOutletsResponse
instance A.FromJSON GetOutletsResponse where
  parseJSON = A.withObject "GetOutletsResponse" $ \o ->
    GetOutletsResponse
      <$> (o .:  "outlets")
      <*> (o .:? "paging")
      <*> (o .:? "pager")

-- | ToJSON GetOutletsResponse
instance A.ToJSON GetOutletsResponse where
  toJSON GetOutletsResponse {..} =
   _omitNulls
      [ "outlets" .= getOutletsResponseOutlets
      , "paging" .= getOutletsResponsePaging
      , "pager" .= getOutletsResponsePager
      ]


-- | Construct a value of type 'GetOutletsResponse' (by applying it's required fields, if any)
mkGetOutletsResponse
  :: [FullOutletDTO] -- ^ 'getOutletsResponseOutlets': Информация о точках продаж.
  -> GetOutletsResponse
mkGetOutletsResponse getOutletsResponseOutlets =
  GetOutletsResponse
  { getOutletsResponseOutlets
  , getOutletsResponsePaging = Nothing
  , getOutletsResponsePager = Nothing
  }

-- ** GetPriceDTO
-- | GetPriceDTO
-- Цена с указанием времени последнего обновления.
data GetPriceDTO = GetPriceDTO
  { getPriceDTOValue :: !(Double) -- ^ /Required/ "value" - Значение.
  , getPriceDTOCurrencyId :: !(CurrencyType) -- ^ /Required/ "currencyId"
  , getPriceDTOUpdatedAt :: !(DateTime) -- ^ /Required/ "updatedAt" - Время последнего обновления.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPriceDTO
instance A.FromJSON GetPriceDTO where
  parseJSON = A.withObject "GetPriceDTO" $ \o ->
    GetPriceDTO
      <$> (o .:  "value")
      <*> (o .:  "currencyId")
      <*> (o .:  "updatedAt")

-- | ToJSON GetPriceDTO
instance A.ToJSON GetPriceDTO where
  toJSON GetPriceDTO {..} =
   _omitNulls
      [ "value" .= getPriceDTOValue
      , "currencyId" .= getPriceDTOCurrencyId
      , "updatedAt" .= getPriceDTOUpdatedAt
      ]


-- | Construct a value of type 'GetPriceDTO' (by applying it's required fields, if any)
mkGetPriceDTO
  :: Double -- ^ 'getPriceDTOValue': Значение.
  -> CurrencyType -- ^ 'getPriceDTOCurrencyId' 
  -> DateTime -- ^ 'getPriceDTOUpdatedAt': Время последнего обновления.
  -> GetPriceDTO
mkGetPriceDTO getPriceDTOValue getPriceDTOCurrencyId getPriceDTOUpdatedAt =
  GetPriceDTO
  { getPriceDTOValue
  , getPriceDTOCurrencyId
  , getPriceDTOUpdatedAt
  }

-- ** GetPriceWithDiscountDTO
-- | GetPriceWithDiscountDTO
-- Цена с указанием скидки и времени последнего обновления.
data GetPriceWithDiscountDTO = GetPriceWithDiscountDTO
  { getPriceWithDiscountDTOValue :: !(Double) -- ^ /Required/ "value" - Значение.
  , getPriceWithDiscountDTOCurrencyId :: !(CurrencyType) -- ^ /Required/ "currencyId"
  , getPriceWithDiscountDTODiscountBase :: !(Maybe Double) -- ^ "discountBase" - Цена до скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
  , getPriceWithDiscountDTOUpdatedAt :: !(DateTime) -- ^ /Required/ "updatedAt" - Время последнего обновления.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPriceWithDiscountDTO
instance A.FromJSON GetPriceWithDiscountDTO where
  parseJSON = A.withObject "GetPriceWithDiscountDTO" $ \o ->
    GetPriceWithDiscountDTO
      <$> (o .:  "value")
      <*> (o .:  "currencyId")
      <*> (o .:? "discountBase")
      <*> (o .:  "updatedAt")

-- | ToJSON GetPriceWithDiscountDTO
instance A.ToJSON GetPriceWithDiscountDTO where
  toJSON GetPriceWithDiscountDTO {..} =
   _omitNulls
      [ "value" .= getPriceWithDiscountDTOValue
      , "currencyId" .= getPriceWithDiscountDTOCurrencyId
      , "discountBase" .= getPriceWithDiscountDTODiscountBase
      , "updatedAt" .= getPriceWithDiscountDTOUpdatedAt
      ]


-- | Construct a value of type 'GetPriceWithDiscountDTO' (by applying it's required fields, if any)
mkGetPriceWithDiscountDTO
  :: Double -- ^ 'getPriceWithDiscountDTOValue': Значение.
  -> CurrencyType -- ^ 'getPriceWithDiscountDTOCurrencyId' 
  -> DateTime -- ^ 'getPriceWithDiscountDTOUpdatedAt': Время последнего обновления.
  -> GetPriceWithDiscountDTO
mkGetPriceWithDiscountDTO getPriceWithDiscountDTOValue getPriceWithDiscountDTOCurrencyId getPriceWithDiscountDTOUpdatedAt =
  GetPriceWithDiscountDTO
  { getPriceWithDiscountDTOValue
  , getPriceWithDiscountDTOCurrencyId
  , getPriceWithDiscountDTODiscountBase = Nothing
  , getPriceWithDiscountDTOUpdatedAt
  }

-- ** GetPriceWithVatDTO
-- | GetPriceWithVatDTO
-- Цена с указанием ставки НДС и времени последнего обновления.
data GetPriceWithVatDTO = GetPriceWithVatDTO
  { getPriceWithVatDTOValue :: !(Maybe Double) -- ^ "value" - Цена на товар.
  , getPriceWithVatDTODiscountBase :: !(Maybe Double) -- ^ "discountBase" - Цена на товар без скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
  , getPriceWithVatDTOCurrencyId :: !(Maybe CurrencyType) -- ^ "currencyId"
  , getPriceWithVatDTOVat :: !(Maybe Int) -- ^ "vat" - Идентификатор ставки НДС, применяемой для товара:  * &#x60;2&#x60; — 10%. * &#x60;5&#x60; — 0%. * &#x60;6&#x60; — не облагается НДС. * &#x60;7&#x60; — 20%.  Если параметр не указан, используется ставка НДС, установленная в кабинете. 
  , getPriceWithVatDTOUpdatedAt :: !(DateTime) -- ^ /Required/ "updatedAt" - Время последнего обновления.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPriceWithVatDTO
instance A.FromJSON GetPriceWithVatDTO where
  parseJSON = A.withObject "GetPriceWithVatDTO" $ \o ->
    GetPriceWithVatDTO
      <$> (o .:? "value")
      <*> (o .:? "discountBase")
      <*> (o .:? "currencyId")
      <*> (o .:? "vat")
      <*> (o .:  "updatedAt")

-- | ToJSON GetPriceWithVatDTO
instance A.ToJSON GetPriceWithVatDTO where
  toJSON GetPriceWithVatDTO {..} =
   _omitNulls
      [ "value" .= getPriceWithVatDTOValue
      , "discountBase" .= getPriceWithVatDTODiscountBase
      , "currencyId" .= getPriceWithVatDTOCurrencyId
      , "vat" .= getPriceWithVatDTOVat
      , "updatedAt" .= getPriceWithVatDTOUpdatedAt
      ]


-- | Construct a value of type 'GetPriceWithVatDTO' (by applying it's required fields, if any)
mkGetPriceWithVatDTO
  :: DateTime -- ^ 'getPriceWithVatDTOUpdatedAt': Время последнего обновления.
  -> GetPriceWithVatDTO
mkGetPriceWithVatDTO getPriceWithVatDTOUpdatedAt =
  GetPriceWithVatDTO
  { getPriceWithVatDTOValue = Nothing
  , getPriceWithVatDTODiscountBase = Nothing
  , getPriceWithVatDTOCurrencyId = Nothing
  , getPriceWithVatDTOVat = Nothing
  , getPriceWithVatDTOUpdatedAt
  }

-- ** GetPricesByOfferIdsRequest
-- | GetPricesByOfferIdsRequest
-- Запрос списка цен.
data GetPricesByOfferIdsRequest = GetPricesByOfferIdsRequest
  { getPricesByOfferIdsRequestOfferIds :: !(Maybe [Text]) -- ^ "offerIds" - Список SKU.  {% note warning \&quot;Такой список возвращается только целиком\&quot; %}  Если вы запрашиваете информацию по конкретным SKU, не заполняйте:  * &#x60;page_token&#x60; * &#x60;limit&#x60;  {% endnote %}    
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPricesByOfferIdsRequest
instance A.FromJSON GetPricesByOfferIdsRequest where
  parseJSON = A.withObject "GetPricesByOfferIdsRequest" $ \o ->
    GetPricesByOfferIdsRequest
      <$> (o .:? "offerIds")

-- | ToJSON GetPricesByOfferIdsRequest
instance A.ToJSON GetPricesByOfferIdsRequest where
  toJSON GetPricesByOfferIdsRequest {..} =
   _omitNulls
      [ "offerIds" .= getPricesByOfferIdsRequestOfferIds
      ]


-- | Construct a value of type 'GetPricesByOfferIdsRequest' (by applying it's required fields, if any)
mkGetPricesByOfferIdsRequest
  :: GetPricesByOfferIdsRequest
mkGetPricesByOfferIdsRequest =
  GetPricesByOfferIdsRequest
  { getPricesByOfferIdsRequestOfferIds = Nothing
  }

-- ** GetPricesByOfferIdsResponse
-- | GetPricesByOfferIdsResponse
-- Ответ на запрос списка цен.
data GetPricesByOfferIdsResponse = GetPricesByOfferIdsResponse
  { getPricesByOfferIdsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getPricesByOfferIdsResponseResult :: !(Maybe OfferPriceByOfferIdsListResponseDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPricesByOfferIdsResponse
instance A.FromJSON GetPricesByOfferIdsResponse where
  parseJSON = A.withObject "GetPricesByOfferIdsResponse" $ \o ->
    GetPricesByOfferIdsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetPricesByOfferIdsResponse
instance A.ToJSON GetPricesByOfferIdsResponse where
  toJSON GetPricesByOfferIdsResponse {..} =
   _omitNulls
      [ "status" .= getPricesByOfferIdsResponseStatus
      , "result" .= getPricesByOfferIdsResponseResult
      ]


-- | Construct a value of type 'GetPricesByOfferIdsResponse' (by applying it's required fields, if any)
mkGetPricesByOfferIdsResponse
  :: GetPricesByOfferIdsResponse
mkGetPricesByOfferIdsResponse =
  GetPricesByOfferIdsResponse
  { getPricesByOfferIdsResponseStatus = Nothing
  , getPricesByOfferIdsResponseResult = Nothing
  }

-- ** GetPricesResponse
-- | GetPricesResponse
-- Ответ на запрос списка цен.
data GetPricesResponse = GetPricesResponse
  { getPricesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getPricesResponseResult :: !(Maybe OfferPriceListResponseDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPricesResponse
instance A.FromJSON GetPricesResponse where
  parseJSON = A.withObject "GetPricesResponse" $ \o ->
    GetPricesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetPricesResponse
instance A.ToJSON GetPricesResponse where
  toJSON GetPricesResponse {..} =
   _omitNulls
      [ "status" .= getPricesResponseStatus
      , "result" .= getPricesResponseResult
      ]


-- | Construct a value of type 'GetPricesResponse' (by applying it's required fields, if any)
mkGetPricesResponse
  :: GetPricesResponse
mkGetPricesResponse =
  GetPricesResponse
  { getPricesResponseStatus = Nothing
  , getPricesResponseResult = Nothing
  }

-- ** GetPromoAssortmentInfoDTO
-- | GetPromoAssortmentInfoDTO
-- Информация о товарах в акции.
data GetPromoAssortmentInfoDTO = GetPromoAssortmentInfoDTO
  { getPromoAssortmentInfoDTOActiveOffers :: !(Int) -- ^ /Required/ "activeOffers" - Количество товаров, которые участвуют или участвовали в акции.  Учитываются только товары, которые были добавлены вручную.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
  , getPromoAssortmentInfoDTOPotentialOffers :: !(Maybe Int) -- ^ "potentialOffers" - Количество доступных товаров в акции.  Параметр возвращается только для текущих и будущих акций. 
  , getPromoAssortmentInfoDTOProcessing :: !(Maybe Bool) -- ^ "processing" - Есть ли изменения в ассортименте, которые еще не применились. Сохранение изменений занимает некоторое время.  Параметр возвращается только для текущих и будущих акций. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoAssortmentInfoDTO
instance A.FromJSON GetPromoAssortmentInfoDTO where
  parseJSON = A.withObject "GetPromoAssortmentInfoDTO" $ \o ->
    GetPromoAssortmentInfoDTO
      <$> (o .:  "activeOffers")
      <*> (o .:? "potentialOffers")
      <*> (o .:? "processing")

-- | ToJSON GetPromoAssortmentInfoDTO
instance A.ToJSON GetPromoAssortmentInfoDTO where
  toJSON GetPromoAssortmentInfoDTO {..} =
   _omitNulls
      [ "activeOffers" .= getPromoAssortmentInfoDTOActiveOffers
      , "potentialOffers" .= getPromoAssortmentInfoDTOPotentialOffers
      , "processing" .= getPromoAssortmentInfoDTOProcessing
      ]


-- | Construct a value of type 'GetPromoAssortmentInfoDTO' (by applying it's required fields, if any)
mkGetPromoAssortmentInfoDTO
  :: Int -- ^ 'getPromoAssortmentInfoDTOActiveOffers': Количество товаров, которые участвуют или участвовали в акции.  Учитываются только товары, которые были добавлены вручную.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
  -> GetPromoAssortmentInfoDTO
mkGetPromoAssortmentInfoDTO getPromoAssortmentInfoDTOActiveOffers =
  GetPromoAssortmentInfoDTO
  { getPromoAssortmentInfoDTOActiveOffers
  , getPromoAssortmentInfoDTOPotentialOffers = Nothing
  , getPromoAssortmentInfoDTOProcessing = Nothing
  }

-- ** GetPromoBestsellerInfoDTO
-- | GetPromoBestsellerInfoDTO
-- Информация об акции «Бестселлеры Маркета».
data GetPromoBestsellerInfoDTO = GetPromoBestsellerInfoDTO
  { getPromoBestsellerInfoDTOBestseller :: !(Bool) -- ^ /Required/ "bestseller" - Является ли акция «Бестселлером Маркета». Подробнее об этой акции читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/bestsellers).
  , getPromoBestsellerInfoDTOEntryDeadline :: !(Maybe DateTime) -- ^ "entryDeadline" - До какой даты можно добавить товар в акцию «Бестселлеры Маркета».  Параметр возвращается только для текущих и будущих акций «Бестселлеры Маркета». 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoBestsellerInfoDTO
instance A.FromJSON GetPromoBestsellerInfoDTO where
  parseJSON = A.withObject "GetPromoBestsellerInfoDTO" $ \o ->
    GetPromoBestsellerInfoDTO
      <$> (o .:  "bestseller")
      <*> (o .:? "entryDeadline")

-- | ToJSON GetPromoBestsellerInfoDTO
instance A.ToJSON GetPromoBestsellerInfoDTO where
  toJSON GetPromoBestsellerInfoDTO {..} =
   _omitNulls
      [ "bestseller" .= getPromoBestsellerInfoDTOBestseller
      , "entryDeadline" .= getPromoBestsellerInfoDTOEntryDeadline
      ]


-- | Construct a value of type 'GetPromoBestsellerInfoDTO' (by applying it's required fields, if any)
mkGetPromoBestsellerInfoDTO
  :: Bool -- ^ 'getPromoBestsellerInfoDTOBestseller': Является ли акция «Бестселлером Маркета». Подробнее об этой акции читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/bestsellers).
  -> GetPromoBestsellerInfoDTO
mkGetPromoBestsellerInfoDTO getPromoBestsellerInfoDTOBestseller =
  GetPromoBestsellerInfoDTO
  { getPromoBestsellerInfoDTOBestseller
  , getPromoBestsellerInfoDTOEntryDeadline = Nothing
  }

-- ** GetPromoConstraintsDTO
-- | GetPromoConstraintsDTO
-- Ограничения в акции.
data GetPromoConstraintsDTO = GetPromoConstraintsDTO
  { getPromoConstraintsDTOWarehouseIds :: !(Maybe [Integer]) -- ^ "warehouseIds" - Идентификаторы складов, для которых действует акция. Товары, которые лежат на других складах, не будут продаваться по акции.  Параметр возвращается, только если в условиях акции есть ограничение по складу. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoConstraintsDTO
instance A.FromJSON GetPromoConstraintsDTO where
  parseJSON = A.withObject "GetPromoConstraintsDTO" $ \o ->
    GetPromoConstraintsDTO
      <$> (o .:? "warehouseIds")

-- | ToJSON GetPromoConstraintsDTO
instance A.ToJSON GetPromoConstraintsDTO where
  toJSON GetPromoConstraintsDTO {..} =
   _omitNulls
      [ "warehouseIds" .= getPromoConstraintsDTOWarehouseIds
      ]


-- | Construct a value of type 'GetPromoConstraintsDTO' (by applying it's required fields, if any)
mkGetPromoConstraintsDTO
  :: GetPromoConstraintsDTO
mkGetPromoConstraintsDTO =
  GetPromoConstraintsDTO
  { getPromoConstraintsDTOWarehouseIds = Nothing
  }

-- ** GetPromoDTO
-- | GetPromoDTO
-- Информация об акции.
data GetPromoDTO = GetPromoDTO
  { getPromoDTOId :: !(Text) -- ^ /Required/ "id" - Идентификатор акции.
  , getPromoDTOName :: !(Text) -- ^ /Required/ "name" - Название акции.
  , getPromoDTOPeriod :: !(PromoPeriodDTO) -- ^ /Required/ "period"
  , getPromoDTOParticipating :: !(Bool) -- ^ /Required/ "participating" - Участвует или участвовал ли продавец в этой акции.  Для текущих и будущих акций возвращается со значением &#x60;true&#x60;, если в акции есть товары, которые были добавлены вручную. Если товары не участвуют в акции или добавлены в нее автоматически, параметр возвращается со значением &#x60;false&#x60;.  Для прошедших акций всегда возвращается со значением &#x60;true&#x60;.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
  , getPromoDTOAssortmentInfo :: !(GetPromoAssortmentInfoDTO) -- ^ /Required/ "assortmentInfo"
  , getPromoDTOMechanicsInfo :: !(GetPromoMechanicsInfoDTO) -- ^ /Required/ "mechanicsInfo"
  , getPromoDTOBestsellerInfo :: !(GetPromoBestsellerInfoDTO) -- ^ /Required/ "bestsellerInfo"
  , getPromoDTOChannels :: !(Maybe [ChannelType]) -- ^ "channels" - Список каналов продвижения товаров.
  , getPromoDTOConstraints :: !(Maybe GetPromoConstraintsDTO) -- ^ "constraints"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoDTO
instance A.FromJSON GetPromoDTO where
  parseJSON = A.withObject "GetPromoDTO" $ \o ->
    GetPromoDTO
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "period")
      <*> (o .:  "participating")
      <*> (o .:  "assortmentInfo")
      <*> (o .:  "mechanicsInfo")
      <*> (o .:  "bestsellerInfo")
      <*> (o .:? "channels")
      <*> (o .:? "constraints")

-- | ToJSON GetPromoDTO
instance A.ToJSON GetPromoDTO where
  toJSON GetPromoDTO {..} =
   _omitNulls
      [ "id" .= getPromoDTOId
      , "name" .= getPromoDTOName
      , "period" .= getPromoDTOPeriod
      , "participating" .= getPromoDTOParticipating
      , "assortmentInfo" .= getPromoDTOAssortmentInfo
      , "mechanicsInfo" .= getPromoDTOMechanicsInfo
      , "bestsellerInfo" .= getPromoDTOBestsellerInfo
      , "channels" .= getPromoDTOChannels
      , "constraints" .= getPromoDTOConstraints
      ]


-- | Construct a value of type 'GetPromoDTO' (by applying it's required fields, if any)
mkGetPromoDTO
  :: Text -- ^ 'getPromoDTOId': Идентификатор акции.
  -> Text -- ^ 'getPromoDTOName': Название акции.
  -> PromoPeriodDTO -- ^ 'getPromoDTOPeriod' 
  -> Bool -- ^ 'getPromoDTOParticipating': Участвует или участвовал ли продавец в этой акции.  Для текущих и будущих акций возвращается со значением `true`, если в акции есть товары, которые были добавлены вручную. Если товары не участвуют в акции или добавлены в нее автоматически, параметр возвращается со значением `false`.  Для прошедших акций всегда возвращается со значением `true`.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
  -> GetPromoAssortmentInfoDTO -- ^ 'getPromoDTOAssortmentInfo' 
  -> GetPromoMechanicsInfoDTO -- ^ 'getPromoDTOMechanicsInfo' 
  -> GetPromoBestsellerInfoDTO -- ^ 'getPromoDTOBestsellerInfo' 
  -> GetPromoDTO
mkGetPromoDTO getPromoDTOId getPromoDTOName getPromoDTOPeriod getPromoDTOParticipating getPromoDTOAssortmentInfo getPromoDTOMechanicsInfo getPromoDTOBestsellerInfo =
  GetPromoDTO
  { getPromoDTOId
  , getPromoDTOName
  , getPromoDTOPeriod
  , getPromoDTOParticipating
  , getPromoDTOAssortmentInfo
  , getPromoDTOMechanicsInfo
  , getPromoDTOBestsellerInfo
  , getPromoDTOChannels = Nothing
  , getPromoDTOConstraints = Nothing
  }

-- ** GetPromoMechanicsInfoDTO
-- | GetPromoMechanicsInfoDTO
-- Информация о типе акции.
data GetPromoMechanicsInfoDTO = GetPromoMechanicsInfoDTO
  { getPromoMechanicsInfoDTOType :: !(MechanicsType) -- ^ /Required/ "type"
  , getPromoMechanicsInfoDTOPromocodeInfo :: !(Maybe GetPromoPromocodeInfoDTO) -- ^ "promocodeInfo"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoMechanicsInfoDTO
instance A.FromJSON GetPromoMechanicsInfoDTO where
  parseJSON = A.withObject "GetPromoMechanicsInfoDTO" $ \o ->
    GetPromoMechanicsInfoDTO
      <$> (o .:  "type")
      <*> (o .:? "promocodeInfo")

-- | ToJSON GetPromoMechanicsInfoDTO
instance A.ToJSON GetPromoMechanicsInfoDTO where
  toJSON GetPromoMechanicsInfoDTO {..} =
   _omitNulls
      [ "type" .= getPromoMechanicsInfoDTOType
      , "promocodeInfo" .= getPromoMechanicsInfoDTOPromocodeInfo
      ]


-- | Construct a value of type 'GetPromoMechanicsInfoDTO' (by applying it's required fields, if any)
mkGetPromoMechanicsInfoDTO
  :: MechanicsType -- ^ 'getPromoMechanicsInfoDTOType' 
  -> GetPromoMechanicsInfoDTO
mkGetPromoMechanicsInfoDTO getPromoMechanicsInfoDTOType =
  GetPromoMechanicsInfoDTO
  { getPromoMechanicsInfoDTOType
  , getPromoMechanicsInfoDTOPromocodeInfo = Nothing
  }

-- ** GetPromoOfferDTO
-- | GetPromoOfferDTO
-- Товар, который участвует или может участвовать в акции.
data GetPromoOfferDTO = GetPromoOfferDTO
  { getPromoOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , getPromoOfferDTOStatus :: !(PromoOfferParticipationStatusType) -- ^ /Required/ "status"
  , getPromoOfferDTOParams :: !(PromoOfferParamsDTO) -- ^ /Required/ "params"
  , getPromoOfferDTOAutoParticipatingDetails :: !(Maybe PromoOfferAutoParticipatingDetailsDTO) -- ^ "autoParticipatingDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoOfferDTO
instance A.FromJSON GetPromoOfferDTO where
  parseJSON = A.withObject "GetPromoOfferDTO" $ \o ->
    GetPromoOfferDTO
      <$> (o .:  "offerId")
      <*> (o .:  "status")
      <*> (o .:  "params")
      <*> (o .:? "autoParticipatingDetails")

-- | ToJSON GetPromoOfferDTO
instance A.ToJSON GetPromoOfferDTO where
  toJSON GetPromoOfferDTO {..} =
   _omitNulls
      [ "offerId" .= getPromoOfferDTOOfferId
      , "status" .= getPromoOfferDTOStatus
      , "params" .= getPromoOfferDTOParams
      , "autoParticipatingDetails" .= getPromoOfferDTOAutoParticipatingDetails
      ]


-- | Construct a value of type 'GetPromoOfferDTO' (by applying it's required fields, if any)
mkGetPromoOfferDTO
  :: Text -- ^ 'getPromoOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> PromoOfferParticipationStatusType -- ^ 'getPromoOfferDTOStatus' 
  -> PromoOfferParamsDTO -- ^ 'getPromoOfferDTOParams' 
  -> GetPromoOfferDTO
mkGetPromoOfferDTO getPromoOfferDTOOfferId getPromoOfferDTOStatus getPromoOfferDTOParams =
  GetPromoOfferDTO
  { getPromoOfferDTOOfferId
  , getPromoOfferDTOStatus
  , getPromoOfferDTOParams
  , getPromoOfferDTOAutoParticipatingDetails = Nothing
  }

-- ** GetPromoOffersRequest
-- | GetPromoOffersRequest
-- Получение списка товаров, которые участвуют или могут участвовать в акции.
data GetPromoOffersRequest = GetPromoOffersRequest
  { getPromoOffersRequestPromoId :: !(Text) -- ^ /Required/ "promoId" - Идентификатор акции.
  , getPromoOffersRequestStatusType :: !(Maybe PromoOfferParticipationStatusFilterType) -- ^ "statusType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoOffersRequest
instance A.FromJSON GetPromoOffersRequest where
  parseJSON = A.withObject "GetPromoOffersRequest" $ \o ->
    GetPromoOffersRequest
      <$> (o .:  "promoId")
      <*> (o .:? "statusType")

-- | ToJSON GetPromoOffersRequest
instance A.ToJSON GetPromoOffersRequest where
  toJSON GetPromoOffersRequest {..} =
   _omitNulls
      [ "promoId" .= getPromoOffersRequestPromoId
      , "statusType" .= getPromoOffersRequestStatusType
      ]


-- | Construct a value of type 'GetPromoOffersRequest' (by applying it's required fields, if any)
mkGetPromoOffersRequest
  :: Text -- ^ 'getPromoOffersRequestPromoId': Идентификатор акции.
  -> GetPromoOffersRequest
mkGetPromoOffersRequest getPromoOffersRequestPromoId =
  GetPromoOffersRequest
  { getPromoOffersRequestPromoId
  , getPromoOffersRequestStatusType = Nothing
  }

-- ** GetPromoOffersResponse
-- | GetPromoOffersResponse
data GetPromoOffersResponse = GetPromoOffersResponse
  { getPromoOffersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getPromoOffersResponseResult :: !(Maybe GetPromoOffersResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoOffersResponse
instance A.FromJSON GetPromoOffersResponse where
  parseJSON = A.withObject "GetPromoOffersResponse" $ \o ->
    GetPromoOffersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetPromoOffersResponse
instance A.ToJSON GetPromoOffersResponse where
  toJSON GetPromoOffersResponse {..} =
   _omitNulls
      [ "status" .= getPromoOffersResponseStatus
      , "result" .= getPromoOffersResponseResult
      ]


-- | Construct a value of type 'GetPromoOffersResponse' (by applying it's required fields, if any)
mkGetPromoOffersResponse
  :: GetPromoOffersResponse
mkGetPromoOffersResponse =
  GetPromoOffersResponse
  { getPromoOffersResponseStatus = Nothing
  , getPromoOffersResponseResult = Nothing
  }

-- ** GetPromoOffersResultDTO
-- | GetPromoOffersResultDTO
-- Список товаров, которые участвуют или могут участвовать в акции.
data GetPromoOffersResultDTO = GetPromoOffersResultDTO
  { getPromoOffersResultDTOOffers :: !([GetPromoOfferDTO]) -- ^ /Required/ "offers" - Товары, которые участвуют или могут участвовать в акции.
  , getPromoOffersResultDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoOffersResultDTO
instance A.FromJSON GetPromoOffersResultDTO where
  parseJSON = A.withObject "GetPromoOffersResultDTO" $ \o ->
    GetPromoOffersResultDTO
      <$> (o .:  "offers")
      <*> (o .:? "paging")

-- | ToJSON GetPromoOffersResultDTO
instance A.ToJSON GetPromoOffersResultDTO where
  toJSON GetPromoOffersResultDTO {..} =
   _omitNulls
      [ "offers" .= getPromoOffersResultDTOOffers
      , "paging" .= getPromoOffersResultDTOPaging
      ]


-- | Construct a value of type 'GetPromoOffersResultDTO' (by applying it's required fields, if any)
mkGetPromoOffersResultDTO
  :: [GetPromoOfferDTO] -- ^ 'getPromoOffersResultDTOOffers': Товары, которые участвуют или могут участвовать в акции.
  -> GetPromoOffersResultDTO
mkGetPromoOffersResultDTO getPromoOffersResultDTOOffers =
  GetPromoOffersResultDTO
  { getPromoOffersResultDTOOffers
  , getPromoOffersResultDTOPaging = Nothing
  }

-- ** GetPromoPromocodeInfoDTO
-- | GetPromoPromocodeInfoDTO
-- Информация для типа `MARKET_PROMOCODE`.  Параметр заполняется только для этого типа акции. 
data GetPromoPromocodeInfoDTO = GetPromoPromocodeInfoDTO
  { getPromoPromocodeInfoDTOPromocode :: !(Text) -- ^ /Required/ "promocode" - Промокод.
  , getPromoPromocodeInfoDTODiscount :: !(Int) -- ^ /Required/ "discount" - Процент скидки по промокоду.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromoPromocodeInfoDTO
instance A.FromJSON GetPromoPromocodeInfoDTO where
  parseJSON = A.withObject "GetPromoPromocodeInfoDTO" $ \o ->
    GetPromoPromocodeInfoDTO
      <$> (o .:  "promocode")
      <*> (o .:  "discount")

-- | ToJSON GetPromoPromocodeInfoDTO
instance A.ToJSON GetPromoPromocodeInfoDTO where
  toJSON GetPromoPromocodeInfoDTO {..} =
   _omitNulls
      [ "promocode" .= getPromoPromocodeInfoDTOPromocode
      , "discount" .= getPromoPromocodeInfoDTODiscount
      ]


-- | Construct a value of type 'GetPromoPromocodeInfoDTO' (by applying it's required fields, if any)
mkGetPromoPromocodeInfoDTO
  :: Text -- ^ 'getPromoPromocodeInfoDTOPromocode': Промокод.
  -> Int -- ^ 'getPromoPromocodeInfoDTODiscount': Процент скидки по промокоду.
  -> GetPromoPromocodeInfoDTO
mkGetPromoPromocodeInfoDTO getPromoPromocodeInfoDTOPromocode getPromoPromocodeInfoDTODiscount =
  GetPromoPromocodeInfoDTO
  { getPromoPromocodeInfoDTOPromocode
  , getPromoPromocodeInfoDTODiscount
  }

-- ** GetPromosRequest
-- | GetPromosRequest
-- Фильтры для получения списка акций.
data GetPromosRequest = GetPromosRequest
  { getPromosRequestParticipation :: !(Maybe PromoParticipationType) -- ^ "participation"
  , getPromosRequestMechanics :: !(Maybe MechanicsType) -- ^ "mechanics"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromosRequest
instance A.FromJSON GetPromosRequest where
  parseJSON = A.withObject "GetPromosRequest" $ \o ->
    GetPromosRequest
      <$> (o .:? "participation")
      <*> (o .:? "mechanics")

-- | ToJSON GetPromosRequest
instance A.ToJSON GetPromosRequest where
  toJSON GetPromosRequest {..} =
   _omitNulls
      [ "participation" .= getPromosRequestParticipation
      , "mechanics" .= getPromosRequestMechanics
      ]


-- | Construct a value of type 'GetPromosRequest' (by applying it's required fields, if any)
mkGetPromosRequest
  :: GetPromosRequest
mkGetPromosRequest =
  GetPromosRequest
  { getPromosRequestParticipation = Nothing
  , getPromosRequestMechanics = Nothing
  }

-- ** GetPromosResponse
-- | GetPromosResponse
data GetPromosResponse = GetPromosResponse
  { getPromosResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getPromosResponseResult :: !(Maybe GetPromosResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromosResponse
instance A.FromJSON GetPromosResponse where
  parseJSON = A.withObject "GetPromosResponse" $ \o ->
    GetPromosResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetPromosResponse
instance A.ToJSON GetPromosResponse where
  toJSON GetPromosResponse {..} =
   _omitNulls
      [ "status" .= getPromosResponseStatus
      , "result" .= getPromosResponseResult
      ]


-- | Construct a value of type 'GetPromosResponse' (by applying it's required fields, if any)
mkGetPromosResponse
  :: GetPromosResponse
mkGetPromosResponse =
  GetPromosResponse
  { getPromosResponseStatus = Nothing
  , getPromosResponseResult = Nothing
  }

-- ** GetPromosResultDTO
-- | GetPromosResultDTO
-- Информация об акциях Маркета.
data GetPromosResultDTO = GetPromosResultDTO
  { getPromosResultDTOPromos :: !([GetPromoDTO]) -- ^ /Required/ "promos" - Акции Маркета.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetPromosResultDTO
instance A.FromJSON GetPromosResultDTO where
  parseJSON = A.withObject "GetPromosResultDTO" $ \o ->
    GetPromosResultDTO
      <$> (o .:  "promos")

-- | ToJSON GetPromosResultDTO
instance A.ToJSON GetPromosResultDTO where
  toJSON GetPromosResultDTO {..} =
   _omitNulls
      [ "promos" .= getPromosResultDTOPromos
      ]


-- | Construct a value of type 'GetPromosResultDTO' (by applying it's required fields, if any)
mkGetPromosResultDTO
  :: [GetPromoDTO] -- ^ 'getPromosResultDTOPromos': Акции Маркета.
  -> GetPromosResultDTO
mkGetPromosResultDTO getPromosResultDTOPromos =
  GetPromosResultDTO
  { getPromosResultDTOPromos
  }

-- ** GetQualityRatingDetailsResponse
-- | GetQualityRatingDetailsResponse
data GetQualityRatingDetailsResponse = GetQualityRatingDetailsResponse
  { getQualityRatingDetailsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getQualityRatingDetailsResponseResult :: !(Maybe QualityRatingDetailsDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetQualityRatingDetailsResponse
instance A.FromJSON GetQualityRatingDetailsResponse where
  parseJSON = A.withObject "GetQualityRatingDetailsResponse" $ \o ->
    GetQualityRatingDetailsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetQualityRatingDetailsResponse
instance A.ToJSON GetQualityRatingDetailsResponse where
  toJSON GetQualityRatingDetailsResponse {..} =
   _omitNulls
      [ "status" .= getQualityRatingDetailsResponseStatus
      , "result" .= getQualityRatingDetailsResponseResult
      ]


-- | Construct a value of type 'GetQualityRatingDetailsResponse' (by applying it's required fields, if any)
mkGetQualityRatingDetailsResponse
  :: GetQualityRatingDetailsResponse
mkGetQualityRatingDetailsResponse =
  GetQualityRatingDetailsResponse
  { getQualityRatingDetailsResponseStatus = Nothing
  , getQualityRatingDetailsResponseResult = Nothing
  }

-- ** GetQualityRatingRequest
-- | GetQualityRatingRequest
-- Запрос информации по индексу качества.
data GetQualityRatingRequest = GetQualityRatingRequest
  { getQualityRatingRequestDateFrom :: !(Maybe Date) -- ^ "dateFrom" - Начало периода.  Формат даты: &#x60;ГГГГ‑ММ‑ДД&#x60;.  Не может быть раньше 30 дней от текущей даты. 
  , getQualityRatingRequestDateTo :: !(Maybe Date) -- ^ "dateTo" - Конец периода.  Формат даты: &#x60;ГГГГ‑ММ‑ДД&#x60;.  Не может быть позже текущей даты. 
  , getQualityRatingRequestCampaignIds :: !([Integer]) -- ^ /Required/ "campaignIds" - Список идентификаторов магазинов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetQualityRatingRequest
instance A.FromJSON GetQualityRatingRequest where
  parseJSON = A.withObject "GetQualityRatingRequest" $ \o ->
    GetQualityRatingRequest
      <$> (o .:? "dateFrom")
      <*> (o .:? "dateTo")
      <*> (o .:  "campaignIds")

-- | ToJSON GetQualityRatingRequest
instance A.ToJSON GetQualityRatingRequest where
  toJSON GetQualityRatingRequest {..} =
   _omitNulls
      [ "dateFrom" .= getQualityRatingRequestDateFrom
      , "dateTo" .= getQualityRatingRequestDateTo
      , "campaignIds" .= getQualityRatingRequestCampaignIds
      ]


-- | Construct a value of type 'GetQualityRatingRequest' (by applying it's required fields, if any)
mkGetQualityRatingRequest
  :: [Integer] -- ^ 'getQualityRatingRequestCampaignIds': Список идентификаторов магазинов.
  -> GetQualityRatingRequest
mkGetQualityRatingRequest getQualityRatingRequestCampaignIds =
  GetQualityRatingRequest
  { getQualityRatingRequestDateFrom = Nothing
  , getQualityRatingRequestDateTo = Nothing
  , getQualityRatingRequestCampaignIds
  }

-- ** GetQualityRatingResponse
-- | GetQualityRatingResponse
-- Информация об индексе качества магазинов.
data GetQualityRatingResponse = GetQualityRatingResponse
  { getQualityRatingResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getQualityRatingResponseResult :: !(Maybe CampaignsQualityRatingDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetQualityRatingResponse
instance A.FromJSON GetQualityRatingResponse where
  parseJSON = A.withObject "GetQualityRatingResponse" $ \o ->
    GetQualityRatingResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetQualityRatingResponse
instance A.ToJSON GetQualityRatingResponse where
  toJSON GetQualityRatingResponse {..} =
   _omitNulls
      [ "status" .= getQualityRatingResponseStatus
      , "result" .= getQualityRatingResponseResult
      ]


-- | Construct a value of type 'GetQualityRatingResponse' (by applying it's required fields, if any)
mkGetQualityRatingResponse
  :: GetQualityRatingResponse
mkGetQualityRatingResponse =
  GetQualityRatingResponse
  { getQualityRatingResponseStatus = Nothing
  , getQualityRatingResponseResult = Nothing
  }

-- ** GetQuarantineOffersRequest
-- | GetQuarantineOffersRequest
-- Фильтрации товаров  В запросе можно указать либо фильтр offerIds, либо любые другие фильтры товаров. Совместное использование фильтра offerIds с другими фильтрациями приведет к ошибке. 
data GetQuarantineOffersRequest = GetQuarantineOffersRequest
  { getQuarantineOffersRequestOfferIds :: !(Maybe [Text]) -- ^ "offerIds" - Идентификаторы товаров, информация о которых нужна. &lt;br&gt;&lt;br&gt; ⚠️ Не используйте это поле одновременно с фильтрами по статусам карточек, категориям, брендам или тегам. Если вы хотите воспользоваться фильтрами, оставьте поле пустым. 
  , getQuarantineOffersRequestCardStatuses :: !(Maybe [OfferCardStatusType]) -- ^ "cardStatuses" - Фильтр по статусам карточек.  [Что такое карточка товара](https://yandex.ru/support/marketplace/assortment/content/index.html) 
  , getQuarantineOffersRequestCategoryIds :: !(Maybe [Int]) -- ^ "categoryIds" - Фильтр по категориям на Маркете.
  , getQuarantineOffersRequestVendorNames :: !(Maybe [Text]) -- ^ "vendorNames" - Фильтр по брендам.
  , getQuarantineOffersRequestTags :: !(Maybe [Text]) -- ^ "tags" - Фильтр по тегам.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetQuarantineOffersRequest
instance A.FromJSON GetQuarantineOffersRequest where
  parseJSON = A.withObject "GetQuarantineOffersRequest" $ \o ->
    GetQuarantineOffersRequest
      <$> (o .:? "offerIds")
      <*> (o .:? "cardStatuses")
      <*> (o .:? "categoryIds")
      <*> (o .:? "vendorNames")
      <*> (o .:? "tags")

-- | ToJSON GetQuarantineOffersRequest
instance A.ToJSON GetQuarantineOffersRequest where
  toJSON GetQuarantineOffersRequest {..} =
   _omitNulls
      [ "offerIds" .= getQuarantineOffersRequestOfferIds
      , "cardStatuses" .= getQuarantineOffersRequestCardStatuses
      , "categoryIds" .= getQuarantineOffersRequestCategoryIds
      , "vendorNames" .= getQuarantineOffersRequestVendorNames
      , "tags" .= getQuarantineOffersRequestTags
      ]


-- | Construct a value of type 'GetQuarantineOffersRequest' (by applying it's required fields, if any)
mkGetQuarantineOffersRequest
  :: GetQuarantineOffersRequest
mkGetQuarantineOffersRequest =
  GetQuarantineOffersRequest
  { getQuarantineOffersRequestOfferIds = Nothing
  , getQuarantineOffersRequestCardStatuses = Nothing
  , getQuarantineOffersRequestCategoryIds = Nothing
  , getQuarantineOffersRequestVendorNames = Nothing
  , getQuarantineOffersRequestTags = Nothing
  }

-- ** GetQuarantineOffersResponse
-- | GetQuarantineOffersResponse
-- Ответ на запрос списка товаров в карантине.
data GetQuarantineOffersResponse = GetQuarantineOffersResponse
  { getQuarantineOffersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getQuarantineOffersResponseResult :: !(Maybe GetQuarantineOffersResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetQuarantineOffersResponse
instance A.FromJSON GetQuarantineOffersResponse where
  parseJSON = A.withObject "GetQuarantineOffersResponse" $ \o ->
    GetQuarantineOffersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetQuarantineOffersResponse
instance A.ToJSON GetQuarantineOffersResponse where
  toJSON GetQuarantineOffersResponse {..} =
   _omitNulls
      [ "status" .= getQuarantineOffersResponseStatus
      , "result" .= getQuarantineOffersResponseResult
      ]


-- | Construct a value of type 'GetQuarantineOffersResponse' (by applying it's required fields, if any)
mkGetQuarantineOffersResponse
  :: GetQuarantineOffersResponse
mkGetQuarantineOffersResponse =
  GetQuarantineOffersResponse
  { getQuarantineOffersResponseStatus = Nothing
  , getQuarantineOffersResponseResult = Nothing
  }

-- ** GetQuarantineOffersResultDTO
-- | GetQuarantineOffersResultDTO
-- Список товаров в карантине.
data GetQuarantineOffersResultDTO = GetQuarantineOffersResultDTO
  { getQuarantineOffersResultDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , getQuarantineOffersResultDTOOffers :: !([QuarantineOfferDTO]) -- ^ /Required/ "offers" - Страница списка товаров в карантине.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetQuarantineOffersResultDTO
instance A.FromJSON GetQuarantineOffersResultDTO where
  parseJSON = A.withObject "GetQuarantineOffersResultDTO" $ \o ->
    GetQuarantineOffersResultDTO
      <$> (o .:? "paging")
      <*> (o .:  "offers")

-- | ToJSON GetQuarantineOffersResultDTO
instance A.ToJSON GetQuarantineOffersResultDTO where
  toJSON GetQuarantineOffersResultDTO {..} =
   _omitNulls
      [ "paging" .= getQuarantineOffersResultDTOPaging
      , "offers" .= getQuarantineOffersResultDTOOffers
      ]


-- | Construct a value of type 'GetQuarantineOffersResultDTO' (by applying it's required fields, if any)
mkGetQuarantineOffersResultDTO
  :: [QuarantineOfferDTO] -- ^ 'getQuarantineOffersResultDTOOffers': Страница списка товаров в карантине.
  -> GetQuarantineOffersResultDTO
mkGetQuarantineOffersResultDTO getQuarantineOffersResultDTOOffers =
  GetQuarantineOffersResultDTO
  { getQuarantineOffersResultDTOPaging = Nothing
  , getQuarantineOffersResultDTOOffers
  }

-- ** GetRegionWithChildrenResponse
-- | GetRegionWithChildrenResponse
data GetRegionWithChildrenResponse = GetRegionWithChildrenResponse
  { getRegionWithChildrenResponsePager :: !(Maybe FlippingPagerDTO) -- ^ "pager"
  , getRegionWithChildrenResponseRegions :: !(Maybe RegionDTO) -- ^ "regions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRegionWithChildrenResponse
instance A.FromJSON GetRegionWithChildrenResponse where
  parseJSON = A.withObject "GetRegionWithChildrenResponse" $ \o ->
    GetRegionWithChildrenResponse
      <$> (o .:? "pager")
      <*> (o .:? "regions")

-- | ToJSON GetRegionWithChildrenResponse
instance A.ToJSON GetRegionWithChildrenResponse where
  toJSON GetRegionWithChildrenResponse {..} =
   _omitNulls
      [ "pager" .= getRegionWithChildrenResponsePager
      , "regions" .= getRegionWithChildrenResponseRegions
      ]


-- | Construct a value of type 'GetRegionWithChildrenResponse' (by applying it's required fields, if any)
mkGetRegionWithChildrenResponse
  :: GetRegionWithChildrenResponse
mkGetRegionWithChildrenResponse =
  GetRegionWithChildrenResponse
  { getRegionWithChildrenResponsePager = Nothing
  , getRegionWithChildrenResponseRegions = Nothing
  }

-- ** GetRegionsResponse
-- | GetRegionsResponse
data GetRegionsResponse = GetRegionsResponse
  { getRegionsResponseRegions :: !([RegionDTO]) -- ^ /Required/ "regions" - Регион доставки.
  , getRegionsResponsePaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRegionsResponse
instance A.FromJSON GetRegionsResponse where
  parseJSON = A.withObject "GetRegionsResponse" $ \o ->
    GetRegionsResponse
      <$> (o .:  "regions")
      <*> (o .:? "paging")

-- | ToJSON GetRegionsResponse
instance A.ToJSON GetRegionsResponse where
  toJSON GetRegionsResponse {..} =
   _omitNulls
      [ "regions" .= getRegionsResponseRegions
      , "paging" .= getRegionsResponsePaging
      ]


-- | Construct a value of type 'GetRegionsResponse' (by applying it's required fields, if any)
mkGetRegionsResponse
  :: [RegionDTO] -- ^ 'getRegionsResponseRegions': Регион доставки.
  -> GetRegionsResponse
mkGetRegionsResponse getRegionsResponseRegions =
  GetRegionsResponse
  { getRegionsResponseRegions
  , getRegionsResponsePaging = Nothing
  }

-- ** GetReportInfoResponse
-- | GetReportInfoResponse
-- Ответ на запрос информации об отчете.
data GetReportInfoResponse = GetReportInfoResponse
  { getReportInfoResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getReportInfoResponseResult :: !(Maybe ReportInfoDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetReportInfoResponse
instance A.FromJSON GetReportInfoResponse where
  parseJSON = A.withObject "GetReportInfoResponse" $ \o ->
    GetReportInfoResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetReportInfoResponse
instance A.ToJSON GetReportInfoResponse where
  toJSON GetReportInfoResponse {..} =
   _omitNulls
      [ "status" .= getReportInfoResponseStatus
      , "result" .= getReportInfoResponseResult
      ]


-- | Construct a value of type 'GetReportInfoResponse' (by applying it's required fields, if any)
mkGetReportInfoResponse
  :: GetReportInfoResponse
mkGetReportInfoResponse =
  GetReportInfoResponse
  { getReportInfoResponseStatus = Nothing
  , getReportInfoResponseResult = Nothing
  }

-- ** GetReturnResponse
-- | GetReturnResponse
data GetReturnResponse = GetReturnResponse
  { getReturnResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getReturnResponseResult :: !(Maybe ReturnDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetReturnResponse
instance A.FromJSON GetReturnResponse where
  parseJSON = A.withObject "GetReturnResponse" $ \o ->
    GetReturnResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetReturnResponse
instance A.ToJSON GetReturnResponse where
  toJSON GetReturnResponse {..} =
   _omitNulls
      [ "status" .= getReturnResponseStatus
      , "result" .= getReturnResponseResult
      ]


-- | Construct a value of type 'GetReturnResponse' (by applying it's required fields, if any)
mkGetReturnResponse
  :: GetReturnResponse
mkGetReturnResponse =
  GetReturnResponse
  { getReturnResponseStatus = Nothing
  , getReturnResponseResult = Nothing
  }

-- ** GetReturnsResponse
-- | GetReturnsResponse
data GetReturnsResponse = GetReturnsResponse
  { getReturnsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getReturnsResponseResult :: !(Maybe PagedReturnsDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetReturnsResponse
instance A.FromJSON GetReturnsResponse where
  parseJSON = A.withObject "GetReturnsResponse" $ \o ->
    GetReturnsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetReturnsResponse
instance A.ToJSON GetReturnsResponse where
  toJSON GetReturnsResponse {..} =
   _omitNulls
      [ "status" .= getReturnsResponseStatus
      , "result" .= getReturnsResponseResult
      ]


-- | Construct a value of type 'GetReturnsResponse' (by applying it's required fields, if any)
mkGetReturnsResponse
  :: GetReturnsResponse
mkGetReturnsResponse =
  GetReturnsResponse
  { getReturnsResponseStatus = Nothing
  , getReturnsResponseResult = Nothing
  }

-- ** GetShipmentOrdersInfoResponse
-- | GetShipmentOrdersInfoResponse
data GetShipmentOrdersInfoResponse = GetShipmentOrdersInfoResponse
  { getShipmentOrdersInfoResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getShipmentOrdersInfoResponseResult :: !(Maybe OrdersShipmentInfoDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetShipmentOrdersInfoResponse
instance A.FromJSON GetShipmentOrdersInfoResponse where
  parseJSON = A.withObject "GetShipmentOrdersInfoResponse" $ \o ->
    GetShipmentOrdersInfoResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetShipmentOrdersInfoResponse
instance A.ToJSON GetShipmentOrdersInfoResponse where
  toJSON GetShipmentOrdersInfoResponse {..} =
   _omitNulls
      [ "status" .= getShipmentOrdersInfoResponseStatus
      , "result" .= getShipmentOrdersInfoResponseResult
      ]


-- | Construct a value of type 'GetShipmentOrdersInfoResponse' (by applying it's required fields, if any)
mkGetShipmentOrdersInfoResponse
  :: GetShipmentOrdersInfoResponse
mkGetShipmentOrdersInfoResponse =
  GetShipmentOrdersInfoResponse
  { getShipmentOrdersInfoResponseStatus = Nothing
  , getShipmentOrdersInfoResponseResult = Nothing
  }

-- ** GetShipmentResponse
-- | GetShipmentResponse
data GetShipmentResponse = GetShipmentResponse
  { getShipmentResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getShipmentResponseResult :: !(Maybe ShipmentDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetShipmentResponse
instance A.FromJSON GetShipmentResponse where
  parseJSON = A.withObject "GetShipmentResponse" $ \o ->
    GetShipmentResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetShipmentResponse
instance A.ToJSON GetShipmentResponse where
  toJSON GetShipmentResponse {..} =
   _omitNulls
      [ "status" .= getShipmentResponseStatus
      , "result" .= getShipmentResponseResult
      ]


-- | Construct a value of type 'GetShipmentResponse' (by applying it's required fields, if any)
mkGetShipmentResponse
  :: GetShipmentResponse
mkGetShipmentResponse =
  GetShipmentResponse
  { getShipmentResponseStatus = Nothing
  , getShipmentResponseResult = Nothing
  }

-- ** GetSuggestedOfferMappingEntriesRequest
-- | GetSuggestedOfferMappingEntriesRequest
-- Запрос рекомендованных карточек товара.
data GetSuggestedOfferMappingEntriesRequest = GetSuggestedOfferMappingEntriesRequest
  { getSuggestedOfferMappingEntriesRequestOffers :: !([MappingsOfferDTO]) -- ^ /Required/ "offers" - Список товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSuggestedOfferMappingEntriesRequest
instance A.FromJSON GetSuggestedOfferMappingEntriesRequest where
  parseJSON = A.withObject "GetSuggestedOfferMappingEntriesRequest" $ \o ->
    GetSuggestedOfferMappingEntriesRequest
      <$> (o .:  "offers")

-- | ToJSON GetSuggestedOfferMappingEntriesRequest
instance A.ToJSON GetSuggestedOfferMappingEntriesRequest where
  toJSON GetSuggestedOfferMappingEntriesRequest {..} =
   _omitNulls
      [ "offers" .= getSuggestedOfferMappingEntriesRequestOffers
      ]


-- | Construct a value of type 'GetSuggestedOfferMappingEntriesRequest' (by applying it's required fields, if any)
mkGetSuggestedOfferMappingEntriesRequest
  :: [MappingsOfferDTO] -- ^ 'getSuggestedOfferMappingEntriesRequestOffers': Список товаров.
  -> GetSuggestedOfferMappingEntriesRequest
mkGetSuggestedOfferMappingEntriesRequest getSuggestedOfferMappingEntriesRequestOffers =
  GetSuggestedOfferMappingEntriesRequest
  { getSuggestedOfferMappingEntriesRequestOffers
  }

-- ** GetSuggestedOfferMappingEntriesResponse
-- | GetSuggestedOfferMappingEntriesResponse
-- Ответ со списком рекомендованных карточек товара.
data GetSuggestedOfferMappingEntriesResponse = GetSuggestedOfferMappingEntriesResponse
  { getSuggestedOfferMappingEntriesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getSuggestedOfferMappingEntriesResponseResult :: !(Maybe OfferMappingSuggestionsListDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSuggestedOfferMappingEntriesResponse
instance A.FromJSON GetSuggestedOfferMappingEntriesResponse where
  parseJSON = A.withObject "GetSuggestedOfferMappingEntriesResponse" $ \o ->
    GetSuggestedOfferMappingEntriesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetSuggestedOfferMappingEntriesResponse
instance A.ToJSON GetSuggestedOfferMappingEntriesResponse where
  toJSON GetSuggestedOfferMappingEntriesResponse {..} =
   _omitNulls
      [ "status" .= getSuggestedOfferMappingEntriesResponseStatus
      , "result" .= getSuggestedOfferMappingEntriesResponseResult
      ]


-- | Construct a value of type 'GetSuggestedOfferMappingEntriesResponse' (by applying it's required fields, if any)
mkGetSuggestedOfferMappingEntriesResponse
  :: GetSuggestedOfferMappingEntriesResponse
mkGetSuggestedOfferMappingEntriesResponse =
  GetSuggestedOfferMappingEntriesResponse
  { getSuggestedOfferMappingEntriesResponseStatus = Nothing
  , getSuggestedOfferMappingEntriesResponseResult = Nothing
  }

-- ** GetSuggestedOfferMappingsRequest
-- | GetSuggestedOfferMappingsRequest
data GetSuggestedOfferMappingsRequest = GetSuggestedOfferMappingsRequest
  { getSuggestedOfferMappingsRequestOffers :: !(Maybe [SuggestedOfferDTO]) -- ^ "offers" - Список товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSuggestedOfferMappingsRequest
instance A.FromJSON GetSuggestedOfferMappingsRequest where
  parseJSON = A.withObject "GetSuggestedOfferMappingsRequest" $ \o ->
    GetSuggestedOfferMappingsRequest
      <$> (o .:? "offers")

-- | ToJSON GetSuggestedOfferMappingsRequest
instance A.ToJSON GetSuggestedOfferMappingsRequest where
  toJSON GetSuggestedOfferMappingsRequest {..} =
   _omitNulls
      [ "offers" .= getSuggestedOfferMappingsRequestOffers
      ]


-- | Construct a value of type 'GetSuggestedOfferMappingsRequest' (by applying it's required fields, if any)
mkGetSuggestedOfferMappingsRequest
  :: GetSuggestedOfferMappingsRequest
mkGetSuggestedOfferMappingsRequest =
  GetSuggestedOfferMappingsRequest
  { getSuggestedOfferMappingsRequestOffers = Nothing
  }

-- ** GetSuggestedOfferMappingsResponse
-- | GetSuggestedOfferMappingsResponse
data GetSuggestedOfferMappingsResponse = GetSuggestedOfferMappingsResponse
  { getSuggestedOfferMappingsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getSuggestedOfferMappingsResponseResult :: !(Maybe GetSuggestedOfferMappingsResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSuggestedOfferMappingsResponse
instance A.FromJSON GetSuggestedOfferMappingsResponse where
  parseJSON = A.withObject "GetSuggestedOfferMappingsResponse" $ \o ->
    GetSuggestedOfferMappingsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetSuggestedOfferMappingsResponse
instance A.ToJSON GetSuggestedOfferMappingsResponse where
  toJSON GetSuggestedOfferMappingsResponse {..} =
   _omitNulls
      [ "status" .= getSuggestedOfferMappingsResponseStatus
      , "result" .= getSuggestedOfferMappingsResponseResult
      ]


-- | Construct a value of type 'GetSuggestedOfferMappingsResponse' (by applying it's required fields, if any)
mkGetSuggestedOfferMappingsResponse
  :: GetSuggestedOfferMappingsResponse
mkGetSuggestedOfferMappingsResponse =
  GetSuggestedOfferMappingsResponse
  { getSuggestedOfferMappingsResponseStatus = Nothing
  , getSuggestedOfferMappingsResponseResult = Nothing
  }

-- ** GetSuggestedOfferMappingsResultDTO
-- | GetSuggestedOfferMappingsResultDTO
-- Подобранные карточки на Маркете.
data GetSuggestedOfferMappingsResultDTO = GetSuggestedOfferMappingsResultDTO
  { getSuggestedOfferMappingsResultDTOOffers :: !([SuggestedOfferMappingDTO]) -- ^ /Required/ "offers" - Список товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSuggestedOfferMappingsResultDTO
instance A.FromJSON GetSuggestedOfferMappingsResultDTO where
  parseJSON = A.withObject "GetSuggestedOfferMappingsResultDTO" $ \o ->
    GetSuggestedOfferMappingsResultDTO
      <$> (o .:  "offers")

-- | ToJSON GetSuggestedOfferMappingsResultDTO
instance A.ToJSON GetSuggestedOfferMappingsResultDTO where
  toJSON GetSuggestedOfferMappingsResultDTO {..} =
   _omitNulls
      [ "offers" .= getSuggestedOfferMappingsResultDTOOffers
      ]


-- | Construct a value of type 'GetSuggestedOfferMappingsResultDTO' (by applying it's required fields, if any)
mkGetSuggestedOfferMappingsResultDTO
  :: [SuggestedOfferMappingDTO] -- ^ 'getSuggestedOfferMappingsResultDTOOffers': Список товаров.
  -> GetSuggestedOfferMappingsResultDTO
mkGetSuggestedOfferMappingsResultDTO getSuggestedOfferMappingsResultDTOOffers =
  GetSuggestedOfferMappingsResultDTO
  { getSuggestedOfferMappingsResultDTOOffers
  }

-- ** GetWarehouseStocksDTO
-- | GetWarehouseStocksDTO
-- Список складов с информацией об остатках на каждом из них.
data GetWarehouseStocksDTO = GetWarehouseStocksDTO
  { getWarehouseStocksDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , getWarehouseStocksDTOWarehouses :: !([WarehouseOffersDTO]) -- ^ /Required/ "warehouses" - Страница списка складов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWarehouseStocksDTO
instance A.FromJSON GetWarehouseStocksDTO where
  parseJSON = A.withObject "GetWarehouseStocksDTO" $ \o ->
    GetWarehouseStocksDTO
      <$> (o .:? "paging")
      <*> (o .:  "warehouses")

-- | ToJSON GetWarehouseStocksDTO
instance A.ToJSON GetWarehouseStocksDTO where
  toJSON GetWarehouseStocksDTO {..} =
   _omitNulls
      [ "paging" .= getWarehouseStocksDTOPaging
      , "warehouses" .= getWarehouseStocksDTOWarehouses
      ]


-- | Construct a value of type 'GetWarehouseStocksDTO' (by applying it's required fields, if any)
mkGetWarehouseStocksDTO
  :: [WarehouseOffersDTO] -- ^ 'getWarehouseStocksDTOWarehouses': Страница списка складов.
  -> GetWarehouseStocksDTO
mkGetWarehouseStocksDTO getWarehouseStocksDTOWarehouses =
  GetWarehouseStocksDTO
  { getWarehouseStocksDTOPaging = Nothing
  , getWarehouseStocksDTOWarehouses
  }

-- ** GetWarehouseStocksRequest
-- | GetWarehouseStocksRequest
-- Фильтры для запроса остатков. 
data GetWarehouseStocksRequest = GetWarehouseStocksRequest
  { getWarehouseStocksRequestWithTurnover :: !(Maybe Bool) -- ^ "withTurnover" - **Только для модели FBY**  Возвращать ли информацию по оборачиваемости.  Значение по умолчанию — &#x60;false&#x60;. Если информация нужна, передайте значение &#x60;true&#x60;. 
  , getWarehouseStocksRequestArchived :: !(Maybe Bool) -- ^ "archived" - Фильтр по нахождению в архиве.  Передайте &#x60;true&#x60;, чтобы получить информацию об остатках товаров, которые находятся в архиве. Если фильтр не заполнен или передано &#x60;false&#x60;, в ответе возвращается информация о товарах, которые не находятся в архиве. 
  , getWarehouseStocksRequestOfferIds :: !(Maybe [Text]) -- ^ "offerIds" - Фильтр по вашим SKU товаров.  Возвращается информация об остатках всех переданных SKU, включая товары в архиве.  {% note warning \&quot;Такой список возвращается только целиком\&quot; %}  Если вы запрашиваете информацию по конкретным SKU, не заполняйте:  * &#x60;page_token&#x60; * &#x60;limit&#x60; * &#x60;archived&#x60;  {% endnote %}    
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWarehouseStocksRequest
instance A.FromJSON GetWarehouseStocksRequest where
  parseJSON = A.withObject "GetWarehouseStocksRequest" $ \o ->
    GetWarehouseStocksRequest
      <$> (o .:? "withTurnover")
      <*> (o .:? "archived")
      <*> (o .:? "offerIds")

-- | ToJSON GetWarehouseStocksRequest
instance A.ToJSON GetWarehouseStocksRequest where
  toJSON GetWarehouseStocksRequest {..} =
   _omitNulls
      [ "withTurnover" .= getWarehouseStocksRequestWithTurnover
      , "archived" .= getWarehouseStocksRequestArchived
      , "offerIds" .= getWarehouseStocksRequestOfferIds
      ]


-- | Construct a value of type 'GetWarehouseStocksRequest' (by applying it's required fields, if any)
mkGetWarehouseStocksRequest
  :: GetWarehouseStocksRequest
mkGetWarehouseStocksRequest =
  GetWarehouseStocksRequest
  { getWarehouseStocksRequestWithTurnover = Nothing
  , getWarehouseStocksRequestArchived = Nothing
  , getWarehouseStocksRequestOfferIds = Nothing
  }

-- ** GetWarehouseStocksResponse
-- | GetWarehouseStocksResponse
data GetWarehouseStocksResponse = GetWarehouseStocksResponse
  { getWarehouseStocksResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getWarehouseStocksResponseResult :: !(Maybe GetWarehouseStocksDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWarehouseStocksResponse
instance A.FromJSON GetWarehouseStocksResponse where
  parseJSON = A.withObject "GetWarehouseStocksResponse" $ \o ->
    GetWarehouseStocksResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetWarehouseStocksResponse
instance A.ToJSON GetWarehouseStocksResponse where
  toJSON GetWarehouseStocksResponse {..} =
   _omitNulls
      [ "status" .= getWarehouseStocksResponseStatus
      , "result" .= getWarehouseStocksResponseResult
      ]


-- | Construct a value of type 'GetWarehouseStocksResponse' (by applying it's required fields, if any)
mkGetWarehouseStocksResponse
  :: GetWarehouseStocksResponse
mkGetWarehouseStocksResponse =
  GetWarehouseStocksResponse
  { getWarehouseStocksResponseStatus = Nothing
  , getWarehouseStocksResponseResult = Nothing
  }

-- ** GetWarehousesResponse
-- | GetWarehousesResponse
data GetWarehousesResponse = GetWarehousesResponse
  { getWarehousesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , getWarehousesResponseResult :: !(Maybe WarehousesDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWarehousesResponse
instance A.FromJSON GetWarehousesResponse where
  parseJSON = A.withObject "GetWarehousesResponse" $ \o ->
    GetWarehousesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON GetWarehousesResponse
instance A.ToJSON GetWarehousesResponse where
  toJSON GetWarehousesResponse {..} =
   _omitNulls
      [ "status" .= getWarehousesResponseStatus
      , "result" .= getWarehousesResponseResult
      ]


-- | Construct a value of type 'GetWarehousesResponse' (by applying it's required fields, if any)
mkGetWarehousesResponse
  :: GetWarehousesResponse
mkGetWarehousesResponse =
  GetWarehousesResponse
  { getWarehousesResponseStatus = Nothing
  , getWarehousesResponseResult = Nothing
  }

-- ** GoodsFeedbackCommentAuthorDTO
-- | GoodsFeedbackCommentAuthorDTO
-- Информация об авторе комментария.
data GoodsFeedbackCommentAuthorDTO = GoodsFeedbackCommentAuthorDTO
  { goodsFeedbackCommentAuthorDTOType :: !(Maybe GoodsFeedbackCommentAuthorType) -- ^ "type"
  , goodsFeedbackCommentAuthorDTOName :: !(Maybe Text) -- ^ "name" - Имя автора или название кабинета.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsFeedbackCommentAuthorDTO
instance A.FromJSON GoodsFeedbackCommentAuthorDTO where
  parseJSON = A.withObject "GoodsFeedbackCommentAuthorDTO" $ \o ->
    GoodsFeedbackCommentAuthorDTO
      <$> (o .:? "type")
      <*> (o .:? "name")

-- | ToJSON GoodsFeedbackCommentAuthorDTO
instance A.ToJSON GoodsFeedbackCommentAuthorDTO where
  toJSON GoodsFeedbackCommentAuthorDTO {..} =
   _omitNulls
      [ "type" .= goodsFeedbackCommentAuthorDTOType
      , "name" .= goodsFeedbackCommentAuthorDTOName
      ]


-- | Construct a value of type 'GoodsFeedbackCommentAuthorDTO' (by applying it's required fields, if any)
mkGoodsFeedbackCommentAuthorDTO
  :: GoodsFeedbackCommentAuthorDTO
mkGoodsFeedbackCommentAuthorDTO =
  GoodsFeedbackCommentAuthorDTO
  { goodsFeedbackCommentAuthorDTOType = Nothing
  , goodsFeedbackCommentAuthorDTOName = Nothing
  }

-- ** GoodsFeedbackCommentDTO
-- | GoodsFeedbackCommentDTO
-- Комментарий к отзыву.
data GoodsFeedbackCommentDTO = GoodsFeedbackCommentDTO
  { goodsFeedbackCommentDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор комментария к отзыву. 
  , goodsFeedbackCommentDTOText :: !(Text) -- ^ /Required/ "text" - Текст комментария.
  , goodsFeedbackCommentDTOCanModify :: !(Maybe Bool) -- ^ "canModify" - Может ли продавец изменять комментарий или удалять его.
  , goodsFeedbackCommentDTOParentId :: !(Maybe Integer) -- ^ "parentId" - Идентификатор комментария к отзыву. 
  , goodsFeedbackCommentDTOAuthor :: !(GoodsFeedbackCommentAuthorDTO) -- ^ /Required/ "author"
  , goodsFeedbackCommentDTOStatus :: !(GoodsFeedbackCommentStatusType) -- ^ /Required/ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsFeedbackCommentDTO
instance A.FromJSON GoodsFeedbackCommentDTO where
  parseJSON = A.withObject "GoodsFeedbackCommentDTO" $ \o ->
    GoodsFeedbackCommentDTO
      <$> (o .:  "id")
      <*> (o .:  "text")
      <*> (o .:? "canModify")
      <*> (o .:? "parentId")
      <*> (o .:  "author")
      <*> (o .:  "status")

-- | ToJSON GoodsFeedbackCommentDTO
instance A.ToJSON GoodsFeedbackCommentDTO where
  toJSON GoodsFeedbackCommentDTO {..} =
   _omitNulls
      [ "id" .= goodsFeedbackCommentDTOId
      , "text" .= goodsFeedbackCommentDTOText
      , "canModify" .= goodsFeedbackCommentDTOCanModify
      , "parentId" .= goodsFeedbackCommentDTOParentId
      , "author" .= goodsFeedbackCommentDTOAuthor
      , "status" .= goodsFeedbackCommentDTOStatus
      ]


-- | Construct a value of type 'GoodsFeedbackCommentDTO' (by applying it's required fields, if any)
mkGoodsFeedbackCommentDTO
  :: Integer -- ^ 'goodsFeedbackCommentDTOId': Идентификатор комментария к отзыву. 
  -> Text -- ^ 'goodsFeedbackCommentDTOText': Текст комментария.
  -> GoodsFeedbackCommentAuthorDTO -- ^ 'goodsFeedbackCommentDTOAuthor' 
  -> GoodsFeedbackCommentStatusType -- ^ 'goodsFeedbackCommentDTOStatus' 
  -> GoodsFeedbackCommentDTO
mkGoodsFeedbackCommentDTO goodsFeedbackCommentDTOId goodsFeedbackCommentDTOText goodsFeedbackCommentDTOAuthor goodsFeedbackCommentDTOStatus =
  GoodsFeedbackCommentDTO
  { goodsFeedbackCommentDTOId
  , goodsFeedbackCommentDTOText
  , goodsFeedbackCommentDTOCanModify = Nothing
  , goodsFeedbackCommentDTOParentId = Nothing
  , goodsFeedbackCommentDTOAuthor
  , goodsFeedbackCommentDTOStatus
  }

-- ** GoodsFeedbackCommentListDTO
-- | GoodsFeedbackCommentListDTO
-- Комментарии к отзыву.
data GoodsFeedbackCommentListDTO = GoodsFeedbackCommentListDTO
  { goodsFeedbackCommentListDTOComments :: !([GoodsFeedbackCommentDTO]) -- ^ /Required/ "comments" - Список комментариев.
  , goodsFeedbackCommentListDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsFeedbackCommentListDTO
instance A.FromJSON GoodsFeedbackCommentListDTO where
  parseJSON = A.withObject "GoodsFeedbackCommentListDTO" $ \o ->
    GoodsFeedbackCommentListDTO
      <$> (o .:  "comments")
      <*> (o .:? "paging")

-- | ToJSON GoodsFeedbackCommentListDTO
instance A.ToJSON GoodsFeedbackCommentListDTO where
  toJSON GoodsFeedbackCommentListDTO {..} =
   _omitNulls
      [ "comments" .= goodsFeedbackCommentListDTOComments
      , "paging" .= goodsFeedbackCommentListDTOPaging
      ]


-- | Construct a value of type 'GoodsFeedbackCommentListDTO' (by applying it's required fields, if any)
mkGoodsFeedbackCommentListDTO
  :: [GoodsFeedbackCommentDTO] -- ^ 'goodsFeedbackCommentListDTOComments': Список комментариев.
  -> GoodsFeedbackCommentListDTO
mkGoodsFeedbackCommentListDTO goodsFeedbackCommentListDTOComments =
  GoodsFeedbackCommentListDTO
  { goodsFeedbackCommentListDTOComments
  , goodsFeedbackCommentListDTOPaging = Nothing
  }

-- ** GoodsFeedbackDTO
-- | GoodsFeedbackDTO
-- Отзыв о товаре.
data GoodsFeedbackDTO = GoodsFeedbackDTO
  { goodsFeedbackDTOFeedbackId :: !(Integer) -- ^ /Required/ "feedbackId" - Идентификатор отзыва. 
  , goodsFeedbackDTOCreatedAt :: !(DateTime) -- ^ /Required/ "createdAt" - Дата и время создания отзыва.
  , goodsFeedbackDTONeedReaction :: !(Bool) -- ^ /Required/ "needReaction" - Нужен ли ответ на отзыв.
  , goodsFeedbackDTOIdentifiers :: !(GoodsFeedbackIdentifiersDTO) -- ^ /Required/ "identifiers"
  , goodsFeedbackDTOAuthor :: !(Maybe Text) -- ^ "author" - Имя автора отзыва.
  , goodsFeedbackDTODescription :: !(Maybe GoodsFeedbackDescriptionDTO) -- ^ "description"
  , goodsFeedbackDTOMedia :: !(Maybe GoodsFeedbackMediaDTO) -- ^ "media"
  , goodsFeedbackDTOStatistics :: !(GoodsFeedbackStatisticsDTO) -- ^ /Required/ "statistics"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsFeedbackDTO
instance A.FromJSON GoodsFeedbackDTO where
  parseJSON = A.withObject "GoodsFeedbackDTO" $ \o ->
    GoodsFeedbackDTO
      <$> (o .:  "feedbackId")
      <*> (o .:  "createdAt")
      <*> (o .:  "needReaction")
      <*> (o .:  "identifiers")
      <*> (o .:? "author")
      <*> (o .:? "description")
      <*> (o .:? "media")
      <*> (o .:  "statistics")

-- | ToJSON GoodsFeedbackDTO
instance A.ToJSON GoodsFeedbackDTO where
  toJSON GoodsFeedbackDTO {..} =
   _omitNulls
      [ "feedbackId" .= goodsFeedbackDTOFeedbackId
      , "createdAt" .= goodsFeedbackDTOCreatedAt
      , "needReaction" .= goodsFeedbackDTONeedReaction
      , "identifiers" .= goodsFeedbackDTOIdentifiers
      , "author" .= goodsFeedbackDTOAuthor
      , "description" .= goodsFeedbackDTODescription
      , "media" .= goodsFeedbackDTOMedia
      , "statistics" .= goodsFeedbackDTOStatistics
      ]


-- | Construct a value of type 'GoodsFeedbackDTO' (by applying it's required fields, if any)
mkGoodsFeedbackDTO
  :: Integer -- ^ 'goodsFeedbackDTOFeedbackId': Идентификатор отзыва. 
  -> DateTime -- ^ 'goodsFeedbackDTOCreatedAt': Дата и время создания отзыва.
  -> Bool -- ^ 'goodsFeedbackDTONeedReaction': Нужен ли ответ на отзыв.
  -> GoodsFeedbackIdentifiersDTO -- ^ 'goodsFeedbackDTOIdentifiers' 
  -> GoodsFeedbackStatisticsDTO -- ^ 'goodsFeedbackDTOStatistics' 
  -> GoodsFeedbackDTO
mkGoodsFeedbackDTO goodsFeedbackDTOFeedbackId goodsFeedbackDTOCreatedAt goodsFeedbackDTONeedReaction goodsFeedbackDTOIdentifiers goodsFeedbackDTOStatistics =
  GoodsFeedbackDTO
  { goodsFeedbackDTOFeedbackId
  , goodsFeedbackDTOCreatedAt
  , goodsFeedbackDTONeedReaction
  , goodsFeedbackDTOIdentifiers
  , goodsFeedbackDTOAuthor = Nothing
  , goodsFeedbackDTODescription = Nothing
  , goodsFeedbackDTOMedia = Nothing
  , goodsFeedbackDTOStatistics
  }

-- ** GoodsFeedbackDescriptionDTO
-- | GoodsFeedbackDescriptionDTO
-- Текстовая часть отзыва.
data GoodsFeedbackDescriptionDTO = GoodsFeedbackDescriptionDTO
  { goodsFeedbackDescriptionDTOAdvantages :: !(Maybe Text) -- ^ "advantages" - Описание плюсов товара в отзыве.
  , goodsFeedbackDescriptionDTODisadvantages :: !(Maybe Text) -- ^ "disadvantages" - Описание минусов товара в отзыве.
  , goodsFeedbackDescriptionDTOComment :: !(Maybe Text) -- ^ "comment" - Комментарий в отзыве.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsFeedbackDescriptionDTO
instance A.FromJSON GoodsFeedbackDescriptionDTO where
  parseJSON = A.withObject "GoodsFeedbackDescriptionDTO" $ \o ->
    GoodsFeedbackDescriptionDTO
      <$> (o .:? "advantages")
      <*> (o .:? "disadvantages")
      <*> (o .:? "comment")

-- | ToJSON GoodsFeedbackDescriptionDTO
instance A.ToJSON GoodsFeedbackDescriptionDTO where
  toJSON GoodsFeedbackDescriptionDTO {..} =
   _omitNulls
      [ "advantages" .= goodsFeedbackDescriptionDTOAdvantages
      , "disadvantages" .= goodsFeedbackDescriptionDTODisadvantages
      , "comment" .= goodsFeedbackDescriptionDTOComment
      ]


-- | Construct a value of type 'GoodsFeedbackDescriptionDTO' (by applying it's required fields, if any)
mkGoodsFeedbackDescriptionDTO
  :: GoodsFeedbackDescriptionDTO
mkGoodsFeedbackDescriptionDTO =
  GoodsFeedbackDescriptionDTO
  { goodsFeedbackDescriptionDTOAdvantages = Nothing
  , goodsFeedbackDescriptionDTODisadvantages = Nothing
  , goodsFeedbackDescriptionDTOComment = Nothing
  }

-- ** GoodsFeedbackIdentifiersDTO
-- | GoodsFeedbackIdentifiersDTO
-- Идентификаторы, которые связаны с отзывом.
data GoodsFeedbackIdentifiersDTO = GoodsFeedbackIdentifiersDTO
  { goodsFeedbackIdentifiersDTOOrderId :: !(Integer) -- ^ /Required/ "orderId" - Идентификатор заказа на Маркете.
  , goodsFeedbackIdentifiersDTOModelId :: !(Integer) -- ^ /Required/ "modelId" - Идентификатор модели товара.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsFeedbackIdentifiersDTO
instance A.FromJSON GoodsFeedbackIdentifiersDTO where
  parseJSON = A.withObject "GoodsFeedbackIdentifiersDTO" $ \o ->
    GoodsFeedbackIdentifiersDTO
      <$> (o .:  "orderId")
      <*> (o .:  "modelId")

-- | ToJSON GoodsFeedbackIdentifiersDTO
instance A.ToJSON GoodsFeedbackIdentifiersDTO where
  toJSON GoodsFeedbackIdentifiersDTO {..} =
   _omitNulls
      [ "orderId" .= goodsFeedbackIdentifiersDTOOrderId
      , "modelId" .= goodsFeedbackIdentifiersDTOModelId
      ]


-- | Construct a value of type 'GoodsFeedbackIdentifiersDTO' (by applying it's required fields, if any)
mkGoodsFeedbackIdentifiersDTO
  :: Integer -- ^ 'goodsFeedbackIdentifiersDTOOrderId': Идентификатор заказа на Маркете.
  -> Integer -- ^ 'goodsFeedbackIdentifiersDTOModelId': Идентификатор модели товара.
  -> GoodsFeedbackIdentifiersDTO
mkGoodsFeedbackIdentifiersDTO goodsFeedbackIdentifiersDTOOrderId goodsFeedbackIdentifiersDTOModelId =
  GoodsFeedbackIdentifiersDTO
  { goodsFeedbackIdentifiersDTOOrderId
  , goodsFeedbackIdentifiersDTOModelId
  }

-- ** GoodsFeedbackListDTO
-- | GoodsFeedbackListDTO
-- Список отзывов о товарах. 
data GoodsFeedbackListDTO = GoodsFeedbackListDTO
  { goodsFeedbackListDTOFeedbacks :: !([GoodsFeedbackDTO]) -- ^ /Required/ "feedbacks" - Список отзывов.
  , goodsFeedbackListDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsFeedbackListDTO
instance A.FromJSON GoodsFeedbackListDTO where
  parseJSON = A.withObject "GoodsFeedbackListDTO" $ \o ->
    GoodsFeedbackListDTO
      <$> (o .:  "feedbacks")
      <*> (o .:? "paging")

-- | ToJSON GoodsFeedbackListDTO
instance A.ToJSON GoodsFeedbackListDTO where
  toJSON GoodsFeedbackListDTO {..} =
   _omitNulls
      [ "feedbacks" .= goodsFeedbackListDTOFeedbacks
      , "paging" .= goodsFeedbackListDTOPaging
      ]


-- | Construct a value of type 'GoodsFeedbackListDTO' (by applying it's required fields, if any)
mkGoodsFeedbackListDTO
  :: [GoodsFeedbackDTO] -- ^ 'goodsFeedbackListDTOFeedbacks': Список отзывов.
  -> GoodsFeedbackListDTO
mkGoodsFeedbackListDTO goodsFeedbackListDTOFeedbacks =
  GoodsFeedbackListDTO
  { goodsFeedbackListDTOFeedbacks
  , goodsFeedbackListDTOPaging = Nothing
  }

-- ** GoodsFeedbackMediaDTO
-- | GoodsFeedbackMediaDTO
-- Фото и видео.
data GoodsFeedbackMediaDTO = GoodsFeedbackMediaDTO
  { goodsFeedbackMediaDTOPhotos :: !(Maybe [Text]) -- ^ "photos" - Ссылки на фото.
  , goodsFeedbackMediaDTOVideos :: !(Maybe [Text]) -- ^ "videos" - Ссылки на видео.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsFeedbackMediaDTO
instance A.FromJSON GoodsFeedbackMediaDTO where
  parseJSON = A.withObject "GoodsFeedbackMediaDTO" $ \o ->
    GoodsFeedbackMediaDTO
      <$> (o .:? "photos")
      <*> (o .:? "videos")

-- | ToJSON GoodsFeedbackMediaDTO
instance A.ToJSON GoodsFeedbackMediaDTO where
  toJSON GoodsFeedbackMediaDTO {..} =
   _omitNulls
      [ "photos" .= goodsFeedbackMediaDTOPhotos
      , "videos" .= goodsFeedbackMediaDTOVideos
      ]


-- | Construct a value of type 'GoodsFeedbackMediaDTO' (by applying it's required fields, if any)
mkGoodsFeedbackMediaDTO
  :: GoodsFeedbackMediaDTO
mkGoodsFeedbackMediaDTO =
  GoodsFeedbackMediaDTO
  { goodsFeedbackMediaDTOPhotos = Nothing
  , goodsFeedbackMediaDTOVideos = Nothing
  }

-- ** GoodsFeedbackStatisticsDTO
-- | GoodsFeedbackStatisticsDTO
-- Статистическая информация по отзыву.
data GoodsFeedbackStatisticsDTO = GoodsFeedbackStatisticsDTO
  { goodsFeedbackStatisticsDTORating :: !(Int) -- ^ /Required/ "rating" - Оценка товара.
  , goodsFeedbackStatisticsDTOCommentsCount :: !(Integer) -- ^ /Required/ "commentsCount" - Количество комментариев к отзыву.  Учитываются только ответы на отзывы, а не дочерние комментарии. 
  , goodsFeedbackStatisticsDTORecommended :: !(Maybe Bool) -- ^ "recommended" - Рекомендуют ли этот товар.
  , goodsFeedbackStatisticsDTOPaidAmount :: !(Maybe Integer) -- ^ "paidAmount" - Количество баллов Плюса, которое автор получил за отзыв.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsFeedbackStatisticsDTO
instance A.FromJSON GoodsFeedbackStatisticsDTO where
  parseJSON = A.withObject "GoodsFeedbackStatisticsDTO" $ \o ->
    GoodsFeedbackStatisticsDTO
      <$> (o .:  "rating")
      <*> (o .:  "commentsCount")
      <*> (o .:? "recommended")
      <*> (o .:? "paidAmount")

-- | ToJSON GoodsFeedbackStatisticsDTO
instance A.ToJSON GoodsFeedbackStatisticsDTO where
  toJSON GoodsFeedbackStatisticsDTO {..} =
   _omitNulls
      [ "rating" .= goodsFeedbackStatisticsDTORating
      , "commentsCount" .= goodsFeedbackStatisticsDTOCommentsCount
      , "recommended" .= goodsFeedbackStatisticsDTORecommended
      , "paidAmount" .= goodsFeedbackStatisticsDTOPaidAmount
      ]


-- | Construct a value of type 'GoodsFeedbackStatisticsDTO' (by applying it's required fields, if any)
mkGoodsFeedbackStatisticsDTO
  :: Int -- ^ 'goodsFeedbackStatisticsDTORating': Оценка товара.
  -> Integer -- ^ 'goodsFeedbackStatisticsDTOCommentsCount': Количество комментариев к отзыву.  Учитываются только ответы на отзывы, а не дочерние комментарии. 
  -> GoodsFeedbackStatisticsDTO
mkGoodsFeedbackStatisticsDTO goodsFeedbackStatisticsDTORating goodsFeedbackStatisticsDTOCommentsCount =
  GoodsFeedbackStatisticsDTO
  { goodsFeedbackStatisticsDTORating
  , goodsFeedbackStatisticsDTOCommentsCount
  , goodsFeedbackStatisticsDTORecommended = Nothing
  , goodsFeedbackStatisticsDTOPaidAmount = Nothing
  }

-- ** GoodsStatsDTO
-- | GoodsStatsDTO
-- Отчет по товарам.
data GoodsStatsDTO = GoodsStatsDTO
  { goodsStatsDTOShopSkus :: !([GoodsStatsGoodsDTO]) -- ^ /Required/ "shopSkus" - Список товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsStatsDTO
instance A.FromJSON GoodsStatsDTO where
  parseJSON = A.withObject "GoodsStatsDTO" $ \o ->
    GoodsStatsDTO
      <$> (o .:  "shopSkus")

-- | ToJSON GoodsStatsDTO
instance A.ToJSON GoodsStatsDTO where
  toJSON GoodsStatsDTO {..} =
   _omitNulls
      [ "shopSkus" .= goodsStatsDTOShopSkus
      ]


-- | Construct a value of type 'GoodsStatsDTO' (by applying it's required fields, if any)
mkGoodsStatsDTO
  :: [GoodsStatsGoodsDTO] -- ^ 'goodsStatsDTOShopSkus': Список товаров.
  -> GoodsStatsDTO
mkGoodsStatsDTO goodsStatsDTOShopSkus =
  GoodsStatsDTO
  { goodsStatsDTOShopSkus
  }

-- ** GoodsStatsGoodsDTO
-- | GoodsStatsGoodsDTO
-- Информация о товаре.
data GoodsStatsGoodsDTO = GoodsStatsGoodsDTO
  { goodsStatsGoodsDTOShopSku :: !(Maybe Text) -- ^ "shopSku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , goodsStatsGoodsDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  , goodsStatsGoodsDTOName :: !(Maybe Text) -- ^ "name" - Название товара.
  , goodsStatsGoodsDTOPrice :: !(Maybe Double) -- ^ "price" - Цена на товар в валюте, которая установлена [в кабинете продавца на Маркете](https://partner.market.yandex.ru/).
  , goodsStatsGoodsDTOCategoryId :: !(Maybe Integer) -- ^ "categoryId" - Идентификатор категории товара на Маркете.
  , goodsStatsGoodsDTOCategoryName :: !(Maybe Text) -- ^ "categoryName" - Название категории товара на Маркете.
  , goodsStatsGoodsDTOWeightDimensions :: !(Maybe GoodsStatsWeightDimensionsDTO) -- ^ "weightDimensions"
  , goodsStatsGoodsDTOWarehouses :: !(Maybe [GoodsStatsWarehouseDTO]) -- ^ "warehouses" - Информация о складах, на которых хранится товар.  Параметр не приходит, если товара нет ни на одном складе. 
  , goodsStatsGoodsDTOTariffs :: !(Maybe [TariffDTO]) -- ^ "tariffs" - Информация о тарифах, по которым нужно заплатить за услуги Маркета.  По некоторым услугам могут возвращаться несколько разных стоимостей. Например, в модели FBS стоимость услуги &#x60;SORTING&#x60; (обработка заказа) зависит от способа отгрузки и количества заказов в отгрузке. Подробнее о тарифах на услуги читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/introduction/rates/models/). 
  , goodsStatsGoodsDTOPictures :: !(Maybe [Text]) -- ^ "pictures" - Ссылки (URL) изображений товара в хорошем качестве.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsStatsGoodsDTO
instance A.FromJSON GoodsStatsGoodsDTO where
  parseJSON = A.withObject "GoodsStatsGoodsDTO" $ \o ->
    GoodsStatsGoodsDTO
      <$> (o .:? "shopSku")
      <*> (o .:? "marketSku")
      <*> (o .:? "name")
      <*> (o .:? "price")
      <*> (o .:? "categoryId")
      <*> (o .:? "categoryName")
      <*> (o .:? "weightDimensions")
      <*> (o .:? "warehouses")
      <*> (o .:? "tariffs")
      <*> (o .:? "pictures")

-- | ToJSON GoodsStatsGoodsDTO
instance A.ToJSON GoodsStatsGoodsDTO where
  toJSON GoodsStatsGoodsDTO {..} =
   _omitNulls
      [ "shopSku" .= goodsStatsGoodsDTOShopSku
      , "marketSku" .= goodsStatsGoodsDTOMarketSku
      , "name" .= goodsStatsGoodsDTOName
      , "price" .= goodsStatsGoodsDTOPrice
      , "categoryId" .= goodsStatsGoodsDTOCategoryId
      , "categoryName" .= goodsStatsGoodsDTOCategoryName
      , "weightDimensions" .= goodsStatsGoodsDTOWeightDimensions
      , "warehouses" .= goodsStatsGoodsDTOWarehouses
      , "tariffs" .= goodsStatsGoodsDTOTariffs
      , "pictures" .= goodsStatsGoodsDTOPictures
      ]


-- | Construct a value of type 'GoodsStatsGoodsDTO' (by applying it's required fields, if any)
mkGoodsStatsGoodsDTO
  :: GoodsStatsGoodsDTO
mkGoodsStatsGoodsDTO =
  GoodsStatsGoodsDTO
  { goodsStatsGoodsDTOShopSku = Nothing
  , goodsStatsGoodsDTOMarketSku = Nothing
  , goodsStatsGoodsDTOName = Nothing
  , goodsStatsGoodsDTOPrice = Nothing
  , goodsStatsGoodsDTOCategoryId = Nothing
  , goodsStatsGoodsDTOCategoryName = Nothing
  , goodsStatsGoodsDTOWeightDimensions = Nothing
  , goodsStatsGoodsDTOWarehouses = Nothing
  , goodsStatsGoodsDTOTariffs = Nothing
  , goodsStatsGoodsDTOPictures = Nothing
  }

-- ** GoodsStatsWarehouseDTO
-- | GoodsStatsWarehouseDTO
-- Информация о складе.
data GoodsStatsWarehouseDTO = GoodsStatsWarehouseDTO
  { goodsStatsWarehouseDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор склада.
  , goodsStatsWarehouseDTOName :: !(Maybe Text) -- ^ "name" - Название склада.
  , goodsStatsWarehouseDTOStocks :: !([WarehouseStockDTO]) -- ^ /Required/ "stocks" - Информация об остатках товаров на складе.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsStatsWarehouseDTO
instance A.FromJSON GoodsStatsWarehouseDTO where
  parseJSON = A.withObject "GoodsStatsWarehouseDTO" $ \o ->
    GoodsStatsWarehouseDTO
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:  "stocks")

-- | ToJSON GoodsStatsWarehouseDTO
instance A.ToJSON GoodsStatsWarehouseDTO where
  toJSON GoodsStatsWarehouseDTO {..} =
   _omitNulls
      [ "id" .= goodsStatsWarehouseDTOId
      , "name" .= goodsStatsWarehouseDTOName
      , "stocks" .= goodsStatsWarehouseDTOStocks
      ]


-- | Construct a value of type 'GoodsStatsWarehouseDTO' (by applying it's required fields, if any)
mkGoodsStatsWarehouseDTO
  :: [WarehouseStockDTO] -- ^ 'goodsStatsWarehouseDTOStocks': Информация об остатках товаров на складе.
  -> GoodsStatsWarehouseDTO
mkGoodsStatsWarehouseDTO goodsStatsWarehouseDTOStocks =
  GoodsStatsWarehouseDTO
  { goodsStatsWarehouseDTOId = Nothing
  , goodsStatsWarehouseDTOName = Nothing
  , goodsStatsWarehouseDTOStocks
  }

-- ** GoodsStatsWeightDimensionsDTO
-- | GoodsStatsWeightDimensionsDTO
-- Информация о весе и габаритах товара.  Если товар уже привязан к карточке (`marketSku`), в ответе вернутся габариты из карточки Маркета, а не размеры, которые вы передаете. 
data GoodsStatsWeightDimensionsDTO = GoodsStatsWeightDimensionsDTO
  { goodsStatsWeightDimensionsDTOLength :: !(Maybe Double) -- ^ "length" - Длина товара в сантиметрах.
  , goodsStatsWeightDimensionsDTOWidth :: !(Maybe Double) -- ^ "width" - Ширина товара в сантиметрах.
  , goodsStatsWeightDimensionsDTOHeight :: !(Maybe Double) -- ^ "height" - Высота товара в сантиметрах.
  , goodsStatsWeightDimensionsDTOWeight :: !(Maybe Double) -- ^ "weight" - Вес товара в килограммах.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoodsStatsWeightDimensionsDTO
instance A.FromJSON GoodsStatsWeightDimensionsDTO where
  parseJSON = A.withObject "GoodsStatsWeightDimensionsDTO" $ \o ->
    GoodsStatsWeightDimensionsDTO
      <$> (o .:? "length")
      <*> (o .:? "width")
      <*> (o .:? "height")
      <*> (o .:? "weight")

-- | ToJSON GoodsStatsWeightDimensionsDTO
instance A.ToJSON GoodsStatsWeightDimensionsDTO where
  toJSON GoodsStatsWeightDimensionsDTO {..} =
   _omitNulls
      [ "length" .= goodsStatsWeightDimensionsDTOLength
      , "width" .= goodsStatsWeightDimensionsDTOWidth
      , "height" .= goodsStatsWeightDimensionsDTOHeight
      , "weight" .= goodsStatsWeightDimensionsDTOWeight
      ]


-- | Construct a value of type 'GoodsStatsWeightDimensionsDTO' (by applying it's required fields, if any)
mkGoodsStatsWeightDimensionsDTO
  :: GoodsStatsWeightDimensionsDTO
mkGoodsStatsWeightDimensionsDTO =
  GoodsStatsWeightDimensionsDTO
  { goodsStatsWeightDimensionsDTOLength = Nothing
  , goodsStatsWeightDimensionsDTOWidth = Nothing
  , goodsStatsWeightDimensionsDTOHeight = Nothing
  , goodsStatsWeightDimensionsDTOWeight = Nothing
  }

-- ** GpsDTO
-- | GpsDTO
-- GPS-координаты широты и долготы. 
data GpsDTO = GpsDTO
  { gpsDTOLatitude :: !(Double) -- ^ /Required/ "latitude" - Широта.
  , gpsDTOLongitude :: !(Double) -- ^ /Required/ "longitude" - Долгота.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GpsDTO
instance A.FromJSON GpsDTO where
  parseJSON = A.withObject "GpsDTO" $ \o ->
    GpsDTO
      <$> (o .:  "latitude")
      <*> (o .:  "longitude")

-- | ToJSON GpsDTO
instance A.ToJSON GpsDTO where
  toJSON GpsDTO {..} =
   _omitNulls
      [ "latitude" .= gpsDTOLatitude
      , "longitude" .= gpsDTOLongitude
      ]


-- | Construct a value of type 'GpsDTO' (by applying it's required fields, if any)
mkGpsDTO
  :: Double -- ^ 'gpsDTOLatitude': Широта.
  -> Double -- ^ 'gpsDTOLongitude': Долгота.
  -> GpsDTO
mkGpsDTO gpsDTOLatitude gpsDTOLongitude =
  GpsDTO
  { gpsDTOLatitude
  , gpsDTOLongitude
  }

-- ** HiddenOfferDTO
-- | HiddenOfferDTO
-- Информация о скрытии.
data HiddenOfferDTO = HiddenOfferDTO
  { hiddenOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HiddenOfferDTO
instance A.FromJSON HiddenOfferDTO where
  parseJSON = A.withObject "HiddenOfferDTO" $ \o ->
    HiddenOfferDTO
      <$> (o .:  "offerId")

-- | ToJSON HiddenOfferDTO
instance A.ToJSON HiddenOfferDTO where
  toJSON HiddenOfferDTO {..} =
   _omitNulls
      [ "offerId" .= hiddenOfferDTOOfferId
      ]


-- | Construct a value of type 'HiddenOfferDTO' (by applying it's required fields, if any)
mkHiddenOfferDTO
  :: Text -- ^ 'hiddenOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> HiddenOfferDTO
mkHiddenOfferDTO hiddenOfferDTOOfferId =
  HiddenOfferDTO
  { hiddenOfferDTOOfferId
  }

-- ** LogisticPickupPointDTO
-- | LogisticPickupPointDTO
-- Описание пункта вывоза для возврата.
data LogisticPickupPointDTO = LogisticPickupPointDTO
  { logisticPickupPointDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор пункта вывоза.
  , logisticPickupPointDTOName :: !(Maybe Text) -- ^ "name" - Название пункта вывоза.
  , logisticPickupPointDTOAddress :: !(Maybe PickupAddressDTO) -- ^ "address"
  , logisticPickupPointDTOInstruction :: !(Maybe Text) -- ^ "instruction" - Дополнительные инструкции к вывозу.
  , logisticPickupPointDTOType :: !(Maybe LogisticPointType) -- ^ "type"
  , logisticPickupPointDTOLogisticPartnerId :: !(Maybe Integer) -- ^ "logisticPartnerId" - Идентификатор логистического партнера, к которому относится логистическая точка.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogisticPickupPointDTO
instance A.FromJSON LogisticPickupPointDTO where
  parseJSON = A.withObject "LogisticPickupPointDTO" $ \o ->
    LogisticPickupPointDTO
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "address")
      <*> (o .:? "instruction")
      <*> (o .:? "type")
      <*> (o .:? "logisticPartnerId")

-- | ToJSON LogisticPickupPointDTO
instance A.ToJSON LogisticPickupPointDTO where
  toJSON LogisticPickupPointDTO {..} =
   _omitNulls
      [ "id" .= logisticPickupPointDTOId
      , "name" .= logisticPickupPointDTOName
      , "address" .= logisticPickupPointDTOAddress
      , "instruction" .= logisticPickupPointDTOInstruction
      , "type" .= logisticPickupPointDTOType
      , "logisticPartnerId" .= logisticPickupPointDTOLogisticPartnerId
      ]


-- | Construct a value of type 'LogisticPickupPointDTO' (by applying it's required fields, if any)
mkLogisticPickupPointDTO
  :: LogisticPickupPointDTO
mkLogisticPickupPointDTO =
  LogisticPickupPointDTO
  { logisticPickupPointDTOId = Nothing
  , logisticPickupPointDTOName = Nothing
  , logisticPickupPointDTOAddress = Nothing
  , logisticPickupPointDTOInstruction = Nothing
  , logisticPickupPointDTOType = Nothing
  , logisticPickupPointDTOLogisticPartnerId = Nothing
  }

-- ** MappingsOfferDTO
-- | MappingsOfferDTO
-- Информация о товарах в каталоге.
data MappingsOfferDTO = MappingsOfferDTO
  { mappingsOfferDTOName :: !(Maybe Text) -- ^ "name" - Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
  , mappingsOfferDTOShopSku :: !(Maybe Text) -- ^ "shopSku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , mappingsOfferDTOCategory :: !(Maybe Text) -- ^ "category" - Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;. 
  , mappingsOfferDTOVendor :: !(Maybe Text) -- ^ "vendor" - Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
  , mappingsOfferDTOVendorCode :: !(Maybe Text) -- ^ "vendorCode" - Артикул товара от производителя.
  , mappingsOfferDTODescription :: !(Maybe Text) -- ^ "description" - Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\&lt;h&gt;, \\&lt;h1&gt;, \\&lt;h2&gt; и так далее — для заголовков; * \\&lt;br&gt; и \\&lt;p&gt; — для переноса строки; * \\&lt;ol&gt; — для нумерованного списка; * \\&lt;ul&gt; — для маркированного списка; * \\&lt;li&gt; — для создания элементов списка (должен находиться внутри \\&lt;ol&gt; или \\&lt;ul&gt;); * \\&lt;div&gt; — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
  , mappingsOfferDTOId :: !(Maybe Text) -- ^ "id" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , mappingsOfferDTOFeedId :: !(Maybe Integer) -- ^ "feedId" - Идентификатор фида.
  , mappingsOfferDTOBarcodes :: !(Maybe [Text]) -- ^ "barcodes" - Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
  , mappingsOfferDTOUrls :: !(Maybe [Text]) -- ^ "urls" - URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
  , mappingsOfferDTOPictures :: !(Maybe [Text]) -- ^ "pictures" - Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр &#x60;picture&#x60;. 
  , mappingsOfferDTOManufacturer :: !(Maybe Text) -- ^ "manufacturer" - Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
  , mappingsOfferDTOManufacturerCountries :: !(Maybe [Text]) -- ^ "manufacturerCountries" - Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
  , mappingsOfferDTOMinShipment :: !(Maybe Int) -- ^ "minShipment" - Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
  , mappingsOfferDTOTransportUnitSize :: !(Maybe Int) -- ^ "transportUnitSize" - Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
  , mappingsOfferDTOQuantumOfSupply :: !(Maybe Int) -- ^ "quantumOfSupply" - Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
  , mappingsOfferDTODeliveryDurationDays :: !(Maybe Int) -- ^ "deliveryDurationDays" - Срок, за который продавец поставляет товары на склад, в днях.
  , mappingsOfferDTOBoxCount :: !(Maybe Int) -- ^ "boxCount" - Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
  , mappingsOfferDTOCustomsCommodityCodes :: !(Maybe [Text]) -- ^ "customsCommodityCodes" - Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
  , mappingsOfferDTOWeightDimensions :: !(Maybe OfferWeightDimensionsDTO) -- ^ "weightDimensions"
  , mappingsOfferDTOSupplyScheduleDays :: !(Maybe [DayOfWeekType]) -- ^ "supplyScheduleDays" - Дни недели, в которые продавец поставляет товары на склад.
  , mappingsOfferDTOShelfLifeDays :: !(Maybe Int) -- ^ "shelfLifeDays" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Вместо него используйте &#x60;shelfLife&#x60;. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
  , mappingsOfferDTOLifeTimeDays :: !(Maybe Int) -- ^ "lifeTimeDays" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Вместо него используйте &#x60;lifeTime&#x60;. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
  , mappingsOfferDTOGuaranteePeriodDays :: !(Maybe Int) -- ^ "guaranteePeriodDays" - Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
  , mappingsOfferDTOProcessingState :: !(Maybe OfferProcessingStateDTO) -- ^ "processingState"
  , mappingsOfferDTOAvailability :: !(Maybe OfferAvailabilityStatusType) -- ^ "availability"
  , mappingsOfferDTOShelfLife :: !(Maybe TimePeriodDTO) -- ^ "shelfLife"
  , mappingsOfferDTOLifeTime :: !(Maybe TimePeriodDTO) -- ^ "lifeTime"
  , mappingsOfferDTOGuaranteePeriod :: !(Maybe TimePeriodDTO) -- ^ "guaranteePeriod"
  , mappingsOfferDTOCertificate :: !(Maybe Text) -- ^ "certificate" - Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
  , mappingsOfferDTOPrice :: !(Maybe Double) -- ^ "price" - Цена на товар в рублях.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MappingsOfferDTO
instance A.FromJSON MappingsOfferDTO where
  parseJSON = A.withObject "MappingsOfferDTO" $ \o ->
    MappingsOfferDTO
      <$> (o .:? "name")
      <*> (o .:? "shopSku")
      <*> (o .:? "category")
      <*> (o .:? "vendor")
      <*> (o .:? "vendorCode")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "feedId")
      <*> (o .:? "barcodes")
      <*> (o .:? "urls")
      <*> (o .:? "pictures")
      <*> (o .:? "manufacturer")
      <*> (o .:? "manufacturerCountries")
      <*> (o .:? "minShipment")
      <*> (o .:? "transportUnitSize")
      <*> (o .:? "quantumOfSupply")
      <*> (o .:? "deliveryDurationDays")
      <*> (o .:? "boxCount")
      <*> (o .:? "customsCommodityCodes")
      <*> (o .:? "weightDimensions")
      <*> (o .:? "supplyScheduleDays")
      <*> (o .:? "shelfLifeDays")
      <*> (o .:? "lifeTimeDays")
      <*> (o .:? "guaranteePeriodDays")
      <*> (o .:? "processingState")
      <*> (o .:? "availability")
      <*> (o .:? "shelfLife")
      <*> (o .:? "lifeTime")
      <*> (o .:? "guaranteePeriod")
      <*> (o .:? "certificate")
      <*> (o .:? "price")

-- | ToJSON MappingsOfferDTO
instance A.ToJSON MappingsOfferDTO where
  toJSON MappingsOfferDTO {..} =
   _omitNulls
      [ "name" .= mappingsOfferDTOName
      , "shopSku" .= mappingsOfferDTOShopSku
      , "category" .= mappingsOfferDTOCategory
      , "vendor" .= mappingsOfferDTOVendor
      , "vendorCode" .= mappingsOfferDTOVendorCode
      , "description" .= mappingsOfferDTODescription
      , "id" .= mappingsOfferDTOId
      , "feedId" .= mappingsOfferDTOFeedId
      , "barcodes" .= mappingsOfferDTOBarcodes
      , "urls" .= mappingsOfferDTOUrls
      , "pictures" .= mappingsOfferDTOPictures
      , "manufacturer" .= mappingsOfferDTOManufacturer
      , "manufacturerCountries" .= mappingsOfferDTOManufacturerCountries
      , "minShipment" .= mappingsOfferDTOMinShipment
      , "transportUnitSize" .= mappingsOfferDTOTransportUnitSize
      , "quantumOfSupply" .= mappingsOfferDTOQuantumOfSupply
      , "deliveryDurationDays" .= mappingsOfferDTODeliveryDurationDays
      , "boxCount" .= mappingsOfferDTOBoxCount
      , "customsCommodityCodes" .= mappingsOfferDTOCustomsCommodityCodes
      , "weightDimensions" .= mappingsOfferDTOWeightDimensions
      , "supplyScheduleDays" .= mappingsOfferDTOSupplyScheduleDays
      , "shelfLifeDays" .= mappingsOfferDTOShelfLifeDays
      , "lifeTimeDays" .= mappingsOfferDTOLifeTimeDays
      , "guaranteePeriodDays" .= mappingsOfferDTOGuaranteePeriodDays
      , "processingState" .= mappingsOfferDTOProcessingState
      , "availability" .= mappingsOfferDTOAvailability
      , "shelfLife" .= mappingsOfferDTOShelfLife
      , "lifeTime" .= mappingsOfferDTOLifeTime
      , "guaranteePeriod" .= mappingsOfferDTOGuaranteePeriod
      , "certificate" .= mappingsOfferDTOCertificate
      , "price" .= mappingsOfferDTOPrice
      ]


-- | Construct a value of type 'MappingsOfferDTO' (by applying it's required fields, if any)
mkMappingsOfferDTO
  :: MappingsOfferDTO
mkMappingsOfferDTO =
  MappingsOfferDTO
  { mappingsOfferDTOName = Nothing
  , mappingsOfferDTOShopSku = Nothing
  , mappingsOfferDTOCategory = Nothing
  , mappingsOfferDTOVendor = Nothing
  , mappingsOfferDTOVendorCode = Nothing
  , mappingsOfferDTODescription = Nothing
  , mappingsOfferDTOId = Nothing
  , mappingsOfferDTOFeedId = Nothing
  , mappingsOfferDTOBarcodes = Nothing
  , mappingsOfferDTOUrls = Nothing
  , mappingsOfferDTOPictures = Nothing
  , mappingsOfferDTOManufacturer = Nothing
  , mappingsOfferDTOManufacturerCountries = Nothing
  , mappingsOfferDTOMinShipment = Nothing
  , mappingsOfferDTOTransportUnitSize = Nothing
  , mappingsOfferDTOQuantumOfSupply = Nothing
  , mappingsOfferDTODeliveryDurationDays = Nothing
  , mappingsOfferDTOBoxCount = Nothing
  , mappingsOfferDTOCustomsCommodityCodes = Nothing
  , mappingsOfferDTOWeightDimensions = Nothing
  , mappingsOfferDTOSupplyScheduleDays = Nothing
  , mappingsOfferDTOShelfLifeDays = Nothing
  , mappingsOfferDTOLifeTimeDays = Nothing
  , mappingsOfferDTOGuaranteePeriodDays = Nothing
  , mappingsOfferDTOProcessingState = Nothing
  , mappingsOfferDTOAvailability = Nothing
  , mappingsOfferDTOShelfLife = Nothing
  , mappingsOfferDTOLifeTime = Nothing
  , mappingsOfferDTOGuaranteePeriod = Nothing
  , mappingsOfferDTOCertificate = Nothing
  , mappingsOfferDTOPrice = Nothing
  }

-- ** MappingsOfferInfoDTO
-- | MappingsOfferInfoDTO
-- Базовая информация о товарах в каталоге.
data MappingsOfferInfoDTO = MappingsOfferInfoDTO
  { mappingsOfferInfoDTOName :: !(Maybe Text) -- ^ "name" - Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
  , mappingsOfferInfoDTOShopSku :: !(Maybe Text) -- ^ "shopSku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , mappingsOfferInfoDTOCategory :: !(Maybe Text) -- ^ "category" - Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;. 
  , mappingsOfferInfoDTOVendor :: !(Maybe Text) -- ^ "vendor" - Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
  , mappingsOfferInfoDTOVendorCode :: !(Maybe Text) -- ^ "vendorCode" - Артикул товара от производителя.
  , mappingsOfferInfoDTODescription :: !(Maybe Text) -- ^ "description" - Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\&lt;h&gt;, \\&lt;h1&gt;, \\&lt;h2&gt; и так далее — для заголовков; * \\&lt;br&gt; и \\&lt;p&gt; — для переноса строки; * \\&lt;ol&gt; — для нумерованного списка; * \\&lt;ul&gt; — для маркированного списка; * \\&lt;li&gt; — для создания элементов списка (должен находиться внутри \\&lt;ol&gt; или \\&lt;ul&gt;); * \\&lt;div&gt; — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
  , mappingsOfferInfoDTOId :: !(Maybe Text) -- ^ "id" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , mappingsOfferInfoDTOFeedId :: !(Maybe Integer) -- ^ "feedId" - Идентификатор фида.
  , mappingsOfferInfoDTOBarcodes :: !(Maybe [Text]) -- ^ "barcodes" - Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
  , mappingsOfferInfoDTOUrls :: !(Maybe [Text]) -- ^ "urls" - URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
  , mappingsOfferInfoDTOPictures :: !(Maybe [Text]) -- ^ "pictures" - Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр &#x60;picture&#x60;. 
  , mappingsOfferInfoDTOManufacturer :: !(Maybe Text) -- ^ "manufacturer" - Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
  , mappingsOfferInfoDTOManufacturerCountries :: !(Maybe [Text]) -- ^ "manufacturerCountries" - Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
  , mappingsOfferInfoDTOMinShipment :: !(Maybe Int) -- ^ "minShipment" - Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
  , mappingsOfferInfoDTOTransportUnitSize :: !(Maybe Int) -- ^ "transportUnitSize" - Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
  , mappingsOfferInfoDTOQuantumOfSupply :: !(Maybe Int) -- ^ "quantumOfSupply" - Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
  , mappingsOfferInfoDTODeliveryDurationDays :: !(Maybe Int) -- ^ "deliveryDurationDays" - Срок, за который продавец поставляет товары на склад, в днях.
  , mappingsOfferInfoDTOBoxCount :: !(Maybe Int) -- ^ "boxCount" - Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
  , mappingsOfferInfoDTOCustomsCommodityCodes :: !(Maybe [Text]) -- ^ "customsCommodityCodes" - Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
  , mappingsOfferInfoDTOWeightDimensions :: !(Maybe OfferWeightDimensionsDTO) -- ^ "weightDimensions"
  , mappingsOfferInfoDTOSupplyScheduleDays :: !(Maybe [DayOfWeekType]) -- ^ "supplyScheduleDays" - Дни недели, в которые продавец поставляет товары на склад.
  , mappingsOfferInfoDTOShelfLifeDays :: !(Maybe Int) -- ^ "shelfLifeDays" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Вместо него используйте &#x60;shelfLife&#x60;. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
  , mappingsOfferInfoDTOLifeTimeDays :: !(Maybe Int) -- ^ "lifeTimeDays" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Вместо него используйте &#x60;lifeTime&#x60;. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
  , mappingsOfferInfoDTOGuaranteePeriodDays :: !(Maybe Int) -- ^ "guaranteePeriodDays" - Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
  , mappingsOfferInfoDTOProcessingState :: !(Maybe OfferProcessingStateDTO) -- ^ "processingState"
  , mappingsOfferInfoDTOAvailability :: !(Maybe OfferAvailabilityStatusType) -- ^ "availability"
  , mappingsOfferInfoDTOShelfLife :: !(Maybe TimePeriodDTO) -- ^ "shelfLife"
  , mappingsOfferInfoDTOLifeTime :: !(Maybe TimePeriodDTO) -- ^ "lifeTime"
  , mappingsOfferInfoDTOGuaranteePeriod :: !(Maybe TimePeriodDTO) -- ^ "guaranteePeriod"
  , mappingsOfferInfoDTOCertificate :: !(Maybe Text) -- ^ "certificate" - Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MappingsOfferInfoDTO
instance A.FromJSON MappingsOfferInfoDTO where
  parseJSON = A.withObject "MappingsOfferInfoDTO" $ \o ->
    MappingsOfferInfoDTO
      <$> (o .:? "name")
      <*> (o .:? "shopSku")
      <*> (o .:? "category")
      <*> (o .:? "vendor")
      <*> (o .:? "vendorCode")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "feedId")
      <*> (o .:? "barcodes")
      <*> (o .:? "urls")
      <*> (o .:? "pictures")
      <*> (o .:? "manufacturer")
      <*> (o .:? "manufacturerCountries")
      <*> (o .:? "minShipment")
      <*> (o .:? "transportUnitSize")
      <*> (o .:? "quantumOfSupply")
      <*> (o .:? "deliveryDurationDays")
      <*> (o .:? "boxCount")
      <*> (o .:? "customsCommodityCodes")
      <*> (o .:? "weightDimensions")
      <*> (o .:? "supplyScheduleDays")
      <*> (o .:? "shelfLifeDays")
      <*> (o .:? "lifeTimeDays")
      <*> (o .:? "guaranteePeriodDays")
      <*> (o .:? "processingState")
      <*> (o .:? "availability")
      <*> (o .:? "shelfLife")
      <*> (o .:? "lifeTime")
      <*> (o .:? "guaranteePeriod")
      <*> (o .:? "certificate")

-- | ToJSON MappingsOfferInfoDTO
instance A.ToJSON MappingsOfferInfoDTO where
  toJSON MappingsOfferInfoDTO {..} =
   _omitNulls
      [ "name" .= mappingsOfferInfoDTOName
      , "shopSku" .= mappingsOfferInfoDTOShopSku
      , "category" .= mappingsOfferInfoDTOCategory
      , "vendor" .= mappingsOfferInfoDTOVendor
      , "vendorCode" .= mappingsOfferInfoDTOVendorCode
      , "description" .= mappingsOfferInfoDTODescription
      , "id" .= mappingsOfferInfoDTOId
      , "feedId" .= mappingsOfferInfoDTOFeedId
      , "barcodes" .= mappingsOfferInfoDTOBarcodes
      , "urls" .= mappingsOfferInfoDTOUrls
      , "pictures" .= mappingsOfferInfoDTOPictures
      , "manufacturer" .= mappingsOfferInfoDTOManufacturer
      , "manufacturerCountries" .= mappingsOfferInfoDTOManufacturerCountries
      , "minShipment" .= mappingsOfferInfoDTOMinShipment
      , "transportUnitSize" .= mappingsOfferInfoDTOTransportUnitSize
      , "quantumOfSupply" .= mappingsOfferInfoDTOQuantumOfSupply
      , "deliveryDurationDays" .= mappingsOfferInfoDTODeliveryDurationDays
      , "boxCount" .= mappingsOfferInfoDTOBoxCount
      , "customsCommodityCodes" .= mappingsOfferInfoDTOCustomsCommodityCodes
      , "weightDimensions" .= mappingsOfferInfoDTOWeightDimensions
      , "supplyScheduleDays" .= mappingsOfferInfoDTOSupplyScheduleDays
      , "shelfLifeDays" .= mappingsOfferInfoDTOShelfLifeDays
      , "lifeTimeDays" .= mappingsOfferInfoDTOLifeTimeDays
      , "guaranteePeriodDays" .= mappingsOfferInfoDTOGuaranteePeriodDays
      , "processingState" .= mappingsOfferInfoDTOProcessingState
      , "availability" .= mappingsOfferInfoDTOAvailability
      , "shelfLife" .= mappingsOfferInfoDTOShelfLife
      , "lifeTime" .= mappingsOfferInfoDTOLifeTime
      , "guaranteePeriod" .= mappingsOfferInfoDTOGuaranteePeriod
      , "certificate" .= mappingsOfferInfoDTOCertificate
      ]


-- | Construct a value of type 'MappingsOfferInfoDTO' (by applying it's required fields, if any)
mkMappingsOfferInfoDTO
  :: MappingsOfferInfoDTO
mkMappingsOfferInfoDTO =
  MappingsOfferInfoDTO
  { mappingsOfferInfoDTOName = Nothing
  , mappingsOfferInfoDTOShopSku = Nothing
  , mappingsOfferInfoDTOCategory = Nothing
  , mappingsOfferInfoDTOVendor = Nothing
  , mappingsOfferInfoDTOVendorCode = Nothing
  , mappingsOfferInfoDTODescription = Nothing
  , mappingsOfferInfoDTOId = Nothing
  , mappingsOfferInfoDTOFeedId = Nothing
  , mappingsOfferInfoDTOBarcodes = Nothing
  , mappingsOfferInfoDTOUrls = Nothing
  , mappingsOfferInfoDTOPictures = Nothing
  , mappingsOfferInfoDTOManufacturer = Nothing
  , mappingsOfferInfoDTOManufacturerCountries = Nothing
  , mappingsOfferInfoDTOMinShipment = Nothing
  , mappingsOfferInfoDTOTransportUnitSize = Nothing
  , mappingsOfferInfoDTOQuantumOfSupply = Nothing
  , mappingsOfferInfoDTODeliveryDurationDays = Nothing
  , mappingsOfferInfoDTOBoxCount = Nothing
  , mappingsOfferInfoDTOCustomsCommodityCodes = Nothing
  , mappingsOfferInfoDTOWeightDimensions = Nothing
  , mappingsOfferInfoDTOSupplyScheduleDays = Nothing
  , mappingsOfferInfoDTOShelfLifeDays = Nothing
  , mappingsOfferInfoDTOLifeTimeDays = Nothing
  , mappingsOfferInfoDTOGuaranteePeriodDays = Nothing
  , mappingsOfferInfoDTOProcessingState = Nothing
  , mappingsOfferInfoDTOAvailability = Nothing
  , mappingsOfferInfoDTOShelfLife = Nothing
  , mappingsOfferInfoDTOLifeTime = Nothing
  , mappingsOfferInfoDTOGuaranteePeriod = Nothing
  , mappingsOfferInfoDTOCertificate = Nothing
  }

-- ** MaxSaleQuantumDTO
-- | MaxSaleQuantumDTO
-- Лимит на установку кванта и минимального количества товаров по категориям. 
data MaxSaleQuantumDTO = MaxSaleQuantumDTO
  { maxSaleQuantumDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор категории.
  , maxSaleQuantumDTOName :: !(Maybe Text) -- ^ "name" - Название категории.
  , maxSaleQuantumDTOMaxSaleQuantum :: !(Maybe Int) -- ^ "maxSaleQuantum" - Лимит на установку кванта и минимального количества товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MaxSaleQuantumDTO
instance A.FromJSON MaxSaleQuantumDTO where
  parseJSON = A.withObject "MaxSaleQuantumDTO" $ \o ->
    MaxSaleQuantumDTO
      <$> (o .:  "id")
      <*> (o .:? "name")
      <*> (o .:? "maxSaleQuantum")

-- | ToJSON MaxSaleQuantumDTO
instance A.ToJSON MaxSaleQuantumDTO where
  toJSON MaxSaleQuantumDTO {..} =
   _omitNulls
      [ "id" .= maxSaleQuantumDTOId
      , "name" .= maxSaleQuantumDTOName
      , "maxSaleQuantum" .= maxSaleQuantumDTOMaxSaleQuantum
      ]


-- | Construct a value of type 'MaxSaleQuantumDTO' (by applying it's required fields, if any)
mkMaxSaleQuantumDTO
  :: Integer -- ^ 'maxSaleQuantumDTOId': Идентификатор категории.
  -> MaxSaleQuantumDTO
mkMaxSaleQuantumDTO maxSaleQuantumDTOId =
  MaxSaleQuantumDTO
  { maxSaleQuantumDTOId
  , maxSaleQuantumDTOName = Nothing
  , maxSaleQuantumDTOMaxSaleQuantum = Nothing
  }

-- ** ModelDTO
-- | ModelDTO
-- Модель товара.
data ModelDTO = ModelDTO
  { modelDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор модели товара.
  , modelDTOName :: !(Maybe Text) -- ^ "name" - Название модели товара.
  , modelDTOPrices :: !(Maybe ModelPriceDTO) -- ^ "prices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelDTO
instance A.FromJSON ModelDTO where
  parseJSON = A.withObject "ModelDTO" $ \o ->
    ModelDTO
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "prices")

-- | ToJSON ModelDTO
instance A.ToJSON ModelDTO where
  toJSON ModelDTO {..} =
   _omitNulls
      [ "id" .= modelDTOId
      , "name" .= modelDTOName
      , "prices" .= modelDTOPrices
      ]


-- | Construct a value of type 'ModelDTO' (by applying it's required fields, if any)
mkModelDTO
  :: ModelDTO
mkModelDTO =
  ModelDTO
  { modelDTOId = Nothing
  , modelDTOName = Nothing
  , modelDTOPrices = Nothing
  }

-- ** ModelOfferDTO
-- | ModelOfferDTO
-- Информация о предложении.
data ModelOfferDTO = ModelOfferDTO
  { modelOfferDTODiscount :: !(Maybe Int) -- ^ "discount" - Скидка на предложение в процентах.
  , modelOfferDTOName :: !(Maybe Text) -- ^ "name" - Наименование предложения.
  , modelOfferDTOPos :: !(Maybe Int) -- ^ "pos" - Позиция предложения в выдаче Маркета на карточке модели.
  , modelOfferDTOPreDiscountPrice :: !(Maybe Double) -- ^ "preDiscountPrice" - Цена предложения без скидки магазина.
  , modelOfferDTOPrice :: !(Maybe Double) -- ^ "price" - Цена предложения без скидки, которую получает покупатель при оплате через Yandex Pay.
  , modelOfferDTORegionId :: !(Maybe Integer) -- ^ "regionId" - Идентификатор региона предложения (регион, откуда доставляется товар).  Сначала показываются предложения, доставляемые из региона, указанного в запросе в параметре &#x60;regionId&#x60;. Предложения, доставляемые из других регионов, показываются после них. 
  , modelOfferDTOShippingCost :: !(Maybe Double) -- ^ "shippingCost" - Стоимость доставки товара в регион:  * &#x60;0&#x60; — доставка осуществляется бесплатно. * &#x60;-1&#x60; — магазин не осуществляет доставку этого товара (самовывоз).  Если стоимость доставки неизвестна, параметр не выводится. 
  , modelOfferDTOShopName :: !(Maybe Text) -- ^ "shopName" - Название магазина (в том виде, в котором отображается на Маркете).
  , modelOfferDTOShopRating :: !(Maybe Int) -- ^ "shopRating" - Рейтинг магазина.  Возможные значения: * &#x60;-1&#x60; — у магазинов, недавно появившихся на Маркете, рейтинг появляется не сразу. До момента появления рейтинга для таких магазинов возвращается значение &#x60;-1&#x60;. * &#x60;1&#x60;. * &#x60;2&#x60;. * &#x60;3&#x60;. * &#x60;4&#x60;. * &#x60;5&#x60;. 
  , modelOfferDTOInStock :: !(Maybe Int) -- ^ "inStock" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %} 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelOfferDTO
instance A.FromJSON ModelOfferDTO where
  parseJSON = A.withObject "ModelOfferDTO" $ \o ->
    ModelOfferDTO
      <$> (o .:? "discount")
      <*> (o .:? "name")
      <*> (o .:? "pos")
      <*> (o .:? "preDiscountPrice")
      <*> (o .:? "price")
      <*> (o .:? "regionId")
      <*> (o .:? "shippingCost")
      <*> (o .:? "shopName")
      <*> (o .:? "shopRating")
      <*> (o .:? "inStock")

-- | ToJSON ModelOfferDTO
instance A.ToJSON ModelOfferDTO where
  toJSON ModelOfferDTO {..} =
   _omitNulls
      [ "discount" .= modelOfferDTODiscount
      , "name" .= modelOfferDTOName
      , "pos" .= modelOfferDTOPos
      , "preDiscountPrice" .= modelOfferDTOPreDiscountPrice
      , "price" .= modelOfferDTOPrice
      , "regionId" .= modelOfferDTORegionId
      , "shippingCost" .= modelOfferDTOShippingCost
      , "shopName" .= modelOfferDTOShopName
      , "shopRating" .= modelOfferDTOShopRating
      , "inStock" .= modelOfferDTOInStock
      ]


-- | Construct a value of type 'ModelOfferDTO' (by applying it's required fields, if any)
mkModelOfferDTO
  :: ModelOfferDTO
mkModelOfferDTO =
  ModelOfferDTO
  { modelOfferDTODiscount = Nothing
  , modelOfferDTOName = Nothing
  , modelOfferDTOPos = Nothing
  , modelOfferDTOPreDiscountPrice = Nothing
  , modelOfferDTOPrice = Nothing
  , modelOfferDTORegionId = Nothing
  , modelOfferDTOShippingCost = Nothing
  , modelOfferDTOShopName = Nothing
  , modelOfferDTOShopRating = Nothing
  , modelOfferDTOInStock = Nothing
  }

-- ** ModelPriceDTO
-- | ModelPriceDTO
-- Информация о ценах на модель товара.
data ModelPriceDTO = ModelPriceDTO
  { modelPriceDTOAvg :: !(Maybe Double) -- ^ "avg" - Средняя цена предложения для модели в регионе.
  , modelPriceDTOMax :: !(Maybe Double) -- ^ "max" - Максимальная цена предложения для модели в регионе.
  , modelPriceDTOMin :: !(Maybe Double) -- ^ "min" - Минимальная цена предложения для модели в регионе.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelPriceDTO
instance A.FromJSON ModelPriceDTO where
  parseJSON = A.withObject "ModelPriceDTO" $ \o ->
    ModelPriceDTO
      <$> (o .:? "avg")
      <*> (o .:? "max")
      <*> (o .:? "min")

-- | ToJSON ModelPriceDTO
instance A.ToJSON ModelPriceDTO where
  toJSON ModelPriceDTO {..} =
   _omitNulls
      [ "avg" .= modelPriceDTOAvg
      , "max" .= modelPriceDTOMax
      , "min" .= modelPriceDTOMin
      ]


-- | Construct a value of type 'ModelPriceDTO' (by applying it's required fields, if any)
mkModelPriceDTO
  :: ModelPriceDTO
mkModelPriceDTO =
  ModelPriceDTO
  { modelPriceDTOAvg = Nothing
  , modelPriceDTOMax = Nothing
  , modelPriceDTOMin = Nothing
  }

-- ** ModelsDTO
-- | ModelsDTO
-- Список моделей товаров.
data ModelsDTO = ModelsDTO
  { modelsDTOModels :: !([ModelDTO]) -- ^ /Required/ "models" - Список моделей товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsDTO
instance A.FromJSON ModelsDTO where
  parseJSON = A.withObject "ModelsDTO" $ \o ->
    ModelsDTO
      <$> (o .:  "models")

-- | ToJSON ModelsDTO
instance A.ToJSON ModelsDTO where
  toJSON ModelsDTO {..} =
   _omitNulls
      [ "models" .= modelsDTOModels
      ]


-- | Construct a value of type 'ModelsDTO' (by applying it's required fields, if any)
mkModelsDTO
  :: [ModelDTO] -- ^ 'modelsDTOModels': Список моделей товаров.
  -> ModelsDTO
mkModelsDTO modelsDTOModels =
  ModelsDTO
  { modelsDTOModels
  }

-- ** OfferCampaignStatusDTO
-- | OfferCampaignStatusDTO
-- Статус товара в магазине.
data OfferCampaignStatusDTO = OfferCampaignStatusDTO
  { offerCampaignStatusDTOCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - Идентификатор кампании. 
  , offerCampaignStatusDTOStatus :: !(OfferCampaignStatusType) -- ^ /Required/ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferCampaignStatusDTO
instance A.FromJSON OfferCampaignStatusDTO where
  parseJSON = A.withObject "OfferCampaignStatusDTO" $ \o ->
    OfferCampaignStatusDTO
      <$> (o .:  "campaignId")
      <*> (o .:  "status")

-- | ToJSON OfferCampaignStatusDTO
instance A.ToJSON OfferCampaignStatusDTO where
  toJSON OfferCampaignStatusDTO {..} =
   _omitNulls
      [ "campaignId" .= offerCampaignStatusDTOCampaignId
      , "status" .= offerCampaignStatusDTOStatus
      ]


-- | Construct a value of type 'OfferCampaignStatusDTO' (by applying it's required fields, if any)
mkOfferCampaignStatusDTO
  :: Integer -- ^ 'offerCampaignStatusDTOCampaignId': Идентификатор кампании. 
  -> OfferCampaignStatusType -- ^ 'offerCampaignStatusDTOStatus' 
  -> OfferCampaignStatusDTO
mkOfferCampaignStatusDTO offerCampaignStatusDTOCampaignId offerCampaignStatusDTOStatus =
  OfferCampaignStatusDTO
  { offerCampaignStatusDTOCampaignId
  , offerCampaignStatusDTOStatus
  }

-- ** OfferCardDTO
-- | OfferCardDTO
-- Информация о состоянии карточки товара.  Если поле `mapping` отсутствует в ответе, Маркет еще не успел обработать информацию о товаре. Чтобы определить категорию такого товара, повторите запрос через несколько минут. 
data OfferCardDTO = OfferCardDTO
  { offerCardDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , offerCardDTOMapping :: !(Maybe GetMappingDTO) -- ^ "mapping"
  , offerCardDTOParameterValues :: !(Maybe [ParameterValueDTO]) -- ^ "parameterValues" - Список характеристик с их значениями. 
  , offerCardDTOCardStatus :: !(Maybe OfferCardStatusType) -- ^ "cardStatus"
  , offerCardDTOContentRating :: !(Maybe Int) -- ^ "contentRating" - Процент заполненности карточки.
  , offerCardDTORecommendations :: !(Maybe [OfferCardRecommendationDTO]) -- ^ "recommendations" - Список рекомендаций к заполнению карточки.  Рекомендации Маркета помогают заполнять карточку так, чтобы покупателям было проще найти ваш товар и решиться на покупку. 
  , offerCardDTOErrors :: !(Maybe [OfferErrorDTO]) -- ^ "errors" - Ошибки в контенте, препятствующие размещению товара на витрине.
  , offerCardDTOWarnings :: !(Maybe [OfferErrorDTO]) -- ^ "warnings" - Связанные с контентом предупреждения, не препятствующие размещению товара на витрине.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferCardDTO
instance A.FromJSON OfferCardDTO where
  parseJSON = A.withObject "OfferCardDTO" $ \o ->
    OfferCardDTO
      <$> (o .:  "offerId")
      <*> (o .:? "mapping")
      <*> (o .:? "parameterValues")
      <*> (o .:? "cardStatus")
      <*> (o .:? "contentRating")
      <*> (o .:? "recommendations")
      <*> (o .:? "errors")
      <*> (o .:? "warnings")

-- | ToJSON OfferCardDTO
instance A.ToJSON OfferCardDTO where
  toJSON OfferCardDTO {..} =
   _omitNulls
      [ "offerId" .= offerCardDTOOfferId
      , "mapping" .= offerCardDTOMapping
      , "parameterValues" .= offerCardDTOParameterValues
      , "cardStatus" .= offerCardDTOCardStatus
      , "contentRating" .= offerCardDTOContentRating
      , "recommendations" .= offerCardDTORecommendations
      , "errors" .= offerCardDTOErrors
      , "warnings" .= offerCardDTOWarnings
      ]


-- | Construct a value of type 'OfferCardDTO' (by applying it's required fields, if any)
mkOfferCardDTO
  :: Text -- ^ 'offerCardDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> OfferCardDTO
mkOfferCardDTO offerCardDTOOfferId =
  OfferCardDTO
  { offerCardDTOOfferId
  , offerCardDTOMapping = Nothing
  , offerCardDTOParameterValues = Nothing
  , offerCardDTOCardStatus = Nothing
  , offerCardDTOContentRating = Nothing
  , offerCardDTORecommendations = Nothing
  , offerCardDTOErrors = Nothing
  , offerCardDTOWarnings = Nothing
  }

-- ** OfferCardRecommendationDTO
-- | OfferCardRecommendationDTO
-- Рекомендация по заполнению карточки товара.
data OfferCardRecommendationDTO = OfferCardRecommendationDTO
  { offerCardRecommendationDTOType :: !(OfferCardRecommendationType) -- ^ /Required/ "type"
  , offerCardRecommendationDTOPercent :: !(Maybe Int) -- ^ "percent" - Процент выполнения рекомендации. Указывается для рекомендаций некоторых типов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferCardRecommendationDTO
instance A.FromJSON OfferCardRecommendationDTO where
  parseJSON = A.withObject "OfferCardRecommendationDTO" $ \o ->
    OfferCardRecommendationDTO
      <$> (o .:  "type")
      <*> (o .:? "percent")

-- | ToJSON OfferCardRecommendationDTO
instance A.ToJSON OfferCardRecommendationDTO where
  toJSON OfferCardRecommendationDTO {..} =
   _omitNulls
      [ "type" .= offerCardRecommendationDTOType
      , "percent" .= offerCardRecommendationDTOPercent
      ]


-- | Construct a value of type 'OfferCardRecommendationDTO' (by applying it's required fields, if any)
mkOfferCardRecommendationDTO
  :: OfferCardRecommendationType -- ^ 'offerCardRecommendationDTOType' 
  -> OfferCardRecommendationDTO
mkOfferCardRecommendationDTO offerCardRecommendationDTOType =
  OfferCardRecommendationDTO
  { offerCardRecommendationDTOType
  , offerCardRecommendationDTOPercent = Nothing
  }

-- ** OfferCardsContentStatusDTO
-- | OfferCardsContentStatusDTO
-- Список товаров с информацией о состоянии карточек.
data OfferCardsContentStatusDTO = OfferCardsContentStatusDTO
  { offerCardsContentStatusDTOOfferCards :: !([OfferCardDTO]) -- ^ /Required/ "offerCards" - Страница списка товаров с информацией о состоянии карточек.
  , offerCardsContentStatusDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferCardsContentStatusDTO
instance A.FromJSON OfferCardsContentStatusDTO where
  parseJSON = A.withObject "OfferCardsContentStatusDTO" $ \o ->
    OfferCardsContentStatusDTO
      <$> (o .:  "offerCards")
      <*> (o .:? "paging")

-- | ToJSON OfferCardsContentStatusDTO
instance A.ToJSON OfferCardsContentStatusDTO where
  toJSON OfferCardsContentStatusDTO {..} =
   _omitNulls
      [ "offerCards" .= offerCardsContentStatusDTOOfferCards
      , "paging" .= offerCardsContentStatusDTOPaging
      ]


-- | Construct a value of type 'OfferCardsContentStatusDTO' (by applying it's required fields, if any)
mkOfferCardsContentStatusDTO
  :: [OfferCardDTO] -- ^ 'offerCardsContentStatusDTOOfferCards': Страница списка товаров с информацией о состоянии карточек.
  -> OfferCardsContentStatusDTO
mkOfferCardsContentStatusDTO offerCardsContentStatusDTOOfferCards =
  OfferCardsContentStatusDTO
  { offerCardsContentStatusDTOOfferCards
  , offerCardsContentStatusDTOPaging = Nothing
  }

-- ** OfferConditionDTO
-- | OfferConditionDTO
-- Состояние уцененного товара. 
data OfferConditionDTO = OfferConditionDTO
  { offerConditionDTOType :: !(Maybe OfferConditionType) -- ^ "type"
  , offerConditionDTOQuality :: !(Maybe OfferConditionQualityType) -- ^ "quality"
  , offerConditionDTOReason :: !(Maybe Text) -- ^ "reason" - Описание товара. Подробно опишите дефекты, насколько они заметны и где их искать. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferConditionDTO
instance A.FromJSON OfferConditionDTO where
  parseJSON = A.withObject "OfferConditionDTO" $ \o ->
    OfferConditionDTO
      <$> (o .:? "type")
      <*> (o .:? "quality")
      <*> (o .:? "reason")

-- | ToJSON OfferConditionDTO
instance A.ToJSON OfferConditionDTO where
  toJSON OfferConditionDTO {..} =
   _omitNulls
      [ "type" .= offerConditionDTOType
      , "quality" .= offerConditionDTOQuality
      , "reason" .= offerConditionDTOReason
      ]


-- | Construct a value of type 'OfferConditionDTO' (by applying it's required fields, if any)
mkOfferConditionDTO
  :: OfferConditionDTO
mkOfferConditionDTO =
  OfferConditionDTO
  { offerConditionDTOType = Nothing
  , offerConditionDTOQuality = Nothing
  , offerConditionDTOReason = Nothing
  }

-- ** OfferContentDTO
-- | OfferContentDTO
-- Товар с указанными характеристиками.
data OfferContentDTO = OfferContentDTO
  { offerContentDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , offerContentDTOCategoryId :: !(Int) -- ^ /Required/ "categoryId" - Идентификатор категории на Маркете. Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).
  , offerContentDTOParameterValues :: !([ParameterValueDTO]) -- ^ /Required/ "parameterValues" - Список характеристик с их значениями.  С &#x60;parameterValues&#x60; обязательно передавайте &#x60;marketCategoryId&#x60; — идентификатор категории на Маркете, к которой относятся указанные характеристики товара.  При **изменении** характеристик передавайте только те, значение которых нужно обновить.  Чтобы **удалить** значение заданной характеристики, передайте ее &#x60;parameterId&#x60; с пустым &#x60;value&#x60;.  Максимальное количество характеристик — 300. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferContentDTO
instance A.FromJSON OfferContentDTO where
  parseJSON = A.withObject "OfferContentDTO" $ \o ->
    OfferContentDTO
      <$> (o .:  "offerId")
      <*> (o .:  "categoryId")
      <*> (o .:  "parameterValues")

-- | ToJSON OfferContentDTO
instance A.ToJSON OfferContentDTO where
  toJSON OfferContentDTO {..} =
   _omitNulls
      [ "offerId" .= offerContentDTOOfferId
      , "categoryId" .= offerContentDTOCategoryId
      , "parameterValues" .= offerContentDTOParameterValues
      ]


-- | Construct a value of type 'OfferContentDTO' (by applying it's required fields, if any)
mkOfferContentDTO
  :: Text -- ^ 'offerContentDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> Int -- ^ 'offerContentDTOCategoryId': Идентификатор категории на Маркете. Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).
  -> [ParameterValueDTO] -- ^ 'offerContentDTOParameterValues': Список характеристик с их значениями.  С `parameterValues` обязательно передавайте `marketCategoryId` — идентификатор категории на Маркете, к которой относятся указанные характеристики товара.  При **изменении** характеристик передавайте только те, значение которых нужно обновить.  Чтобы **удалить** значение заданной характеристики, передайте ее `parameterId` с пустым `value`.  Максимальное количество характеристик — 300. 
  -> OfferContentDTO
mkOfferContentDTO offerContentDTOOfferId offerContentDTOCategoryId offerContentDTOParameterValues =
  OfferContentDTO
  { offerContentDTOOfferId
  , offerContentDTOCategoryId
  , offerContentDTOParameterValues
  }

-- ** OfferContentErrorDTO
-- | OfferContentErrorDTO
-- Текст ошибки.
data OfferContentErrorDTO = OfferContentErrorDTO
  { offerContentErrorDTOType :: !(OfferContentErrorType) -- ^ /Required/ "type"
  , offerContentErrorDTOParameterId :: !(Maybe Integer) -- ^ "parameterId" - Идентификатор характеристики, с которой связана ошибка.
  , offerContentErrorDTOMessage :: !(Text) -- ^ /Required/ "message" - Текст ошибки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferContentErrorDTO
instance A.FromJSON OfferContentErrorDTO where
  parseJSON = A.withObject "OfferContentErrorDTO" $ \o ->
    OfferContentErrorDTO
      <$> (o .:  "type")
      <*> (o .:? "parameterId")
      <*> (o .:  "message")

-- | ToJSON OfferContentErrorDTO
instance A.ToJSON OfferContentErrorDTO where
  toJSON OfferContentErrorDTO {..} =
   _omitNulls
      [ "type" .= offerContentErrorDTOType
      , "parameterId" .= offerContentErrorDTOParameterId
      , "message" .= offerContentErrorDTOMessage
      ]


-- | Construct a value of type 'OfferContentErrorDTO' (by applying it's required fields, if any)
mkOfferContentErrorDTO
  :: OfferContentErrorType -- ^ 'offerContentErrorDTOType' 
  -> Text -- ^ 'offerContentErrorDTOMessage': Текст ошибки.
  -> OfferContentErrorDTO
mkOfferContentErrorDTO offerContentErrorDTOType offerContentErrorDTOMessage =
  OfferContentErrorDTO
  { offerContentErrorDTOType
  , offerContentErrorDTOParameterId = Nothing
  , offerContentErrorDTOMessage
  }

-- ** OfferDTO
-- | OfferDTO
-- Предложение.
data OfferDTO = OfferDTO
  { offerDTOPrice :: !(Maybe Double) -- ^ "price" - Цена предложения.  До версии 2.0 партнерского API у параметра был тип String. 
  , offerDTOFeedId :: !(Maybe Integer) -- ^ "feedId" - Идентификатор прайс-листа, содержащего предложение.  Параметр доступен начиная с версии 2.0 партнерского API. 
  , offerDTOId :: !(Maybe Text) -- ^ "id" - Идентификатор предложения из прайс-листа.  Параметр выводится, если в прайс-листе задан уникальный идентификатор. Если в прайс-листе содержится несколько предложений с одинаковыми идентификаторами, параметр &#x60;id&#x60; указывается только для первого из них, для остальных параметры &#x60;id&#x60; и &#x60;feedId&#x60; не выводятся.  Параметр доступен начиная с версии 2.0 партнерского API. 
  , offerDTOShopCategoryId :: !(Maybe Text) -- ^ "shopCategoryId" - Идентификатор категории предложения, указанный магазином в прайс-листе.  Параметр выводится только для предложений, у которых указана категория в прайс-листе.  Параметр доступен начиная с версии 2.0 партнерского API. 
  , offerDTOMarketCategoryId :: !(Maybe Int) -- ^ "marketCategoryId" - Идентификатор категории предложения в дереве категорий Маркета. Параметр доступен начиная с версии 2.0 партнерского API. 
  , offerDTOPreDiscountPrice :: !(Maybe Double) -- ^ "preDiscountPrice" - Цена предложения без скидки.
  , offerDTODiscount :: !(Maybe Int) -- ^ "discount" - Скидка на предложение в процентах.
  , offerDTOCutPrice :: !(Maybe Bool) -- ^ "cutPrice" - Является ли предложение уцененным:  * &#x60;true&#x60; — да. * &#x60;false&#x60; — нет.  Параметр доступен начиная с версии 2.58 партнерского API. 
  , offerDTOUrl :: !(Maybe Text) -- ^ "url" - URL-адрес предложения на сайте магазина.
  , offerDTOModelId :: !(Integer) -- ^ /Required/ "modelId" - Идентификатор модели Маркета, с которой соотнесено предложение.  Если предложение не соотнесено ни с какой карточкой модели, то параметр &#x60;modelid&#x60; содержит значение &#x60;0&#x60;.  {% note info %}  Идентификатор модели присутствует в URL карточки модели в виде значения параметра &#x60;product&#x60;. Например: &#x60;https://market.yandex.ru/product/13584121&#x60;.  {% endnote %} 
  , offerDTOName :: !(Maybe Text) -- ^ "name" - Наименование предложения.
  , offerDTOCurrency :: !(Maybe CurrencyType) -- ^ "currency"
  , offerDTOBid :: !(Maybe Double) -- ^ "bid" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Ставка на клик. 
  , offerDTOCbid :: !(Maybe Double) -- ^ "cbid" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Ставка на клик. 
  , offerDTOFee :: !(Maybe Double) -- ^ "fee" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Процент комиссии на товар при продаже по CPA. 
  , offerDTOBlocked :: !(Maybe Bool) -- ^ "blocked" - Признак блокировки предложения. Возможные значения: * &#x60;false&#x60; — предложение активно, параметр не выводится. * &#x60;true&#x60; — предложение заблокировано. Параметр выводится, если предложение заблокировано и не попадает в выдачу Маркета. Это может произойти из-за отключения магазина. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferDTO
instance A.FromJSON OfferDTO where
  parseJSON = A.withObject "OfferDTO" $ \o ->
    OfferDTO
      <$> (o .:? "price")
      <*> (o .:? "feedId")
      <*> (o .:? "id")
      <*> (o .:? "shopCategoryId")
      <*> (o .:? "marketCategoryId")
      <*> (o .:? "preDiscountPrice")
      <*> (o .:? "discount")
      <*> (o .:? "cutPrice")
      <*> (o .:? "url")
      <*> (o .:  "modelId")
      <*> (o .:? "name")
      <*> (o .:? "currency")
      <*> (o .:? "bid")
      <*> (o .:? "cbid")
      <*> (o .:? "fee")
      <*> (o .:? "blocked")

-- | ToJSON OfferDTO
instance A.ToJSON OfferDTO where
  toJSON OfferDTO {..} =
   _omitNulls
      [ "price" .= offerDTOPrice
      , "feedId" .= offerDTOFeedId
      , "id" .= offerDTOId
      , "shopCategoryId" .= offerDTOShopCategoryId
      , "marketCategoryId" .= offerDTOMarketCategoryId
      , "preDiscountPrice" .= offerDTOPreDiscountPrice
      , "discount" .= offerDTODiscount
      , "cutPrice" .= offerDTOCutPrice
      , "url" .= offerDTOUrl
      , "modelId" .= offerDTOModelId
      , "name" .= offerDTOName
      , "currency" .= offerDTOCurrency
      , "bid" .= offerDTOBid
      , "cbid" .= offerDTOCbid
      , "fee" .= offerDTOFee
      , "blocked" .= offerDTOBlocked
      ]


-- | Construct a value of type 'OfferDTO' (by applying it's required fields, if any)
mkOfferDTO
  :: Integer -- ^ 'offerDTOModelId': Идентификатор модели Маркета, с которой соотнесено предложение.  Если предложение не соотнесено ни с какой карточкой модели, то параметр `modelid` содержит значение `0`.  {% note info %}  Идентификатор модели присутствует в URL карточки модели в виде значения параметра `product`. Например: `https://market.yandex.ru/product/13584121`.  {% endnote %} 
  -> OfferDTO
mkOfferDTO offerDTOModelId =
  OfferDTO
  { offerDTOPrice = Nothing
  , offerDTOFeedId = Nothing
  , offerDTOId = Nothing
  , offerDTOShopCategoryId = Nothing
  , offerDTOMarketCategoryId = Nothing
  , offerDTOPreDiscountPrice = Nothing
  , offerDTODiscount = Nothing
  , offerDTOCutPrice = Nothing
  , offerDTOUrl = Nothing
  , offerDTOModelId
  , offerDTOName = Nothing
  , offerDTOCurrency = Nothing
  , offerDTOBid = Nothing
  , offerDTOCbid = Nothing
  , offerDTOFee = Nothing
  , offerDTOBlocked = Nothing
  }

-- ** OfferErrorDTO
-- | OfferErrorDTO
-- Сообщение об ошибке, связанной с размещением товара.
data OfferErrorDTO = OfferErrorDTO
  { offerErrorDTOMessage :: !(Maybe Text) -- ^ "message" - Тип ошибки.
  , offerErrorDTOComment :: !(Maybe Text) -- ^ "comment" - Пояснение.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferErrorDTO
instance A.FromJSON OfferErrorDTO where
  parseJSON = A.withObject "OfferErrorDTO" $ \o ->
    OfferErrorDTO
      <$> (o .:? "message")
      <*> (o .:? "comment")

-- | ToJSON OfferErrorDTO
instance A.ToJSON OfferErrorDTO where
  toJSON OfferErrorDTO {..} =
   _omitNulls
      [ "message" .= offerErrorDTOMessage
      , "comment" .= offerErrorDTOComment
      ]


-- | Construct a value of type 'OfferErrorDTO' (by applying it's required fields, if any)
mkOfferErrorDTO
  :: OfferErrorDTO
mkOfferErrorDTO =
  OfferErrorDTO
  { offerErrorDTOMessage = Nothing
  , offerErrorDTOComment = Nothing
  }

-- ** OfferForRecommendationDTO
-- | OfferForRecommendationDTO
-- Информация о состоянии цены на товар.
data OfferForRecommendationDTO = OfferForRecommendationDTO
  { offerForRecommendationDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , offerForRecommendationDTOPrice :: !(Maybe BasePriceDTO) -- ^ "price"
  , offerForRecommendationDTOCofinancePrice :: !(Maybe GetPriceDTO) -- ^ "cofinancePrice"
  , offerForRecommendationDTOCompetitiveness :: !(Maybe PriceCompetitivenessType) -- ^ "competitiveness"
  , offerForRecommendationDTOShows :: !(Maybe Integer) -- ^ "shows" - Количество показов карточки товара за последние 7 дней.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferForRecommendationDTO
instance A.FromJSON OfferForRecommendationDTO where
  parseJSON = A.withObject "OfferForRecommendationDTO" $ \o ->
    OfferForRecommendationDTO
      <$> (o .:? "offerId")
      <*> (o .:? "price")
      <*> (o .:? "cofinancePrice")
      <*> (o .:? "competitiveness")
      <*> (o .:? "shows")

-- | ToJSON OfferForRecommendationDTO
instance A.ToJSON OfferForRecommendationDTO where
  toJSON OfferForRecommendationDTO {..} =
   _omitNulls
      [ "offerId" .= offerForRecommendationDTOOfferId
      , "price" .= offerForRecommendationDTOPrice
      , "cofinancePrice" .= offerForRecommendationDTOCofinancePrice
      , "competitiveness" .= offerForRecommendationDTOCompetitiveness
      , "shows" .= offerForRecommendationDTOShows
      ]


-- | Construct a value of type 'OfferForRecommendationDTO' (by applying it's required fields, if any)
mkOfferForRecommendationDTO
  :: OfferForRecommendationDTO
mkOfferForRecommendationDTO =
  OfferForRecommendationDTO
  { offerForRecommendationDTOOfferId = Nothing
  , offerForRecommendationDTOPrice = Nothing
  , offerForRecommendationDTOCofinancePrice = Nothing
  , offerForRecommendationDTOCompetitiveness = Nothing
  , offerForRecommendationDTOShows = Nothing
  }

-- ** OfferManualDTO
-- | OfferManualDTO
-- Инструкция по использованию товара. 
data OfferManualDTO = OfferManualDTO
  { offerManualDTOUrl :: !(Text) -- ^ /Required/ "url" - Ссылка на инструкцию.
  , offerManualDTOTitle :: !(Maybe Text) -- ^ "title" - Название инструкции, которое будет отображаться на карточке товара. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferManualDTO
instance A.FromJSON OfferManualDTO where
  parseJSON = A.withObject "OfferManualDTO" $ \o ->
    OfferManualDTO
      <$> (o .:  "url")
      <*> (o .:? "title")

-- | ToJSON OfferManualDTO
instance A.ToJSON OfferManualDTO where
  toJSON OfferManualDTO {..} =
   _omitNulls
      [ "url" .= offerManualDTOUrl
      , "title" .= offerManualDTOTitle
      ]


-- | Construct a value of type 'OfferManualDTO' (by applying it's required fields, if any)
mkOfferManualDTO
  :: Text -- ^ 'offerManualDTOUrl': Ссылка на инструкцию.
  -> OfferManualDTO
mkOfferManualDTO offerManualDTOUrl =
  OfferManualDTO
  { offerManualDTOUrl
  , offerManualDTOTitle = Nothing
  }

-- ** OfferMappingDTO
-- | OfferMappingDTO
-- Информация о текущей карточке товара на Маркете.
data OfferMappingDTO = OfferMappingDTO
  { offerMappingDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  , offerMappingDTOModelId :: !(Maybe Integer) -- ^ "modelId" - Идентификатор модели для текущей карточки товара на Маркете.  Например, две лопатки разных цветов имеют разные SKU на Маркете (параметр &#x60;marketSku&#x60;), но одинаковый идентификатор модели товара. 
  , offerMappingDTOCategoryId :: !(Maybe Integer) -- ^ "categoryId" - Идентификатор категории для текущей карточки товара на Маркете.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferMappingDTO
instance A.FromJSON OfferMappingDTO where
  parseJSON = A.withObject "OfferMappingDTO" $ \o ->
    OfferMappingDTO
      <$> (o .:? "marketSku")
      <*> (o .:? "modelId")
      <*> (o .:? "categoryId")

-- | ToJSON OfferMappingDTO
instance A.ToJSON OfferMappingDTO where
  toJSON OfferMappingDTO {..} =
   _omitNulls
      [ "marketSku" .= offerMappingDTOMarketSku
      , "modelId" .= offerMappingDTOModelId
      , "categoryId" .= offerMappingDTOCategoryId
      ]


-- | Construct a value of type 'OfferMappingDTO' (by applying it's required fields, if any)
mkOfferMappingDTO
  :: OfferMappingDTO
mkOfferMappingDTO =
  OfferMappingDTO
  { offerMappingDTOMarketSku = Nothing
  , offerMappingDTOModelId = Nothing
  , offerMappingDTOCategoryId = Nothing
  }

-- ** OfferMappingEntriesDTO
-- | OfferMappingEntriesDTO
-- Информация о товарах в каталоге.
data OfferMappingEntriesDTO = OfferMappingEntriesDTO
  { offerMappingEntriesDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , offerMappingEntriesDTOOfferMappingEntries :: !([OfferMappingEntryDTO]) -- ^ /Required/ "offerMappingEntries" - Информация о товарах в каталоге.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferMappingEntriesDTO
instance A.FromJSON OfferMappingEntriesDTO where
  parseJSON = A.withObject "OfferMappingEntriesDTO" $ \o ->
    OfferMappingEntriesDTO
      <$> (o .:? "paging")
      <*> (o .:  "offerMappingEntries")

-- | ToJSON OfferMappingEntriesDTO
instance A.ToJSON OfferMappingEntriesDTO where
  toJSON OfferMappingEntriesDTO {..} =
   _omitNulls
      [ "paging" .= offerMappingEntriesDTOPaging
      , "offerMappingEntries" .= offerMappingEntriesDTOOfferMappingEntries
      ]


-- | Construct a value of type 'OfferMappingEntriesDTO' (by applying it's required fields, if any)
mkOfferMappingEntriesDTO
  :: [OfferMappingEntryDTO] -- ^ 'offerMappingEntriesDTOOfferMappingEntries': Информация о товарах в каталоге.
  -> OfferMappingEntriesDTO
mkOfferMappingEntriesDTO offerMappingEntriesDTOOfferMappingEntries =
  OfferMappingEntriesDTO
  { offerMappingEntriesDTOPaging = Nothing
  , offerMappingEntriesDTOOfferMappingEntries
  }

-- ** OfferMappingEntryDTO
-- | OfferMappingEntryDTO
-- Список товаров. 
data OfferMappingEntryDTO = OfferMappingEntryDTO
  { offerMappingEntryDTOMapping :: !(Maybe OfferMappingDTO) -- ^ "mapping"
  , offerMappingEntryDTOAwaitingModerationMapping :: !(Maybe OfferMappingDTO) -- ^ "awaitingModerationMapping"
  , offerMappingEntryDTORejectedMapping :: !(Maybe OfferMappingDTO) -- ^ "rejectedMapping"
  , offerMappingEntryDTOOffer :: !(Maybe MappingsOfferDTO) -- ^ "offer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferMappingEntryDTO
instance A.FromJSON OfferMappingEntryDTO where
  parseJSON = A.withObject "OfferMappingEntryDTO" $ \o ->
    OfferMappingEntryDTO
      <$> (o .:? "mapping")
      <*> (o .:? "awaitingModerationMapping")
      <*> (o .:? "rejectedMapping")
      <*> (o .:? "offer")

-- | ToJSON OfferMappingEntryDTO
instance A.ToJSON OfferMappingEntryDTO where
  toJSON OfferMappingEntryDTO {..} =
   _omitNulls
      [ "mapping" .= offerMappingEntryDTOMapping
      , "awaitingModerationMapping" .= offerMappingEntryDTOAwaitingModerationMapping
      , "rejectedMapping" .= offerMappingEntryDTORejectedMapping
      , "offer" .= offerMappingEntryDTOOffer
      ]


-- | Construct a value of type 'OfferMappingEntryDTO' (by applying it's required fields, if any)
mkOfferMappingEntryDTO
  :: OfferMappingEntryDTO
mkOfferMappingEntryDTO =
  OfferMappingEntryDTO
  { offerMappingEntryDTOMapping = Nothing
  , offerMappingEntryDTOAwaitingModerationMapping = Nothing
  , offerMappingEntryDTORejectedMapping = Nothing
  , offerMappingEntryDTOOffer = Nothing
  }

-- ** OfferMappingErrorDTO
-- | OfferMappingErrorDTO
-- Текст ошибки.
data OfferMappingErrorDTO = OfferMappingErrorDTO
  { offerMappingErrorDTOType :: !(OfferMappingErrorType) -- ^ /Required/ "type"
  , offerMappingErrorDTOParameterId :: !(Maybe Integer) -- ^ "parameterId" - Идентификатор характеристики, с которой связана ошибка.
  , offerMappingErrorDTOMessage :: !(Text) -- ^ /Required/ "message" - Текст ошибки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferMappingErrorDTO
instance A.FromJSON OfferMappingErrorDTO where
  parseJSON = A.withObject "OfferMappingErrorDTO" $ \o ->
    OfferMappingErrorDTO
      <$> (o .:  "type")
      <*> (o .:? "parameterId")
      <*> (o .:  "message")

-- | ToJSON OfferMappingErrorDTO
instance A.ToJSON OfferMappingErrorDTO where
  toJSON OfferMappingErrorDTO {..} =
   _omitNulls
      [ "type" .= offerMappingErrorDTOType
      , "parameterId" .= offerMappingErrorDTOParameterId
      , "message" .= offerMappingErrorDTOMessage
      ]


-- | Construct a value of type 'OfferMappingErrorDTO' (by applying it's required fields, if any)
mkOfferMappingErrorDTO
  :: OfferMappingErrorType -- ^ 'offerMappingErrorDTOType' 
  -> Text -- ^ 'offerMappingErrorDTOMessage': Текст ошибки.
  -> OfferMappingErrorDTO
mkOfferMappingErrorDTO offerMappingErrorDTOType offerMappingErrorDTOMessage =
  OfferMappingErrorDTO
  { offerMappingErrorDTOType
  , offerMappingErrorDTOParameterId = Nothing
  , offerMappingErrorDTOMessage
  }

-- ** OfferMappingInfoDTO
-- | OfferMappingInfoDTO
-- Информация о карточке товара.
data OfferMappingInfoDTO = OfferMappingInfoDTO
  { offerMappingInfoDTOMapping :: !(Maybe OfferMappingDTO) -- ^ "mapping"
  , offerMappingInfoDTOAwaitingModerationMapping :: !(Maybe OfferMappingDTO) -- ^ "awaitingModerationMapping"
  , offerMappingInfoDTORejectedMapping :: !(Maybe OfferMappingDTO) -- ^ "rejectedMapping"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferMappingInfoDTO
instance A.FromJSON OfferMappingInfoDTO where
  parseJSON = A.withObject "OfferMappingInfoDTO" $ \o ->
    OfferMappingInfoDTO
      <$> (o .:? "mapping")
      <*> (o .:? "awaitingModerationMapping")
      <*> (o .:? "rejectedMapping")

-- | ToJSON OfferMappingInfoDTO
instance A.ToJSON OfferMappingInfoDTO where
  toJSON OfferMappingInfoDTO {..} =
   _omitNulls
      [ "mapping" .= offerMappingInfoDTOMapping
      , "awaitingModerationMapping" .= offerMappingInfoDTOAwaitingModerationMapping
      , "rejectedMapping" .= offerMappingInfoDTORejectedMapping
      ]


-- | Construct a value of type 'OfferMappingInfoDTO' (by applying it's required fields, if any)
mkOfferMappingInfoDTO
  :: OfferMappingInfoDTO
mkOfferMappingInfoDTO =
  OfferMappingInfoDTO
  { offerMappingInfoDTOMapping = Nothing
  , offerMappingInfoDTOAwaitingModerationMapping = Nothing
  , offerMappingInfoDTORejectedMapping = Nothing
  }

-- ** OfferMappingSuggestionsListDTO
-- | OfferMappingSuggestionsListDTO
-- Список рекомендованных карточек товара.
data OfferMappingSuggestionsListDTO = OfferMappingSuggestionsListDTO
  { offerMappingSuggestionsListDTOOffers :: !([EnrichedMappingsOfferDTO]) -- ^ /Required/ "offers" - Список товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferMappingSuggestionsListDTO
instance A.FromJSON OfferMappingSuggestionsListDTO where
  parseJSON = A.withObject "OfferMappingSuggestionsListDTO" $ \o ->
    OfferMappingSuggestionsListDTO
      <$> (o .:  "offers")

-- | ToJSON OfferMappingSuggestionsListDTO
instance A.ToJSON OfferMappingSuggestionsListDTO where
  toJSON OfferMappingSuggestionsListDTO {..} =
   _omitNulls
      [ "offers" .= offerMappingSuggestionsListDTOOffers
      ]


-- | Construct a value of type 'OfferMappingSuggestionsListDTO' (by applying it's required fields, if any)
mkOfferMappingSuggestionsListDTO
  :: [EnrichedMappingsOfferDTO] -- ^ 'offerMappingSuggestionsListDTOOffers': Список товаров.
  -> OfferMappingSuggestionsListDTO
mkOfferMappingSuggestionsListDTO offerMappingSuggestionsListDTOOffers =
  OfferMappingSuggestionsListDTO
  { offerMappingSuggestionsListDTOOffers
  }

-- ** OfferParamDTO
-- | OfferParamDTO
-- Параметры товара.  Если у товара несколько значений одного параметра, передайте их с одним и тем же `name`, но разными `value`.  {% cut \"Пример\" %}  ```json \"params\": [   {     \"name\": \"Цвет\",     \"value\": \"Зеленый\"   },   {     \"name\": \"Цвет\",     \"value\": \"Желтый\"   } ] ```  {% endcut %} 
data OfferParamDTO = OfferParamDTO
  { offerParamDTOName :: !(Text) -- ^ /Required/ "name" - Название.  Должно совпадать с названием характеристики на Маркете. Узнать его можно из Excel-шаблона категории или через запрос [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md). 
  , offerParamDTOValue :: !(Text) -- ^ /Required/ "value" - Значение. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferParamDTO
instance A.FromJSON OfferParamDTO where
  parseJSON = A.withObject "OfferParamDTO" $ \o ->
    OfferParamDTO
      <$> (o .:  "name")
      <*> (o .:  "value")

-- | ToJSON OfferParamDTO
instance A.ToJSON OfferParamDTO where
  toJSON OfferParamDTO {..} =
   _omitNulls
      [ "name" .= offerParamDTOName
      , "value" .= offerParamDTOValue
      ]


-- | Construct a value of type 'OfferParamDTO' (by applying it's required fields, if any)
mkOfferParamDTO
  :: Text -- ^ 'offerParamDTOName': Название.  Должно совпадать с названием характеристики на Маркете. Узнать его можно из Excel-шаблона категории или через запрос [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md). 
  -> Text -- ^ 'offerParamDTOValue': Значение. 
  -> OfferParamDTO
mkOfferParamDTO offerParamDTOName offerParamDTOValue =
  OfferParamDTO
  { offerParamDTOName
  , offerParamDTOValue
  }

-- ** OfferPriceByOfferIdsListResponseDTO
-- | OfferPriceByOfferIdsListResponseDTO
-- Список цен.
data OfferPriceByOfferIdsListResponseDTO = OfferPriceByOfferIdsListResponseDTO
  { offerPriceByOfferIdsListResponseDTOOffers :: !([OfferPriceByOfferIdsResponseDTO]) -- ^ /Required/ "offers" - Страница списка цен.
  , offerPriceByOfferIdsListResponseDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferPriceByOfferIdsListResponseDTO
instance A.FromJSON OfferPriceByOfferIdsListResponseDTO where
  parseJSON = A.withObject "OfferPriceByOfferIdsListResponseDTO" $ \o ->
    OfferPriceByOfferIdsListResponseDTO
      <$> (o .:  "offers")
      <*> (o .:? "paging")

-- | ToJSON OfferPriceByOfferIdsListResponseDTO
instance A.ToJSON OfferPriceByOfferIdsListResponseDTO where
  toJSON OfferPriceByOfferIdsListResponseDTO {..} =
   _omitNulls
      [ "offers" .= offerPriceByOfferIdsListResponseDTOOffers
      , "paging" .= offerPriceByOfferIdsListResponseDTOPaging
      ]


-- | Construct a value of type 'OfferPriceByOfferIdsListResponseDTO' (by applying it's required fields, if any)
mkOfferPriceByOfferIdsListResponseDTO
  :: [OfferPriceByOfferIdsResponseDTO] -- ^ 'offerPriceByOfferIdsListResponseDTOOffers': Страница списка цен.
  -> OfferPriceByOfferIdsListResponseDTO
mkOfferPriceByOfferIdsListResponseDTO offerPriceByOfferIdsListResponseDTOOffers =
  OfferPriceByOfferIdsListResponseDTO
  { offerPriceByOfferIdsListResponseDTOOffers
  , offerPriceByOfferIdsListResponseDTOPaging = Nothing
  }

-- ** OfferPriceByOfferIdsResponseDTO
-- | OfferPriceByOfferIdsResponseDTO
-- Информация об установленной цене.
data OfferPriceByOfferIdsResponseDTO = OfferPriceByOfferIdsResponseDTO
  { offerPriceByOfferIdsResponseDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , offerPriceByOfferIdsResponseDTOPrice :: !(Maybe PriceDTO) -- ^ "price"
  , offerPriceByOfferIdsResponseDTOUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt" - Дата и время последнего обновления цены.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferPriceByOfferIdsResponseDTO
instance A.FromJSON OfferPriceByOfferIdsResponseDTO where
  parseJSON = A.withObject "OfferPriceByOfferIdsResponseDTO" $ \o ->
    OfferPriceByOfferIdsResponseDTO
      <$> (o .:? "offerId")
      <*> (o .:? "price")
      <*> (o .:? "updatedAt")

-- | ToJSON OfferPriceByOfferIdsResponseDTO
instance A.ToJSON OfferPriceByOfferIdsResponseDTO where
  toJSON OfferPriceByOfferIdsResponseDTO {..} =
   _omitNulls
      [ "offerId" .= offerPriceByOfferIdsResponseDTOOfferId
      , "price" .= offerPriceByOfferIdsResponseDTOPrice
      , "updatedAt" .= offerPriceByOfferIdsResponseDTOUpdatedAt
      ]


-- | Construct a value of type 'OfferPriceByOfferIdsResponseDTO' (by applying it's required fields, if any)
mkOfferPriceByOfferIdsResponseDTO
  :: OfferPriceByOfferIdsResponseDTO
mkOfferPriceByOfferIdsResponseDTO =
  OfferPriceByOfferIdsResponseDTO
  { offerPriceByOfferIdsResponseDTOOfferId = Nothing
  , offerPriceByOfferIdsResponseDTOPrice = Nothing
  , offerPriceByOfferIdsResponseDTOUpdatedAt = Nothing
  }

-- ** OfferPriceDTO
-- | OfferPriceDTO
-- Товар с информацией о новой цене на него.
data OfferPriceDTO = OfferPriceDTO
  { offerPriceDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , offerPriceDTOPrice :: !(Maybe PriceDTO) -- ^ "price"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferPriceDTO
instance A.FromJSON OfferPriceDTO where
  parseJSON = A.withObject "OfferPriceDTO" $ \o ->
    OfferPriceDTO
      <$> (o .:? "offerId")
      <*> (o .:? "price")

-- | ToJSON OfferPriceDTO
instance A.ToJSON OfferPriceDTO where
  toJSON OfferPriceDTO {..} =
   _omitNulls
      [ "offerId" .= offerPriceDTOOfferId
      , "price" .= offerPriceDTOPrice
      ]


-- | Construct a value of type 'OfferPriceDTO' (by applying it's required fields, if any)
mkOfferPriceDTO
  :: OfferPriceDTO
mkOfferPriceDTO =
  OfferPriceDTO
  { offerPriceDTOOfferId = Nothing
  , offerPriceDTOPrice = Nothing
  }

-- ** OfferPriceListResponseDTO
-- | OfferPriceListResponseDTO
-- Список цен на товары.
data OfferPriceListResponseDTO = OfferPriceListResponseDTO
  { offerPriceListResponseDTOOffers :: !([OfferPriceResponseDTO]) -- ^ /Required/ "offers" - Страница списка.
  , offerPriceListResponseDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , offerPriceListResponseDTOTotal :: !(Maybe Int) -- ^ "total" - Количество всех цен магазина, измененных через API.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferPriceListResponseDTO
instance A.FromJSON OfferPriceListResponseDTO where
  parseJSON = A.withObject "OfferPriceListResponseDTO" $ \o ->
    OfferPriceListResponseDTO
      <$> (o .:  "offers")
      <*> (o .:? "paging")
      <*> (o .:? "total")

-- | ToJSON OfferPriceListResponseDTO
instance A.ToJSON OfferPriceListResponseDTO where
  toJSON OfferPriceListResponseDTO {..} =
   _omitNulls
      [ "offers" .= offerPriceListResponseDTOOffers
      , "paging" .= offerPriceListResponseDTOPaging
      , "total" .= offerPriceListResponseDTOTotal
      ]


-- | Construct a value of type 'OfferPriceListResponseDTO' (by applying it's required fields, if any)
mkOfferPriceListResponseDTO
  :: [OfferPriceResponseDTO] -- ^ 'offerPriceListResponseDTOOffers': Страница списка.
  -> OfferPriceListResponseDTO
mkOfferPriceListResponseDTO offerPriceListResponseDTOOffers =
  OfferPriceListResponseDTO
  { offerPriceListResponseDTOOffers
  , offerPriceListResponseDTOPaging = Nothing
  , offerPriceListResponseDTOTotal = Nothing
  }

-- ** OfferPriceResponseDTO
-- | OfferPriceResponseDTO
-- Информация об установленной цене на товар.
data OfferPriceResponseDTO = OfferPriceResponseDTO
  { offerPriceResponseDTOId :: !(Maybe Text) -- ^ "id" - Идентификатор предложения из прайс-листа.
  , offerPriceResponseDTOPrice :: !(Maybe PriceDTO) -- ^ "price"
  , offerPriceResponseDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  , offerPriceResponseDTOUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt" - Дата и время последнего обновления цены на товар.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferPriceResponseDTO
instance A.FromJSON OfferPriceResponseDTO where
  parseJSON = A.withObject "OfferPriceResponseDTO" $ \o ->
    OfferPriceResponseDTO
      <$> (o .:? "id")
      <*> (o .:? "price")
      <*> (o .:? "marketSku")
      <*> (o .:? "updatedAt")

-- | ToJSON OfferPriceResponseDTO
instance A.ToJSON OfferPriceResponseDTO where
  toJSON OfferPriceResponseDTO {..} =
   _omitNulls
      [ "id" .= offerPriceResponseDTOId
      , "price" .= offerPriceResponseDTOPrice
      , "marketSku" .= offerPriceResponseDTOMarketSku
      , "updatedAt" .= offerPriceResponseDTOUpdatedAt
      ]


-- | Construct a value of type 'OfferPriceResponseDTO' (by applying it's required fields, if any)
mkOfferPriceResponseDTO
  :: OfferPriceResponseDTO
mkOfferPriceResponseDTO =
  OfferPriceResponseDTO
  { offerPriceResponseDTOId = Nothing
  , offerPriceResponseDTOPrice = Nothing
  , offerPriceResponseDTOMarketSku = Nothing
  , offerPriceResponseDTOUpdatedAt = Nothing
  }

-- ** OfferProcessingNoteDTO
-- | OfferProcessingNoteDTO
-- Причины, по которым товар не прошел модерацию.
data OfferProcessingNoteDTO = OfferProcessingNoteDTO
  { offerProcessingNoteDTOType :: !(Maybe OfferProcessingNoteType) -- ^ "type"
  , offerProcessingNoteDTOPayload :: !(Maybe Text) -- ^ "payload" - Дополнительная информация о причине отклонения товара. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferProcessingNoteDTO
instance A.FromJSON OfferProcessingNoteDTO where
  parseJSON = A.withObject "OfferProcessingNoteDTO" $ \o ->
    OfferProcessingNoteDTO
      <$> (o .:? "type")
      <*> (o .:? "payload")

-- | ToJSON OfferProcessingNoteDTO
instance A.ToJSON OfferProcessingNoteDTO where
  toJSON OfferProcessingNoteDTO {..} =
   _omitNulls
      [ "type" .= offerProcessingNoteDTOType
      , "payload" .= offerProcessingNoteDTOPayload
      ]


-- | Construct a value of type 'OfferProcessingNoteDTO' (by applying it's required fields, if any)
mkOfferProcessingNoteDTO
  :: OfferProcessingNoteDTO
mkOfferProcessingNoteDTO =
  OfferProcessingNoteDTO
  { offerProcessingNoteDTOType = Nothing
  , offerProcessingNoteDTOPayload = Nothing
  }

-- ** OfferProcessingStateDTO
-- | OfferProcessingStateDTO
-- Информация о статусе публикации товара на Маркете.
data OfferProcessingStateDTO = OfferProcessingStateDTO
  { offerProcessingStateDTOStatus :: !(Maybe OfferProcessingStatusType) -- ^ "status"
  , offerProcessingStateDTONotes :: !(Maybe [OfferProcessingNoteDTO]) -- ^ "notes" - Причины, по которым товар не прошел модерацию.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferProcessingStateDTO
instance A.FromJSON OfferProcessingStateDTO where
  parseJSON = A.withObject "OfferProcessingStateDTO" $ \o ->
    OfferProcessingStateDTO
      <$> (o .:? "status")
      <*> (o .:? "notes")

-- | ToJSON OfferProcessingStateDTO
instance A.ToJSON OfferProcessingStateDTO where
  toJSON OfferProcessingStateDTO {..} =
   _omitNulls
      [ "status" .= offerProcessingStateDTOStatus
      , "notes" .= offerProcessingStateDTONotes
      ]


-- | Construct a value of type 'OfferProcessingStateDTO' (by applying it's required fields, if any)
mkOfferProcessingStateDTO
  :: OfferProcessingStateDTO
mkOfferProcessingStateDTO =
  OfferProcessingStateDTO
  { offerProcessingStateDTOStatus = Nothing
  , offerProcessingStateDTONotes = Nothing
  }

-- ** OfferRecommendationDTO
-- | OfferRecommendationDTO
-- Информация о состоянии цен и рекомендации. 
data OfferRecommendationDTO = OfferRecommendationDTO
  { offerRecommendationDTOOffer :: !(Maybe OfferForRecommendationDTO) -- ^ "offer"
  , offerRecommendationDTORecommendation :: !(Maybe OfferRecommendationInfoDTO) -- ^ "recommendation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferRecommendationDTO
instance A.FromJSON OfferRecommendationDTO where
  parseJSON = A.withObject "OfferRecommendationDTO" $ \o ->
    OfferRecommendationDTO
      <$> (o .:? "offer")
      <*> (o .:? "recommendation")

-- | ToJSON OfferRecommendationDTO
instance A.ToJSON OfferRecommendationDTO where
  toJSON OfferRecommendationDTO {..} =
   _omitNulls
      [ "offer" .= offerRecommendationDTOOffer
      , "recommendation" .= offerRecommendationDTORecommendation
      ]


-- | Construct a value of type 'OfferRecommendationDTO' (by applying it's required fields, if any)
mkOfferRecommendationDTO
  :: OfferRecommendationDTO
mkOfferRecommendationDTO =
  OfferRecommendationDTO
  { offerRecommendationDTOOffer = Nothing
  , offerRecommendationDTORecommendation = Nothing
  }

-- ** OfferRecommendationInfoDTO
-- | OfferRecommendationInfoDTO
-- Рекомендации, касающиеся цены на товар.
data OfferRecommendationInfoDTO = OfferRecommendationInfoDTO
  { offerRecommendationInfoDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , offerRecommendationInfoDTORecommendedCofinancePrice :: !(Maybe BasePriceDTO) -- ^ "recommendedCofinancePrice"
  , offerRecommendationInfoDTOCompetitivenessThresholds :: !(Maybe PriceCompetitivenessThresholdsDTO) -- ^ "competitivenessThresholds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferRecommendationInfoDTO
instance A.FromJSON OfferRecommendationInfoDTO where
  parseJSON = A.withObject "OfferRecommendationInfoDTO" $ \o ->
    OfferRecommendationInfoDTO
      <$> (o .:? "offerId")
      <*> (o .:? "recommendedCofinancePrice")
      <*> (o .:? "competitivenessThresholds")

-- | ToJSON OfferRecommendationInfoDTO
instance A.ToJSON OfferRecommendationInfoDTO where
  toJSON OfferRecommendationInfoDTO {..} =
   _omitNulls
      [ "offerId" .= offerRecommendationInfoDTOOfferId
      , "recommendedCofinancePrice" .= offerRecommendationInfoDTORecommendedCofinancePrice
      , "competitivenessThresholds" .= offerRecommendationInfoDTOCompetitivenessThresholds
      ]


-- | Construct a value of type 'OfferRecommendationInfoDTO' (by applying it's required fields, if any)
mkOfferRecommendationInfoDTO
  :: OfferRecommendationInfoDTO
mkOfferRecommendationInfoDTO =
  OfferRecommendationInfoDTO
  { offerRecommendationInfoDTOOfferId = Nothing
  , offerRecommendationInfoDTORecommendedCofinancePrice = Nothing
  , offerRecommendationInfoDTOCompetitivenessThresholds = Nothing
  }

-- ** OfferRecommendationsResultDTO
-- | OfferRecommendationsResultDTO
-- Список товаров с рекомендациями.
data OfferRecommendationsResultDTO = OfferRecommendationsResultDTO
  { offerRecommendationsResultDTOPaging :: !(Maybe ScrollingPagerDTO) -- ^ "paging"
  , offerRecommendationsResultDTOOfferRecommendations :: !([OfferRecommendationDTO]) -- ^ /Required/ "offerRecommendations" - Страница списка товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferRecommendationsResultDTO
instance A.FromJSON OfferRecommendationsResultDTO where
  parseJSON = A.withObject "OfferRecommendationsResultDTO" $ \o ->
    OfferRecommendationsResultDTO
      <$> (o .:? "paging")
      <*> (o .:  "offerRecommendations")

-- | ToJSON OfferRecommendationsResultDTO
instance A.ToJSON OfferRecommendationsResultDTO where
  toJSON OfferRecommendationsResultDTO {..} =
   _omitNulls
      [ "paging" .= offerRecommendationsResultDTOPaging
      , "offerRecommendations" .= offerRecommendationsResultDTOOfferRecommendations
      ]


-- | Construct a value of type 'OfferRecommendationsResultDTO' (by applying it's required fields, if any)
mkOfferRecommendationsResultDTO
  :: [OfferRecommendationDTO] -- ^ 'offerRecommendationsResultDTOOfferRecommendations': Страница списка товаров.
  -> OfferRecommendationsResultDTO
mkOfferRecommendationsResultDTO offerRecommendationsResultDTOOfferRecommendations =
  OfferRecommendationsResultDTO
  { offerRecommendationsResultDTOPaging = Nothing
  , offerRecommendationsResultDTOOfferRecommendations
  }

-- ** OfferSellingProgramDTO
-- | OfferSellingProgramDTO
-- Информация о том, по каким моделям можно продавать товар, а по каким нельзя.
data OfferSellingProgramDTO = OfferSellingProgramDTO
  { offerSellingProgramDTOSellingProgram :: !(SellingProgramType) -- ^ /Required/ "sellingProgram"
  , offerSellingProgramDTOStatus :: !(OfferSellingProgramStatusType) -- ^ /Required/ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferSellingProgramDTO
instance A.FromJSON OfferSellingProgramDTO where
  parseJSON = A.withObject "OfferSellingProgramDTO" $ \o ->
    OfferSellingProgramDTO
      <$> (o .:  "sellingProgram")
      <*> (o .:  "status")

-- | ToJSON OfferSellingProgramDTO
instance A.ToJSON OfferSellingProgramDTO where
  toJSON OfferSellingProgramDTO {..} =
   _omitNulls
      [ "sellingProgram" .= offerSellingProgramDTOSellingProgram
      , "status" .= offerSellingProgramDTOStatus
      ]


-- | Construct a value of type 'OfferSellingProgramDTO' (by applying it's required fields, if any)
mkOfferSellingProgramDTO
  :: SellingProgramType -- ^ 'offerSellingProgramDTOSellingProgram' 
  -> OfferSellingProgramStatusType -- ^ 'offerSellingProgramDTOStatus' 
  -> OfferSellingProgramDTO
mkOfferSellingProgramDTO offerSellingProgramDTOSellingProgram offerSellingProgramDTOStatus =
  OfferSellingProgramDTO
  { offerSellingProgramDTOSellingProgram
  , offerSellingProgramDTOStatus
  }

-- ** OfferWeightDimensionsDTO
-- | OfferWeightDimensionsDTO
-- Габариты упаковки и вес товара.  Если товар занимает несколько коробок, перед измерением размеров сложите их компактно.  ![Схема измерения многоместных грузов](../../_images/reference/boxes-measure.png) 
data OfferWeightDimensionsDTO = OfferWeightDimensionsDTO
  { offerWeightDimensionsDTOLength :: !(Double) -- ^ /Required/ "length" - Длина упаковки в см. 
  , offerWeightDimensionsDTOWidth :: !(Double) -- ^ /Required/ "width" - Ширина упаковки в см. 
  , offerWeightDimensionsDTOHeight :: !(Double) -- ^ /Required/ "height" - Высота упаковки в см. 
  , offerWeightDimensionsDTOWeight :: !(Double) -- ^ /Required/ "weight" - Вес товара в кг с учетом упаковки (брутто). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OfferWeightDimensionsDTO
instance A.FromJSON OfferWeightDimensionsDTO where
  parseJSON = A.withObject "OfferWeightDimensionsDTO" $ \o ->
    OfferWeightDimensionsDTO
      <$> (o .:  "length")
      <*> (o .:  "width")
      <*> (o .:  "height")
      <*> (o .:  "weight")

-- | ToJSON OfferWeightDimensionsDTO
instance A.ToJSON OfferWeightDimensionsDTO where
  toJSON OfferWeightDimensionsDTO {..} =
   _omitNulls
      [ "length" .= offerWeightDimensionsDTOLength
      , "width" .= offerWeightDimensionsDTOWidth
      , "height" .= offerWeightDimensionsDTOHeight
      , "weight" .= offerWeightDimensionsDTOWeight
      ]


-- | Construct a value of type 'OfferWeightDimensionsDTO' (by applying it's required fields, if any)
mkOfferWeightDimensionsDTO
  :: Double -- ^ 'offerWeightDimensionsDTOLength': Длина упаковки в см. 
  -> Double -- ^ 'offerWeightDimensionsDTOWidth': Ширина упаковки в см. 
  -> Double -- ^ 'offerWeightDimensionsDTOHeight': Высота упаковки в см. 
  -> Double -- ^ 'offerWeightDimensionsDTOWeight': Вес товара в кг с учетом упаковки (брутто). 
  -> OfferWeightDimensionsDTO
mkOfferWeightDimensionsDTO offerWeightDimensionsDTOLength offerWeightDimensionsDTOWidth offerWeightDimensionsDTOHeight offerWeightDimensionsDTOWeight =
  OfferWeightDimensionsDTO
  { offerWeightDimensionsDTOLength
  , offerWeightDimensionsDTOWidth
  , offerWeightDimensionsDTOHeight
  , offerWeightDimensionsDTOWeight
  }

-- ** OffersDTO
-- | OffersDTO
-- Найденные предложения магазина.
data OffersDTO = OffersDTO
  { offersDTOOffers :: !([OfferDTO]) -- ^ /Required/ "offers" - Список предложений магазина.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OffersDTO
instance A.FromJSON OffersDTO where
  parseJSON = A.withObject "OffersDTO" $ \o ->
    OffersDTO
      <$> (o .:  "offers")

-- | ToJSON OffersDTO
instance A.ToJSON OffersDTO where
  toJSON OffersDTO {..} =
   _omitNulls
      [ "offers" .= offersDTOOffers
      ]


-- | Construct a value of type 'OffersDTO' (by applying it's required fields, if any)
mkOffersDTO
  :: [OfferDTO] -- ^ 'offersDTOOffers': Список предложений магазина.
  -> OffersDTO
mkOffersDTO offersDTOOffers =
  OffersDTO
  { offersDTOOffers
  }

-- ** OptionValuesLimitedDTO
-- | OptionValuesLimitedDTO
-- Значение ограничивающей характеристики и список допустимых значений ограничиваемой характеристики.
data OptionValuesLimitedDTO = OptionValuesLimitedDTO
  { optionValuesLimitedDTOLimitingOptionValueId :: !(Integer) -- ^ /Required/ "limitingOptionValueId" - Идентификатор значения ограничивающей характеристики.
  , optionValuesLimitedDTOOptionValueIds :: !([Integer]) -- ^ /Required/ "optionValueIds" - Идентификаторы допустимых значений ограничиваемой характеристики. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OptionValuesLimitedDTO
instance A.FromJSON OptionValuesLimitedDTO where
  parseJSON = A.withObject "OptionValuesLimitedDTO" $ \o ->
    OptionValuesLimitedDTO
      <$> (o .:  "limitingOptionValueId")
      <*> (o .:  "optionValueIds")

-- | ToJSON OptionValuesLimitedDTO
instance A.ToJSON OptionValuesLimitedDTO where
  toJSON OptionValuesLimitedDTO {..} =
   _omitNulls
      [ "limitingOptionValueId" .= optionValuesLimitedDTOLimitingOptionValueId
      , "optionValueIds" .= optionValuesLimitedDTOOptionValueIds
      ]


-- | Construct a value of type 'OptionValuesLimitedDTO' (by applying it's required fields, if any)
mkOptionValuesLimitedDTO
  :: Integer -- ^ 'optionValuesLimitedDTOLimitingOptionValueId': Идентификатор значения ограничивающей характеристики.
  -> [Integer] -- ^ 'optionValuesLimitedDTOOptionValueIds': Идентификаторы допустимых значений ограничиваемой характеристики. 
  -> OptionValuesLimitedDTO
mkOptionValuesLimitedDTO optionValuesLimitedDTOLimitingOptionValueId optionValuesLimitedDTOOptionValueIds =
  OptionValuesLimitedDTO
  { optionValuesLimitedDTOLimitingOptionValueId
  , optionValuesLimitedDTOOptionValueIds
  }

-- ** OrderBoxLayoutDTO
-- | OrderBoxLayoutDTO
-- Информация о коробке.
data OrderBoxLayoutDTO = OrderBoxLayoutDTO
  { orderBoxLayoutDTOItems :: !([OrderBoxLayoutItemDTO]) -- ^ /Required/ "items" - Список товаров в коробке.  Если в коробке едет часть большого товара, в списке может быть только один пункт. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBoxLayoutDTO
instance A.FromJSON OrderBoxLayoutDTO where
  parseJSON = A.withObject "OrderBoxLayoutDTO" $ \o ->
    OrderBoxLayoutDTO
      <$> (o .:  "items")

-- | ToJSON OrderBoxLayoutDTO
instance A.ToJSON OrderBoxLayoutDTO where
  toJSON OrderBoxLayoutDTO {..} =
   _omitNulls
      [ "items" .= orderBoxLayoutDTOItems
      ]


-- | Construct a value of type 'OrderBoxLayoutDTO' (by applying it's required fields, if any)
mkOrderBoxLayoutDTO
  :: [OrderBoxLayoutItemDTO] -- ^ 'orderBoxLayoutDTOItems': Список товаров в коробке.  Если в коробке едет часть большого товара, в списке может быть только один пункт. 
  -> OrderBoxLayoutDTO
mkOrderBoxLayoutDTO orderBoxLayoutDTOItems =
  OrderBoxLayoutDTO
  { orderBoxLayoutDTOItems
  }

-- ** OrderBoxLayoutItemDTO
-- | OrderBoxLayoutItemDTO
-- Информация о товаре в коробке.
data OrderBoxLayoutItemDTO = OrderBoxLayoutItemDTO
  { orderBoxLayoutItemDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор товара в заказе.  {% cut \&quot;Где его взять\&quot; %}  Идентификатор приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр &#x60;id&#x60; в &#x60;items&#x60;.  {% endcut %}   
  , orderBoxLayoutItemDTOFullCount :: !(Maybe Int) -- ^ "fullCount" - Количество единиц товара в коробке.  Используйте это поле, если в коробке поедут целые товары, не разделенные на части. Не используйте это поле одновременно с &#x60;partialCount&#x60;. 
  , orderBoxLayoutItemDTOPartialCount :: !(Maybe OrderBoxLayoutPartialCountDTO) -- ^ "partialCount"
  , orderBoxLayoutItemDTOInstances :: !(Maybe [BriefOrderItemInstanceDTO]) -- ^ "instances" - Переданные вами коды маркировки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBoxLayoutItemDTO
instance A.FromJSON OrderBoxLayoutItemDTO where
  parseJSON = A.withObject "OrderBoxLayoutItemDTO" $ \o ->
    OrderBoxLayoutItemDTO
      <$> (o .:  "id")
      <*> (o .:? "fullCount")
      <*> (o .:? "partialCount")
      <*> (o .:? "instances")

-- | ToJSON OrderBoxLayoutItemDTO
instance A.ToJSON OrderBoxLayoutItemDTO where
  toJSON OrderBoxLayoutItemDTO {..} =
   _omitNulls
      [ "id" .= orderBoxLayoutItemDTOId
      , "fullCount" .= orderBoxLayoutItemDTOFullCount
      , "partialCount" .= orderBoxLayoutItemDTOPartialCount
      , "instances" .= orderBoxLayoutItemDTOInstances
      ]


-- | Construct a value of type 'OrderBoxLayoutItemDTO' (by applying it's required fields, if any)
mkOrderBoxLayoutItemDTO
  :: Integer -- ^ 'orderBoxLayoutItemDTOId': Идентификатор товара в заказе.  {% cut \"Где его взять\" %}  Идентификатор приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр `id` в `items`.  {% endcut %}   
  -> OrderBoxLayoutItemDTO
mkOrderBoxLayoutItemDTO orderBoxLayoutItemDTOId =
  OrderBoxLayoutItemDTO
  { orderBoxLayoutItemDTOId
  , orderBoxLayoutItemDTOFullCount = Nothing
  , orderBoxLayoutItemDTOPartialCount = Nothing
  , orderBoxLayoutItemDTOInstances = Nothing
  }

-- ** OrderBoxLayoutPartialCountDTO
-- | OrderBoxLayoutPartialCountDTO
-- Информация о части товара в коробке.
data OrderBoxLayoutPartialCountDTO = OrderBoxLayoutPartialCountDTO
  { orderBoxLayoutPartialCountDTOCurrent :: !(Int) -- ^ /Required/ "current" - Номер части, начиная с 1.
  , orderBoxLayoutPartialCountDTOTotal :: !(Int) -- ^ /Required/ "total" - На сколько всего частей разделен товар.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBoxLayoutPartialCountDTO
instance A.FromJSON OrderBoxLayoutPartialCountDTO where
  parseJSON = A.withObject "OrderBoxLayoutPartialCountDTO" $ \o ->
    OrderBoxLayoutPartialCountDTO
      <$> (o .:  "current")
      <*> (o .:  "total")

-- | ToJSON OrderBoxLayoutPartialCountDTO
instance A.ToJSON OrderBoxLayoutPartialCountDTO where
  toJSON OrderBoxLayoutPartialCountDTO {..} =
   _omitNulls
      [ "current" .= orderBoxLayoutPartialCountDTOCurrent
      , "total" .= orderBoxLayoutPartialCountDTOTotal
      ]


-- | Construct a value of type 'OrderBoxLayoutPartialCountDTO' (by applying it's required fields, if any)
mkOrderBoxLayoutPartialCountDTO
  :: Int -- ^ 'orderBoxLayoutPartialCountDTOCurrent': Номер части, начиная с 1.
  -> Int -- ^ 'orderBoxLayoutPartialCountDTOTotal': На сколько всего частей разделен товар.
  -> OrderBoxLayoutPartialCountDTO
mkOrderBoxLayoutPartialCountDTO orderBoxLayoutPartialCountDTOCurrent orderBoxLayoutPartialCountDTOTotal =
  OrderBoxLayoutPartialCountDTO
  { orderBoxLayoutPartialCountDTOCurrent
  , orderBoxLayoutPartialCountDTOTotal
  }

-- ** OrderBoxesLayoutDTO
-- | OrderBoxesLayoutDTO
-- Распределение товаров по коробкам.
data OrderBoxesLayoutDTO = OrderBoxesLayoutDTO
  { orderBoxesLayoutDTOBoxes :: !([EnrichedOrderBoxLayoutDTO]) -- ^ /Required/ "boxes" - Список коробок.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBoxesLayoutDTO
instance A.FromJSON OrderBoxesLayoutDTO where
  parseJSON = A.withObject "OrderBoxesLayoutDTO" $ \o ->
    OrderBoxesLayoutDTO
      <$> (o .:  "boxes")

-- | ToJSON OrderBoxesLayoutDTO
instance A.ToJSON OrderBoxesLayoutDTO where
  toJSON OrderBoxesLayoutDTO {..} =
   _omitNulls
      [ "boxes" .= orderBoxesLayoutDTOBoxes
      ]


-- | Construct a value of type 'OrderBoxesLayoutDTO' (by applying it's required fields, if any)
mkOrderBoxesLayoutDTO
  :: [EnrichedOrderBoxLayoutDTO] -- ^ 'orderBoxesLayoutDTOBoxes': Список коробок.
  -> OrderBoxesLayoutDTO
mkOrderBoxesLayoutDTO orderBoxesLayoutDTOBoxes =
  OrderBoxesLayoutDTO
  { orderBoxesLayoutDTOBoxes
  }

-- ** OrderBusinessBuyerDTO
-- | OrderBusinessBuyerDTO
-- Информация о покупателе. 
data OrderBusinessBuyerDTO = OrderBusinessBuyerDTO
  { orderBusinessBuyerDTOInn :: !(Maybe Text) -- ^ "inn" - ИНН.
  , orderBusinessBuyerDTOKpp :: !(Maybe Text) -- ^ "kpp" - КПП.
  , orderBusinessBuyerDTOOrganizationName :: !(Maybe Text) -- ^ "organizationName" - Наименование юридического лица.
  , orderBusinessBuyerDTOOrganizationJurAddress :: !(Maybe Text) -- ^ "organizationJurAddress" - Юридический адрес.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBusinessBuyerDTO
instance A.FromJSON OrderBusinessBuyerDTO where
  parseJSON = A.withObject "OrderBusinessBuyerDTO" $ \o ->
    OrderBusinessBuyerDTO
      <$> (o .:? "inn")
      <*> (o .:? "kpp")
      <*> (o .:? "organizationName")
      <*> (o .:? "organizationJurAddress")

-- | ToJSON OrderBusinessBuyerDTO
instance A.ToJSON OrderBusinessBuyerDTO where
  toJSON OrderBusinessBuyerDTO {..} =
   _omitNulls
      [ "inn" .= orderBusinessBuyerDTOInn
      , "kpp" .= orderBusinessBuyerDTOKpp
      , "organizationName" .= orderBusinessBuyerDTOOrganizationName
      , "organizationJurAddress" .= orderBusinessBuyerDTOOrganizationJurAddress
      ]


-- | Construct a value of type 'OrderBusinessBuyerDTO' (by applying it's required fields, if any)
mkOrderBusinessBuyerDTO
  :: OrderBusinessBuyerDTO
mkOrderBusinessBuyerDTO =
  OrderBusinessBuyerDTO
  { orderBusinessBuyerDTOInn = Nothing
  , orderBusinessBuyerDTOKpp = Nothing
  , orderBusinessBuyerDTOOrganizationName = Nothing
  , orderBusinessBuyerDTOOrganizationJurAddress = Nothing
  }

-- ** OrderBusinessDocumentsDTO
-- | OrderBusinessDocumentsDTO
-- Информация о документах. 
data OrderBusinessDocumentsDTO = OrderBusinessDocumentsDTO
  { orderBusinessDocumentsDTOUpd :: !(Maybe DocumentDTO) -- ^ "upd"
  , orderBusinessDocumentsDTOUkd :: !(Maybe DocumentDTO) -- ^ "ukd"
  , orderBusinessDocumentsDTOTorgTwelve :: !(Maybe DocumentDTO) -- ^ "torgTwelve"
  , orderBusinessDocumentsDTOSf :: !(Maybe DocumentDTO) -- ^ "sf"
  , orderBusinessDocumentsDTOKsf :: !(Maybe DocumentDTO) -- ^ "ksf"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBusinessDocumentsDTO
instance A.FromJSON OrderBusinessDocumentsDTO where
  parseJSON = A.withObject "OrderBusinessDocumentsDTO" $ \o ->
    OrderBusinessDocumentsDTO
      <$> (o .:? "upd")
      <*> (o .:? "ukd")
      <*> (o .:? "torgTwelve")
      <*> (o .:? "sf")
      <*> (o .:? "ksf")

-- | ToJSON OrderBusinessDocumentsDTO
instance A.ToJSON OrderBusinessDocumentsDTO where
  toJSON OrderBusinessDocumentsDTO {..} =
   _omitNulls
      [ "upd" .= orderBusinessDocumentsDTOUpd
      , "ukd" .= orderBusinessDocumentsDTOUkd
      , "torgTwelve" .= orderBusinessDocumentsDTOTorgTwelve
      , "sf" .= orderBusinessDocumentsDTOSf
      , "ksf" .= orderBusinessDocumentsDTOKsf
      ]


-- | Construct a value of type 'OrderBusinessDocumentsDTO' (by applying it's required fields, if any)
mkOrderBusinessDocumentsDTO
  :: OrderBusinessDocumentsDTO
mkOrderBusinessDocumentsDTO =
  OrderBusinessDocumentsDTO
  { orderBusinessDocumentsDTOUpd = Nothing
  , orderBusinessDocumentsDTOUkd = Nothing
  , orderBusinessDocumentsDTOTorgTwelve = Nothing
  , orderBusinessDocumentsDTOSf = Nothing
  , orderBusinessDocumentsDTOKsf = Nothing
  }

-- ** OrderBuyerBasicInfoDTO
-- | OrderBuyerBasicInfoDTO
-- Информация о покупателе с базовыми полями.
data OrderBuyerBasicInfoDTO = OrderBuyerBasicInfoDTO
  { orderBuyerBasicInfoDTOId :: !(Maybe Text) -- ^ "id" - Идентификатор покупателя.
  , orderBuyerBasicInfoDTOLastName :: !(Maybe Text) -- ^ "lastName" - Фамилия покупателя.
  , orderBuyerBasicInfoDTOFirstName :: !(Maybe Text) -- ^ "firstName" - Имя покупателя.
  , orderBuyerBasicInfoDTOMiddleName :: !(Maybe Text) -- ^ "middleName" - Отчество покупателя.
  , orderBuyerBasicInfoDTOType :: !(Maybe OrderBuyerType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBuyerBasicInfoDTO
instance A.FromJSON OrderBuyerBasicInfoDTO where
  parseJSON = A.withObject "OrderBuyerBasicInfoDTO" $ \o ->
    OrderBuyerBasicInfoDTO
      <$> (o .:? "id")
      <*> (o .:? "lastName")
      <*> (o .:? "firstName")
      <*> (o .:? "middleName")
      <*> (o .:? "type")

-- | ToJSON OrderBuyerBasicInfoDTO
instance A.ToJSON OrderBuyerBasicInfoDTO where
  toJSON OrderBuyerBasicInfoDTO {..} =
   _omitNulls
      [ "id" .= orderBuyerBasicInfoDTOId
      , "lastName" .= orderBuyerBasicInfoDTOLastName
      , "firstName" .= orderBuyerBasicInfoDTOFirstName
      , "middleName" .= orderBuyerBasicInfoDTOMiddleName
      , "type" .= orderBuyerBasicInfoDTOType
      ]


-- | Construct a value of type 'OrderBuyerBasicInfoDTO' (by applying it's required fields, if any)
mkOrderBuyerBasicInfoDTO
  :: OrderBuyerBasicInfoDTO
mkOrderBuyerBasicInfoDTO =
  OrderBuyerBasicInfoDTO
  { orderBuyerBasicInfoDTOId = Nothing
  , orderBuyerBasicInfoDTOLastName = Nothing
  , orderBuyerBasicInfoDTOFirstName = Nothing
  , orderBuyerBasicInfoDTOMiddleName = Nothing
  , orderBuyerBasicInfoDTOType = Nothing
  }

-- ** OrderBuyerDTO
-- | OrderBuyerDTO
-- Информация о покупателе.  Параметры `id`, `lastName`, `firstName` и `middleName` возвращаются, только если вы работаете по модели DBS. 
data OrderBuyerDTO = OrderBuyerDTO
  { orderBuyerDTOId :: !(Maybe Text) -- ^ "id" - Идентификатор покупателя.
  , orderBuyerDTOLastName :: !(Maybe Text) -- ^ "lastName" - Фамилия покупателя.
  , orderBuyerDTOFirstName :: !(Maybe Text) -- ^ "firstName" - Имя покупателя.
  , orderBuyerDTOMiddleName :: !(Maybe Text) -- ^ "middleName" - Отчество покупателя.
  , orderBuyerDTOType :: !(Maybe OrderBuyerType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBuyerDTO
instance A.FromJSON OrderBuyerDTO where
  parseJSON = A.withObject "OrderBuyerDTO" $ \o ->
    OrderBuyerDTO
      <$> (o .:? "id")
      <*> (o .:? "lastName")
      <*> (o .:? "firstName")
      <*> (o .:? "middleName")
      <*> (o .:? "type")

-- | ToJSON OrderBuyerDTO
instance A.ToJSON OrderBuyerDTO where
  toJSON OrderBuyerDTO {..} =
   _omitNulls
      [ "id" .= orderBuyerDTOId
      , "lastName" .= orderBuyerDTOLastName
      , "firstName" .= orderBuyerDTOFirstName
      , "middleName" .= orderBuyerDTOMiddleName
      , "type" .= orderBuyerDTOType
      ]


-- | Construct a value of type 'OrderBuyerDTO' (by applying it's required fields, if any)
mkOrderBuyerDTO
  :: OrderBuyerDTO
mkOrderBuyerDTO =
  OrderBuyerDTO
  { orderBuyerDTOId = Nothing
  , orderBuyerDTOLastName = Nothing
  , orderBuyerDTOFirstName = Nothing
  , orderBuyerDTOMiddleName = Nothing
  , orderBuyerDTOType = Nothing
  }

-- ** OrderBuyerInfoDTO
-- | OrderBuyerInfoDTO
-- Информация о покупателе и его номере телефона.
data OrderBuyerInfoDTO = OrderBuyerInfoDTO
  { orderBuyerInfoDTOId :: !(Maybe Text) -- ^ "id" - Идентификатор покупателя.
  , orderBuyerInfoDTOLastName :: !(Maybe Text) -- ^ "lastName" - Фамилия покупателя.
  , orderBuyerInfoDTOFirstName :: !(Maybe Text) -- ^ "firstName" - Имя покупателя.
  , orderBuyerInfoDTOMiddleName :: !(Maybe Text) -- ^ "middleName" - Отчество покупателя.
  , orderBuyerInfoDTOType :: !(Maybe OrderBuyerType) -- ^ "type"
  , orderBuyerInfoDTOPhone :: !(Maybe Text) -- ^ "phone" - Подменный номер телефона покупателя. Подробнее о таких номерах читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/orders/dbs/call#fake-number).  Формат номера: &#x60;+&lt;код_страны&gt;&lt;код_региона&gt;&lt;номер_телефона&gt;&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBuyerInfoDTO
instance A.FromJSON OrderBuyerInfoDTO where
  parseJSON = A.withObject "OrderBuyerInfoDTO" $ \o ->
    OrderBuyerInfoDTO
      <$> (o .:? "id")
      <*> (o .:? "lastName")
      <*> (o .:? "firstName")
      <*> (o .:? "middleName")
      <*> (o .:? "type")
      <*> (o .:? "phone")

-- | ToJSON OrderBuyerInfoDTO
instance A.ToJSON OrderBuyerInfoDTO where
  toJSON OrderBuyerInfoDTO {..} =
   _omitNulls
      [ "id" .= orderBuyerInfoDTOId
      , "lastName" .= orderBuyerInfoDTOLastName
      , "firstName" .= orderBuyerInfoDTOFirstName
      , "middleName" .= orderBuyerInfoDTOMiddleName
      , "type" .= orderBuyerInfoDTOType
      , "phone" .= orderBuyerInfoDTOPhone
      ]


-- | Construct a value of type 'OrderBuyerInfoDTO' (by applying it's required fields, if any)
mkOrderBuyerInfoDTO
  :: OrderBuyerInfoDTO
mkOrderBuyerInfoDTO =
  OrderBuyerInfoDTO
  { orderBuyerInfoDTOId = Nothing
  , orderBuyerInfoDTOLastName = Nothing
  , orderBuyerInfoDTOFirstName = Nothing
  , orderBuyerInfoDTOMiddleName = Nothing
  , orderBuyerInfoDTOType = Nothing
  , orderBuyerInfoDTOPhone = Nothing
  }

-- ** OrderCourierDTO
-- | OrderCourierDTO
-- Информация о курьере.
data OrderCourierDTO = OrderCourierDTO
  { orderCourierDTOFullName :: !(Maybe Text) -- ^ "fullName" - Полное имя курьера.
  , orderCourierDTOPhone :: !(Maybe Text) -- ^ "phone" - Номер телефона курьера.
  , orderCourierDTOPhoneExtension :: !(Maybe Text) -- ^ "phoneExtension" - Добавочный номер телефона.
  , orderCourierDTOVehicleNumber :: !(Maybe Text) -- ^ "vehicleNumber" - Номер транспортного средства.
  , orderCourierDTOVehicleDescription :: !(Maybe Text) -- ^ "vehicleDescription" - Описание машины. Например, модель и цвет.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderCourierDTO
instance A.FromJSON OrderCourierDTO where
  parseJSON = A.withObject "OrderCourierDTO" $ \o ->
    OrderCourierDTO
      <$> (o .:? "fullName")
      <*> (o .:? "phone")
      <*> (o .:? "phoneExtension")
      <*> (o .:? "vehicleNumber")
      <*> (o .:? "vehicleDescription")

-- | ToJSON OrderCourierDTO
instance A.ToJSON OrderCourierDTO where
  toJSON OrderCourierDTO {..} =
   _omitNulls
      [ "fullName" .= orderCourierDTOFullName
      , "phone" .= orderCourierDTOPhone
      , "phoneExtension" .= orderCourierDTOPhoneExtension
      , "vehicleNumber" .= orderCourierDTOVehicleNumber
      , "vehicleDescription" .= orderCourierDTOVehicleDescription
      ]


-- | Construct a value of type 'OrderCourierDTO' (by applying it's required fields, if any)
mkOrderCourierDTO
  :: OrderCourierDTO
mkOrderCourierDTO =
  OrderCourierDTO
  { orderCourierDTOFullName = Nothing
  , orderCourierDTOPhone = Nothing
  , orderCourierDTOPhoneExtension = Nothing
  , orderCourierDTOVehicleNumber = Nothing
  , orderCourierDTOVehicleDescription = Nothing
  }

-- ** OrderDTO
-- | OrderDTO
-- Заказ.
data OrderDTO = OrderDTO
  { orderDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор заказа.
  , orderDTOStatus :: !(Maybe OrderStatusType) -- ^ "status"
  , orderDTOSubstatus :: !(Maybe OrderSubstatusType) -- ^ "substatus"
  , orderDTOCreationDate :: !(Maybe Text) -- ^ "creationDate"
  , orderDTOUpdatedAt :: !(Maybe Text) -- ^ "updatedAt"
  , orderDTOCurrency :: !(Maybe CurrencyType) -- ^ "currency"
  , orderDTOItemsTotal :: !(Maybe Double) -- ^ "itemsTotal" - Платеж покупателя. 
  , orderDTODeliveryTotal :: !(Maybe Double) -- ^ "deliveryTotal" - Стоимость доставки. 
  , orderDTOBuyerItemsTotal :: !(Maybe Double) -- ^ "buyerItemsTotal" - {% note warning \&quot;\&quot; %}  Этот параметр устарел.  {% endnote %}  Стоимость всех товаров в заказе в валюте покупателя после применения скидок и без учета стоимости доставки. 
  , orderDTOBuyerTotal :: !(Maybe Double) -- ^ "buyerTotal" - {% note warning \&quot;\&quot; %}  Этот параметр устарел.  {% endnote %}  Стоимость всех товаров в заказе в валюте покупателя после применения скидок и с учетом стоимости доставки. 
  , orderDTOBuyerItemsTotalBeforeDiscount :: !(Maybe Double) -- ^ "buyerItemsTotalBeforeDiscount" - Стоимость всех товаров в заказе в валюте покупателя без учета стоимости доставки и до применения скидок по:  * акциям; * купонам; * промокодам. 
  , orderDTOBuyerTotalBeforeDiscount :: !(Maybe Double) -- ^ "buyerTotalBeforeDiscount" - {% note warning \&quot;\&quot; %}  Этот параметр устарел.  {% endnote %}  Стоимость всех товаров в заказе в валюте покупателя до применения скидок и с учетом стоимости доставки (&#x60;buyerItemsTotalBeforeDiscount&#x60; + стоимость доставки). 
  , orderDTOPaymentType :: !(Maybe OrderPaymentType) -- ^ "paymentType"
  , orderDTOPaymentMethod :: !(Maybe OrderPaymentMethodType) -- ^ "paymentMethod"
  , orderDTOFake :: !(Maybe Bool) -- ^ "fake" - Тип заказа:  * &#x60;false&#x60; — настоящий заказ покупателя.  * &#x60;true&#x60; — [тестовый](../../pushapi/concepts/sandbox.md) заказ Маркета. 
  , orderDTOItems :: !([OrderItemDTO]) -- ^ /Required/ "items" - Список товаров в заказе.
  , orderDTOSubsidies :: !(Maybe [OrderSubsidyDTO]) -- ^ "subsidies" - Список субсидий по типам.
  , orderDTODelivery :: !(Maybe OrderDeliveryDTO) -- ^ "delivery"
  , orderDTOBuyer :: !(Maybe OrderBuyerDTO) -- ^ "buyer"
  , orderDTONotes :: !(Maybe Text) -- ^ "notes" - Комментарий к заказу.
  , orderDTOTaxSystem :: !(Maybe OrderTaxSystemType) -- ^ "taxSystem"
  , orderDTOCancelRequested :: !(Maybe Bool) -- ^ "cancelRequested" - **Только для модели DBS**  Запрошена ли отмена. 
  , orderDTOExpiryDate :: !(Maybe Text) -- ^ "expiryDate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderDTO
instance A.FromJSON OrderDTO where
  parseJSON = A.withObject "OrderDTO" $ \o ->
    OrderDTO
      <$> (o .:? "id")
      <*> (o .:? "status")
      <*> (o .:? "substatus")
      <*> (o .:? "creationDate")
      <*> (o .:? "updatedAt")
      <*> (o .:? "currency")
      <*> (o .:? "itemsTotal")
      <*> (o .:? "deliveryTotal")
      <*> (o .:? "buyerItemsTotal")
      <*> (o .:? "buyerTotal")
      <*> (o .:? "buyerItemsTotalBeforeDiscount")
      <*> (o .:? "buyerTotalBeforeDiscount")
      <*> (o .:? "paymentType")
      <*> (o .:? "paymentMethod")
      <*> (o .:? "fake")
      <*> (o .:  "items")
      <*> (o .:? "subsidies")
      <*> (o .:? "delivery")
      <*> (o .:? "buyer")
      <*> (o .:? "notes")
      <*> (o .:? "taxSystem")
      <*> (o .:? "cancelRequested")
      <*> (o .:? "expiryDate")

-- | ToJSON OrderDTO
instance A.ToJSON OrderDTO where
  toJSON OrderDTO {..} =
   _omitNulls
      [ "id" .= orderDTOId
      , "status" .= orderDTOStatus
      , "substatus" .= orderDTOSubstatus
      , "creationDate" .= orderDTOCreationDate
      , "updatedAt" .= orderDTOUpdatedAt
      , "currency" .= orderDTOCurrency
      , "itemsTotal" .= orderDTOItemsTotal
      , "deliveryTotal" .= orderDTODeliveryTotal
      , "buyerItemsTotal" .= orderDTOBuyerItemsTotal
      , "buyerTotal" .= orderDTOBuyerTotal
      , "buyerItemsTotalBeforeDiscount" .= orderDTOBuyerItemsTotalBeforeDiscount
      , "buyerTotalBeforeDiscount" .= orderDTOBuyerTotalBeforeDiscount
      , "paymentType" .= orderDTOPaymentType
      , "paymentMethod" .= orderDTOPaymentMethod
      , "fake" .= orderDTOFake
      , "items" .= orderDTOItems
      , "subsidies" .= orderDTOSubsidies
      , "delivery" .= orderDTODelivery
      , "buyer" .= orderDTOBuyer
      , "notes" .= orderDTONotes
      , "taxSystem" .= orderDTOTaxSystem
      , "cancelRequested" .= orderDTOCancelRequested
      , "expiryDate" .= orderDTOExpiryDate
      ]


-- | Construct a value of type 'OrderDTO' (by applying it's required fields, if any)
mkOrderDTO
  :: [OrderItemDTO] -- ^ 'orderDTOItems': Список товаров в заказе.
  -> OrderDTO
mkOrderDTO orderDTOItems =
  OrderDTO
  { orderDTOId = Nothing
  , orderDTOStatus = Nothing
  , orderDTOSubstatus = Nothing
  , orderDTOCreationDate = Nothing
  , orderDTOUpdatedAt = Nothing
  , orderDTOCurrency = Nothing
  , orderDTOItemsTotal = Nothing
  , orderDTODeliveryTotal = Nothing
  , orderDTOBuyerItemsTotal = Nothing
  , orderDTOBuyerTotal = Nothing
  , orderDTOBuyerItemsTotalBeforeDiscount = Nothing
  , orderDTOBuyerTotalBeforeDiscount = Nothing
  , orderDTOPaymentType = Nothing
  , orderDTOPaymentMethod = Nothing
  , orderDTOFake = Nothing
  , orderDTOItems
  , orderDTOSubsidies = Nothing
  , orderDTODelivery = Nothing
  , orderDTOBuyer = Nothing
  , orderDTONotes = Nothing
  , orderDTOTaxSystem = Nothing
  , orderDTOCancelRequested = Nothing
  , orderDTOExpiryDate = Nothing
  }

-- ** OrderDeliveryAddressDTO
-- | OrderDeliveryAddressDTO
-- Адрес доставки.  Указывается, если `type=DELIVERY`, `type=POST` или `type=PICKUP` (адрес пункта выдачи). 
data OrderDeliveryAddressDTO = OrderDeliveryAddressDTO
  { orderDeliveryAddressDTOCountry :: !(Maybe Text) -- ^ "country" - Страна.  Обязательный параметр. 
  , orderDeliveryAddressDTOPostcode :: !(Maybe Text) -- ^ "postcode" - Почтовый индекс.  Указывается, если выбрана доставка почтой (&#x60;delivery type&#x3D;POST&#x60;). 
  , orderDeliveryAddressDTOCity :: !(Maybe Text) -- ^ "city" - Город или населенный пункт.  Обязательный параметр. 
  , orderDeliveryAddressDTODistrict :: !(Maybe Text) -- ^ "district" - Район.
  , orderDeliveryAddressDTOSubway :: !(Maybe Text) -- ^ "subway" - Станция метро.
  , orderDeliveryAddressDTOStreet :: !(Maybe Text) -- ^ "street" - Улица.  Обязательный параметр. 
  , orderDeliveryAddressDTOHouse :: !(Maybe Text) -- ^ "house" - Дом или владение.  Обязательный параметр. 
  , orderDeliveryAddressDTOBlock :: !(Maybe Text) -- ^ "block" - Корпус или строение.
  , orderDeliveryAddressDTOEntrance :: !(Maybe Text) -- ^ "entrance" - Подъезд.
  , orderDeliveryAddressDTOEntryphone :: !(Maybe Text) -- ^ "entryphone" - Код домофона.
  , orderDeliveryAddressDTOFloor :: !(Maybe Text) -- ^ "floor" - Этаж.
  , orderDeliveryAddressDTOApartment :: !(Maybe Text) -- ^ "apartment" - Квартира или офис.
  , orderDeliveryAddressDTOPhone :: !(Maybe Text) -- ^ "phone" - Телефон получателя заказа.  Обязательный параметр. 
  , orderDeliveryAddressDTORecipient :: !(Maybe Text) -- ^ "recipient" - Фамилия, имя и отчество получателя заказа.  Обязательный параметр. 
  , orderDeliveryAddressDTOGps :: !(Maybe GpsDTO) -- ^ "gps"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderDeliveryAddressDTO
instance A.FromJSON OrderDeliveryAddressDTO where
  parseJSON = A.withObject "OrderDeliveryAddressDTO" $ \o ->
    OrderDeliveryAddressDTO
      <$> (o .:? "country")
      <*> (o .:? "postcode")
      <*> (o .:? "city")
      <*> (o .:? "district")
      <*> (o .:? "subway")
      <*> (o .:? "street")
      <*> (o .:? "house")
      <*> (o .:? "block")
      <*> (o .:? "entrance")
      <*> (o .:? "entryphone")
      <*> (o .:? "floor")
      <*> (o .:? "apartment")
      <*> (o .:? "phone")
      <*> (o .:? "recipient")
      <*> (o .:? "gps")

-- | ToJSON OrderDeliveryAddressDTO
instance A.ToJSON OrderDeliveryAddressDTO where
  toJSON OrderDeliveryAddressDTO {..} =
   _omitNulls
      [ "country" .= orderDeliveryAddressDTOCountry
      , "postcode" .= orderDeliveryAddressDTOPostcode
      , "city" .= orderDeliveryAddressDTOCity
      , "district" .= orderDeliveryAddressDTODistrict
      , "subway" .= orderDeliveryAddressDTOSubway
      , "street" .= orderDeliveryAddressDTOStreet
      , "house" .= orderDeliveryAddressDTOHouse
      , "block" .= orderDeliveryAddressDTOBlock
      , "entrance" .= orderDeliveryAddressDTOEntrance
      , "entryphone" .= orderDeliveryAddressDTOEntryphone
      , "floor" .= orderDeliveryAddressDTOFloor
      , "apartment" .= orderDeliveryAddressDTOApartment
      , "phone" .= orderDeliveryAddressDTOPhone
      , "recipient" .= orderDeliveryAddressDTORecipient
      , "gps" .= orderDeliveryAddressDTOGps
      ]


-- | Construct a value of type 'OrderDeliveryAddressDTO' (by applying it's required fields, if any)
mkOrderDeliveryAddressDTO
  :: OrderDeliveryAddressDTO
mkOrderDeliveryAddressDTO =
  OrderDeliveryAddressDTO
  { orderDeliveryAddressDTOCountry = Nothing
  , orderDeliveryAddressDTOPostcode = Nothing
  , orderDeliveryAddressDTOCity = Nothing
  , orderDeliveryAddressDTODistrict = Nothing
  , orderDeliveryAddressDTOSubway = Nothing
  , orderDeliveryAddressDTOStreet = Nothing
  , orderDeliveryAddressDTOHouse = Nothing
  , orderDeliveryAddressDTOBlock = Nothing
  , orderDeliveryAddressDTOEntrance = Nothing
  , orderDeliveryAddressDTOEntryphone = Nothing
  , orderDeliveryAddressDTOFloor = Nothing
  , orderDeliveryAddressDTOApartment = Nothing
  , orderDeliveryAddressDTOPhone = Nothing
  , orderDeliveryAddressDTORecipient = Nothing
  , orderDeliveryAddressDTOGps = Nothing
  }

-- ** OrderDeliveryDTO
-- | OrderDeliveryDTO
-- Информация о доставке.
data OrderDeliveryDTO = OrderDeliveryDTO
  { orderDeliveryDTOId :: !(Maybe Text) -- ^ "id" - Идентификатор доставки, присвоенный магазином.  Указывается, только если магазин передал данный идентификатор в ответе на запрос методом [POST cart](../../pushapi/reference/cart.md). 
  , orderDeliveryDTOType :: !(Maybe OrderDeliveryType) -- ^ "type"
  , orderDeliveryDTOServiceName :: !(Maybe Text) -- ^ "serviceName" - Наименование службы доставки.
  , orderDeliveryDTOPrice :: !(Maybe Double) -- ^ "price" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Стоимость доставки смотрите в параметре &#x60;deliveryTotal&#x60;.  {% endnote %}  Стоимость доставки в валюте заказа. 
  , orderDeliveryDTODeliveryPartnerType :: !(Maybe OrderDeliveryPartnerType) -- ^ "deliveryPartnerType"
  , orderDeliveryDTOCourier :: !(Maybe OrderCourierDTO) -- ^ "courier"
  , orderDeliveryDTODates :: !(Maybe OrderDeliveryDatesDTO) -- ^ "dates"
  , orderDeliveryDTORegion :: !(Maybe RegionDTO) -- ^ "region"
  , orderDeliveryDTOAddress :: !(Maybe OrderDeliveryAddressDTO) -- ^ "address"
  , orderDeliveryDTOVat :: !(Maybe OrderVatType) -- ^ "vat"
  , orderDeliveryDTODeliveryServiceId :: !(Maybe Integer) -- ^ "deliveryServiceId" - Идентификатор службы доставки.
  , orderDeliveryDTOLiftType :: !(Maybe OrderLiftType) -- ^ "liftType"
  , orderDeliveryDTOLiftPrice :: !(Maybe Double) -- ^ "liftPrice" - Стоимость подъема на этаж.
  , orderDeliveryDTOOutletCode :: !(Maybe Text) -- ^ "outletCode" - Идентификатор пункта самовывоза, присвоенный магазином.
  , orderDeliveryDTOOutletStorageLimitDate :: !(Maybe Text) -- ^ "outletStorageLimitDate" - Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  , orderDeliveryDTODispatchType :: !(Maybe OrderDeliveryDispatchType) -- ^ "dispatchType"
  , orderDeliveryDTOTracks :: !(Maybe [OrderTrackDTO]) -- ^ "tracks" - Информация для отслеживания перемещений посылки.
  , orderDeliveryDTOShipments :: !(Maybe [OrderShipmentDTO]) -- ^ "shipments" - Информация о посылках.
  , orderDeliveryDTOEstimated :: !(Maybe Bool) -- ^ "estimated" - Приблизительная ли дата доставки.
  , orderDeliveryDTOEacType :: !(Maybe OrderDeliveryEacType) -- ^ "eacType"
  , orderDeliveryDTOEacCode :: !(Maybe Text) -- ^ "eacCode" - Код подтверждения ЭАПП (для типа &#x60;MERCHANT_TO_COURIER&#x60;). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderDeliveryDTO
instance A.FromJSON OrderDeliveryDTO where
  parseJSON = A.withObject "OrderDeliveryDTO" $ \o ->
    OrderDeliveryDTO
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "serviceName")
      <*> (o .:? "price")
      <*> (o .:? "deliveryPartnerType")
      <*> (o .:? "courier")
      <*> (o .:? "dates")
      <*> (o .:? "region")
      <*> (o .:? "address")
      <*> (o .:? "vat")
      <*> (o .:? "deliveryServiceId")
      <*> (o .:? "liftType")
      <*> (o .:? "liftPrice")
      <*> (o .:? "outletCode")
      <*> (o .:? "outletStorageLimitDate")
      <*> (o .:? "dispatchType")
      <*> (o .:? "tracks")
      <*> (o .:? "shipments")
      <*> (o .:? "estimated")
      <*> (o .:? "eacType")
      <*> (o .:? "eacCode")

-- | ToJSON OrderDeliveryDTO
instance A.ToJSON OrderDeliveryDTO where
  toJSON OrderDeliveryDTO {..} =
   _omitNulls
      [ "id" .= orderDeliveryDTOId
      , "type" .= orderDeliveryDTOType
      , "serviceName" .= orderDeliveryDTOServiceName
      , "price" .= orderDeliveryDTOPrice
      , "deliveryPartnerType" .= orderDeliveryDTODeliveryPartnerType
      , "courier" .= orderDeliveryDTOCourier
      , "dates" .= orderDeliveryDTODates
      , "region" .= orderDeliveryDTORegion
      , "address" .= orderDeliveryDTOAddress
      , "vat" .= orderDeliveryDTOVat
      , "deliveryServiceId" .= orderDeliveryDTODeliveryServiceId
      , "liftType" .= orderDeliveryDTOLiftType
      , "liftPrice" .= orderDeliveryDTOLiftPrice
      , "outletCode" .= orderDeliveryDTOOutletCode
      , "outletStorageLimitDate" .= orderDeliveryDTOOutletStorageLimitDate
      , "dispatchType" .= orderDeliveryDTODispatchType
      , "tracks" .= orderDeliveryDTOTracks
      , "shipments" .= orderDeliveryDTOShipments
      , "estimated" .= orderDeliveryDTOEstimated
      , "eacType" .= orderDeliveryDTOEacType
      , "eacCode" .= orderDeliveryDTOEacCode
      ]


-- | Construct a value of type 'OrderDeliveryDTO' (by applying it's required fields, if any)
mkOrderDeliveryDTO
  :: OrderDeliveryDTO
mkOrderDeliveryDTO =
  OrderDeliveryDTO
  { orderDeliveryDTOId = Nothing
  , orderDeliveryDTOType = Nothing
  , orderDeliveryDTOServiceName = Nothing
  , orderDeliveryDTOPrice = Nothing
  , orderDeliveryDTODeliveryPartnerType = Nothing
  , orderDeliveryDTOCourier = Nothing
  , orderDeliveryDTODates = Nothing
  , orderDeliveryDTORegion = Nothing
  , orderDeliveryDTOAddress = Nothing
  , orderDeliveryDTOVat = Nothing
  , orderDeliveryDTODeliveryServiceId = Nothing
  , orderDeliveryDTOLiftType = Nothing
  , orderDeliveryDTOLiftPrice = Nothing
  , orderDeliveryDTOOutletCode = Nothing
  , orderDeliveryDTOOutletStorageLimitDate = Nothing
  , orderDeliveryDTODispatchType = Nothing
  , orderDeliveryDTOTracks = Nothing
  , orderDeliveryDTOShipments = Nothing
  , orderDeliveryDTOEstimated = Nothing
  , orderDeliveryDTOEacType = Nothing
  , orderDeliveryDTOEacCode = Nothing
  }

-- ** OrderDeliveryDateDTO
-- | OrderDeliveryDateDTO
-- Информация о новой дате доставки заказа.
data OrderDeliveryDateDTO = OrderDeliveryDateDTO
  { orderDeliveryDateDTOToDate :: !(Date) -- ^ /Required/ "toDate" - Новая дата доставки заказа.  Формат даты: &#x60;ГГГГ-ММ-ДД&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderDeliveryDateDTO
instance A.FromJSON OrderDeliveryDateDTO where
  parseJSON = A.withObject "OrderDeliveryDateDTO" $ \o ->
    OrderDeliveryDateDTO
      <$> (o .:  "toDate")

-- | ToJSON OrderDeliveryDateDTO
instance A.ToJSON OrderDeliveryDateDTO where
  toJSON OrderDeliveryDateDTO {..} =
   _omitNulls
      [ "toDate" .= orderDeliveryDateDTOToDate
      ]


-- | Construct a value of type 'OrderDeliveryDateDTO' (by applying it's required fields, if any)
mkOrderDeliveryDateDTO
  :: Date -- ^ 'orderDeliveryDateDTOToDate': Новая дата доставки заказа.  Формат даты: `ГГГГ-ММ-ДД`. 
  -> OrderDeliveryDateDTO
mkOrderDeliveryDateDTO orderDeliveryDateDTOToDate =
  OrderDeliveryDateDTO
  { orderDeliveryDateDTOToDate
  }

-- ** OrderDeliveryDatesDTO
-- | OrderDeliveryDatesDTO
-- Диапазон дат доставки.
data OrderDeliveryDatesDTO = OrderDeliveryDatesDTO
  { orderDeliveryDatesDTOFromDate :: !(Maybe Text) -- ^ "fromDate" - Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  , orderDeliveryDatesDTOToDate :: !(Maybe Text) -- ^ "toDate" - Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  , orderDeliveryDatesDTOFromTime :: !(Maybe Text) -- ^ "fromTime" - Начало интервала времени доставки.  Передается только совместно с параметром &#x60;type&#x3D;DELIVERY&#x60;.  Формат времени: 24-часовой, &#x60;ЧЧ:ММ&#x60;. В качестве минут всегда должно быть указано &#x60;00&#x60; (исключение — &#x60;23:59&#x60;).  Минимальное значение: &#x60;00:00&#x60;. 
  , orderDeliveryDatesDTOToTime :: !(Maybe Text) -- ^ "toTime" - Конец интервала времени доставки.  Передается только совместно с параметром &#x60;type&#x3D;DELIVERY&#x60;.  Формат времени: 24-часовой, &#x60;ЧЧ:ММ&#x60;. В качестве минут всегда должно быть указано &#x60;00&#x60; (исключение — &#x60;23:59&#x60;).  Максимальное значение: &#x60;23:59&#x60;. 
  , orderDeliveryDatesDTORealDeliveryDate :: !(Maybe Text) -- ^ "realDeliveryDate" - Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderDeliveryDatesDTO
instance A.FromJSON OrderDeliveryDatesDTO where
  parseJSON = A.withObject "OrderDeliveryDatesDTO" $ \o ->
    OrderDeliveryDatesDTO
      <$> (o .:? "fromDate")
      <*> (o .:? "toDate")
      <*> (o .:? "fromTime")
      <*> (o .:? "toTime")
      <*> (o .:? "realDeliveryDate")

-- | ToJSON OrderDeliveryDatesDTO
instance A.ToJSON OrderDeliveryDatesDTO where
  toJSON OrderDeliveryDatesDTO {..} =
   _omitNulls
      [ "fromDate" .= orderDeliveryDatesDTOFromDate
      , "toDate" .= orderDeliveryDatesDTOToDate
      , "fromTime" .= orderDeliveryDatesDTOFromTime
      , "toTime" .= orderDeliveryDatesDTOToTime
      , "realDeliveryDate" .= orderDeliveryDatesDTORealDeliveryDate
      ]


-- | Construct a value of type 'OrderDeliveryDatesDTO' (by applying it's required fields, if any)
mkOrderDeliveryDatesDTO
  :: OrderDeliveryDatesDTO
mkOrderDeliveryDatesDTO =
  OrderDeliveryDatesDTO
  { orderDeliveryDatesDTOFromDate = Nothing
  , orderDeliveryDatesDTOToDate = Nothing
  , orderDeliveryDatesDTOFromTime = Nothing
  , orderDeliveryDatesDTOToTime = Nothing
  , orderDeliveryDatesDTORealDeliveryDate = Nothing
  }

-- ** OrderDigitalItemDTO
-- | OrderDigitalItemDTO
-- Ключ цифрового товара.
data OrderDigitalItemDTO = OrderDigitalItemDTO
  { orderDigitalItemDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор товара в заказе.  Он приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр &#x60;id&#x60; в &#x60;items&#x60;. 
  , orderDigitalItemDTOCode :: !(Text) -- ^ /Required/ "code" - Сам ключ.
  , orderDigitalItemDTOSlip :: !(Text) -- ^ /Required/ "slip" - Инструкция по активации.
  , orderDigitalItemDTOActivateTill :: !(Date) -- ^ /Required/ "activate_till" - Дата, до которой нужно активировать ключ. Если ключ действует бессрочно, укажите любую дату в отдаленном будущем.  Формат даты: &#x60;ГГГГ-ММ-ДД&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderDigitalItemDTO
instance A.FromJSON OrderDigitalItemDTO where
  parseJSON = A.withObject "OrderDigitalItemDTO" $ \o ->
    OrderDigitalItemDTO
      <$> (o .:  "id")
      <*> (o .:  "code")
      <*> (o .:  "slip")
      <*> (o .:  "activate_till")

-- | ToJSON OrderDigitalItemDTO
instance A.ToJSON OrderDigitalItemDTO where
  toJSON OrderDigitalItemDTO {..} =
   _omitNulls
      [ "id" .= orderDigitalItemDTOId
      , "code" .= orderDigitalItemDTOCode
      , "slip" .= orderDigitalItemDTOSlip
      , "activate_till" .= orderDigitalItemDTOActivateTill
      ]


-- | Construct a value of type 'OrderDigitalItemDTO' (by applying it's required fields, if any)
mkOrderDigitalItemDTO
  :: Integer -- ^ 'orderDigitalItemDTOId': Идентификатор товара в заказе.  Он приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр `id` в `items`. 
  -> Text -- ^ 'orderDigitalItemDTOCode': Сам ключ.
  -> Text -- ^ 'orderDigitalItemDTOSlip': Инструкция по активации.
  -> Date -- ^ 'orderDigitalItemDTOActivateTill': Дата, до которой нужно активировать ключ. Если ключ действует бессрочно, укажите любую дату в отдаленном будущем.  Формат даты: `ГГГГ-ММ-ДД`. 
  -> OrderDigitalItemDTO
mkOrderDigitalItemDTO orderDigitalItemDTOId orderDigitalItemDTOCode orderDigitalItemDTOSlip orderDigitalItemDTOActivateTill =
  OrderDigitalItemDTO
  { orderDigitalItemDTOId
  , orderDigitalItemDTOCode
  , orderDigitalItemDTOSlip
  , orderDigitalItemDTOActivateTill
  }

-- ** OrderItemDTO
-- | OrderItemDTO
-- Список товаров в заказе.
data OrderItemDTO = OrderItemDTO
  { orderItemDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор товара в заказе.  Позволяет идентифицировать товар в рамках данного заказа. 
  , orderItemDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , orderItemDTOOfferName :: !(Maybe Text) -- ^ "offerName" - Название товара.
  , orderItemDTOPrice :: !(Maybe Double) -- ^ "price" - Цена на товар в валюте заказа без учета вознаграждения партнеру за скидки по промокодам, купонам и акциям (параметр &#x60;subsidies&#x60;). 
  , orderItemDTOBuyerPrice :: !(Maybe Double) -- ^ "buyerPrice" - Цена на товар в валюте покупателя. В цене уже учтены скидки по:  * акциям; * купонам; * промокодам. 
  , orderItemDTOBuyerPriceBeforeDiscount :: !(Maybe Double) -- ^ "buyerPriceBeforeDiscount" - Стоимость товара в валюте покупателя до применения скидок по:  * акциям; * купонам; * промокодам. 
  , orderItemDTOPriceBeforeDiscount :: !(Maybe Double) -- ^ "priceBeforeDiscount" - {% note warning \&quot;\&quot; %}  Этот параметр устарел.  {% endnote %}  Стоимость товара в валюте магазина до применения скидок. 
  , orderItemDTOCount :: !(Maybe Int) -- ^ "count" - Количество единиц товара.
  , orderItemDTOVat :: !(Maybe OrderVatType) -- ^ "vat"
  , orderItemDTOShopSku :: !(Maybe Text) -- ^ "shopSku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , orderItemDTOSubsidy :: !(Maybe Double) -- ^ "subsidy" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Вместо него используйте &#x60;subsidies&#x60;.  {% endnote %}  Общее вознаграждение партнеру за DBS-доставку и все скидки на товар:  * по промокодам; * по купонам; * по баллам Плюса; * по акциям.  Передается в валюте заказа. 
  , orderItemDTOPartnerWarehouseId :: !(Maybe Text) -- ^ "partnerWarehouseId" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Идентификатор склада в системе партнера, на который сформирован заказ. 
  , orderItemDTOPromos :: !(Maybe [OrderItemPromoDTO]) -- ^ "promos" - Информация о вознаграждениях партнеру за скидки на товар по промокодам, купонам и акциям.
  , orderItemDTOInstances :: !(Maybe [OrderItemInstanceDTO]) -- ^ "instances" - Информация о маркировке единиц товара.  Возвращаются данные для маркировки, переданные в запросе [PUT campaigns/{campaignId}/orders/{orderId}/cis](../../reference/orders/provideOrderItemCis.md).  Если магазин еще не передавал коды для этого заказа, &#x60;instances&#x60; отсутствует. 
  , orderItemDTODetails :: !(Maybe [OrderItemDetailDTO]) -- ^ "details" - Информация об удалении товара из заказа. 
  , orderItemDTOSubsidies :: !(Maybe [OrderItemSubsidyDTO]) -- ^ "subsidies" - Список субсидий по типам.
  , orderItemDTORequiredInstanceTypes :: !(Maybe [OrderItemInstanceType]) -- ^ "requiredInstanceTypes" - Список необходимых маркировок товара.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderItemDTO
instance A.FromJSON OrderItemDTO where
  parseJSON = A.withObject "OrderItemDTO" $ \o ->
    OrderItemDTO
      <$> (o .:? "id")
      <*> (o .:? "offerId")
      <*> (o .:? "offerName")
      <*> (o .:? "price")
      <*> (o .:? "buyerPrice")
      <*> (o .:? "buyerPriceBeforeDiscount")
      <*> (o .:? "priceBeforeDiscount")
      <*> (o .:? "count")
      <*> (o .:? "vat")
      <*> (o .:? "shopSku")
      <*> (o .:? "subsidy")
      <*> (o .:? "partnerWarehouseId")
      <*> (o .:? "promos")
      <*> (o .:? "instances")
      <*> (o .:? "details")
      <*> (o .:? "subsidies")
      <*> (o .:? "requiredInstanceTypes")

-- | ToJSON OrderItemDTO
instance A.ToJSON OrderItemDTO where
  toJSON OrderItemDTO {..} =
   _omitNulls
      [ "id" .= orderItemDTOId
      , "offerId" .= orderItemDTOOfferId
      , "offerName" .= orderItemDTOOfferName
      , "price" .= orderItemDTOPrice
      , "buyerPrice" .= orderItemDTOBuyerPrice
      , "buyerPriceBeforeDiscount" .= orderItemDTOBuyerPriceBeforeDiscount
      , "priceBeforeDiscount" .= orderItemDTOPriceBeforeDiscount
      , "count" .= orderItemDTOCount
      , "vat" .= orderItemDTOVat
      , "shopSku" .= orderItemDTOShopSku
      , "subsidy" .= orderItemDTOSubsidy
      , "partnerWarehouseId" .= orderItemDTOPartnerWarehouseId
      , "promos" .= orderItemDTOPromos
      , "instances" .= orderItemDTOInstances
      , "details" .= orderItemDTODetails
      , "subsidies" .= orderItemDTOSubsidies
      , "requiredInstanceTypes" .= orderItemDTORequiredInstanceTypes
      ]


-- | Construct a value of type 'OrderItemDTO' (by applying it's required fields, if any)
mkOrderItemDTO
  :: OrderItemDTO
mkOrderItemDTO =
  OrderItemDTO
  { orderItemDTOId = Nothing
  , orderItemDTOOfferId = Nothing
  , orderItemDTOOfferName = Nothing
  , orderItemDTOPrice = Nothing
  , orderItemDTOBuyerPrice = Nothing
  , orderItemDTOBuyerPriceBeforeDiscount = Nothing
  , orderItemDTOPriceBeforeDiscount = Nothing
  , orderItemDTOCount = Nothing
  , orderItemDTOVat = Nothing
  , orderItemDTOShopSku = Nothing
  , orderItemDTOSubsidy = Nothing
  , orderItemDTOPartnerWarehouseId = Nothing
  , orderItemDTOPromos = Nothing
  , orderItemDTOInstances = Nothing
  , orderItemDTODetails = Nothing
  , orderItemDTOSubsidies = Nothing
  , orderItemDTORequiredInstanceTypes = Nothing
  }

-- ** OrderItemDetailDTO
-- | OrderItemDetailDTO
-- Детали по товару в заказе.
data OrderItemDetailDTO = OrderItemDetailDTO
  { orderItemDetailDTOItemCount :: !(Maybe Integer) -- ^ "itemCount" - Количество единиц товара.
  , orderItemDetailDTOItemStatus :: !(Maybe OrderItemStatusType) -- ^ "itemStatus"
  , orderItemDetailDTOUpdateDate :: !(Maybe Text) -- ^ "updateDate" - Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderItemDetailDTO
instance A.FromJSON OrderItemDetailDTO where
  parseJSON = A.withObject "OrderItemDetailDTO" $ \o ->
    OrderItemDetailDTO
      <$> (o .:? "itemCount")
      <*> (o .:? "itemStatus")
      <*> (o .:? "updateDate")

-- | ToJSON OrderItemDetailDTO
instance A.ToJSON OrderItemDetailDTO where
  toJSON OrderItemDetailDTO {..} =
   _omitNulls
      [ "itemCount" .= orderItemDetailDTOItemCount
      , "itemStatus" .= orderItemDetailDTOItemStatus
      , "updateDate" .= orderItemDetailDTOUpdateDate
      ]


-- | Construct a value of type 'OrderItemDetailDTO' (by applying it's required fields, if any)
mkOrderItemDetailDTO
  :: OrderItemDetailDTO
mkOrderItemDetailDTO =
  OrderItemDetailDTO
  { orderItemDetailDTOItemCount = Nothing
  , orderItemDetailDTOItemStatus = Nothing
  , orderItemDetailDTOUpdateDate = Nothing
  }

-- ** OrderItemInstanceDTO
-- | OrderItemInstanceDTO
-- Переданные вами для данной позиции коды маркировки или УИНы. Коды «Честного знака» возвращаются в двух вариантах — с криптохвостом и без. 
data OrderItemInstanceDTO = OrderItemInstanceDTO
  { orderItemInstanceDTOCis :: !(Maybe Text) -- ^ "cis" - Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/) без криптохвоста.
  , orderItemInstanceDTOCisFull :: !(Maybe Text) -- ^ "cisFull" - Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/) с криптохвостом.
  , orderItemInstanceDTOUin :: !(Maybe Text) -- ^ "uin" - УИН ювелирного изделия (16-значный код) Производитель получает УИН, когда регистрирует изделие в системе контроля за оборотом драгоценных металлов и камней — ГИИС ДМДК. 
  , orderItemInstanceDTORnpt :: !(Maybe Text) -- ^ "rnpt" - Регистрационный номер партии товара.  Представляет собой строку из четырех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ/ХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на партию товара. Далее — дата, номер декларации и номер маркированного товара в декларации. 
  , orderItemInstanceDTOGtd :: !(Maybe Text) -- ^ "gtd" - Грузовая таможенная декларация.  Представляет собой строку из трех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на ввезенные товары. Далее — дата и номер декларации. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderItemInstanceDTO
instance A.FromJSON OrderItemInstanceDTO where
  parseJSON = A.withObject "OrderItemInstanceDTO" $ \o ->
    OrderItemInstanceDTO
      <$> (o .:? "cis")
      <*> (o .:? "cisFull")
      <*> (o .:? "uin")
      <*> (o .:? "rnpt")
      <*> (o .:? "gtd")

-- | ToJSON OrderItemInstanceDTO
instance A.ToJSON OrderItemInstanceDTO where
  toJSON OrderItemInstanceDTO {..} =
   _omitNulls
      [ "cis" .= orderItemInstanceDTOCis
      , "cisFull" .= orderItemInstanceDTOCisFull
      , "uin" .= orderItemInstanceDTOUin
      , "rnpt" .= orderItemInstanceDTORnpt
      , "gtd" .= orderItemInstanceDTOGtd
      ]


-- | Construct a value of type 'OrderItemInstanceDTO' (by applying it's required fields, if any)
mkOrderItemInstanceDTO
  :: OrderItemInstanceDTO
mkOrderItemInstanceDTO =
  OrderItemInstanceDTO
  { orderItemInstanceDTOCis = Nothing
  , orderItemInstanceDTOCisFull = Nothing
  , orderItemInstanceDTOUin = Nothing
  , orderItemInstanceDTORnpt = Nothing
  , orderItemInstanceDTOGtd = Nothing
  }

-- ** OrderItemInstanceModificationDTO
-- | OrderItemInstanceModificationDTO
-- Позиция в корзине, требующая маркировки.
data OrderItemInstanceModificationDTO = OrderItemInstanceModificationDTO
  { orderItemInstanceModificationDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор товара в заказе.  Он приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр &#x60;id&#x60; в &#x60;items&#x60;. 
  , orderItemInstanceModificationDTOInstances :: !([BriefOrderItemInstanceDTO]) -- ^ /Required/ "instances" - Список кодов маркировки единиц товара. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderItemInstanceModificationDTO
instance A.FromJSON OrderItemInstanceModificationDTO where
  parseJSON = A.withObject "OrderItemInstanceModificationDTO" $ \o ->
    OrderItemInstanceModificationDTO
      <$> (o .:  "id")
      <*> (o .:  "instances")

-- | ToJSON OrderItemInstanceModificationDTO
instance A.ToJSON OrderItemInstanceModificationDTO where
  toJSON OrderItemInstanceModificationDTO {..} =
   _omitNulls
      [ "id" .= orderItemInstanceModificationDTOId
      , "instances" .= orderItemInstanceModificationDTOInstances
      ]


-- | Construct a value of type 'OrderItemInstanceModificationDTO' (by applying it's required fields, if any)
mkOrderItemInstanceModificationDTO
  :: Integer -- ^ 'orderItemInstanceModificationDTOId': Идентификатор товара в заказе.  Он приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр `id` в `items`. 
  -> [BriefOrderItemInstanceDTO] -- ^ 'orderItemInstanceModificationDTOInstances': Список кодов маркировки единиц товара. 
  -> OrderItemInstanceModificationDTO
mkOrderItemInstanceModificationDTO orderItemInstanceModificationDTOId orderItemInstanceModificationDTOInstances =
  OrderItemInstanceModificationDTO
  { orderItemInstanceModificationDTOId
  , orderItemInstanceModificationDTOInstances
  }

-- ** OrderItemModificationDTO
-- | OrderItemModificationDTO
-- Список товаров в заказе.  Если магазин не передал информацию о товаре во входных данных, он будет удален из заказа.  Обязательный параметр. 
data OrderItemModificationDTO = OrderItemModificationDTO
  { orderItemModificationDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор товара в рамках заказа.  Получить идентификатор можно с помощью ресурсов [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).  Обязательный параметр. 
  , orderItemModificationDTOCount :: !(Int) -- ^ /Required/ "count" - Новое количество товара.
  , orderItemModificationDTOInstances :: !(Maybe [BriefOrderItemInstanceDTO]) -- ^ "instances" - Информация о маркировке единиц товара.  Передавайте в запросе все единицы товара, который подлежит маркировке.  Обязательный параметр, если в заказе есть товары, подлежащие маркировке [в системе «Честный ЗНАК»](https://честныйзнак.рф/). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderItemModificationDTO
instance A.FromJSON OrderItemModificationDTO where
  parseJSON = A.withObject "OrderItemModificationDTO" $ \o ->
    OrderItemModificationDTO
      <$> (o .:  "id")
      <*> (o .:  "count")
      <*> (o .:? "instances")

-- | ToJSON OrderItemModificationDTO
instance A.ToJSON OrderItemModificationDTO where
  toJSON OrderItemModificationDTO {..} =
   _omitNulls
      [ "id" .= orderItemModificationDTOId
      , "count" .= orderItemModificationDTOCount
      , "instances" .= orderItemModificationDTOInstances
      ]


-- | Construct a value of type 'OrderItemModificationDTO' (by applying it's required fields, if any)
mkOrderItemModificationDTO
  :: Integer -- ^ 'orderItemModificationDTOId': Идентификатор товара в рамках заказа.  Получить идентификатор можно с помощью ресурсов [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).  Обязательный параметр. 
  -> Int -- ^ 'orderItemModificationDTOCount': Новое количество товара.
  -> OrderItemModificationDTO
mkOrderItemModificationDTO orderItemModificationDTOId orderItemModificationDTOCount =
  OrderItemModificationDTO
  { orderItemModificationDTOId
  , orderItemModificationDTOCount
  , orderItemModificationDTOInstances = Nothing
  }

-- ** OrderItemPromoDTO
-- | OrderItemPromoDTO
-- Информация о вознаграждениях партнеру за скидки на товар по промокодам, купонам и акциям.
data OrderItemPromoDTO = OrderItemPromoDTO
  { orderItemPromoDTOType :: !(OrderPromoType) -- ^ /Required/ "type"
  , orderItemPromoDTODiscount :: !(Maybe Double) -- ^ "discount" - Размер пользовательской скидки в валюте покупателя. 
  , orderItemPromoDTOSubsidy :: !(Maybe Double) -- ^ "subsidy" - Вознаграждение партнеру от Маркета за товар, проданный в рамках акции.  Передается в валюте заказа. 
  , orderItemPromoDTOShopPromoId :: !(Maybe Text) -- ^ "shopPromoId" - Идентификатор акции поставщика. 
  , orderItemPromoDTOMarketPromoId :: !(Maybe Text) -- ^ "marketPromoId" - Идентификатор акции в рамках соглашения на оказание услуг по продвижению сервиса между Маркетом и партнером.  Параметр передается, только если параметр &#x60;type&#x3D;MARKET_DEAL&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderItemPromoDTO
instance A.FromJSON OrderItemPromoDTO where
  parseJSON = A.withObject "OrderItemPromoDTO" $ \o ->
    OrderItemPromoDTO
      <$> (o .:  "type")
      <*> (o .:? "discount")
      <*> (o .:? "subsidy")
      <*> (o .:? "shopPromoId")
      <*> (o .:? "marketPromoId")

-- | ToJSON OrderItemPromoDTO
instance A.ToJSON OrderItemPromoDTO where
  toJSON OrderItemPromoDTO {..} =
   _omitNulls
      [ "type" .= orderItemPromoDTOType
      , "discount" .= orderItemPromoDTODiscount
      , "subsidy" .= orderItemPromoDTOSubsidy
      , "shopPromoId" .= orderItemPromoDTOShopPromoId
      , "marketPromoId" .= orderItemPromoDTOMarketPromoId
      ]


-- | Construct a value of type 'OrderItemPromoDTO' (by applying it's required fields, if any)
mkOrderItemPromoDTO
  :: OrderPromoType -- ^ 'orderItemPromoDTOType' 
  -> OrderItemPromoDTO
mkOrderItemPromoDTO orderItemPromoDTOType =
  OrderItemPromoDTO
  { orderItemPromoDTOType
  , orderItemPromoDTODiscount = Nothing
  , orderItemPromoDTOSubsidy = Nothing
  , orderItemPromoDTOShopPromoId = Nothing
  , orderItemPromoDTOMarketPromoId = Nothing
  }

-- ** OrderItemSubsidyDTO
-- | OrderItemSubsidyDTO
-- Общее вознаграждение партнеру за все скидки на товар:  * по промокодам, купонам и акциям; * по баллам Плюса.  Передается в валюте заказа. 
data OrderItemSubsidyDTO = OrderItemSubsidyDTO
  { orderItemSubsidyDTOType :: !(Maybe OrderItemSubsidyType) -- ^ "type"
  , orderItemSubsidyDTOAmount :: !(Maybe Double) -- ^ "amount" - Сумма субсидии.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderItemSubsidyDTO
instance A.FromJSON OrderItemSubsidyDTO where
  parseJSON = A.withObject "OrderItemSubsidyDTO" $ \o ->
    OrderItemSubsidyDTO
      <$> (o .:? "type")
      <*> (o .:? "amount")

-- | ToJSON OrderItemSubsidyDTO
instance A.ToJSON OrderItemSubsidyDTO where
  toJSON OrderItemSubsidyDTO {..} =
   _omitNulls
      [ "type" .= orderItemSubsidyDTOType
      , "amount" .= orderItemSubsidyDTOAmount
      ]


-- | Construct a value of type 'OrderItemSubsidyDTO' (by applying it's required fields, if any)
mkOrderItemSubsidyDTO
  :: OrderItemSubsidyDTO
mkOrderItemSubsidyDTO =
  OrderItemSubsidyDTO
  { orderItemSubsidyDTOType = Nothing
  , orderItemSubsidyDTOAmount = Nothing
  }

-- ** OrderItemsModificationResultDTO
-- | OrderItemsModificationResultDTO
-- Краткие сведения о промаркированных товарах. Параметр возвращается, если ответ `OK`. 
data OrderItemsModificationResultDTO = OrderItemsModificationResultDTO
  { orderItemsModificationResultDTOItems :: !([BriefOrderItemDTO]) -- ^ /Required/ "items" - Список позиций в заказе, подлежащих маркировке.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderItemsModificationResultDTO
instance A.FromJSON OrderItemsModificationResultDTO where
  parseJSON = A.withObject "OrderItemsModificationResultDTO" $ \o ->
    OrderItemsModificationResultDTO
      <$> (o .:  "items")

-- | ToJSON OrderItemsModificationResultDTO
instance A.ToJSON OrderItemsModificationResultDTO where
  toJSON OrderItemsModificationResultDTO {..} =
   _omitNulls
      [ "items" .= orderItemsModificationResultDTOItems
      ]


-- | Construct a value of type 'OrderItemsModificationResultDTO' (by applying it's required fields, if any)
mkOrderItemsModificationResultDTO
  :: [BriefOrderItemDTO] -- ^ 'orderItemsModificationResultDTOItems': Список позиций в заказе, подлежащих маркировке.
  -> OrderItemsModificationResultDTO
mkOrderItemsModificationResultDTO orderItemsModificationResultDTOItems =
  OrderItemsModificationResultDTO
  { orderItemsModificationResultDTOItems
  }

-- ** OrderLabelDTO
-- | OrderLabelDTO
-- Данные для печати ярлыка.
data OrderLabelDTO = OrderLabelDTO
  { orderLabelDTOOrderId :: !(Integer) -- ^ /Required/ "orderId" - Идентификатор заказа.
  , orderLabelDTOPlacesNumber :: !(Int) -- ^ /Required/ "placesNumber" - Количество коробок в заказе.
  , orderLabelDTOUrl :: !(Text) -- ^ /Required/ "url" - URL файла с ярлыками‑наклейками на все коробки в заказе.  Соответствует URL, по которому выполняется запрос [GET campaigns/{campaignId}/orders/{orderId}/delivery/labels](../../reference/orders/generateOrderLabels.md). 
  , orderLabelDTOParcelBoxLabels :: !([ParcelBoxLabelDTO]) -- ^ /Required/ "parcelBoxLabels" - Информация на ярлыке.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderLabelDTO
instance A.FromJSON OrderLabelDTO where
  parseJSON = A.withObject "OrderLabelDTO" $ \o ->
    OrderLabelDTO
      <$> (o .:  "orderId")
      <*> (o .:  "placesNumber")
      <*> (o .:  "url")
      <*> (o .:  "parcelBoxLabels")

-- | ToJSON OrderLabelDTO
instance A.ToJSON OrderLabelDTO where
  toJSON OrderLabelDTO {..} =
   _omitNulls
      [ "orderId" .= orderLabelDTOOrderId
      , "placesNumber" .= orderLabelDTOPlacesNumber
      , "url" .= orderLabelDTOUrl
      , "parcelBoxLabels" .= orderLabelDTOParcelBoxLabels
      ]


-- | Construct a value of type 'OrderLabelDTO' (by applying it's required fields, if any)
mkOrderLabelDTO
  :: Integer -- ^ 'orderLabelDTOOrderId': Идентификатор заказа.
  -> Int -- ^ 'orderLabelDTOPlacesNumber': Количество коробок в заказе.
  -> Text -- ^ 'orderLabelDTOUrl': URL файла с ярлыками‑наклейками на все коробки в заказе.  Соответствует URL, по которому выполняется запрос [GET campaigns/{campaignId}/orders/{orderId}/delivery/labels](../../reference/orders/generateOrderLabels.md). 
  -> [ParcelBoxLabelDTO] -- ^ 'orderLabelDTOParcelBoxLabels': Информация на ярлыке.
  -> OrderLabelDTO
mkOrderLabelDTO orderLabelDTOOrderId orderLabelDTOPlacesNumber orderLabelDTOUrl orderLabelDTOParcelBoxLabels =
  OrderLabelDTO
  { orderLabelDTOOrderId
  , orderLabelDTOPlacesNumber
  , orderLabelDTOUrl
  , orderLabelDTOParcelBoxLabels
  }

-- ** OrderParcelBoxDTO
-- | OrderParcelBoxDTO
-- Информация о грузоместе.
data OrderParcelBoxDTO = OrderParcelBoxDTO
  { orderParcelBoxDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор грузоместа.
  , orderParcelBoxDTOFulfilmentId :: !(Maybe Text) -- ^ "fulfilmentId" - Идентификатор грузового места в информационной системе магазина.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderParcelBoxDTO
instance A.FromJSON OrderParcelBoxDTO where
  parseJSON = A.withObject "OrderParcelBoxDTO" $ \o ->
    OrderParcelBoxDTO
      <$> (o .:? "id")
      <*> (o .:? "fulfilmentId")

-- | ToJSON OrderParcelBoxDTO
instance A.ToJSON OrderParcelBoxDTO where
  toJSON OrderParcelBoxDTO {..} =
   _omitNulls
      [ "id" .= orderParcelBoxDTOId
      , "fulfilmentId" .= orderParcelBoxDTOFulfilmentId
      ]


-- | Construct a value of type 'OrderParcelBoxDTO' (by applying it's required fields, if any)
mkOrderParcelBoxDTO
  :: OrderParcelBoxDTO
mkOrderParcelBoxDTO =
  OrderParcelBoxDTO
  { orderParcelBoxDTOId = Nothing
  , orderParcelBoxDTOFulfilmentId = Nothing
  }

-- ** OrderShipmentDTO
-- | OrderShipmentDTO
-- Список посылок.  В параметре может указываться несколько посылок. 
data OrderShipmentDTO = OrderShipmentDTO
  { orderShipmentDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор посылки, присвоенный Маркетом.
  , orderShipmentDTOShipmentDate :: !(Maybe Text) -- ^ "shipmentDate" - Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  , orderShipmentDTOShipmentTime :: !(Maybe Text) -- ^ "shipmentTime" - **Только для модели Экспресс**  Время, к которому магазин должен упаковать заказ и перевести его в статус &#x60;READY_TO_SHIP&#x60;. После смены статуса за заказом приедет курьер.  Поле может появиться не сразу. Запрашивайте информацию о заказе в течении 5–10 минут, пока оно не вернется.  Формат времени: 24-часовой, &#x60;ЧЧ:ММ&#x60;.  Если заказ сделан организацией, параметр не возвращается до согласования даты доставки. 
  , orderShipmentDTOTracks :: !(Maybe [OrderTrackDTO]) -- ^ "tracks" - **Только для модели DBS**  Информация для отслеживания перемещений посылки. 
  , orderShipmentDTOBoxes :: !(Maybe [OrderParcelBoxDTO]) -- ^ "boxes" - Список грузовых мест.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderShipmentDTO
instance A.FromJSON OrderShipmentDTO where
  parseJSON = A.withObject "OrderShipmentDTO" $ \o ->
    OrderShipmentDTO
      <$> (o .:? "id")
      <*> (o .:? "shipmentDate")
      <*> (o .:? "shipmentTime")
      <*> (o .:? "tracks")
      <*> (o .:? "boxes")

-- | ToJSON OrderShipmentDTO
instance A.ToJSON OrderShipmentDTO where
  toJSON OrderShipmentDTO {..} =
   _omitNulls
      [ "id" .= orderShipmentDTOId
      , "shipmentDate" .= orderShipmentDTOShipmentDate
      , "shipmentTime" .= orderShipmentDTOShipmentTime
      , "tracks" .= orderShipmentDTOTracks
      , "boxes" .= orderShipmentDTOBoxes
      ]


-- | Construct a value of type 'OrderShipmentDTO' (by applying it's required fields, if any)
mkOrderShipmentDTO
  :: OrderShipmentDTO
mkOrderShipmentDTO =
  OrderShipmentDTO
  { orderShipmentDTOId = Nothing
  , orderShipmentDTOShipmentDate = Nothing
  , orderShipmentDTOShipmentTime = Nothing
  , orderShipmentDTOTracks = Nothing
  , orderShipmentDTOBoxes = Nothing
  }

-- ** OrderStateDTO
-- | OrderStateDTO
-- Информация по заказу.
data OrderStateDTO = OrderStateDTO
  { orderStateDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор заказа.
  , orderStateDTOStatus :: !(OrderStatusType) -- ^ /Required/ "status"
  , orderStateDTOSubstatus :: !(Maybe OrderSubstatusType) -- ^ "substatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderStateDTO
instance A.FromJSON OrderStateDTO where
  parseJSON = A.withObject "OrderStateDTO" $ \o ->
    OrderStateDTO
      <$> (o .:  "id")
      <*> (o .:  "status")
      <*> (o .:? "substatus")

-- | ToJSON OrderStateDTO
instance A.ToJSON OrderStateDTO where
  toJSON OrderStateDTO {..} =
   _omitNulls
      [ "id" .= orderStateDTOId
      , "status" .= orderStateDTOStatus
      , "substatus" .= orderStateDTOSubstatus
      ]


-- | Construct a value of type 'OrderStateDTO' (by applying it's required fields, if any)
mkOrderStateDTO
  :: Integer -- ^ 'orderStateDTOId': Идентификатор заказа.
  -> OrderStatusType -- ^ 'orderStateDTOStatus' 
  -> OrderStateDTO
mkOrderStateDTO orderStateDTOId orderStateDTOStatus =
  OrderStateDTO
  { orderStateDTOId
  , orderStateDTOStatus
  , orderStateDTOSubstatus = Nothing
  }

-- ** OrderStatusChangeDTO
-- | OrderStatusChangeDTO
-- Заказ.
data OrderStatusChangeDTO = OrderStatusChangeDTO
  { orderStatusChangeDTOStatus :: !(OrderStatusType) -- ^ /Required/ "status"
  , orderStatusChangeDTOSubstatus :: !(Maybe OrderSubstatusType) -- ^ "substatus"
  , orderStatusChangeDTODelivery :: !(Maybe OrderStatusChangeDeliveryDTO) -- ^ "delivery"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderStatusChangeDTO
instance A.FromJSON OrderStatusChangeDTO where
  parseJSON = A.withObject "OrderStatusChangeDTO" $ \o ->
    OrderStatusChangeDTO
      <$> (o .:  "status")
      <*> (o .:? "substatus")
      <*> (o .:? "delivery")

-- | ToJSON OrderStatusChangeDTO
instance A.ToJSON OrderStatusChangeDTO where
  toJSON OrderStatusChangeDTO {..} =
   _omitNulls
      [ "status" .= orderStatusChangeDTOStatus
      , "substatus" .= orderStatusChangeDTOSubstatus
      , "delivery" .= orderStatusChangeDTODelivery
      ]


-- | Construct a value of type 'OrderStatusChangeDTO' (by applying it's required fields, if any)
mkOrderStatusChangeDTO
  :: OrderStatusType -- ^ 'orderStatusChangeDTOStatus' 
  -> OrderStatusChangeDTO
mkOrderStatusChangeDTO orderStatusChangeDTOStatus =
  OrderStatusChangeDTO
  { orderStatusChangeDTOStatus
  , orderStatusChangeDTOSubstatus = Nothing
  , orderStatusChangeDTODelivery = Nothing
  }

-- ** OrderStatusChangeDeliveryDTO
-- | OrderStatusChangeDeliveryDTO
-- Информация о доставке.
data OrderStatusChangeDeliveryDTO = OrderStatusChangeDeliveryDTO
  { orderStatusChangeDeliveryDTODates :: !(Maybe OrderStatusChangeDeliveryDatesDTO) -- ^ "dates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderStatusChangeDeliveryDTO
instance A.FromJSON OrderStatusChangeDeliveryDTO where
  parseJSON = A.withObject "OrderStatusChangeDeliveryDTO" $ \o ->
    OrderStatusChangeDeliveryDTO
      <$> (o .:? "dates")

-- | ToJSON OrderStatusChangeDeliveryDTO
instance A.ToJSON OrderStatusChangeDeliveryDTO where
  toJSON OrderStatusChangeDeliveryDTO {..} =
   _omitNulls
      [ "dates" .= orderStatusChangeDeliveryDTODates
      ]


-- | Construct a value of type 'OrderStatusChangeDeliveryDTO' (by applying it's required fields, if any)
mkOrderStatusChangeDeliveryDTO
  :: OrderStatusChangeDeliveryDTO
mkOrderStatusChangeDeliveryDTO =
  OrderStatusChangeDeliveryDTO
  { orderStatusChangeDeliveryDTODates = Nothing
  }

-- ** OrderStatusChangeDeliveryDatesDTO
-- | OrderStatusChangeDeliveryDatesDTO
-- Диапазон дат доставки.
data OrderStatusChangeDeliveryDatesDTO = OrderStatusChangeDeliveryDatesDTO
  { orderStatusChangeDeliveryDatesDTORealDeliveryDate :: !(Maybe Date) -- ^ "realDeliveryDate" - **Только для модели DBS**  Фактическая дата доставки. &lt;br&gt;&lt;br&gt; Когда передавать параметр &#x60;realDeliveryDate&#x60;:  * Не передавайте параметр, если:   * переводите заказ в любой статус, кроме &#x60;PICKUP&#x60; или &#x60;DELIVERED&#x60;;   * меняете статус заказа на &#x60;PICKUP&#x60; или &#x60;DELIVERED&#x60; в день доставки — будет указана дата выполнения запроса. * Передавайте дату доставки, если переводите заказ в статус &#x60;PICKUP&#x60; или &#x60;DELIVERED&#x60; не в день доставки. Нельзя указывать дату доставки в будущем.    {% note warning \&quot;Индекс качества\&quot; %}    Передача статуса после установленного срока снижает индекс качества. О сроках читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/tech#dbs).    {% endnote %}      
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderStatusChangeDeliveryDatesDTO
instance A.FromJSON OrderStatusChangeDeliveryDatesDTO where
  parseJSON = A.withObject "OrderStatusChangeDeliveryDatesDTO" $ \o ->
    OrderStatusChangeDeliveryDatesDTO
      <$> (o .:? "realDeliveryDate")

-- | ToJSON OrderStatusChangeDeliveryDatesDTO
instance A.ToJSON OrderStatusChangeDeliveryDatesDTO where
  toJSON OrderStatusChangeDeliveryDatesDTO {..} =
   _omitNulls
      [ "realDeliveryDate" .= orderStatusChangeDeliveryDatesDTORealDeliveryDate
      ]


-- | Construct a value of type 'OrderStatusChangeDeliveryDatesDTO' (by applying it's required fields, if any)
mkOrderStatusChangeDeliveryDatesDTO
  :: OrderStatusChangeDeliveryDatesDTO
mkOrderStatusChangeDeliveryDatesDTO =
  OrderStatusChangeDeliveryDatesDTO
  { orderStatusChangeDeliveryDatesDTORealDeliveryDate = Nothing
  }

-- ** OrderSubsidyDTO
-- | OrderSubsidyDTO
-- Общее вознаграждение партнеру за DBS-доставку и все скидки на товар:  * по промокодам, купонам и акциям; * по баллам Плюса; * по доставке (DBS).  Передается в валюте заказа. 
data OrderSubsidyDTO = OrderSubsidyDTO
  { orderSubsidyDTOType :: !(Maybe OrderSubsidyType) -- ^ "type"
  , orderSubsidyDTOAmount :: !(Maybe Double) -- ^ "amount" - Сумма субсидии.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderSubsidyDTO
instance A.FromJSON OrderSubsidyDTO where
  parseJSON = A.withObject "OrderSubsidyDTO" $ \o ->
    OrderSubsidyDTO
      <$> (o .:? "type")
      <*> (o .:? "amount")

-- | ToJSON OrderSubsidyDTO
instance A.ToJSON OrderSubsidyDTO where
  toJSON OrderSubsidyDTO {..} =
   _omitNulls
      [ "type" .= orderSubsidyDTOType
      , "amount" .= orderSubsidyDTOAmount
      ]


-- | Construct a value of type 'OrderSubsidyDTO' (by applying it's required fields, if any)
mkOrderSubsidyDTO
  :: OrderSubsidyDTO
mkOrderSubsidyDTO =
  OrderSubsidyDTO
  { orderSubsidyDTOType = Nothing
  , orderSubsidyDTOAmount = Nothing
  }

-- ** OrderTrackDTO
-- | OrderTrackDTO
-- Информация о трек-номере посылки (DBS).
data OrderTrackDTO = OrderTrackDTO
  { orderTrackDTOTrackCode :: !(Maybe Text) -- ^ "trackCode" - Трек‑номер посылки.
  , orderTrackDTODeliveryServiceId :: !(Maybe Integer) -- ^ "deliveryServiceId" - Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderTrackDTO
instance A.FromJSON OrderTrackDTO where
  parseJSON = A.withObject "OrderTrackDTO" $ \o ->
    OrderTrackDTO
      <$> (o .:? "trackCode")
      <*> (o .:? "deliveryServiceId")

-- | ToJSON OrderTrackDTO
instance A.ToJSON OrderTrackDTO where
  toJSON OrderTrackDTO {..} =
   _omitNulls
      [ "trackCode" .= orderTrackDTOTrackCode
      , "deliveryServiceId" .= orderTrackDTODeliveryServiceId
      ]


-- | Construct a value of type 'OrderTrackDTO' (by applying it's required fields, if any)
mkOrderTrackDTO
  :: OrderTrackDTO
mkOrderTrackDTO =
  OrderTrackDTO
  { orderTrackDTOTrackCode = Nothing
  , orderTrackDTODeliveryServiceId = Nothing
  }

-- ** OrdersShipmentInfoDTO
-- | OrdersShipmentInfoDTO
-- Годные/негодные ярлыки по заказам в отгрузке.
data OrdersShipmentInfoDTO = OrdersShipmentInfoDTO
  { ordersShipmentInfoDTOOrderIdsWithLabels :: !([Integer]) -- ^ /Required/ "orderIdsWithLabels" - Идентификаторы заказов в отгрузке, для которых можно распечатать ярлыки.
  , ordersShipmentInfoDTOOrderIdsWithoutLabels :: !([Integer]) -- ^ /Required/ "orderIdsWithoutLabels" - Идентификаторы заказов в отгрузке, для которых нельзя распечатать ярлыки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersShipmentInfoDTO
instance A.FromJSON OrdersShipmentInfoDTO where
  parseJSON = A.withObject "OrdersShipmentInfoDTO" $ \o ->
    OrdersShipmentInfoDTO
      <$> (o .:  "orderIdsWithLabels")
      <*> (o .:  "orderIdsWithoutLabels")

-- | ToJSON OrdersShipmentInfoDTO
instance A.ToJSON OrdersShipmentInfoDTO where
  toJSON OrdersShipmentInfoDTO {..} =
   _omitNulls
      [ "orderIdsWithLabels" .= ordersShipmentInfoDTOOrderIdsWithLabels
      , "orderIdsWithoutLabels" .= ordersShipmentInfoDTOOrderIdsWithoutLabels
      ]


-- | Construct a value of type 'OrdersShipmentInfoDTO' (by applying it's required fields, if any)
mkOrdersShipmentInfoDTO
  :: [Integer] -- ^ 'ordersShipmentInfoDTOOrderIdsWithLabels': Идентификаторы заказов в отгрузке, для которых можно распечатать ярлыки.
  -> [Integer] -- ^ 'ordersShipmentInfoDTOOrderIdsWithoutLabels': Идентификаторы заказов в отгрузке, для которых нельзя распечатать ярлыки.
  -> OrdersShipmentInfoDTO
mkOrdersShipmentInfoDTO ordersShipmentInfoDTOOrderIdsWithLabels ordersShipmentInfoDTOOrderIdsWithoutLabels =
  OrdersShipmentInfoDTO
  { ordersShipmentInfoDTOOrderIdsWithLabels
  , ordersShipmentInfoDTOOrderIdsWithoutLabels
  }

-- ** OrdersStatsCommissionDTO
-- | OrdersStatsCommissionDTO
-- Информация о стоимости услуг.
data OrdersStatsCommissionDTO = OrdersStatsCommissionDTO
  { ordersStatsCommissionDTOType :: !(Maybe OrdersStatsCommissionType) -- ^ "type"
  , ordersStatsCommissionDTOActual :: !(Maybe Double) -- ^ "actual" - Сумма в рублях, которая была выставлена в момент создания заказа и которую нужно оплатить. Точность — два знака после запятой. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsCommissionDTO
instance A.FromJSON OrdersStatsCommissionDTO where
  parseJSON = A.withObject "OrdersStatsCommissionDTO" $ \o ->
    OrdersStatsCommissionDTO
      <$> (o .:? "type")
      <*> (o .:? "actual")

-- | ToJSON OrdersStatsCommissionDTO
instance A.ToJSON OrdersStatsCommissionDTO where
  toJSON OrdersStatsCommissionDTO {..} =
   _omitNulls
      [ "type" .= ordersStatsCommissionDTOType
      , "actual" .= ordersStatsCommissionDTOActual
      ]


-- | Construct a value of type 'OrdersStatsCommissionDTO' (by applying it's required fields, if any)
mkOrdersStatsCommissionDTO
  :: OrdersStatsCommissionDTO
mkOrdersStatsCommissionDTO =
  OrdersStatsCommissionDTO
  { ordersStatsCommissionDTOType = Nothing
  , ordersStatsCommissionDTOActual = Nothing
  }

-- ** OrdersStatsDTO
-- | OrdersStatsDTO
-- Информация по заказам.
data OrdersStatsDTO = OrdersStatsDTO
  { ordersStatsDTOOrders :: !([OrdersStatsOrderDTO]) -- ^ /Required/ "orders" - Список заказов.
  , ordersStatsDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsDTO
instance A.FromJSON OrdersStatsDTO where
  parseJSON = A.withObject "OrdersStatsDTO" $ \o ->
    OrdersStatsDTO
      <$> (o .:  "orders")
      <*> (o .:? "paging")

-- | ToJSON OrdersStatsDTO
instance A.ToJSON OrdersStatsDTO where
  toJSON OrdersStatsDTO {..} =
   _omitNulls
      [ "orders" .= ordersStatsDTOOrders
      , "paging" .= ordersStatsDTOPaging
      ]


-- | Construct a value of type 'OrdersStatsDTO' (by applying it's required fields, if any)
mkOrdersStatsDTO
  :: [OrdersStatsOrderDTO] -- ^ 'ordersStatsDTOOrders': Список заказов.
  -> OrdersStatsDTO
mkOrdersStatsDTO ordersStatsDTOOrders =
  OrdersStatsDTO
  { ordersStatsDTOOrders
  , ordersStatsDTOPaging = Nothing
  }

-- ** OrdersStatsDeliveryRegionDTO
-- | OrdersStatsDeliveryRegionDTO
-- Информация о регионе доставки.
data OrdersStatsDeliveryRegionDTO = OrdersStatsDeliveryRegionDTO
  { ordersStatsDeliveryRegionDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор региона доставки.
  , ordersStatsDeliveryRegionDTOName :: !(Maybe Text) -- ^ "name" - Название региона доставки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsDeliveryRegionDTO
instance A.FromJSON OrdersStatsDeliveryRegionDTO where
  parseJSON = A.withObject "OrdersStatsDeliveryRegionDTO" $ \o ->
    OrdersStatsDeliveryRegionDTO
      <$> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON OrdersStatsDeliveryRegionDTO
instance A.ToJSON OrdersStatsDeliveryRegionDTO where
  toJSON OrdersStatsDeliveryRegionDTO {..} =
   _omitNulls
      [ "id" .= ordersStatsDeliveryRegionDTOId
      , "name" .= ordersStatsDeliveryRegionDTOName
      ]


-- | Construct a value of type 'OrdersStatsDeliveryRegionDTO' (by applying it's required fields, if any)
mkOrdersStatsDeliveryRegionDTO
  :: OrdersStatsDeliveryRegionDTO
mkOrdersStatsDeliveryRegionDTO =
  OrdersStatsDeliveryRegionDTO
  { ordersStatsDeliveryRegionDTOId = Nothing
  , ordersStatsDeliveryRegionDTOName = Nothing
  }

-- ** OrdersStatsDetailsDTO
-- | OrdersStatsDetailsDTO
-- Информация об удалении товара из заказа.
data OrdersStatsDetailsDTO = OrdersStatsDetailsDTO
  { ordersStatsDetailsDTOItemStatus :: !(Maybe OrdersStatsItemStatusType) -- ^ "itemStatus"
  , ordersStatsDetailsDTOItemCount :: !(Maybe Integer) -- ^ "itemCount" - Количество товара со статусом, указанном в параметре &#x60;itemStatus&#x60;.
  , ordersStatsDetailsDTOUpdateDate :: !(Maybe Date) -- ^ "updateDate" - Дата, когда товар получил статус, указанный в параметре &#x60;itemStatus&#x60;.  Формат даты: &#x60;ГГГГ-ММ-ДД&#x60;. 
  , ordersStatsDetailsDTOStockType :: !(Maybe OrdersStatsStockType) -- ^ "stockType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsDetailsDTO
instance A.FromJSON OrdersStatsDetailsDTO where
  parseJSON = A.withObject "OrdersStatsDetailsDTO" $ \o ->
    OrdersStatsDetailsDTO
      <$> (o .:? "itemStatus")
      <*> (o .:? "itemCount")
      <*> (o .:? "updateDate")
      <*> (o .:? "stockType")

-- | ToJSON OrdersStatsDetailsDTO
instance A.ToJSON OrdersStatsDetailsDTO where
  toJSON OrdersStatsDetailsDTO {..} =
   _omitNulls
      [ "itemStatus" .= ordersStatsDetailsDTOItemStatus
      , "itemCount" .= ordersStatsDetailsDTOItemCount
      , "updateDate" .= ordersStatsDetailsDTOUpdateDate
      , "stockType" .= ordersStatsDetailsDTOStockType
      ]


-- | Construct a value of type 'OrdersStatsDetailsDTO' (by applying it's required fields, if any)
mkOrdersStatsDetailsDTO
  :: OrdersStatsDetailsDTO
mkOrdersStatsDetailsDTO =
  OrdersStatsDetailsDTO
  { ordersStatsDetailsDTOItemStatus = Nothing
  , ordersStatsDetailsDTOItemCount = Nothing
  , ordersStatsDetailsDTOUpdateDate = Nothing
  , ordersStatsDetailsDTOStockType = Nothing
  }

-- ** OrdersStatsItemDTO
-- | OrdersStatsItemDTO
-- Список товаров в заказе после возможных изменений.  В ходе обработки заказа Маркет может удалить из него единицы товаров — при проблемах на складе или по инициативе пользователя.  * Если из заказа удалены все единицы товара, его не будет в списке `items` — только в списке `initialItems`.  * Если в заказе осталась хотя бы одна единица товара, он будет и в списке `items` (с уменьшенным количеством единиц `count`), и в списке `initialItems` (с первоначальным количеством единиц `initialCount`). 
data OrdersStatsItemDTO = OrdersStatsItemDTO
  { ordersStatsItemDTOOfferName :: !(Maybe Text) -- ^ "offerName" - Название товара.
  , ordersStatsItemDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  , ordersStatsItemDTOShopSku :: !(Maybe Text) -- ^ "shopSku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , ordersStatsItemDTOCount :: !(Maybe Int) -- ^ "count" - Количество единиц товара с учетом удаленных единиц.  Если из заказа удалены все единицы товара, он попадет только в список &#x60;initialItems&#x60;. 
  , ordersStatsItemDTOPrices :: !(Maybe [OrdersStatsPriceDTO]) -- ^ "prices" - Цена или скидки на товар.
  , ordersStatsItemDTOWarehouse :: !(Maybe OrdersStatsWarehouseDTO) -- ^ "warehouse"
  , ordersStatsItemDTODetails :: !(Maybe [OrdersStatsDetailsDTO]) -- ^ "details" - Информация об удалении товара из заказа.
  , ordersStatsItemDTOCisList :: !(Maybe [Text]) -- ^ "cisList" - Список кодов идентификации товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).
  , ordersStatsItemDTOInitialCount :: !(Maybe Int) -- ^ "initialCount" - Первоначальное количество единиц товара.
  , ordersStatsItemDTOBidFee :: !(Maybe Int) -- ^ "bidFee" - Списанная ставка ближайшего конкурента.  Указывается в процентах от стоимости товара и умножается на 100. Например, ставка 5% обозначается как 500. 
  , ordersStatsItemDTOCofinanceThreshold :: !(Maybe Double) -- ^ "cofinanceThreshold" - Порог для скидок с Маркетом на момент оформления заказа. [Что это такое?](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  Указан в рублях. Точность — два знака после запятой. 
  , ordersStatsItemDTOCofinanceValue :: !(Maybe Double) -- ^ "cofinanceValue" - Скидка с Маркетом. [Что это такое?](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  Указана в рублях. Точность — два знака после запятой. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsItemDTO
instance A.FromJSON OrdersStatsItemDTO where
  parseJSON = A.withObject "OrdersStatsItemDTO" $ \o ->
    OrdersStatsItemDTO
      <$> (o .:? "offerName")
      <*> (o .:? "marketSku")
      <*> (o .:? "shopSku")
      <*> (o .:? "count")
      <*> (o .:? "prices")
      <*> (o .:? "warehouse")
      <*> (o .:? "details")
      <*> (o .:? "cisList")
      <*> (o .:? "initialCount")
      <*> (o .:? "bidFee")
      <*> (o .:? "cofinanceThreshold")
      <*> (o .:? "cofinanceValue")

-- | ToJSON OrdersStatsItemDTO
instance A.ToJSON OrdersStatsItemDTO where
  toJSON OrdersStatsItemDTO {..} =
   _omitNulls
      [ "offerName" .= ordersStatsItemDTOOfferName
      , "marketSku" .= ordersStatsItemDTOMarketSku
      , "shopSku" .= ordersStatsItemDTOShopSku
      , "count" .= ordersStatsItemDTOCount
      , "prices" .= ordersStatsItemDTOPrices
      , "warehouse" .= ordersStatsItemDTOWarehouse
      , "details" .= ordersStatsItemDTODetails
      , "cisList" .= ordersStatsItemDTOCisList
      , "initialCount" .= ordersStatsItemDTOInitialCount
      , "bidFee" .= ordersStatsItemDTOBidFee
      , "cofinanceThreshold" .= ordersStatsItemDTOCofinanceThreshold
      , "cofinanceValue" .= ordersStatsItemDTOCofinanceValue
      ]


-- | Construct a value of type 'OrdersStatsItemDTO' (by applying it's required fields, if any)
mkOrdersStatsItemDTO
  :: OrdersStatsItemDTO
mkOrdersStatsItemDTO =
  OrdersStatsItemDTO
  { ordersStatsItemDTOOfferName = Nothing
  , ordersStatsItemDTOMarketSku = Nothing
  , ordersStatsItemDTOShopSku = Nothing
  , ordersStatsItemDTOCount = Nothing
  , ordersStatsItemDTOPrices = Nothing
  , ordersStatsItemDTOWarehouse = Nothing
  , ordersStatsItemDTODetails = Nothing
  , ordersStatsItemDTOCisList = Nothing
  , ordersStatsItemDTOInitialCount = Nothing
  , ordersStatsItemDTOBidFee = Nothing
  , ordersStatsItemDTOCofinanceThreshold = Nothing
  , ordersStatsItemDTOCofinanceValue = Nothing
  }

-- ** OrdersStatsOrderDTO
-- | OrdersStatsOrderDTO
-- Информация о заказе.
data OrdersStatsOrderDTO = OrdersStatsOrderDTO
  { ordersStatsOrderDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор заказа.
  , ordersStatsOrderDTOCreationDate :: !(Maybe Date) -- ^ "creationDate" - Дата создания заказа.  Формат даты: &#x60;ГГГГ-ММ-ДД&#x60;. 
  , ordersStatsOrderDTOStatusUpdateDate :: !(Maybe DateTime) -- ^ "statusUpdateDate" - Дата и время, когда статус заказа был изменен в последний раз.  Формат даты и времени: ISO 8601. Например, &#x60;2017-11-21T00:00:00&#x60;. Часовой пояс — UTC+03:00 (Москва). 
  , ordersStatsOrderDTOStatus :: !(Maybe OrderStatsStatusType) -- ^ "status"
  , ordersStatsOrderDTOPartnerOrderId :: !(Maybe Text) -- ^ "partnerOrderId" - Идентификатор заказа в информационной системе магазина.
  , ordersStatsOrderDTOPaymentType :: !(Maybe OrdersStatsOrderPaymentType) -- ^ "paymentType"
  , ordersStatsOrderDTOFake :: !(Maybe Bool) -- ^ "fake" - Тип заказа:  * &#x60;false&#x60; — настоящий заказ покупателя.  * &#x60;true&#x60; — [тестовый](../../pushapi/concepts/sandbox.md) заказ Маркета. 
  , ordersStatsOrderDTODeliveryRegion :: !(Maybe OrdersStatsDeliveryRegionDTO) -- ^ "deliveryRegion"
  , ordersStatsOrderDTOItems :: !([OrdersStatsItemDTO]) -- ^ /Required/ "items" - Список товаров в заказе после возможных изменений.
  , ordersStatsOrderDTOInitialItems :: !(Maybe [OrdersStatsItemDTO]) -- ^ "initialItems" - Список товаров в заказе до изменений.
  , ordersStatsOrderDTOPayments :: !([OrdersStatsPaymentDTO]) -- ^ /Required/ "payments" - Информация о денежных переводах по заказу.
  , ordersStatsOrderDTOCommissions :: !([OrdersStatsCommissionDTO]) -- ^ /Required/ "commissions" - Информация о комиссиях за заказ.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsOrderDTO
instance A.FromJSON OrdersStatsOrderDTO where
  parseJSON = A.withObject "OrdersStatsOrderDTO" $ \o ->
    OrdersStatsOrderDTO
      <$> (o .:? "id")
      <*> (o .:? "creationDate")
      <*> (o .:? "statusUpdateDate")
      <*> (o .:? "status")
      <*> (o .:? "partnerOrderId")
      <*> (o .:? "paymentType")
      <*> (o .:? "fake")
      <*> (o .:? "deliveryRegion")
      <*> (o .:  "items")
      <*> (o .:? "initialItems")
      <*> (o .:  "payments")
      <*> (o .:  "commissions")

-- | ToJSON OrdersStatsOrderDTO
instance A.ToJSON OrdersStatsOrderDTO where
  toJSON OrdersStatsOrderDTO {..} =
   _omitNulls
      [ "id" .= ordersStatsOrderDTOId
      , "creationDate" .= ordersStatsOrderDTOCreationDate
      , "statusUpdateDate" .= ordersStatsOrderDTOStatusUpdateDate
      , "status" .= ordersStatsOrderDTOStatus
      , "partnerOrderId" .= ordersStatsOrderDTOPartnerOrderId
      , "paymentType" .= ordersStatsOrderDTOPaymentType
      , "fake" .= ordersStatsOrderDTOFake
      , "deliveryRegion" .= ordersStatsOrderDTODeliveryRegion
      , "items" .= ordersStatsOrderDTOItems
      , "initialItems" .= ordersStatsOrderDTOInitialItems
      , "payments" .= ordersStatsOrderDTOPayments
      , "commissions" .= ordersStatsOrderDTOCommissions
      ]


-- | Construct a value of type 'OrdersStatsOrderDTO' (by applying it's required fields, if any)
mkOrdersStatsOrderDTO
  :: [OrdersStatsItemDTO] -- ^ 'ordersStatsOrderDTOItems': Список товаров в заказе после возможных изменений.
  -> [OrdersStatsPaymentDTO] -- ^ 'ordersStatsOrderDTOPayments': Информация о денежных переводах по заказу.
  -> [OrdersStatsCommissionDTO] -- ^ 'ordersStatsOrderDTOCommissions': Информация о комиссиях за заказ.
  -> OrdersStatsOrderDTO
mkOrdersStatsOrderDTO ordersStatsOrderDTOItems ordersStatsOrderDTOPayments ordersStatsOrderDTOCommissions =
  OrdersStatsOrderDTO
  { ordersStatsOrderDTOId = Nothing
  , ordersStatsOrderDTOCreationDate = Nothing
  , ordersStatsOrderDTOStatusUpdateDate = Nothing
  , ordersStatsOrderDTOStatus = Nothing
  , ordersStatsOrderDTOPartnerOrderId = Nothing
  , ordersStatsOrderDTOPaymentType = Nothing
  , ordersStatsOrderDTOFake = Nothing
  , ordersStatsOrderDTODeliveryRegion = Nothing
  , ordersStatsOrderDTOItems
  , ordersStatsOrderDTOInitialItems = Nothing
  , ordersStatsOrderDTOPayments
  , ordersStatsOrderDTOCommissions
  }

-- ** OrdersStatsPaymentDTO
-- | OrdersStatsPaymentDTO
-- Информация о денежных переводах по заказу.
data OrdersStatsPaymentDTO = OrdersStatsPaymentDTO
  { ordersStatsPaymentDTOId :: !(Maybe Text) -- ^ "id" - Идентификатор денежного перевода.
  , ordersStatsPaymentDTODate :: !(Maybe Date) -- ^ "date" - Дата денежного перевода.  Формат даты: &#x60;ГГГГ-ММ-ДД&#x60;. 
  , ordersStatsPaymentDTOType :: !(Maybe OrdersStatsPaymentType) -- ^ "type"
  , ordersStatsPaymentDTOSource :: !(Maybe OrdersStatsPaymentSourceType) -- ^ "source"
  , ordersStatsPaymentDTOTotal :: !(Maybe Double) -- ^ "total" - Сумма денежного перевода. Значение указывается в рублях независимо от способа денежного перевода. Точность — два знака после запятой. 
  , ordersStatsPaymentDTOPaymentOrder :: !(Maybe OrdersStatsPaymentOrderDTO) -- ^ "paymentOrder"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsPaymentDTO
instance A.FromJSON OrdersStatsPaymentDTO where
  parseJSON = A.withObject "OrdersStatsPaymentDTO" $ \o ->
    OrdersStatsPaymentDTO
      <$> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "type")
      <*> (o .:? "source")
      <*> (o .:? "total")
      <*> (o .:? "paymentOrder")

-- | ToJSON OrdersStatsPaymentDTO
instance A.ToJSON OrdersStatsPaymentDTO where
  toJSON OrdersStatsPaymentDTO {..} =
   _omitNulls
      [ "id" .= ordersStatsPaymentDTOId
      , "date" .= ordersStatsPaymentDTODate
      , "type" .= ordersStatsPaymentDTOType
      , "source" .= ordersStatsPaymentDTOSource
      , "total" .= ordersStatsPaymentDTOTotal
      , "paymentOrder" .= ordersStatsPaymentDTOPaymentOrder
      ]


-- | Construct a value of type 'OrdersStatsPaymentDTO' (by applying it's required fields, if any)
mkOrdersStatsPaymentDTO
  :: OrdersStatsPaymentDTO
mkOrdersStatsPaymentDTO =
  OrdersStatsPaymentDTO
  { ordersStatsPaymentDTOId = Nothing
  , ordersStatsPaymentDTODate = Nothing
  , ordersStatsPaymentDTOType = Nothing
  , ordersStatsPaymentDTOSource = Nothing
  , ordersStatsPaymentDTOTotal = Nothing
  , ordersStatsPaymentDTOPaymentOrder = Nothing
  }

-- ** OrdersStatsPaymentOrderDTO
-- | OrdersStatsPaymentOrderDTO
-- Информация о платежном получении.
data OrdersStatsPaymentOrderDTO = OrdersStatsPaymentOrderDTO
  { ordersStatsPaymentOrderDTOId :: !(Maybe Text) -- ^ "id" - Номер платежного поручения.
  , ordersStatsPaymentOrderDTODate :: !(Maybe Date) -- ^ "date" - Дата платежного поручения.  Формат даты: &#x60;ГГГГ‑ММ‑ДД&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsPaymentOrderDTO
instance A.FromJSON OrdersStatsPaymentOrderDTO where
  parseJSON = A.withObject "OrdersStatsPaymentOrderDTO" $ \o ->
    OrdersStatsPaymentOrderDTO
      <$> (o .:? "id")
      <*> (o .:? "date")

-- | ToJSON OrdersStatsPaymentOrderDTO
instance A.ToJSON OrdersStatsPaymentOrderDTO where
  toJSON OrdersStatsPaymentOrderDTO {..} =
   _omitNulls
      [ "id" .= ordersStatsPaymentOrderDTOId
      , "date" .= ordersStatsPaymentOrderDTODate
      ]


-- | Construct a value of type 'OrdersStatsPaymentOrderDTO' (by applying it's required fields, if any)
mkOrdersStatsPaymentOrderDTO
  :: OrdersStatsPaymentOrderDTO
mkOrdersStatsPaymentOrderDTO =
  OrdersStatsPaymentOrderDTO
  { ordersStatsPaymentOrderDTOId = Nothing
  , ordersStatsPaymentOrderDTODate = Nothing
  }

-- ** OrdersStatsPriceDTO
-- | OrdersStatsPriceDTO
-- Цена или скидки на товар.
data OrdersStatsPriceDTO = OrdersStatsPriceDTO
  { ordersStatsPriceDTOType :: !(Maybe OrdersStatsPriceType) -- ^ "type"
  , ordersStatsPriceDTOCostPerItem :: !(Maybe Double) -- ^ "costPerItem" - Цена или скидка на единицу товара в заказе. Указана в рублях. Точность — два знака после запятой. 
  , ordersStatsPriceDTOTotal :: !(Maybe Double) -- ^ "total" - Суммарная цена или скидка на все единицы товара в заказе. Указана в рублях. Точность — два знака после запятой. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsPriceDTO
instance A.FromJSON OrdersStatsPriceDTO where
  parseJSON = A.withObject "OrdersStatsPriceDTO" $ \o ->
    OrdersStatsPriceDTO
      <$> (o .:? "type")
      <*> (o .:? "costPerItem")
      <*> (o .:? "total")

-- | ToJSON OrdersStatsPriceDTO
instance A.ToJSON OrdersStatsPriceDTO where
  toJSON OrdersStatsPriceDTO {..} =
   _omitNulls
      [ "type" .= ordersStatsPriceDTOType
      , "costPerItem" .= ordersStatsPriceDTOCostPerItem
      , "total" .= ordersStatsPriceDTOTotal
      ]


-- | Construct a value of type 'OrdersStatsPriceDTO' (by applying it's required fields, if any)
mkOrdersStatsPriceDTO
  :: OrdersStatsPriceDTO
mkOrdersStatsPriceDTO =
  OrdersStatsPriceDTO
  { ordersStatsPriceDTOType = Nothing
  , ordersStatsPriceDTOCostPerItem = Nothing
  , ordersStatsPriceDTOTotal = Nothing
  }

-- ** OrdersStatsWarehouseDTO
-- | OrdersStatsWarehouseDTO
-- Информация о складе, на котором хранится товар.
data OrdersStatsWarehouseDTO = OrdersStatsWarehouseDTO
  { ordersStatsWarehouseDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор склада.
  , ordersStatsWarehouseDTOName :: !(Maybe Text) -- ^ "name" - Название склада.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrdersStatsWarehouseDTO
instance A.FromJSON OrdersStatsWarehouseDTO where
  parseJSON = A.withObject "OrdersStatsWarehouseDTO" $ \o ->
    OrdersStatsWarehouseDTO
      <$> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON OrdersStatsWarehouseDTO
instance A.ToJSON OrdersStatsWarehouseDTO where
  toJSON OrdersStatsWarehouseDTO {..} =
   _omitNulls
      [ "id" .= ordersStatsWarehouseDTOId
      , "name" .= ordersStatsWarehouseDTOName
      ]


-- | Construct a value of type 'OrdersStatsWarehouseDTO' (by applying it's required fields, if any)
mkOrdersStatsWarehouseDTO
  :: OrdersStatsWarehouseDTO
mkOrdersStatsWarehouseDTO =
  OrdersStatsWarehouseDTO
  { ordersStatsWarehouseDTOId = Nothing
  , ordersStatsWarehouseDTOName = Nothing
  }

-- ** OutletAddressDTO
-- | OutletAddressDTO
-- Адрес точки продаж. 
data OutletAddressDTO = OutletAddressDTO
  { outletAddressDTORegionId :: !(Integer) -- ^ /Required/ "regionId" - Идентификатор региона.  Идентификатор можно получить c помощью запроса [GET regions](../../reference/regions/searchRegionsByName.md).  {% note alert %}  При создании и редактировании точек продаж можно указывать только регионы типов &#x60;TOWN&#x60; (город), &#x60;CITY&#x60; (крупный город) и &#x60;REPUBLIC_AREA&#x60; (район субъекта федерации). Тип региона указан в выходных параметрах type запросов [GET regions](../../reference/regions/searchRegionsByName.md) и [GET regions/{regionId}](../../reference/regions/searchRegionsById.md).  {% endnote %} 
  , outletAddressDTOStreet :: !(Maybe Text) -- ^ "street" - Улица.
  , outletAddressDTONumber :: !(Maybe Text) -- ^ "number" - Номер дома.
  , outletAddressDTOBuilding :: !(Maybe Text) -- ^ "building" - Номер строения.
  , outletAddressDTOEstate :: !(Maybe Text) -- ^ "estate" - Номер владения.
  , outletAddressDTOBlock :: !(Maybe Text) -- ^ "block" - Номер корпуса.
  , outletAddressDTOAdditional :: !(Maybe Text) -- ^ "additional" - Дополнительная информация.
  , outletAddressDTOKm :: !(Maybe Int) -- ^ "km" - Порядковый номер километра дороги, на котором располагается точка продаж, если отсутствует улица.
  , outletAddressDTOCity :: !(Maybe Text) -- ^ "city" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его. Город или населенный пункт возвращается в параметре &#x60;regionId&#x60;.  {% endnote %} 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OutletAddressDTO
instance A.FromJSON OutletAddressDTO where
  parseJSON = A.withObject "OutletAddressDTO" $ \o ->
    OutletAddressDTO
      <$> (o .:  "regionId")
      <*> (o .:? "street")
      <*> (o .:? "number")
      <*> (o .:? "building")
      <*> (o .:? "estate")
      <*> (o .:? "block")
      <*> (o .:? "additional")
      <*> (o .:? "km")
      <*> (o .:? "city")

-- | ToJSON OutletAddressDTO
instance A.ToJSON OutletAddressDTO where
  toJSON OutletAddressDTO {..} =
   _omitNulls
      [ "regionId" .= outletAddressDTORegionId
      , "street" .= outletAddressDTOStreet
      , "number" .= outletAddressDTONumber
      , "building" .= outletAddressDTOBuilding
      , "estate" .= outletAddressDTOEstate
      , "block" .= outletAddressDTOBlock
      , "additional" .= outletAddressDTOAdditional
      , "km" .= outletAddressDTOKm
      , "city" .= outletAddressDTOCity
      ]


-- | Construct a value of type 'OutletAddressDTO' (by applying it's required fields, if any)
mkOutletAddressDTO
  :: Integer -- ^ 'outletAddressDTORegionId': Идентификатор региона.  Идентификатор можно получить c помощью запроса [GET regions](../../reference/regions/searchRegionsByName.md).  {% note alert %}  При создании и редактировании точек продаж можно указывать только регионы типов `TOWN` (город), `CITY` (крупный город) и `REPUBLIC_AREA` (район субъекта федерации). Тип региона указан в выходных параметрах type запросов [GET regions](../../reference/regions/searchRegionsByName.md) и [GET regions/{regionId}](../../reference/regions/searchRegionsById.md).  {% endnote %} 
  -> OutletAddressDTO
mkOutletAddressDTO outletAddressDTORegionId =
  OutletAddressDTO
  { outletAddressDTORegionId
  , outletAddressDTOStreet = Nothing
  , outletAddressDTONumber = Nothing
  , outletAddressDTOBuilding = Nothing
  , outletAddressDTOEstate = Nothing
  , outletAddressDTOBlock = Nothing
  , outletAddressDTOAdditional = Nothing
  , outletAddressDTOKm = Nothing
  , outletAddressDTOCity = Nothing
  }

-- ** OutletDTO
-- | OutletDTO
-- Информация о точке продаж.
data OutletDTO = OutletDTO
  { outletDTOName :: !(Text) -- ^ /Required/ "name" - Название точки продаж. 
  , outletDTOType :: !(OutletType) -- ^ /Required/ "type"
  , outletDTOCoords :: !(Maybe Text) -- ^ "coords" - Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, &#x60;20.4522144, 54.7104264&#x60;.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в &#x60;address&#x60;. 
  , outletDTOIsMain :: !(Maybe Bool) -- ^ "isMain" - Признак основной точки продаж.  Возможные значения:  * &#x60;false&#x60; — неосновная точка продаж. * &#x60;true&#x60; — основная точка продаж. 
  , outletDTOShopOutletCode :: !(Maybe Text) -- ^ "shopOutletCode" - Идентификатор точки продаж, присвоенный магазином.
  , outletDTOVisibility :: !(Maybe OutletVisibilityType) -- ^ "visibility"
  , outletDTOAddress :: !(OutletAddressDTO) -- ^ /Required/ "address"
  , outletDTOPhones :: !([Text]) -- ^ /Required/ "phones" - Номера телефонов точки продаж. Передавайте в формате: &#x60;+7 (999) 999-99-99&#x60;. 
  , outletDTOWorkingSchedule :: !(OutletWorkingScheduleDTO) -- ^ /Required/ "workingSchedule"
  , outletDTODeliveryRules :: !(Maybe [OutletDeliveryRuleDTO]) -- ^ "deliveryRules" - Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр &#x60;type&#x3D;DEPOT&#x60; или &#x60;type&#x3D;MIXED&#x60;. 
  , outletDTOStoragePeriod :: !(Maybe Integer) -- ^ "storagePeriod" - Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OutletDTO
instance A.FromJSON OutletDTO where
  parseJSON = A.withObject "OutletDTO" $ \o ->
    OutletDTO
      <$> (o .:  "name")
      <*> (o .:  "type")
      <*> (o .:? "coords")
      <*> (o .:? "isMain")
      <*> (o .:? "shopOutletCode")
      <*> (o .:? "visibility")
      <*> (o .:  "address")
      <*> (o .:  "phones")
      <*> (o .:  "workingSchedule")
      <*> (o .:? "deliveryRules")
      <*> (o .:? "storagePeriod")

-- | ToJSON OutletDTO
instance A.ToJSON OutletDTO where
  toJSON OutletDTO {..} =
   _omitNulls
      [ "name" .= outletDTOName
      , "type" .= outletDTOType
      , "coords" .= outletDTOCoords
      , "isMain" .= outletDTOIsMain
      , "shopOutletCode" .= outletDTOShopOutletCode
      , "visibility" .= outletDTOVisibility
      , "address" .= outletDTOAddress
      , "phones" .= outletDTOPhones
      , "workingSchedule" .= outletDTOWorkingSchedule
      , "deliveryRules" .= outletDTODeliveryRules
      , "storagePeriod" .= outletDTOStoragePeriod
      ]


-- | Construct a value of type 'OutletDTO' (by applying it's required fields, if any)
mkOutletDTO
  :: Text -- ^ 'outletDTOName': Название точки продаж. 
  -> OutletType -- ^ 'outletDTOType' 
  -> OutletAddressDTO -- ^ 'outletDTOAddress' 
  -> [Text] -- ^ 'outletDTOPhones': Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`. 
  -> OutletWorkingScheduleDTO -- ^ 'outletDTOWorkingSchedule' 
  -> OutletDTO
mkOutletDTO outletDTOName outletDTOType outletDTOAddress outletDTOPhones outletDTOWorkingSchedule =
  OutletDTO
  { outletDTOName
  , outletDTOType
  , outletDTOCoords = Nothing
  , outletDTOIsMain = Nothing
  , outletDTOShopOutletCode = Nothing
  , outletDTOVisibility = Nothing
  , outletDTOAddress
  , outletDTOPhones
  , outletDTOWorkingSchedule
  , outletDTODeliveryRules = Nothing
  , outletDTOStoragePeriod = Nothing
  }

-- ** OutletDeliveryRuleDTO
-- | OutletDeliveryRuleDTO
-- Информация об условиях доставки для данной точки продаж.
data OutletDeliveryRuleDTO = OutletDeliveryRuleDTO
  { outletDeliveryRuleDTOMinDeliveryDays :: !(Maybe Int) -- ^ "minDeliveryDays" - Минимальный срок доставки товаров в точку продаж. Указан в рабочих днях.  Минимальное значение: &#x60;0&#x60; — доставка в день заказа.  Максимальное значение: &#x60;60&#x60;.  Допустимые сроки доставки (разница между &#x60;minDeliveryDays&#x60; и &#x60;maxDeliveryDays&#x60;) зависят от региона.  Для доставки по своему региону разница не должна превышать двух дней. Например, если &#x60;minDeliveryDays&#x60; равно 1, то для &#x60;maxDeliveryDays&#x60; допускаются значения от 1 до 3.  Для доставки в другие регионы:  * Если &#x60;minDeliveryDays&#x60; до 18 дней, разница не должна превышать четырех дней. Например, если &#x60;minDeliveryDays&#x60; равно 10, то для &#x60;maxDeliveryDays&#x60; допускаются значения от 10 до 14. * Если &#x60;minDeliveryDays&#x60; больше 18 дней, разница должна быть не больше чем в два раза. Например, если &#x60;minDeliveryDays&#x60; равно 21, то для &#x60;maxDeliveryDays&#x60; допускаются значения от 21 до 42.  Обязательный параметр, если &#x60;type&#x3D;\&quot;DEPOT\&quot;&#x60; или &#x60;type&#x3D;\&quot;MIXED\&quot;&#x60;.  Взаимоисключающий с параметром &#x60;unspecifiedDeliveryInterval&#x60;. 
  , outletDeliveryRuleDTOMaxDeliveryDays :: !(Maybe Int) -- ^ "maxDeliveryDays" - Максимальный срок доставки товаров в точку продаж. Указан в рабочих днях.  Минимальное значение: &#x60;0&#x60; — доставка в день заказа.  Максимальное значение: &#x60;60&#x60;.  Допустимые сроки доставки (разница между &#x60;minDeliveryDays&#x60; и &#x60;maxDeliveryDays&#x60;) зависят от региона.  Для доставки по своему региону разница не должна превышать двух дней. Например, если &#x60;minDeliveryDays&#x60; равно 1, то для &#x60;maxDeliveryDays&#x60; допускаются значения от 1 до 3.  Для доставки в другие регионы:  * Если &#x60;minDeliveryDays&#x60; до 18 дней, разница не должна превышать четырех дней. Например, если &#x60;minDeliveryDays&#x60; равно 10, то для &#x60;maxDeliveryDays&#x60; допускаются значения от 10 до 14. * Если &#x60;minDeliveryDays&#x60; больше 18 дней, разница должна быть не больше чем в два раза. Например, если &#x60;minDeliveryDays&#x60; равно 21, то для &#x60;maxDeliveryDays&#x60; допускаются значения от 21 до 42.  Обязательный параметр, если &#x60;type&#x3D;\&quot;DEPOT\&quot;&#x60; или &#x60;type&#x3D;\&quot;MIXED\&quot;&#x60;.  Взаимоисключающий с параметром &#x60;unspecifiedDeliveryInterval&#x60;. 
  , outletDeliveryRuleDTODeliveryServiceId :: !(Maybe Integer) -- ^ "deliveryServiceId" - Идентификатор службы доставки товаров в точку продаж.  Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md). 
  , outletDeliveryRuleDTOOrderBefore :: !(Maybe Int) -- ^ "orderBefore" - Час, до которого покупателю нужно сделать заказ, чтобы он был доставлен в точку продаж в сроки от &#x60;minDeliveryDays&#x60; до &#x60;maxDeliveryDays&#x60;.  Если покупатель оформит заказ после указанного часа, он будет доставлен в сроки от &#x60;minDeliveryDays&#x60; + 1 рабочий день до &#x60;maxDeliveryDays&#x60; + 1 рабочий день.  Значение по умолчанию: &#x60;24&#x60;. 
  , outletDeliveryRuleDTOPriceFreePickup :: !(Maybe Double) -- ^ "priceFreePickup" - Цена на товар, начиная с которой действует бесплатный самовывоз товара из точки продаж.
  , outletDeliveryRuleDTOUnspecifiedDeliveryInterval :: !(Maybe Bool) -- ^ "unspecifiedDeliveryInterval" - Признак доставки товаров в точку продаж на заказ.  Признак выставлен, если:  * точный срок доставки в точку продаж заранее неизвестен (например, если магазин собирает несколько заказов для отправки в точку или населенный пункт); * все товары изготавливаются или поставляются на заказ.  Возможные значения: * &#x60;true&#x60; — товары доставляются в точку продаж на заказ.  Параметр указывается только со значением &#x60;true&#x60;.  Взаимоисключающий с параметрами &#x60;minDeliveryDays&#x60; и &#x60;maxDeliveryDays&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OutletDeliveryRuleDTO
instance A.FromJSON OutletDeliveryRuleDTO where
  parseJSON = A.withObject "OutletDeliveryRuleDTO" $ \o ->
    OutletDeliveryRuleDTO
      <$> (o .:? "minDeliveryDays")
      <*> (o .:? "maxDeliveryDays")
      <*> (o .:? "deliveryServiceId")
      <*> (o .:? "orderBefore")
      <*> (o .:? "priceFreePickup")
      <*> (o .:? "unspecifiedDeliveryInterval")

-- | ToJSON OutletDeliveryRuleDTO
instance A.ToJSON OutletDeliveryRuleDTO where
  toJSON OutletDeliveryRuleDTO {..} =
   _omitNulls
      [ "minDeliveryDays" .= outletDeliveryRuleDTOMinDeliveryDays
      , "maxDeliveryDays" .= outletDeliveryRuleDTOMaxDeliveryDays
      , "deliveryServiceId" .= outletDeliveryRuleDTODeliveryServiceId
      , "orderBefore" .= outletDeliveryRuleDTOOrderBefore
      , "priceFreePickup" .= outletDeliveryRuleDTOPriceFreePickup
      , "unspecifiedDeliveryInterval" .= outletDeliveryRuleDTOUnspecifiedDeliveryInterval
      ]


-- | Construct a value of type 'OutletDeliveryRuleDTO' (by applying it's required fields, if any)
mkOutletDeliveryRuleDTO
  :: OutletDeliveryRuleDTO
mkOutletDeliveryRuleDTO =
  OutletDeliveryRuleDTO
  { outletDeliveryRuleDTOMinDeliveryDays = Nothing
  , outletDeliveryRuleDTOMaxDeliveryDays = Nothing
  , outletDeliveryRuleDTODeliveryServiceId = Nothing
  , outletDeliveryRuleDTOOrderBefore = Nothing
  , outletDeliveryRuleDTOPriceFreePickup = Nothing
  , outletDeliveryRuleDTOUnspecifiedDeliveryInterval = Nothing
  }

-- ** OutletLicenseDTO
-- | OutletLicenseDTO
-- Информация о лицензии.
data OutletLicenseDTO = OutletLicenseDTO
  { outletLicenseDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор лицензии.  Параметр указывается, только если нужно изменить информацию о существующей лицензии. Ее идентификатор можно узнать с помощью запроса [GET campaigns/{campaignId}/outlets/licenses](../../reference/outlets/getOutletLicenses.md). При передаче информации о новой лицензии указывать идентификатор не нужно.  Идентификатор лицензии присваивается Маркетом. Не путайте его с номером, указанным на лицензии: он передается в параметре &#x60;number&#x60;. 
  , outletLicenseDTOOutletId :: !(Maybe Integer) -- ^ "outletId" - Идентификатор точки продаж, для которой действительна лицензия.
  , outletLicenseDTOLicenseType :: !(Maybe LicenseType) -- ^ "licenseType"
  , outletLicenseDTONumber :: !(Maybe Text) -- ^ "number" - Номер лицензии.
  , outletLicenseDTODateOfIssue :: !(Maybe DateTime) -- ^ "dateOfIssue" - Дата выдачи лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время &#x60;00:00:00&#x60; и часовой пояс, соответствующий региону точки продаж. Например, если лицензия для точки продаж в Москве выдана 13 ноября 2017 года, то параметр должен иметь значение &#x60;2017-11-13T00:00:00+03:00&#x60;.  Обязательный параметр.  Не может быть позже даты окончания срока действия, указанной в параметре &#x60;dateOfExpiry&#x60;. 
  , outletLicenseDTODateOfExpiry :: !(Maybe DateTime) -- ^ "dateOfExpiry" - Дата окончания действия лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время &#x60;00:00:00&#x60; и часовой пояс, соответствующий региону точки продаж. Например, если действие лицензии для точки продаж в Москве заканчивается 20 ноября 2022 года, то параметр должен иметь значение &#x60;2022-11-20T00:00:00+03:00&#x60;.  Обязательный параметр.  Не может быть раньше даты выдачи, указанной в параметре &#x60;dateOfIssue&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OutletLicenseDTO
instance A.FromJSON OutletLicenseDTO where
  parseJSON = A.withObject "OutletLicenseDTO" $ \o ->
    OutletLicenseDTO
      <$> (o .:? "id")
      <*> (o .:? "outletId")
      <*> (o .:? "licenseType")
      <*> (o .:? "number")
      <*> (o .:? "dateOfIssue")
      <*> (o .:? "dateOfExpiry")

-- | ToJSON OutletLicenseDTO
instance A.ToJSON OutletLicenseDTO where
  toJSON OutletLicenseDTO {..} =
   _omitNulls
      [ "id" .= outletLicenseDTOId
      , "outletId" .= outletLicenseDTOOutletId
      , "licenseType" .= outletLicenseDTOLicenseType
      , "number" .= outletLicenseDTONumber
      , "dateOfIssue" .= outletLicenseDTODateOfIssue
      , "dateOfExpiry" .= outletLicenseDTODateOfExpiry
      ]


-- | Construct a value of type 'OutletLicenseDTO' (by applying it's required fields, if any)
mkOutletLicenseDTO
  :: OutletLicenseDTO
mkOutletLicenseDTO =
  OutletLicenseDTO
  { outletLicenseDTOId = Nothing
  , outletLicenseDTOOutletId = Nothing
  , outletLicenseDTOLicenseType = Nothing
  , outletLicenseDTONumber = Nothing
  , outletLicenseDTODateOfIssue = Nothing
  , outletLicenseDTODateOfExpiry = Nothing
  }

-- ** OutletLicensesResponseDTO
-- | OutletLicensesResponseDTO
-- Ответ на запрос информации о лицензиях для точек продаж.
data OutletLicensesResponseDTO = OutletLicensesResponseDTO
  { outletLicensesResponseDTOLicenses :: !([FullOutletLicenseDTO]) -- ^ /Required/ "licenses" - Список лицензий.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OutletLicensesResponseDTO
instance A.FromJSON OutletLicensesResponseDTO where
  parseJSON = A.withObject "OutletLicensesResponseDTO" $ \o ->
    OutletLicensesResponseDTO
      <$> (o .:  "licenses")

-- | ToJSON OutletLicensesResponseDTO
instance A.ToJSON OutletLicensesResponseDTO where
  toJSON OutletLicensesResponseDTO {..} =
   _omitNulls
      [ "licenses" .= outletLicensesResponseDTOLicenses
      ]


-- | Construct a value of type 'OutletLicensesResponseDTO' (by applying it's required fields, if any)
mkOutletLicensesResponseDTO
  :: [FullOutletLicenseDTO] -- ^ 'outletLicensesResponseDTOLicenses': Список лицензий.
  -> OutletLicensesResponseDTO
mkOutletLicensesResponseDTO outletLicensesResponseDTOLicenses =
  OutletLicensesResponseDTO
  { outletLicensesResponseDTOLicenses
  }

-- ** OutletResponseDTO
-- | OutletResponseDTO
-- Результат выполнения запроса. Выводится, если `status=\"OK\"`. 
data OutletResponseDTO = OutletResponseDTO
  { outletResponseDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор точки продаж, присвоенный Маркетом.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OutletResponseDTO
instance A.FromJSON OutletResponseDTO where
  parseJSON = A.withObject "OutletResponseDTO" $ \o ->
    OutletResponseDTO
      <$> (o .:? "id")

-- | ToJSON OutletResponseDTO
instance A.ToJSON OutletResponseDTO where
  toJSON OutletResponseDTO {..} =
   _omitNulls
      [ "id" .= outletResponseDTOId
      ]


-- | Construct a value of type 'OutletResponseDTO' (by applying it's required fields, if any)
mkOutletResponseDTO
  :: OutletResponseDTO
mkOutletResponseDTO =
  OutletResponseDTO
  { outletResponseDTOId = Nothing
  }

-- ** OutletWorkingScheduleDTO
-- | OutletWorkingScheduleDTO
-- Список режимов работы точки продаж. 
data OutletWorkingScheduleDTO = OutletWorkingScheduleDTO
  { outletWorkingScheduleDTOWorkInHoliday :: !(Maybe Bool) -- ^ "workInHoliday" - Признак, работает ли точка продаж в дни государственных праздников.  Возможные значения:  * &#x60;false&#x60; — точка продаж не работает в дни государственных праздников. * &#x60;true&#x60; — точка продаж работает в дни государственных праздников. 
  , outletWorkingScheduleDTOScheduleItems :: !([OutletWorkingScheduleItemDTO]) -- ^ /Required/ "scheduleItems" - Список расписаний работы точки продаж. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OutletWorkingScheduleDTO
instance A.FromJSON OutletWorkingScheduleDTO where
  parseJSON = A.withObject "OutletWorkingScheduleDTO" $ \o ->
    OutletWorkingScheduleDTO
      <$> (o .:? "workInHoliday")
      <*> (o .:  "scheduleItems")

-- | ToJSON OutletWorkingScheduleDTO
instance A.ToJSON OutletWorkingScheduleDTO where
  toJSON OutletWorkingScheduleDTO {..} =
   _omitNulls
      [ "workInHoliday" .= outletWorkingScheduleDTOWorkInHoliday
      , "scheduleItems" .= outletWorkingScheduleDTOScheduleItems
      ]


-- | Construct a value of type 'OutletWorkingScheduleDTO' (by applying it's required fields, if any)
mkOutletWorkingScheduleDTO
  :: [OutletWorkingScheduleItemDTO] -- ^ 'outletWorkingScheduleDTOScheduleItems': Список расписаний работы точки продаж. 
  -> OutletWorkingScheduleDTO
mkOutletWorkingScheduleDTO outletWorkingScheduleDTOScheduleItems =
  OutletWorkingScheduleDTO
  { outletWorkingScheduleDTOWorkInHoliday = Nothing
  , outletWorkingScheduleDTOScheduleItems
  }

-- ** OutletWorkingScheduleItemDTO
-- | OutletWorkingScheduleItemDTO
-- Расписание работы точки продаж.
data OutletWorkingScheduleItemDTO = OutletWorkingScheduleItemDTO
  { outletWorkingScheduleItemDTOStartDay :: !(DayOfWeekType) -- ^ /Required/ "startDay"
  , outletWorkingScheduleItemDTOEndDay :: !(DayOfWeekType) -- ^ /Required/ "endDay"
  , outletWorkingScheduleItemDTOStartTime :: !(Text) -- ^ /Required/ "startTime" - Точка продаж работает c указанного часа.  Формат: &#x60;ЧЧ:ММ&#x60;. 
  , outletWorkingScheduleItemDTOEndTime :: !(Text) -- ^ /Required/ "endTime" - Точка продаж работает до указанного часа.  Формат: &#x60;ЧЧ:ММ&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OutletWorkingScheduleItemDTO
instance A.FromJSON OutletWorkingScheduleItemDTO where
  parseJSON = A.withObject "OutletWorkingScheduleItemDTO" $ \o ->
    OutletWorkingScheduleItemDTO
      <$> (o .:  "startDay")
      <*> (o .:  "endDay")
      <*> (o .:  "startTime")
      <*> (o .:  "endTime")

-- | ToJSON OutletWorkingScheduleItemDTO
instance A.ToJSON OutletWorkingScheduleItemDTO where
  toJSON OutletWorkingScheduleItemDTO {..} =
   _omitNulls
      [ "startDay" .= outletWorkingScheduleItemDTOStartDay
      , "endDay" .= outletWorkingScheduleItemDTOEndDay
      , "startTime" .= outletWorkingScheduleItemDTOStartTime
      , "endTime" .= outletWorkingScheduleItemDTOEndTime
      ]


-- | Construct a value of type 'OutletWorkingScheduleItemDTO' (by applying it's required fields, if any)
mkOutletWorkingScheduleItemDTO
  :: DayOfWeekType -- ^ 'outletWorkingScheduleItemDTOStartDay' 
  -> DayOfWeekType -- ^ 'outletWorkingScheduleItemDTOEndDay' 
  -> Text -- ^ 'outletWorkingScheduleItemDTOStartTime': Точка продаж работает c указанного часа.  Формат: `ЧЧ:ММ`. 
  -> Text -- ^ 'outletWorkingScheduleItemDTOEndTime': Точка продаж работает до указанного часа.  Формат: `ЧЧ:ММ`. 
  -> OutletWorkingScheduleItemDTO
mkOutletWorkingScheduleItemDTO outletWorkingScheduleItemDTOStartDay outletWorkingScheduleItemDTOEndDay outletWorkingScheduleItemDTOStartTime outletWorkingScheduleItemDTOEndTime =
  OutletWorkingScheduleItemDTO
  { outletWorkingScheduleItemDTOStartDay
  , outletWorkingScheduleItemDTOEndDay
  , outletWorkingScheduleItemDTOStartTime
  , outletWorkingScheduleItemDTOEndTime
  }

-- ** PagedReturnsDTO
-- | PagedReturnsDTO
-- Возвраты.
data PagedReturnsDTO = PagedReturnsDTO
  { pagedReturnsDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  , pagedReturnsDTOReturns :: !([ReturnDTO]) -- ^ /Required/ "returns" - Список возвратов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PagedReturnsDTO
instance A.FromJSON PagedReturnsDTO where
  parseJSON = A.withObject "PagedReturnsDTO" $ \o ->
    PagedReturnsDTO
      <$> (o .:? "paging")
      <*> (o .:  "returns")

-- | ToJSON PagedReturnsDTO
instance A.ToJSON PagedReturnsDTO where
  toJSON PagedReturnsDTO {..} =
   _omitNulls
      [ "paging" .= pagedReturnsDTOPaging
      , "returns" .= pagedReturnsDTOReturns
      ]


-- | Construct a value of type 'PagedReturnsDTO' (by applying it's required fields, if any)
mkPagedReturnsDTO
  :: [ReturnDTO] -- ^ 'pagedReturnsDTOReturns': Список возвратов.
  -> PagedReturnsDTO
mkPagedReturnsDTO pagedReturnsDTOReturns =
  PagedReturnsDTO
  { pagedReturnsDTOPaging = Nothing
  , pagedReturnsDTOReturns
  }

-- ** PalletsCountDTO
-- | PalletsCountDTO
-- Количество палет в отгрузке.
data PalletsCountDTO = PalletsCountDTO
  { palletsCountDTOPlanned :: !(Maybe Int) -- ^ "planned" - Количество палет, которое заявил продавец.
  , palletsCountDTOFact :: !(Maybe Int) -- ^ "fact" - Количество палет, которое приняли в сортировочном центре.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PalletsCountDTO
instance A.FromJSON PalletsCountDTO where
  parseJSON = A.withObject "PalletsCountDTO" $ \o ->
    PalletsCountDTO
      <$> (o .:? "planned")
      <*> (o .:? "fact")

-- | ToJSON PalletsCountDTO
instance A.ToJSON PalletsCountDTO where
  toJSON PalletsCountDTO {..} =
   _omitNulls
      [ "planned" .= palletsCountDTOPlanned
      , "fact" .= palletsCountDTOFact
      ]


-- | Construct a value of type 'PalletsCountDTO' (by applying it's required fields, if any)
mkPalletsCountDTO
  :: PalletsCountDTO
mkPalletsCountDTO =
  PalletsCountDTO
  { palletsCountDTOPlanned = Nothing
  , palletsCountDTOFact = Nothing
  }

-- ** ParameterValueConstraintsDTO
-- | ParameterValueConstraintsDTO
-- Ограничения на значения характеристик.
data ParameterValueConstraintsDTO = ParameterValueConstraintsDTO
  { parameterValueConstraintsDTOMinValue :: !(Maybe Double) -- ^ "minValue" - Минимальное число.
  , parameterValueConstraintsDTOMaxValue :: !(Maybe Double) -- ^ "maxValue" - Максимальное число.
  , parameterValueConstraintsDTOMaxLength :: !(Maybe Int) -- ^ "maxLength" - Максимальная длина текста.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParameterValueConstraintsDTO
instance A.FromJSON ParameterValueConstraintsDTO where
  parseJSON = A.withObject "ParameterValueConstraintsDTO" $ \o ->
    ParameterValueConstraintsDTO
      <$> (o .:? "minValue")
      <*> (o .:? "maxValue")
      <*> (o .:? "maxLength")

-- | ToJSON ParameterValueConstraintsDTO
instance A.ToJSON ParameterValueConstraintsDTO where
  toJSON ParameterValueConstraintsDTO {..} =
   _omitNulls
      [ "minValue" .= parameterValueConstraintsDTOMinValue
      , "maxValue" .= parameterValueConstraintsDTOMaxValue
      , "maxLength" .= parameterValueConstraintsDTOMaxLength
      ]


-- | Construct a value of type 'ParameterValueConstraintsDTO' (by applying it's required fields, if any)
mkParameterValueConstraintsDTO
  :: ParameterValueConstraintsDTO
mkParameterValueConstraintsDTO =
  ParameterValueConstraintsDTO
  { parameterValueConstraintsDTOMinValue = Nothing
  , parameterValueConstraintsDTOMaxValue = Nothing
  , parameterValueConstraintsDTOMaxLength = Nothing
  }

-- ** ParameterValueDTO
-- | ParameterValueDTO
-- Значение характеристики.  Вы можете указывать несколько значений одной характеристики при условии, что:  * Тип характеристики — `ENUM`. * В ответе на запрос [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md) у данной характеристики поле `multivalue` имеет значение `true`.  Для этого в `parameterValues` передавайте каждое значение отдельно — несколько объектов с параметрами `parameterId`, `valueId` и `value`. Параметр `parameterId` должен быть одинаковым. 
data ParameterValueDTO = ParameterValueDTO
  { parameterValueDTOParameterId :: !(Integer) -- ^ /Required/ "parameterId" - Идентификатор характеристики.
  , parameterValueDTOUnitId :: !(Maybe Integer) -- ^ "unitId" - Идентификатор единицы измерения. Если вы не передали параметр &#x60;unitId&#x60;, используется единица измерения по умолчанию.
  , parameterValueDTOValueId :: !(Maybe Integer) -- ^ "valueId" - Идентификатор значения.  Обязательно указывайте идентификатор, если передаете значение из перечня допустимых значений, полученного от Маркета.  Только для характеристик типа &#x60;ENUM&#x60;. 
  , parameterValueDTOValue :: !(Maybe Text) -- ^ "value" - Значение.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParameterValueDTO
instance A.FromJSON ParameterValueDTO where
  parseJSON = A.withObject "ParameterValueDTO" $ \o ->
    ParameterValueDTO
      <$> (o .:  "parameterId")
      <*> (o .:? "unitId")
      <*> (o .:? "valueId")
      <*> (o .:? "value")

-- | ToJSON ParameterValueDTO
instance A.ToJSON ParameterValueDTO where
  toJSON ParameterValueDTO {..} =
   _omitNulls
      [ "parameterId" .= parameterValueDTOParameterId
      , "unitId" .= parameterValueDTOUnitId
      , "valueId" .= parameterValueDTOValueId
      , "value" .= parameterValueDTOValue
      ]


-- | Construct a value of type 'ParameterValueDTO' (by applying it's required fields, if any)
mkParameterValueDTO
  :: Integer -- ^ 'parameterValueDTOParameterId': Идентификатор характеристики.
  -> ParameterValueDTO
mkParameterValueDTO parameterValueDTOParameterId =
  ParameterValueDTO
  { parameterValueDTOParameterId
  , parameterValueDTOUnitId = Nothing
  , parameterValueDTOValueId = Nothing
  , parameterValueDTOValue = Nothing
  }

-- ** ParameterValueOptionDTO
-- | ParameterValueOptionDTO
-- Значение характеристики.
data ParameterValueOptionDTO = ParameterValueOptionDTO
  { parameterValueOptionDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор значения.
  , parameterValueOptionDTOValue :: !(Text) -- ^ /Required/ "value" - Значение.
  , parameterValueOptionDTODescription :: !(Maybe Text) -- ^ "description" - Описание значения.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParameterValueOptionDTO
instance A.FromJSON ParameterValueOptionDTO where
  parseJSON = A.withObject "ParameterValueOptionDTO" $ \o ->
    ParameterValueOptionDTO
      <$> (o .:  "id")
      <*> (o .:  "value")
      <*> (o .:? "description")

-- | ToJSON ParameterValueOptionDTO
instance A.ToJSON ParameterValueOptionDTO where
  toJSON ParameterValueOptionDTO {..} =
   _omitNulls
      [ "id" .= parameterValueOptionDTOId
      , "value" .= parameterValueOptionDTOValue
      , "description" .= parameterValueOptionDTODescription
      ]


-- | Construct a value of type 'ParameterValueOptionDTO' (by applying it's required fields, if any)
mkParameterValueOptionDTO
  :: Integer -- ^ 'parameterValueOptionDTOId': Идентификатор значения.
  -> Text -- ^ 'parameterValueOptionDTOValue': Значение.
  -> ParameterValueOptionDTO
mkParameterValueOptionDTO parameterValueOptionDTOId parameterValueOptionDTOValue =
  ParameterValueOptionDTO
  { parameterValueOptionDTOId
  , parameterValueOptionDTOValue
  , parameterValueOptionDTODescription = Nothing
  }

-- ** ParcelBoxDTO
-- | ParcelBoxDTO
-- Элемент отображает одно грузовое место. Вложенные поля больше не используются, передавайте элемент пустым в запросах и не обращайте внимание на содержимое в ответах.
data ParcelBoxDTO = ParcelBoxDTO
  { parcelBoxDTOId :: !(Maybe Integer) -- ^ "id" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %} 
  , parcelBoxDTOFulfilmentId :: !(Maybe Text) -- ^ "fulfilmentId" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %} 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParcelBoxDTO
instance A.FromJSON ParcelBoxDTO where
  parseJSON = A.withObject "ParcelBoxDTO" $ \o ->
    ParcelBoxDTO
      <$> (o .:? "id")
      <*> (o .:? "fulfilmentId")

-- | ToJSON ParcelBoxDTO
instance A.ToJSON ParcelBoxDTO where
  toJSON ParcelBoxDTO {..} =
   _omitNulls
      [ "id" .= parcelBoxDTOId
      , "fulfilmentId" .= parcelBoxDTOFulfilmentId
      ]


-- | Construct a value of type 'ParcelBoxDTO' (by applying it's required fields, if any)
mkParcelBoxDTO
  :: ParcelBoxDTO
mkParcelBoxDTO =
  ParcelBoxDTO
  { parcelBoxDTOId = Nothing
  , parcelBoxDTOFulfilmentId = Nothing
  }

-- ** ParcelBoxLabelDTO
-- | ParcelBoxLabelDTO
-- Информация о ярлыке для коробки.
data ParcelBoxLabelDTO = ParcelBoxLabelDTO
  { parcelBoxLabelDTOUrl :: !(Text) -- ^ /Required/ "url" - Соответствует URL, по которому выполняется запрос [GET campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label](../../reference/orders/generateOrderLabel.md). 
  , parcelBoxLabelDTOSupplierName :: !(Text) -- ^ /Required/ "supplierName" - Юридическое название магазина.
  , parcelBoxLabelDTODeliveryServiceName :: !(Text) -- ^ /Required/ "deliveryServiceName" - Юридическое название службы доставки.
  , parcelBoxLabelDTOOrderId :: !(Integer) -- ^ /Required/ "orderId" - Идентификатор заказа в системе Маркета.
  , parcelBoxLabelDTOOrderNum :: !(Text) -- ^ /Required/ "orderNum" - Идентификатор заказа в информационной системе магазина.  Совпадает с &#x60;orderId&#x60;, если Маркету неизвестен номер заказа в системе магазина. 
  , parcelBoxLabelDTORecipientName :: !(Text) -- ^ /Required/ "recipientName" - Фамилия и инициалы получателя заказа.
  , parcelBoxLabelDTOBoxId :: !(Integer) -- ^ /Required/ "boxId" - Идентификатор коробки.
  , parcelBoxLabelDTOFulfilmentId :: !(Text) -- ^ /Required/ "fulfilmentId" - Идентификатор коробки в информационной системе магазина.  Возвращается в формате: &#x60;номер заказа на Маркете-номер коробки&#x60;. Например, &#x60;7206821‑1&#x60;, &#x60;7206821‑2&#x60; и т. д. 
  , parcelBoxLabelDTOPlace :: !(Text) -- ^ /Required/ "place" - Номер коробки в заказе. Возвращается в формате: &#x60;номер места/общее количество мест&#x60;. 
  , parcelBoxLabelDTOWeight :: !(Text) -- ^ /Required/ "weight" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Общая масса всех товаров в заказе. Возвращается в формате: &#x60;weight кг&#x60;. 
  , parcelBoxLabelDTODeliveryServiceId :: !(Text) -- ^ /Required/ "deliveryServiceId" - Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
  , parcelBoxLabelDTODeliveryAddress :: !(Maybe Text) -- ^ "deliveryAddress" - Адрес получателя.
  , parcelBoxLabelDTOShipmentDate :: !(Maybe Text) -- ^ "shipmentDate" - Дата отгрузки в формате &#x60;dd.MM.yyyy&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParcelBoxLabelDTO
instance A.FromJSON ParcelBoxLabelDTO where
  parseJSON = A.withObject "ParcelBoxLabelDTO" $ \o ->
    ParcelBoxLabelDTO
      <$> (o .:  "url")
      <*> (o .:  "supplierName")
      <*> (o .:  "deliveryServiceName")
      <*> (o .:  "orderId")
      <*> (o .:  "orderNum")
      <*> (o .:  "recipientName")
      <*> (o .:  "boxId")
      <*> (o .:  "fulfilmentId")
      <*> (o .:  "place")
      <*> (o .:  "weight")
      <*> (o .:  "deliveryServiceId")
      <*> (o .:? "deliveryAddress")
      <*> (o .:? "shipmentDate")

-- | ToJSON ParcelBoxLabelDTO
instance A.ToJSON ParcelBoxLabelDTO where
  toJSON ParcelBoxLabelDTO {..} =
   _omitNulls
      [ "url" .= parcelBoxLabelDTOUrl
      , "supplierName" .= parcelBoxLabelDTOSupplierName
      , "deliveryServiceName" .= parcelBoxLabelDTODeliveryServiceName
      , "orderId" .= parcelBoxLabelDTOOrderId
      , "orderNum" .= parcelBoxLabelDTOOrderNum
      , "recipientName" .= parcelBoxLabelDTORecipientName
      , "boxId" .= parcelBoxLabelDTOBoxId
      , "fulfilmentId" .= parcelBoxLabelDTOFulfilmentId
      , "place" .= parcelBoxLabelDTOPlace
      , "weight" .= parcelBoxLabelDTOWeight
      , "deliveryServiceId" .= parcelBoxLabelDTODeliveryServiceId
      , "deliveryAddress" .= parcelBoxLabelDTODeliveryAddress
      , "shipmentDate" .= parcelBoxLabelDTOShipmentDate
      ]


-- | Construct a value of type 'ParcelBoxLabelDTO' (by applying it's required fields, if any)
mkParcelBoxLabelDTO
  :: Text -- ^ 'parcelBoxLabelDTOUrl': Соответствует URL, по которому выполняется запрос [GET campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label](../../reference/orders/generateOrderLabel.md). 
  -> Text -- ^ 'parcelBoxLabelDTOSupplierName': Юридическое название магазина.
  -> Text -- ^ 'parcelBoxLabelDTODeliveryServiceName': Юридическое название службы доставки.
  -> Integer -- ^ 'parcelBoxLabelDTOOrderId': Идентификатор заказа в системе Маркета.
  -> Text -- ^ 'parcelBoxLabelDTOOrderNum': Идентификатор заказа в информационной системе магазина.  Совпадает с `orderId`, если Маркету неизвестен номер заказа в системе магазина. 
  -> Text -- ^ 'parcelBoxLabelDTORecipientName': Фамилия и инициалы получателя заказа.
  -> Integer -- ^ 'parcelBoxLabelDTOBoxId': Идентификатор коробки.
  -> Text -- ^ 'parcelBoxLabelDTOFulfilmentId': Идентификатор коробки в информационной системе магазина.  Возвращается в формате: `номер заказа на Маркете-номер коробки`. Например, `7206821‑1`, `7206821‑2` и т. д. 
  -> Text -- ^ 'parcelBoxLabelDTOPlace': Номер коробки в заказе. Возвращается в формате: `номер места/общее количество мест`. 
  -> Text -- ^ 'parcelBoxLabelDTOWeight': {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Общая масса всех товаров в заказе. Возвращается в формате: `weight кг`. 
  -> Text -- ^ 'parcelBoxLabelDTODeliveryServiceId': Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
  -> ParcelBoxLabelDTO
mkParcelBoxLabelDTO parcelBoxLabelDTOUrl parcelBoxLabelDTOSupplierName parcelBoxLabelDTODeliveryServiceName parcelBoxLabelDTOOrderId parcelBoxLabelDTOOrderNum parcelBoxLabelDTORecipientName parcelBoxLabelDTOBoxId parcelBoxLabelDTOFulfilmentId parcelBoxLabelDTOPlace parcelBoxLabelDTOWeight parcelBoxLabelDTODeliveryServiceId =
  ParcelBoxLabelDTO
  { parcelBoxLabelDTOUrl
  , parcelBoxLabelDTOSupplierName
  , parcelBoxLabelDTODeliveryServiceName
  , parcelBoxLabelDTOOrderId
  , parcelBoxLabelDTOOrderNum
  , parcelBoxLabelDTORecipientName
  , parcelBoxLabelDTOBoxId
  , parcelBoxLabelDTOFulfilmentId
  , parcelBoxLabelDTOPlace
  , parcelBoxLabelDTOWeight
  , parcelBoxLabelDTODeliveryServiceId
  , parcelBoxLabelDTODeliveryAddress = Nothing
  , parcelBoxLabelDTOShipmentDate = Nothing
  }

-- ** ParcelDTO
-- | ParcelDTO
-- Информация о грузовых местах в заказе.
data ParcelDTO = ParcelDTO
  { parcelDTOBoxes :: !([ParcelBoxDTO]) -- ^ /Required/ "boxes" - Список грузовых мест. Маркет определяет количество мест по длине этого списка.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParcelDTO
instance A.FromJSON ParcelDTO where
  parseJSON = A.withObject "ParcelDTO" $ \o ->
    ParcelDTO
      <$> (o .:  "boxes")

-- | ToJSON ParcelDTO
instance A.ToJSON ParcelDTO where
  toJSON ParcelDTO {..} =
   _omitNulls
      [ "boxes" .= parcelDTOBoxes
      ]


-- | Construct a value of type 'ParcelDTO' (by applying it's required fields, if any)
mkParcelDTO
  :: [ParcelBoxDTO] -- ^ 'parcelDTOBoxes': Список грузовых мест. Маркет определяет количество мест по длине этого списка.
  -> ParcelDTO
mkParcelDTO parcelDTOBoxes =
  ParcelDTO
  { parcelDTOBoxes
  }

-- ** PartnerShipmentWarehouseDTO
-- | PartnerShipmentWarehouseDTO
-- Данные о складе отправления.
data PartnerShipmentWarehouseDTO = PartnerShipmentWarehouseDTO
  { partnerShipmentWarehouseDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор склада отправления.
  , partnerShipmentWarehouseDTOName :: !(Maybe Text) -- ^ "name" - Наименование склада отправления.
  , partnerShipmentWarehouseDTOAddress :: !(Maybe Text) -- ^ "address" - Адрес склада отправления.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PartnerShipmentWarehouseDTO
instance A.FromJSON PartnerShipmentWarehouseDTO where
  parseJSON = A.withObject "PartnerShipmentWarehouseDTO" $ \o ->
    PartnerShipmentWarehouseDTO
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "address")

-- | ToJSON PartnerShipmentWarehouseDTO
instance A.ToJSON PartnerShipmentWarehouseDTO where
  toJSON PartnerShipmentWarehouseDTO {..} =
   _omitNulls
      [ "id" .= partnerShipmentWarehouseDTOId
      , "name" .= partnerShipmentWarehouseDTOName
      , "address" .= partnerShipmentWarehouseDTOAddress
      ]


-- | Construct a value of type 'PartnerShipmentWarehouseDTO' (by applying it's required fields, if any)
mkPartnerShipmentWarehouseDTO
  :: PartnerShipmentWarehouseDTO
mkPartnerShipmentWarehouseDTO =
  PartnerShipmentWarehouseDTO
  { partnerShipmentWarehouseDTOId = Nothing
  , partnerShipmentWarehouseDTOName = Nothing
  , partnerShipmentWarehouseDTOAddress = Nothing
  }

-- ** PickupAddressDTO
-- | PickupAddressDTO
-- Адрес доставки.
data PickupAddressDTO = PickupAddressDTO
  { pickupAddressDTOCountry :: !(Maybe Text) -- ^ "country" - Страна.
  , pickupAddressDTOCity :: !(Maybe Text) -- ^ "city" - Город.
  , pickupAddressDTOStreet :: !(Maybe Text) -- ^ "street" - Улица.
  , pickupAddressDTOHouse :: !(Maybe Text) -- ^ "house" - Номер дома.
  , pickupAddressDTOPostcode :: !(Maybe Text) -- ^ "postcode" - Почтовый индекс.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PickupAddressDTO
instance A.FromJSON PickupAddressDTO where
  parseJSON = A.withObject "PickupAddressDTO" $ \o ->
    PickupAddressDTO
      <$> (o .:? "country")
      <*> (o .:? "city")
      <*> (o .:? "street")
      <*> (o .:? "house")
      <*> (o .:? "postcode")

-- | ToJSON PickupAddressDTO
instance A.ToJSON PickupAddressDTO where
  toJSON PickupAddressDTO {..} =
   _omitNulls
      [ "country" .= pickupAddressDTOCountry
      , "city" .= pickupAddressDTOCity
      , "street" .= pickupAddressDTOStreet
      , "house" .= pickupAddressDTOHouse
      , "postcode" .= pickupAddressDTOPostcode
      ]


-- | Construct a value of type 'PickupAddressDTO' (by applying it's required fields, if any)
mkPickupAddressDTO
  :: PickupAddressDTO
mkPickupAddressDTO =
  PickupAddressDTO
  { pickupAddressDTOCountry = Nothing
  , pickupAddressDTOCity = Nothing
  , pickupAddressDTOStreet = Nothing
  , pickupAddressDTOHouse = Nothing
  , pickupAddressDTOPostcode = Nothing
  }

-- ** PriceCompetitivenessThresholdsDTO
-- | PriceCompetitivenessThresholdsDTO
-- Максимальные значения цены, при которых она является привлекательной или умеренной.
data PriceCompetitivenessThresholdsDTO = PriceCompetitivenessThresholdsDTO
  { priceCompetitivenessThresholdsDTOOptimalPrice :: !(Maybe BasePriceDTO) -- ^ "optimalPrice"
  , priceCompetitivenessThresholdsDTOAveragePrice :: !(Maybe BasePriceDTO) -- ^ "averagePrice"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceCompetitivenessThresholdsDTO
instance A.FromJSON PriceCompetitivenessThresholdsDTO where
  parseJSON = A.withObject "PriceCompetitivenessThresholdsDTO" $ \o ->
    PriceCompetitivenessThresholdsDTO
      <$> (o .:? "optimalPrice")
      <*> (o .:? "averagePrice")

-- | ToJSON PriceCompetitivenessThresholdsDTO
instance A.ToJSON PriceCompetitivenessThresholdsDTO where
  toJSON PriceCompetitivenessThresholdsDTO {..} =
   _omitNulls
      [ "optimalPrice" .= priceCompetitivenessThresholdsDTOOptimalPrice
      , "averagePrice" .= priceCompetitivenessThresholdsDTOAveragePrice
      ]


-- | Construct a value of type 'PriceCompetitivenessThresholdsDTO' (by applying it's required fields, if any)
mkPriceCompetitivenessThresholdsDTO
  :: PriceCompetitivenessThresholdsDTO
mkPriceCompetitivenessThresholdsDTO =
  PriceCompetitivenessThresholdsDTO
  { priceCompetitivenessThresholdsDTOOptimalPrice = Nothing
  , priceCompetitivenessThresholdsDTOAveragePrice = Nothing
  }

-- ** PriceDTO
-- | PriceDTO
-- Цена с указанием скидки, валюты и времени последнего обновления.
data PriceDTO = PriceDTO
  { priceDTOValue :: !(Maybe Double) -- ^ "value" - Цена на товар.
  , priceDTODiscountBase :: !(Maybe Double) -- ^ "discountBase" - Цена на товар без скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
  , priceDTOCurrencyId :: !(Maybe CurrencyType) -- ^ "currencyId"
  , priceDTOVat :: !(Maybe Int) -- ^ "vat" - Идентификатор ставки НДС, применяемой для товара:  * &#x60;2&#x60; — 10%. * &#x60;5&#x60; — 0%. * &#x60;6&#x60; — не облагается НДС. * &#x60;7&#x60; — 20%.  Если параметр не указан, используется ставка НДС, установленная в кабинете. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceDTO
instance A.FromJSON PriceDTO where
  parseJSON = A.withObject "PriceDTO" $ \o ->
    PriceDTO
      <$> (o .:? "value")
      <*> (o .:? "discountBase")
      <*> (o .:? "currencyId")
      <*> (o .:? "vat")

-- | ToJSON PriceDTO
instance A.ToJSON PriceDTO where
  toJSON PriceDTO {..} =
   _omitNulls
      [ "value" .= priceDTOValue
      , "discountBase" .= priceDTODiscountBase
      , "currencyId" .= priceDTOCurrencyId
      , "vat" .= priceDTOVat
      ]


-- | Construct a value of type 'PriceDTO' (by applying it's required fields, if any)
mkPriceDTO
  :: PriceDTO
mkPriceDTO =
  PriceDTO
  { priceDTOValue = Nothing
  , priceDTODiscountBase = Nothing
  , priceDTOCurrencyId = Nothing
  , priceDTOVat = Nothing
  }

-- ** PriceQuarantineVerdictDTO
-- | PriceQuarantineVerdictDTO
-- Причина попадания товара в карантин.
data PriceQuarantineVerdictDTO = PriceQuarantineVerdictDTO
  { priceQuarantineVerdictDTOType :: !(Maybe PriceQuarantineVerdictType) -- ^ "type"
  , priceQuarantineVerdictDTOParams :: !([PriceQuarantineVerdictParameterDTO]) -- ^ /Required/ "params" - Цена, из-за которой товар попал в карантин, и значения для сравнения. Конкретный набор параметров зависит от типа карантина.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceQuarantineVerdictDTO
instance A.FromJSON PriceQuarantineVerdictDTO where
  parseJSON = A.withObject "PriceQuarantineVerdictDTO" $ \o ->
    PriceQuarantineVerdictDTO
      <$> (o .:? "type")
      <*> (o .:  "params")

-- | ToJSON PriceQuarantineVerdictDTO
instance A.ToJSON PriceQuarantineVerdictDTO where
  toJSON PriceQuarantineVerdictDTO {..} =
   _omitNulls
      [ "type" .= priceQuarantineVerdictDTOType
      , "params" .= priceQuarantineVerdictDTOParams
      ]


-- | Construct a value of type 'PriceQuarantineVerdictDTO' (by applying it's required fields, if any)
mkPriceQuarantineVerdictDTO
  :: [PriceQuarantineVerdictParameterDTO] -- ^ 'priceQuarantineVerdictDTOParams': Цена, из-за которой товар попал в карантин, и значения для сравнения. Конкретный набор параметров зависит от типа карантина.
  -> PriceQuarantineVerdictDTO
mkPriceQuarantineVerdictDTO priceQuarantineVerdictDTOParams =
  PriceQuarantineVerdictDTO
  { priceQuarantineVerdictDTOType = Nothing
  , priceQuarantineVerdictDTOParams
  }

-- ** PriceQuarantineVerdictParameterDTO
-- | PriceQuarantineVerdictParameterDTO
-- Параметр карантина.
data PriceQuarantineVerdictParameterDTO = PriceQuarantineVerdictParameterDTO
  { priceQuarantineVerdictParameterDTOName :: !(PriceQuarantineVerdictParamNameType) -- ^ /Required/ "name"
  , priceQuarantineVerdictParameterDTOValue :: !(Text) -- ^ /Required/ "value" - Значение параметра.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceQuarantineVerdictParameterDTO
instance A.FromJSON PriceQuarantineVerdictParameterDTO where
  parseJSON = A.withObject "PriceQuarantineVerdictParameterDTO" $ \o ->
    PriceQuarantineVerdictParameterDTO
      <$> (o .:  "name")
      <*> (o .:  "value")

-- | ToJSON PriceQuarantineVerdictParameterDTO
instance A.ToJSON PriceQuarantineVerdictParameterDTO where
  toJSON PriceQuarantineVerdictParameterDTO {..} =
   _omitNulls
      [ "name" .= priceQuarantineVerdictParameterDTOName
      , "value" .= priceQuarantineVerdictParameterDTOValue
      ]


-- | Construct a value of type 'PriceQuarantineVerdictParameterDTO' (by applying it's required fields, if any)
mkPriceQuarantineVerdictParameterDTO
  :: PriceQuarantineVerdictParamNameType -- ^ 'priceQuarantineVerdictParameterDTOName' 
  -> Text -- ^ 'priceQuarantineVerdictParameterDTOValue': Значение параметра.
  -> PriceQuarantineVerdictParameterDTO
mkPriceQuarantineVerdictParameterDTO priceQuarantineVerdictParameterDTOName priceQuarantineVerdictParameterDTOValue =
  PriceQuarantineVerdictParameterDTO
  { priceQuarantineVerdictParameterDTOName
  , priceQuarantineVerdictParameterDTOValue
  }

-- ** PriceRecommendationItemDTO
-- | PriceRecommendationItemDTO
-- Рекомендованная цена.
data PriceRecommendationItemDTO = PriceRecommendationItemDTO
  { priceRecommendationItemDTOCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - Идентификатор кампании.
  , priceRecommendationItemDTOPrice :: !(Double) -- ^ /Required/ "price" - Рекомендованная цена на товар. Чтобы продвижение хорошо работало, цена на товар должна быть не выше этого значения. [Подробно о рекомендованных ценах](https://yandex.ru/support/marketplace/marketing/campaigns.html#prices) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceRecommendationItemDTO
instance A.FromJSON PriceRecommendationItemDTO where
  parseJSON = A.withObject "PriceRecommendationItemDTO" $ \o ->
    PriceRecommendationItemDTO
      <$> (o .:  "campaignId")
      <*> (o .:  "price")

-- | ToJSON PriceRecommendationItemDTO
instance A.ToJSON PriceRecommendationItemDTO where
  toJSON PriceRecommendationItemDTO {..} =
   _omitNulls
      [ "campaignId" .= priceRecommendationItemDTOCampaignId
      , "price" .= priceRecommendationItemDTOPrice
      ]


-- | Construct a value of type 'PriceRecommendationItemDTO' (by applying it's required fields, if any)
mkPriceRecommendationItemDTO
  :: Integer -- ^ 'priceRecommendationItemDTOCampaignId': Идентификатор кампании.
  -> Double -- ^ 'priceRecommendationItemDTOPrice': Рекомендованная цена на товар. Чтобы продвижение хорошо работало, цена на товар должна быть не выше этого значения. [Подробно о рекомендованных ценах](https://yandex.ru/support/marketplace/marketing/campaigns.html#prices) 
  -> PriceRecommendationItemDTO
mkPriceRecommendationItemDTO priceRecommendationItemDTOCampaignId priceRecommendationItemDTOPrice =
  PriceRecommendationItemDTO
  { priceRecommendationItemDTOCampaignId
  , priceRecommendationItemDTOPrice
  }

-- ** PriceSuggestDTO
-- | PriceSuggestDTO
-- Тип цены.
data PriceSuggestDTO = PriceSuggestDTO
  { priceSuggestDTOType :: !(Maybe PriceSuggestType) -- ^ "type"
  , priceSuggestDTOPrice :: !(Maybe Double) -- ^ "price" - Цена в рублях.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceSuggestDTO
instance A.FromJSON PriceSuggestDTO where
  parseJSON = A.withObject "PriceSuggestDTO" $ \o ->
    PriceSuggestDTO
      <$> (o .:? "type")
      <*> (o .:? "price")

-- | ToJSON PriceSuggestDTO
instance A.ToJSON PriceSuggestDTO where
  toJSON PriceSuggestDTO {..} =
   _omitNulls
      [ "type" .= priceSuggestDTOType
      , "price" .= priceSuggestDTOPrice
      ]


-- | Construct a value of type 'PriceSuggestDTO' (by applying it's required fields, if any)
mkPriceSuggestDTO
  :: PriceSuggestDTO
mkPriceSuggestDTO =
  PriceSuggestDTO
  { priceSuggestDTOType = Nothing
  , priceSuggestDTOPrice = Nothing
  }

-- ** PriceSuggestOfferDTO
-- | PriceSuggestOfferDTO
-- Товар с ценами для продвижения.
data PriceSuggestOfferDTO = PriceSuggestOfferDTO
  { priceSuggestOfferDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  , priceSuggestOfferDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , priceSuggestOfferDTOPriceSuggestion :: !(Maybe [PriceSuggestDTO]) -- ^ "priceSuggestion" - Цены для продвижения. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceSuggestOfferDTO
instance A.FromJSON PriceSuggestOfferDTO where
  parseJSON = A.withObject "PriceSuggestOfferDTO" $ \o ->
    PriceSuggestOfferDTO
      <$> (o .:? "marketSku")
      <*> (o .:? "offerId")
      <*> (o .:? "priceSuggestion")

-- | ToJSON PriceSuggestOfferDTO
instance A.ToJSON PriceSuggestOfferDTO where
  toJSON PriceSuggestOfferDTO {..} =
   _omitNulls
      [ "marketSku" .= priceSuggestOfferDTOMarketSku
      , "offerId" .= priceSuggestOfferDTOOfferId
      , "priceSuggestion" .= priceSuggestOfferDTOPriceSuggestion
      ]


-- | Construct a value of type 'PriceSuggestOfferDTO' (by applying it's required fields, if any)
mkPriceSuggestOfferDTO
  :: PriceSuggestOfferDTO
mkPriceSuggestOfferDTO =
  PriceSuggestOfferDTO
  { priceSuggestOfferDTOMarketSku = Nothing
  , priceSuggestOfferDTOOfferId = Nothing
  , priceSuggestOfferDTOPriceSuggestion = Nothing
  }

-- ** PromoOfferAutoParticipatingDetailsDTO
-- | PromoOfferAutoParticipatingDetailsDTO
-- Информация об автоматическом добавлении товара в акцию.  Причины, по которым товар не был добавлен автоматически в других магазинах, можно узнать в кабинете продавца на Маркете на странице акции.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
data PromoOfferAutoParticipatingDetailsDTO = PromoOfferAutoParticipatingDetailsDTO
  { promoOfferAutoParticipatingDetailsDTOCampaignIds :: !(Maybe [Integer]) -- ^ "campaignIds" - Магазины, в которых товар добавлен в акцию автоматически.  Возвращается, если статус товара в акции — &#x60;PARTIALLY_AUTO&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromoOfferAutoParticipatingDetailsDTO
instance A.FromJSON PromoOfferAutoParticipatingDetailsDTO where
  parseJSON = A.withObject "PromoOfferAutoParticipatingDetailsDTO" $ \o ->
    PromoOfferAutoParticipatingDetailsDTO
      <$> (o .:? "campaignIds")

-- | ToJSON PromoOfferAutoParticipatingDetailsDTO
instance A.ToJSON PromoOfferAutoParticipatingDetailsDTO where
  toJSON PromoOfferAutoParticipatingDetailsDTO {..} =
   _omitNulls
      [ "campaignIds" .= promoOfferAutoParticipatingDetailsDTOCampaignIds
      ]


-- | Construct a value of type 'PromoOfferAutoParticipatingDetailsDTO' (by applying it's required fields, if any)
mkPromoOfferAutoParticipatingDetailsDTO
  :: PromoOfferAutoParticipatingDetailsDTO
mkPromoOfferAutoParticipatingDetailsDTO =
  PromoOfferAutoParticipatingDetailsDTO
  { promoOfferAutoParticipatingDetailsDTOCampaignIds = Nothing
  }

-- ** PromoOfferDiscountParamsDTO
-- | PromoOfferDiscountParamsDTO
-- Параметры товара в акции с типом `DIRECT_DISCOUNT` или `BLUE_FLASH`.
data PromoOfferDiscountParamsDTO = PromoOfferDiscountParamsDTO
  { promoOfferDiscountParamsDTOPrice :: !(Maybe Integer) -- ^ "price" - Зачеркнутая цена — та, по которой товар продавался до акции.  Указывается в рублях.  Возвращается, только если товар участвует в акции. 
  , promoOfferDiscountParamsDTOPromoPrice :: !(Maybe Integer) -- ^ "promoPrice" - Цена по акции — та, по которой вы хотите продавать товар.  Указывается в рублях.  Возвращается, только если товар участвует в акции. 
  , promoOfferDiscountParamsDTOMaxPromoPrice :: !(Integer) -- ^ /Required/ "maxPromoPrice" - Максимально возможная цена для участия в акции.  Указывается в рублях.  Возвращается для всех товаров. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromoOfferDiscountParamsDTO
instance A.FromJSON PromoOfferDiscountParamsDTO where
  parseJSON = A.withObject "PromoOfferDiscountParamsDTO" $ \o ->
    PromoOfferDiscountParamsDTO
      <$> (o .:? "price")
      <*> (o .:? "promoPrice")
      <*> (o .:  "maxPromoPrice")

-- | ToJSON PromoOfferDiscountParamsDTO
instance A.ToJSON PromoOfferDiscountParamsDTO where
  toJSON PromoOfferDiscountParamsDTO {..} =
   _omitNulls
      [ "price" .= promoOfferDiscountParamsDTOPrice
      , "promoPrice" .= promoOfferDiscountParamsDTOPromoPrice
      , "maxPromoPrice" .= promoOfferDiscountParamsDTOMaxPromoPrice
      ]


-- | Construct a value of type 'PromoOfferDiscountParamsDTO' (by applying it's required fields, if any)
mkPromoOfferDiscountParamsDTO
  :: Integer -- ^ 'promoOfferDiscountParamsDTOMaxPromoPrice': Максимально возможная цена для участия в акции.  Указывается в рублях.  Возвращается для всех товаров. 
  -> PromoOfferDiscountParamsDTO
mkPromoOfferDiscountParamsDTO promoOfferDiscountParamsDTOMaxPromoPrice =
  PromoOfferDiscountParamsDTO
  { promoOfferDiscountParamsDTOPrice = Nothing
  , promoOfferDiscountParamsDTOPromoPrice = Nothing
  , promoOfferDiscountParamsDTOMaxPromoPrice
  }

-- ** PromoOfferParamsDTO
-- | PromoOfferParamsDTO
-- Параметры товара в акции.  Возвращается параметр, который соответствует типу акции. 
data PromoOfferParamsDTO = PromoOfferParamsDTO
  { promoOfferParamsDTODiscountParams :: !(Maybe PromoOfferDiscountParamsDTO) -- ^ "discountParams"
  , promoOfferParamsDTOPromocodeParams :: !(Maybe PromoOfferPromocodeParamsDTO) -- ^ "promocodeParams"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromoOfferParamsDTO
instance A.FromJSON PromoOfferParamsDTO where
  parseJSON = A.withObject "PromoOfferParamsDTO" $ \o ->
    PromoOfferParamsDTO
      <$> (o .:? "discountParams")
      <*> (o .:? "promocodeParams")

-- | ToJSON PromoOfferParamsDTO
instance A.ToJSON PromoOfferParamsDTO where
  toJSON PromoOfferParamsDTO {..} =
   _omitNulls
      [ "discountParams" .= promoOfferParamsDTODiscountParams
      , "promocodeParams" .= promoOfferParamsDTOPromocodeParams
      ]


-- | Construct a value of type 'PromoOfferParamsDTO' (by applying it's required fields, if any)
mkPromoOfferParamsDTO
  :: PromoOfferParamsDTO
mkPromoOfferParamsDTO =
  PromoOfferParamsDTO
  { promoOfferParamsDTODiscountParams = Nothing
  , promoOfferParamsDTOPromocodeParams = Nothing
  }

-- ** PromoOfferPromocodeParamsDTO
-- | PromoOfferPromocodeParamsDTO
-- Параметры товара в акции с типом `MARKET_PROMOCODE`.
data PromoOfferPromocodeParamsDTO = PromoOfferPromocodeParamsDTO
  { promoOfferPromocodeParamsDTOMaxPrice :: !(Integer) -- ^ /Required/ "maxPrice" - Максимально возможная цена для участия в акции до применения промокода.  Указывается в рублях.  Возвращается для всех товаров. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromoOfferPromocodeParamsDTO
instance A.FromJSON PromoOfferPromocodeParamsDTO where
  parseJSON = A.withObject "PromoOfferPromocodeParamsDTO" $ \o ->
    PromoOfferPromocodeParamsDTO
      <$> (o .:  "maxPrice")

-- | ToJSON PromoOfferPromocodeParamsDTO
instance A.ToJSON PromoOfferPromocodeParamsDTO where
  toJSON PromoOfferPromocodeParamsDTO {..} =
   _omitNulls
      [ "maxPrice" .= promoOfferPromocodeParamsDTOMaxPrice
      ]


-- | Construct a value of type 'PromoOfferPromocodeParamsDTO' (by applying it's required fields, if any)
mkPromoOfferPromocodeParamsDTO
  :: Integer -- ^ 'promoOfferPromocodeParamsDTOMaxPrice': Максимально возможная цена для участия в акции до применения промокода.  Указывается в рублях.  Возвращается для всех товаров. 
  -> PromoOfferPromocodeParamsDTO
mkPromoOfferPromocodeParamsDTO promoOfferPromocodeParamsDTOMaxPrice =
  PromoOfferPromocodeParamsDTO
  { promoOfferPromocodeParamsDTOMaxPrice
  }

-- ** PromoOfferUpdateWarningDTO
-- | PromoOfferUpdateWarningDTO
-- Предупреждение, которое появилось при добавлении товара в акцию или изменении его цен.
data PromoOfferUpdateWarningDTO = PromoOfferUpdateWarningDTO
  { promoOfferUpdateWarningDTOCode :: !(PromoOfferUpdateWarningCodeType) -- ^ /Required/ "code"
  , promoOfferUpdateWarningDTOCampaignIds :: !(Maybe [Integer]) -- ^ "campaignIds" - Идентификаторы магазинов в кабинете, для которых получены предупреждения.  Не возвращается, если предупреждения действуют для всех магазинов в кабинете. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromoOfferUpdateWarningDTO
instance A.FromJSON PromoOfferUpdateWarningDTO where
  parseJSON = A.withObject "PromoOfferUpdateWarningDTO" $ \o ->
    PromoOfferUpdateWarningDTO
      <$> (o .:  "code")
      <*> (o .:? "campaignIds")

-- | ToJSON PromoOfferUpdateWarningDTO
instance A.ToJSON PromoOfferUpdateWarningDTO where
  toJSON PromoOfferUpdateWarningDTO {..} =
   _omitNulls
      [ "code" .= promoOfferUpdateWarningDTOCode
      , "campaignIds" .= promoOfferUpdateWarningDTOCampaignIds
      ]


-- | Construct a value of type 'PromoOfferUpdateWarningDTO' (by applying it's required fields, if any)
mkPromoOfferUpdateWarningDTO
  :: PromoOfferUpdateWarningCodeType -- ^ 'promoOfferUpdateWarningDTOCode' 
  -> PromoOfferUpdateWarningDTO
mkPromoOfferUpdateWarningDTO promoOfferUpdateWarningDTOCode =
  PromoOfferUpdateWarningDTO
  { promoOfferUpdateWarningDTOCode
  , promoOfferUpdateWarningDTOCampaignIds = Nothing
  }

-- ** PromoPeriodDTO
-- | PromoPeriodDTO
-- Время проведения акции.
data PromoPeriodDTO = PromoPeriodDTO
  { promoPeriodDTODateTimeFrom :: !(DateTime) -- ^ /Required/ "dateTimeFrom" - Дата и время начала акции.
  , promoPeriodDTODateTimeTo :: !(DateTime) -- ^ /Required/ "dateTimeTo" - Дата и время окончания акции.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromoPeriodDTO
instance A.FromJSON PromoPeriodDTO where
  parseJSON = A.withObject "PromoPeriodDTO" $ \o ->
    PromoPeriodDTO
      <$> (o .:  "dateTimeFrom")
      <*> (o .:  "dateTimeTo")

-- | ToJSON PromoPeriodDTO
instance A.ToJSON PromoPeriodDTO where
  toJSON PromoPeriodDTO {..} =
   _omitNulls
      [ "dateTimeFrom" .= promoPeriodDTODateTimeFrom
      , "dateTimeTo" .= promoPeriodDTODateTimeTo
      ]


-- | Construct a value of type 'PromoPeriodDTO' (by applying it's required fields, if any)
mkPromoPeriodDTO
  :: DateTime -- ^ 'promoPeriodDTODateTimeFrom': Дата и время начала акции.
  -> DateTime -- ^ 'promoPeriodDTODateTimeTo': Дата и время окончания акции.
  -> PromoPeriodDTO
mkPromoPeriodDTO promoPeriodDTODateTimeFrom promoPeriodDTODateTimeTo =
  PromoPeriodDTO
  { promoPeriodDTODateTimeFrom
  , promoPeriodDTODateTimeTo
  }

-- ** ProvideOrderDigitalCodesRequest
-- | ProvideOrderDigitalCodesRequest
-- Запрос на передачу ключей цифровых товаров.
data ProvideOrderDigitalCodesRequest = ProvideOrderDigitalCodesRequest
  { provideOrderDigitalCodesRequestItems :: !([OrderDigitalItemDTO]) -- ^ /Required/ "items" - Список проданных ключей.  Если в заказе есть несколько **одинаковых** товаров (например, несколько ключей к одной и той же подписке), передайте каждый в виде отдельного элемента массива. &#x60;id&#x60; у этих элементов должен быть один и тот же. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvideOrderDigitalCodesRequest
instance A.FromJSON ProvideOrderDigitalCodesRequest where
  parseJSON = A.withObject "ProvideOrderDigitalCodesRequest" $ \o ->
    ProvideOrderDigitalCodesRequest
      <$> (o .:  "items")

-- | ToJSON ProvideOrderDigitalCodesRequest
instance A.ToJSON ProvideOrderDigitalCodesRequest where
  toJSON ProvideOrderDigitalCodesRequest {..} =
   _omitNulls
      [ "items" .= provideOrderDigitalCodesRequestItems
      ]


-- | Construct a value of type 'ProvideOrderDigitalCodesRequest' (by applying it's required fields, if any)
mkProvideOrderDigitalCodesRequest
  :: [OrderDigitalItemDTO] -- ^ 'provideOrderDigitalCodesRequestItems': Список проданных ключей.  Если в заказе есть несколько **одинаковых** товаров (например, несколько ключей к одной и той же подписке), передайте каждый в виде отдельного элемента массива. `id` у этих элементов должен быть один и тот же. 
  -> ProvideOrderDigitalCodesRequest
mkProvideOrderDigitalCodesRequest provideOrderDigitalCodesRequestItems =
  ProvideOrderDigitalCodesRequest
  { provideOrderDigitalCodesRequestItems
  }

-- ** ProvideOrderItemIdentifiersRequest
-- | ProvideOrderItemIdentifiersRequest
data ProvideOrderItemIdentifiersRequest = ProvideOrderItemIdentifiersRequest
  { provideOrderItemIdentifiersRequestItems :: !([OrderItemInstanceModificationDTO]) -- ^ /Required/ "items" - Список позиций, требующих маркировки. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvideOrderItemIdentifiersRequest
instance A.FromJSON ProvideOrderItemIdentifiersRequest where
  parseJSON = A.withObject "ProvideOrderItemIdentifiersRequest" $ \o ->
    ProvideOrderItemIdentifiersRequest
      <$> (o .:  "items")

-- | ToJSON ProvideOrderItemIdentifiersRequest
instance A.ToJSON ProvideOrderItemIdentifiersRequest where
  toJSON ProvideOrderItemIdentifiersRequest {..} =
   _omitNulls
      [ "items" .= provideOrderItemIdentifiersRequestItems
      ]


-- | Construct a value of type 'ProvideOrderItemIdentifiersRequest' (by applying it's required fields, if any)
mkProvideOrderItemIdentifiersRequest
  :: [OrderItemInstanceModificationDTO] -- ^ 'provideOrderItemIdentifiersRequestItems': Список позиций, требующих маркировки. 
  -> ProvideOrderItemIdentifiersRequest
mkProvideOrderItemIdentifiersRequest provideOrderItemIdentifiersRequestItems =
  ProvideOrderItemIdentifiersRequest
  { provideOrderItemIdentifiersRequestItems
  }

-- ** ProvideOrderItemIdentifiersResponse
-- | ProvideOrderItemIdentifiersResponse
data ProvideOrderItemIdentifiersResponse = ProvideOrderItemIdentifiersResponse
  { provideOrderItemIdentifiersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , provideOrderItemIdentifiersResponseResult :: !(Maybe OrderItemsModificationResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvideOrderItemIdentifiersResponse
instance A.FromJSON ProvideOrderItemIdentifiersResponse where
  parseJSON = A.withObject "ProvideOrderItemIdentifiersResponse" $ \o ->
    ProvideOrderItemIdentifiersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON ProvideOrderItemIdentifiersResponse
instance A.ToJSON ProvideOrderItemIdentifiersResponse where
  toJSON ProvideOrderItemIdentifiersResponse {..} =
   _omitNulls
      [ "status" .= provideOrderItemIdentifiersResponseStatus
      , "result" .= provideOrderItemIdentifiersResponseResult
      ]


-- | Construct a value of type 'ProvideOrderItemIdentifiersResponse' (by applying it's required fields, if any)
mkProvideOrderItemIdentifiersResponse
  :: ProvideOrderItemIdentifiersResponse
mkProvideOrderItemIdentifiersResponse =
  ProvideOrderItemIdentifiersResponse
  { provideOrderItemIdentifiersResponseStatus = Nothing
  , provideOrderItemIdentifiersResponseResult = Nothing
  }

-- ** PutSkuBidsRequest
-- | PutSkuBidsRequest
-- description.
data PutSkuBidsRequest = PutSkuBidsRequest
  { putSkuBidsRequestBids :: !([SkuBidItemDTO]) -- ^ /Required/ "bids" - Список товаров и ставки для продвижения, которые на них нужно установить.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PutSkuBidsRequest
instance A.FromJSON PutSkuBidsRequest where
  parseJSON = A.withObject "PutSkuBidsRequest" $ \o ->
    PutSkuBidsRequest
      <$> (o .:  "bids")

-- | ToJSON PutSkuBidsRequest
instance A.ToJSON PutSkuBidsRequest where
  toJSON PutSkuBidsRequest {..} =
   _omitNulls
      [ "bids" .= putSkuBidsRequestBids
      ]


-- | Construct a value of type 'PutSkuBidsRequest' (by applying it's required fields, if any)
mkPutSkuBidsRequest
  :: [SkuBidItemDTO] -- ^ 'putSkuBidsRequestBids': Список товаров и ставки для продвижения, которые на них нужно установить.
  -> PutSkuBidsRequest
mkPutSkuBidsRequest putSkuBidsRequestBids =
  PutSkuBidsRequest
  { putSkuBidsRequestBids
  }

-- ** QualityRatingAffectedOrderDTO
-- | QualityRatingAffectedOrderDTO
-- Информация о заказе, который повлиял на индекс качества.
data QualityRatingAffectedOrderDTO = QualityRatingAffectedOrderDTO
  { qualityRatingAffectedOrderDTOOrderId :: !(Integer) -- ^ /Required/ "orderId" - Идентификатор заказа.
  , qualityRatingAffectedOrderDTODescription :: !(Text) -- ^ /Required/ "description" - Описание проблемы.
  , qualityRatingAffectedOrderDTOComponentType :: !(AffectedOrderQualityRatingComponentType) -- ^ /Required/ "componentType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QualityRatingAffectedOrderDTO
instance A.FromJSON QualityRatingAffectedOrderDTO where
  parseJSON = A.withObject "QualityRatingAffectedOrderDTO" $ \o ->
    QualityRatingAffectedOrderDTO
      <$> (o .:  "orderId")
      <*> (o .:  "description")
      <*> (o .:  "componentType")

-- | ToJSON QualityRatingAffectedOrderDTO
instance A.ToJSON QualityRatingAffectedOrderDTO where
  toJSON QualityRatingAffectedOrderDTO {..} =
   _omitNulls
      [ "orderId" .= qualityRatingAffectedOrderDTOOrderId
      , "description" .= qualityRatingAffectedOrderDTODescription
      , "componentType" .= qualityRatingAffectedOrderDTOComponentType
      ]


-- | Construct a value of type 'QualityRatingAffectedOrderDTO' (by applying it's required fields, if any)
mkQualityRatingAffectedOrderDTO
  :: Integer -- ^ 'qualityRatingAffectedOrderDTOOrderId': Идентификатор заказа.
  -> Text -- ^ 'qualityRatingAffectedOrderDTODescription': Описание проблемы.
  -> AffectedOrderQualityRatingComponentType -- ^ 'qualityRatingAffectedOrderDTOComponentType' 
  -> QualityRatingAffectedOrderDTO
mkQualityRatingAffectedOrderDTO qualityRatingAffectedOrderDTOOrderId qualityRatingAffectedOrderDTODescription qualityRatingAffectedOrderDTOComponentType =
  QualityRatingAffectedOrderDTO
  { qualityRatingAffectedOrderDTOOrderId
  , qualityRatingAffectedOrderDTODescription
  , qualityRatingAffectedOrderDTOComponentType
  }

-- ** QualityRatingComponentDTO
-- | QualityRatingComponentDTO
-- Составляющая индекса качества.
data QualityRatingComponentDTO = QualityRatingComponentDTO
  { qualityRatingComponentDTOValue :: !(Double) -- ^ /Required/ "value" - Значение составляющей в процентах.
  , qualityRatingComponentDTOComponentType :: !(QualityRatingComponentType) -- ^ /Required/ "componentType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QualityRatingComponentDTO
instance A.FromJSON QualityRatingComponentDTO where
  parseJSON = A.withObject "QualityRatingComponentDTO" $ \o ->
    QualityRatingComponentDTO
      <$> (o .:  "value")
      <*> (o .:  "componentType")

-- | ToJSON QualityRatingComponentDTO
instance A.ToJSON QualityRatingComponentDTO where
  toJSON QualityRatingComponentDTO {..} =
   _omitNulls
      [ "value" .= qualityRatingComponentDTOValue
      , "componentType" .= qualityRatingComponentDTOComponentType
      ]


-- | Construct a value of type 'QualityRatingComponentDTO' (by applying it's required fields, if any)
mkQualityRatingComponentDTO
  :: Double -- ^ 'qualityRatingComponentDTOValue': Значение составляющей в процентах.
  -> QualityRatingComponentType -- ^ 'qualityRatingComponentDTOComponentType' 
  -> QualityRatingComponentDTO
mkQualityRatingComponentDTO qualityRatingComponentDTOValue qualityRatingComponentDTOComponentType =
  QualityRatingComponentDTO
  { qualityRatingComponentDTOValue
  , qualityRatingComponentDTOComponentType
  }

-- ** QualityRatingDTO
-- | QualityRatingDTO
-- Информация об индексе качества.
data QualityRatingDTO = QualityRatingDTO
  { qualityRatingDTORating :: !(Integer) -- ^ /Required/ "rating" - Значение индекса качества.
  , qualityRatingDTOCalculationDate :: !(Date) -- ^ /Required/ "calculationDate" - Дата вычисления.  Формат даты: &#x60;ГГГГ‑ММ‑ДД&#x60;. 
  , qualityRatingDTOComponents :: !([QualityRatingComponentDTO]) -- ^ /Required/ "components" - Составляющие индекса качества.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QualityRatingDTO
instance A.FromJSON QualityRatingDTO where
  parseJSON = A.withObject "QualityRatingDTO" $ \o ->
    QualityRatingDTO
      <$> (o .:  "rating")
      <*> (o .:  "calculationDate")
      <*> (o .:  "components")

-- | ToJSON QualityRatingDTO
instance A.ToJSON QualityRatingDTO where
  toJSON QualityRatingDTO {..} =
   _omitNulls
      [ "rating" .= qualityRatingDTORating
      , "calculationDate" .= qualityRatingDTOCalculationDate
      , "components" .= qualityRatingDTOComponents
      ]


-- | Construct a value of type 'QualityRatingDTO' (by applying it's required fields, if any)
mkQualityRatingDTO
  :: Integer -- ^ 'qualityRatingDTORating': Значение индекса качества.
  -> Date -- ^ 'qualityRatingDTOCalculationDate': Дата вычисления.  Формат даты: `ГГГГ‑ММ‑ДД`. 
  -> [QualityRatingComponentDTO] -- ^ 'qualityRatingDTOComponents': Составляющие индекса качества.
  -> QualityRatingDTO
mkQualityRatingDTO qualityRatingDTORating qualityRatingDTOCalculationDate qualityRatingDTOComponents =
  QualityRatingDTO
  { qualityRatingDTORating
  , qualityRatingDTOCalculationDate
  , qualityRatingDTOComponents
  }

-- ** QualityRatingDetailsDTO
-- | QualityRatingDetailsDTO
-- Информация о заказах, которые повлияли на индекс качества.
data QualityRatingDetailsDTO = QualityRatingDetailsDTO
  { qualityRatingDetailsDTOAffectedOrders :: !([QualityRatingAffectedOrderDTO]) -- ^ /Required/ "affectedOrders" - Список заказов, которые повлияли на индекс качества.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QualityRatingDetailsDTO
instance A.FromJSON QualityRatingDetailsDTO where
  parseJSON = A.withObject "QualityRatingDetailsDTO" $ \o ->
    QualityRatingDetailsDTO
      <$> (o .:  "affectedOrders")

-- | ToJSON QualityRatingDetailsDTO
instance A.ToJSON QualityRatingDetailsDTO where
  toJSON QualityRatingDetailsDTO {..} =
   _omitNulls
      [ "affectedOrders" .= qualityRatingDetailsDTOAffectedOrders
      ]


-- | Construct a value of type 'QualityRatingDetailsDTO' (by applying it's required fields, if any)
mkQualityRatingDetailsDTO
  :: [QualityRatingAffectedOrderDTO] -- ^ 'qualityRatingDetailsDTOAffectedOrders': Список заказов, которые повлияли на индекс качества.
  -> QualityRatingDetailsDTO
mkQualityRatingDetailsDTO qualityRatingDetailsDTOAffectedOrders =
  QualityRatingDetailsDTO
  { qualityRatingDetailsDTOAffectedOrders
  }

-- ** QuantumDTO
-- | QuantumDTO
-- Настройка продажи квантами.  Чтобы сбросить установленные ранее значения, передайте пустой параметр `quantum`.  {% cut \"Пример\" %}  ```json {   \"offers\": [     {       \"offerId\": \"08e35dc1-89a2-11e3-8055-0015e9b8c48d\",       \"quantum\": {}     }   ] } ```  {% endcut %} 
data QuantumDTO = QuantumDTO
  { quantumDTOMinQuantity :: !(Maybe Int) -- ^ "minQuantity" - Минимальное количество единиц товара в заказе. Например, если указать 10, покупатель сможет добавить в корзину не меньше 10 единиц.  ⚠️ Если количество товара на складе меньше заданного, ограничение не сработает и покупатель сможет его заказать. 
  , quantumDTOStepQuantity :: !(Maybe Int) -- ^ "stepQuantity" - На сколько единиц покупатель сможет увеличить количество товара в корзине.  Например, если задать 5, покупатель сможет добавить к заказу только 5, 10, 15, ... единиц товара.  ⚠️ Если количество товара на складе не дотягивает до кванта, ограничение не сработает и покупатель сможет заказать количество, не кратное кванту. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QuantumDTO
instance A.FromJSON QuantumDTO where
  parseJSON = A.withObject "QuantumDTO" $ \o ->
    QuantumDTO
      <$> (o .:? "minQuantity")
      <*> (o .:? "stepQuantity")

-- | ToJSON QuantumDTO
instance A.ToJSON QuantumDTO where
  toJSON QuantumDTO {..} =
   _omitNulls
      [ "minQuantity" .= quantumDTOMinQuantity
      , "stepQuantity" .= quantumDTOStepQuantity
      ]


-- | Construct a value of type 'QuantumDTO' (by applying it's required fields, if any)
mkQuantumDTO
  :: QuantumDTO
mkQuantumDTO =
  QuantumDTO
  { quantumDTOMinQuantity = Nothing
  , quantumDTOStepQuantity = Nothing
  }

-- ** QuarantineOfferDTO
-- | QuarantineOfferDTO
-- Товар в карантине.
data QuarantineOfferDTO = QuarantineOfferDTO
  { quarantineOfferDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , quarantineOfferDTOCurrentPrice :: !(Maybe BasePriceDTO) -- ^ "currentPrice"
  , quarantineOfferDTOLastValidPrice :: !(Maybe BasePriceDTO) -- ^ "lastValidPrice"
  , quarantineOfferDTOVerdicts :: !(Maybe [PriceQuarantineVerdictDTO]) -- ^ "verdicts" - Причины попадания товара в карантин.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QuarantineOfferDTO
instance A.FromJSON QuarantineOfferDTO where
  parseJSON = A.withObject "QuarantineOfferDTO" $ \o ->
    QuarantineOfferDTO
      <$> (o .:? "offerId")
      <*> (o .:? "currentPrice")
      <*> (o .:? "lastValidPrice")
      <*> (o .:? "verdicts")

-- | ToJSON QuarantineOfferDTO
instance A.ToJSON QuarantineOfferDTO where
  toJSON QuarantineOfferDTO {..} =
   _omitNulls
      [ "offerId" .= quarantineOfferDTOOfferId
      , "currentPrice" .= quarantineOfferDTOCurrentPrice
      , "lastValidPrice" .= quarantineOfferDTOLastValidPrice
      , "verdicts" .= quarantineOfferDTOVerdicts
      ]


-- | Construct a value of type 'QuarantineOfferDTO' (by applying it's required fields, if any)
mkQuarantineOfferDTO
  :: QuarantineOfferDTO
mkQuarantineOfferDTO =
  QuarantineOfferDTO
  { quarantineOfferDTOOfferId = Nothing
  , quarantineOfferDTOCurrentPrice = Nothing
  , quarantineOfferDTOLastValidPrice = Nothing
  , quarantineOfferDTOVerdicts = Nothing
  }

-- ** RegionDTO
-- | RegionDTO
-- Регион доставки.
data RegionDTO = RegionDTO
  { regionDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор региона.
  , regionDTOName :: !(Text) -- ^ /Required/ "name" - Название региона.
  , regionDTOType :: !(RegionType) -- ^ /Required/ "type"
  , regionDTOParent :: !(Maybe RegionDTO) -- ^ "parent"
  , regionDTOChildren :: !(Maybe [RegionDTO]) -- ^ "children" - Дочерние регионы.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RegionDTO
instance A.FromJSON RegionDTO where
  parseJSON = A.withObject "RegionDTO" $ \o ->
    RegionDTO
      <$> (o .:? "id")
      <*> (o .:  "name")
      <*> (o .:  "type")
      <*> (o .:? "parent")
      <*> (o .:? "children")

-- | ToJSON RegionDTO
instance A.ToJSON RegionDTO where
  toJSON RegionDTO {..} =
   _omitNulls
      [ "id" .= regionDTOId
      , "name" .= regionDTOName
      , "type" .= regionDTOType
      , "parent" .= regionDTOParent
      , "children" .= regionDTOChildren
      ]


-- | Construct a value of type 'RegionDTO' (by applying it's required fields, if any)
mkRegionDTO
  :: Text -- ^ 'regionDTOName': Название региона.
  -> RegionType -- ^ 'regionDTOType' 
  -> RegionDTO
mkRegionDTO regionDTOName regionDTOType =
  RegionDTO
  { regionDTOId = Nothing
  , regionDTOName
  , regionDTOType
  , regionDTOParent = Nothing
  , regionDTOChildren = Nothing
  }

-- ** RegionalModelInfoDTO
-- | RegionalModelInfoDTO
-- Региональная информация.
data RegionalModelInfoDTO = RegionalModelInfoDTO
  { regionalModelInfoDTOCurrency :: !(Maybe CurrencyType) -- ^ "currency"
  , regionalModelInfoDTORegionId :: !(Maybe Integer) -- ^ "regionId" - Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RegionalModelInfoDTO
instance A.FromJSON RegionalModelInfoDTO where
  parseJSON = A.withObject "RegionalModelInfoDTO" $ \o ->
    RegionalModelInfoDTO
      <$> (o .:? "currency")
      <*> (o .:? "regionId")

-- | ToJSON RegionalModelInfoDTO
instance A.ToJSON RegionalModelInfoDTO where
  toJSON RegionalModelInfoDTO {..} =
   _omitNulls
      [ "currency" .= regionalModelInfoDTOCurrency
      , "regionId" .= regionalModelInfoDTORegionId
      ]


-- | Construct a value of type 'RegionalModelInfoDTO' (by applying it's required fields, if any)
mkRegionalModelInfoDTO
  :: RegionalModelInfoDTO
mkRegionalModelInfoDTO =
  RegionalModelInfoDTO
  { regionalModelInfoDTOCurrency = Nothing
  , regionalModelInfoDTORegionId = Nothing
  }

-- ** RejectedPromoOfferDeleteDTO
-- | RejectedPromoOfferDeleteDTO
-- Информация о товаре и ошибки, которые появились при его удалении.
data RejectedPromoOfferDeleteDTO = RejectedPromoOfferDeleteDTO
  { rejectedPromoOfferDeleteDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , rejectedPromoOfferDeleteDTOReason :: !(RejectedPromoOfferDeleteReasonType) -- ^ /Required/ "reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RejectedPromoOfferDeleteDTO
instance A.FromJSON RejectedPromoOfferDeleteDTO where
  parseJSON = A.withObject "RejectedPromoOfferDeleteDTO" $ \o ->
    RejectedPromoOfferDeleteDTO
      <$> (o .:  "offerId")
      <*> (o .:  "reason")

-- | ToJSON RejectedPromoOfferDeleteDTO
instance A.ToJSON RejectedPromoOfferDeleteDTO where
  toJSON RejectedPromoOfferDeleteDTO {..} =
   _omitNulls
      [ "offerId" .= rejectedPromoOfferDeleteDTOOfferId
      , "reason" .= rejectedPromoOfferDeleteDTOReason
      ]


-- | Construct a value of type 'RejectedPromoOfferDeleteDTO' (by applying it's required fields, if any)
mkRejectedPromoOfferDeleteDTO
  :: Text -- ^ 'rejectedPromoOfferDeleteDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> RejectedPromoOfferDeleteReasonType -- ^ 'rejectedPromoOfferDeleteDTOReason' 
  -> RejectedPromoOfferDeleteDTO
mkRejectedPromoOfferDeleteDTO rejectedPromoOfferDeleteDTOOfferId rejectedPromoOfferDeleteDTOReason =
  RejectedPromoOfferDeleteDTO
  { rejectedPromoOfferDeleteDTOOfferId
  , rejectedPromoOfferDeleteDTOReason
  }

-- ** RejectedPromoOfferUpdateDTO
-- | RejectedPromoOfferUpdateDTO
-- Описание отклоненного изменения.
data RejectedPromoOfferUpdateDTO = RejectedPromoOfferUpdateDTO
  { rejectedPromoOfferUpdateDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , rejectedPromoOfferUpdateDTOReason :: !(RejectedPromoOfferUpdateReasonType) -- ^ /Required/ "reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RejectedPromoOfferUpdateDTO
instance A.FromJSON RejectedPromoOfferUpdateDTO where
  parseJSON = A.withObject "RejectedPromoOfferUpdateDTO" $ \o ->
    RejectedPromoOfferUpdateDTO
      <$> (o .:  "offerId")
      <*> (o .:  "reason")

-- | ToJSON RejectedPromoOfferUpdateDTO
instance A.ToJSON RejectedPromoOfferUpdateDTO where
  toJSON RejectedPromoOfferUpdateDTO {..} =
   _omitNulls
      [ "offerId" .= rejectedPromoOfferUpdateDTOOfferId
      , "reason" .= rejectedPromoOfferUpdateDTOReason
      ]


-- | Construct a value of type 'RejectedPromoOfferUpdateDTO' (by applying it's required fields, if any)
mkRejectedPromoOfferUpdateDTO
  :: Text -- ^ 'rejectedPromoOfferUpdateDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> RejectedPromoOfferUpdateReasonType -- ^ 'rejectedPromoOfferUpdateDTOReason' 
  -> RejectedPromoOfferUpdateDTO
mkRejectedPromoOfferUpdateDTO rejectedPromoOfferUpdateDTOOfferId rejectedPromoOfferUpdateDTOReason =
  RejectedPromoOfferUpdateDTO
  { rejectedPromoOfferUpdateDTOOfferId
  , rejectedPromoOfferUpdateDTOReason
  }

-- ** ReportInfoDTO
-- | ReportInfoDTO
-- Статус генерации и ссылка на готовый отчет.
data ReportInfoDTO = ReportInfoDTO
  { reportInfoDTOStatus :: !(ReportStatusType) -- ^ /Required/ "status"
  , reportInfoDTOSubStatus :: !(Maybe ReportSubStatusType) -- ^ "subStatus"
  , reportInfoDTOGenerationRequestedAt :: !(DateTime) -- ^ /Required/ "generationRequestedAt" - Дата и время запроса на генерацию.
  , reportInfoDTOGenerationFinishedAt :: !(Maybe DateTime) -- ^ "generationFinishedAt" - Дата и время завершения генерации.
  , reportInfoDTOFile :: !(Maybe Text) -- ^ "file" - Ссылка на готовый отчет.
  , reportInfoDTOEstimatedGenerationTime :: !(Maybe Integer) -- ^ "estimatedGenerationTime" - Ожидаемая продолжительность генерации в миллисекундах.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReportInfoDTO
instance A.FromJSON ReportInfoDTO where
  parseJSON = A.withObject "ReportInfoDTO" $ \o ->
    ReportInfoDTO
      <$> (o .:  "status")
      <*> (o .:? "subStatus")
      <*> (o .:  "generationRequestedAt")
      <*> (o .:? "generationFinishedAt")
      <*> (o .:? "file")
      <*> (o .:? "estimatedGenerationTime")

-- | ToJSON ReportInfoDTO
instance A.ToJSON ReportInfoDTO where
  toJSON ReportInfoDTO {..} =
   _omitNulls
      [ "status" .= reportInfoDTOStatus
      , "subStatus" .= reportInfoDTOSubStatus
      , "generationRequestedAt" .= reportInfoDTOGenerationRequestedAt
      , "generationFinishedAt" .= reportInfoDTOGenerationFinishedAt
      , "file" .= reportInfoDTOFile
      , "estimatedGenerationTime" .= reportInfoDTOEstimatedGenerationTime
      ]


-- | Construct a value of type 'ReportInfoDTO' (by applying it's required fields, if any)
mkReportInfoDTO
  :: ReportStatusType -- ^ 'reportInfoDTOStatus' 
  -> DateTime -- ^ 'reportInfoDTOGenerationRequestedAt': Дата и время запроса на генерацию.
  -> ReportInfoDTO
mkReportInfoDTO reportInfoDTOStatus reportInfoDTOGenerationRequestedAt =
  ReportInfoDTO
  { reportInfoDTOStatus
  , reportInfoDTOSubStatus = Nothing
  , reportInfoDTOGenerationRequestedAt
  , reportInfoDTOGenerationFinishedAt = Nothing
  , reportInfoDTOFile = Nothing
  , reportInfoDTOEstimatedGenerationTime = Nothing
  }

-- ** ReturnDTO
-- | ReturnDTO
-- Возврат заказа.
data ReturnDTO = ReturnDTO
  { returnDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор возврата.
  , returnDTOOrderId :: !(Maybe Integer) -- ^ "orderId" - Номер заказа.
  , returnDTOCreationDate :: !(Maybe DateTime) -- ^ "creationDate" - Дата создания возврата клиентом.
  , returnDTOUpdateDate :: !(Maybe DateTime) -- ^ "updateDate" - Дата обновления возврата.
  , returnDTORefundStatus :: !(Maybe RefundStatusType) -- ^ "refundStatus"
  , returnDTOLogisticPickupPoint :: !(Maybe LogisticPickupPointDTO) -- ^ "logisticPickupPoint"
  , returnDTOShipmentRecipientType :: !(Maybe RecipientType) -- ^ "shipmentRecipientType"
  , returnDTOShipmentStatus :: !(Maybe ReturnShipmentStatusType) -- ^ "shipmentStatus"
  , returnDTORefundAmount :: !(Maybe Integer) -- ^ "refundAmount" - Сумма возврата.
  , returnDTOItems :: !([ReturnItemDTO]) -- ^ /Required/ "items" - Список товаров в возврате.
  , returnDTOReturnType :: !(Maybe ReturnType) -- ^ "returnType"
  , returnDTOFastReturn :: !(Maybe Bool) -- ^ "fastReturn" - Используется ли опция **Быстрый возврат денег за дешевый брак**. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReturnDTO
instance A.FromJSON ReturnDTO where
  parseJSON = A.withObject "ReturnDTO" $ \o ->
    ReturnDTO
      <$> (o .:? "id")
      <*> (o .:? "orderId")
      <*> (o .:? "creationDate")
      <*> (o .:? "updateDate")
      <*> (o .:? "refundStatus")
      <*> (o .:? "logisticPickupPoint")
      <*> (o .:? "shipmentRecipientType")
      <*> (o .:? "shipmentStatus")
      <*> (o .:? "refundAmount")
      <*> (o .:  "items")
      <*> (o .:? "returnType")
      <*> (o .:? "fastReturn")

-- | ToJSON ReturnDTO
instance A.ToJSON ReturnDTO where
  toJSON ReturnDTO {..} =
   _omitNulls
      [ "id" .= returnDTOId
      , "orderId" .= returnDTOOrderId
      , "creationDate" .= returnDTOCreationDate
      , "updateDate" .= returnDTOUpdateDate
      , "refundStatus" .= returnDTORefundStatus
      , "logisticPickupPoint" .= returnDTOLogisticPickupPoint
      , "shipmentRecipientType" .= returnDTOShipmentRecipientType
      , "shipmentStatus" .= returnDTOShipmentStatus
      , "refundAmount" .= returnDTORefundAmount
      , "items" .= returnDTOItems
      , "returnType" .= returnDTOReturnType
      , "fastReturn" .= returnDTOFastReturn
      ]


-- | Construct a value of type 'ReturnDTO' (by applying it's required fields, if any)
mkReturnDTO
  :: [ReturnItemDTO] -- ^ 'returnDTOItems': Список товаров в возврате.
  -> ReturnDTO
mkReturnDTO returnDTOItems =
  ReturnDTO
  { returnDTOId = Nothing
  , returnDTOOrderId = Nothing
  , returnDTOCreationDate = Nothing
  , returnDTOUpdateDate = Nothing
  , returnDTORefundStatus = Nothing
  , returnDTOLogisticPickupPoint = Nothing
  , returnDTOShipmentRecipientType = Nothing
  , returnDTOShipmentStatus = Nothing
  , returnDTORefundAmount = Nothing
  , returnDTOItems
  , returnDTOReturnType = Nothing
  , returnDTOFastReturn = Nothing
  }

-- ** ReturnDecisionDTO
-- | ReturnDecisionDTO
-- Решения по возвратам.
data ReturnDecisionDTO = ReturnDecisionDTO
  { returnDecisionDTOReturnItemId :: !(Maybe Integer) -- ^ "returnItemId" - Идентификатор товара в возврате.
  , returnDecisionDTOCount :: !(Maybe Int) -- ^ "count" - Количество единиц товара.
  , returnDecisionDTOComment :: !(Maybe Text) -- ^ "comment" - Комментарий.
  , returnDecisionDTOReasonType :: !(Maybe ReturnDecisionReasonType) -- ^ "reasonType"
  , returnDecisionDTOSubreasonType :: !(Maybe ReturnDecisionSubreasonType) -- ^ "subreasonType"
  , returnDecisionDTODecisionType :: !(Maybe ReturnDecisionType) -- ^ "decisionType"
  , returnDecisionDTORefundAmount :: !(Maybe Integer) -- ^ "refundAmount" - Сумма возврата.
  , returnDecisionDTOPartnerCompensation :: !(Maybe Integer) -- ^ "partnerCompensation" - Компенсация за обратную доставку.
  , returnDecisionDTOImages :: !(Maybe [Text]) -- ^ "images" - Список хеш-кодов фотографий товара от покупателя.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReturnDecisionDTO
instance A.FromJSON ReturnDecisionDTO where
  parseJSON = A.withObject "ReturnDecisionDTO" $ \o ->
    ReturnDecisionDTO
      <$> (o .:? "returnItemId")
      <*> (o .:? "count")
      <*> (o .:? "comment")
      <*> (o .:? "reasonType")
      <*> (o .:? "subreasonType")
      <*> (o .:? "decisionType")
      <*> (o .:? "refundAmount")
      <*> (o .:? "partnerCompensation")
      <*> (o .:? "images")

-- | ToJSON ReturnDecisionDTO
instance A.ToJSON ReturnDecisionDTO where
  toJSON ReturnDecisionDTO {..} =
   _omitNulls
      [ "returnItemId" .= returnDecisionDTOReturnItemId
      , "count" .= returnDecisionDTOCount
      , "comment" .= returnDecisionDTOComment
      , "reasonType" .= returnDecisionDTOReasonType
      , "subreasonType" .= returnDecisionDTOSubreasonType
      , "decisionType" .= returnDecisionDTODecisionType
      , "refundAmount" .= returnDecisionDTORefundAmount
      , "partnerCompensation" .= returnDecisionDTOPartnerCompensation
      , "images" .= returnDecisionDTOImages
      ]


-- | Construct a value of type 'ReturnDecisionDTO' (by applying it's required fields, if any)
mkReturnDecisionDTO
  :: ReturnDecisionDTO
mkReturnDecisionDTO =
  ReturnDecisionDTO
  { returnDecisionDTOReturnItemId = Nothing
  , returnDecisionDTOCount = Nothing
  , returnDecisionDTOComment = Nothing
  , returnDecisionDTOReasonType = Nothing
  , returnDecisionDTOSubreasonType = Nothing
  , returnDecisionDTODecisionType = Nothing
  , returnDecisionDTORefundAmount = Nothing
  , returnDecisionDTOPartnerCompensation = Nothing
  , returnDecisionDTOImages = Nothing
  }

-- ** ReturnInstanceDTO
-- | ReturnInstanceDTO
-- Логистическая информация по возврату.
data ReturnInstanceDTO = ReturnInstanceDTO
  { returnInstanceDTOStockType :: !(Maybe ReturnInstanceStockType) -- ^ "stockType"
  , returnInstanceDTOStatus :: !(Maybe ReturnInstanceStatusType) -- ^ "status"
  , returnInstanceDTOCis :: !(Maybe Text) -- ^ "cis" - Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).
  , returnInstanceDTOImei :: !(Maybe Text) -- ^ "imei" - Международный идентификатор мобильного оборудования.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReturnInstanceDTO
instance A.FromJSON ReturnInstanceDTO where
  parseJSON = A.withObject "ReturnInstanceDTO" $ \o ->
    ReturnInstanceDTO
      <$> (o .:? "stockType")
      <*> (o .:? "status")
      <*> (o .:? "cis")
      <*> (o .:? "imei")

-- | ToJSON ReturnInstanceDTO
instance A.ToJSON ReturnInstanceDTO where
  toJSON ReturnInstanceDTO {..} =
   _omitNulls
      [ "stockType" .= returnInstanceDTOStockType
      , "status" .= returnInstanceDTOStatus
      , "cis" .= returnInstanceDTOCis
      , "imei" .= returnInstanceDTOImei
      ]


-- | Construct a value of type 'ReturnInstanceDTO' (by applying it's required fields, if any)
mkReturnInstanceDTO
  :: ReturnInstanceDTO
mkReturnInstanceDTO =
  ReturnInstanceDTO
  { returnInstanceDTOStockType = Nothing
  , returnInstanceDTOStatus = Nothing
  , returnInstanceDTOCis = Nothing
  , returnInstanceDTOImei = Nothing
  }

-- ** ReturnItemDTO
-- | ReturnItemDTO
-- Список товаров в возврате.
data ReturnItemDTO = ReturnItemDTO
  { returnItemDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  , returnItemDTOShopSku :: !(Text) -- ^ /Required/ "shopSku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , returnItemDTOCount :: !(Integer) -- ^ /Required/ "count" - Количество единиц товара.
  , returnItemDTODecisions :: !(Maybe [ReturnDecisionDTO]) -- ^ "decisions" - Список решений по возврату.
  , returnItemDTOInstances :: !(Maybe [ReturnInstanceDTO]) -- ^ "instances" - Список логистических позиций возврата.
  , returnItemDTOTracks :: !(Maybe [TrackDTO]) -- ^ "tracks" - Список трек-кодов для почтовых отправлений.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReturnItemDTO
instance A.FromJSON ReturnItemDTO where
  parseJSON = A.withObject "ReturnItemDTO" $ \o ->
    ReturnItemDTO
      <$> (o .:? "marketSku")
      <*> (o .:  "shopSku")
      <*> (o .:  "count")
      <*> (o .:? "decisions")
      <*> (o .:? "instances")
      <*> (o .:? "tracks")

-- | ToJSON ReturnItemDTO
instance A.ToJSON ReturnItemDTO where
  toJSON ReturnItemDTO {..} =
   _omitNulls
      [ "marketSku" .= returnItemDTOMarketSku
      , "shopSku" .= returnItemDTOShopSku
      , "count" .= returnItemDTOCount
      , "decisions" .= returnItemDTODecisions
      , "instances" .= returnItemDTOInstances
      , "tracks" .= returnItemDTOTracks
      ]


-- | Construct a value of type 'ReturnItemDTO' (by applying it's required fields, if any)
mkReturnItemDTO
  :: Text -- ^ 'returnItemDTOShopSku': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> Integer -- ^ 'returnItemDTOCount': Количество единиц товара.
  -> ReturnItemDTO
mkReturnItemDTO returnItemDTOShopSku returnItemDTOCount =
  ReturnItemDTO
  { returnItemDTOMarketSku = Nothing
  , returnItemDTOShopSku
  , returnItemDTOCount
  , returnItemDTODecisions = Nothing
  , returnItemDTOInstances = Nothing
  , returnItemDTOTracks = Nothing
  }

-- ** ScrollingPagerDTO
-- | ScrollingPagerDTO
-- Информация о страницах результатов.
data ScrollingPagerDTO = ScrollingPagerDTO
  { scrollingPagerDTONextPageToken :: !(Maybe Text) -- ^ "nextPageToken" - Идентификатор следующей страницы результатов.
  , scrollingPagerDTOPrevPageToken :: !(Maybe Text) -- ^ "prevPageToken" - Идентификатор предыдущей страницы результатов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScrollingPagerDTO
instance A.FromJSON ScrollingPagerDTO where
  parseJSON = A.withObject "ScrollingPagerDTO" $ \o ->
    ScrollingPagerDTO
      <$> (o .:? "nextPageToken")
      <*> (o .:? "prevPageToken")

-- | ToJSON ScrollingPagerDTO
instance A.ToJSON ScrollingPagerDTO where
  toJSON ScrollingPagerDTO {..} =
   _omitNulls
      [ "nextPageToken" .= scrollingPagerDTONextPageToken
      , "prevPageToken" .= scrollingPagerDTOPrevPageToken
      ]


-- | Construct a value of type 'ScrollingPagerDTO' (by applying it's required fields, if any)
mkScrollingPagerDTO
  :: ScrollingPagerDTO
mkScrollingPagerDTO =
  ScrollingPagerDTO
  { scrollingPagerDTONextPageToken = Nothing
  , scrollingPagerDTOPrevPageToken = Nothing
  }

-- ** SearchModelsResponse
-- | SearchModelsResponse
data SearchModelsResponse = SearchModelsResponse
  { searchModelsResponseModels :: !([ModelDTO]) -- ^ /Required/ "models" - Список моделей товаров.
  , searchModelsResponseCurrency :: !(Maybe CurrencyType) -- ^ "currency"
  , searchModelsResponseRegionId :: !(Maybe Integer) -- ^ "regionId" - Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
  , searchModelsResponsePager :: !(Maybe FlippingPagerDTO) -- ^ "pager"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchModelsResponse
instance A.FromJSON SearchModelsResponse where
  parseJSON = A.withObject "SearchModelsResponse" $ \o ->
    SearchModelsResponse
      <$> (o .:  "models")
      <*> (o .:? "currency")
      <*> (o .:? "regionId")
      <*> (o .:? "pager")

-- | ToJSON SearchModelsResponse
instance A.ToJSON SearchModelsResponse where
  toJSON SearchModelsResponse {..} =
   _omitNulls
      [ "models" .= searchModelsResponseModels
      , "currency" .= searchModelsResponseCurrency
      , "regionId" .= searchModelsResponseRegionId
      , "pager" .= searchModelsResponsePager
      ]


-- | Construct a value of type 'SearchModelsResponse' (by applying it's required fields, if any)
mkSearchModelsResponse
  :: [ModelDTO] -- ^ 'searchModelsResponseModels': Список моделей товаров.
  -> SearchModelsResponse
mkSearchModelsResponse searchModelsResponseModels =
  SearchModelsResponse
  { searchModelsResponseModels
  , searchModelsResponseCurrency = Nothing
  , searchModelsResponseRegionId = Nothing
  , searchModelsResponsePager = Nothing
  }

-- ** SearchShipmentsRequest
-- | SearchShipmentsRequest
-- Запрос информации об отгрузках.
data SearchShipmentsRequest = SearchShipmentsRequest
  { searchShipmentsRequestDateFrom :: !(Date) -- ^ /Required/ "dateFrom" - Начальная дата для фильтрации по дате отгрузки (включительно).  Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  , searchShipmentsRequestDateTo :: !(Date) -- ^ /Required/ "dateTo" - Конечная дата для фильтрации по дате отгрузки (включительно).  Формат даты: &#x60;ДД-ММ-ГГГГ&#x60;. 
  , searchShipmentsRequestStatuses :: !(Maybe [ShipmentStatusType]) -- ^ "statuses" - Список статусов отгрузок.
  , searchShipmentsRequestOrderIds :: !(Maybe [Integer]) -- ^ "orderIds" - Список идентификаторов заказов из отгрузок.
  , searchShipmentsRequestCancelledOrders :: !(Maybe Bool) -- ^ "cancelledOrders" - Возвращать ли отмененные заказы.  Значение по умолчанию — &#x60;true&#x60;. Если возвращать отмененные заказы не нужно, передайте значение &#x60;false&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchShipmentsRequest
instance A.FromJSON SearchShipmentsRequest where
  parseJSON = A.withObject "SearchShipmentsRequest" $ \o ->
    SearchShipmentsRequest
      <$> (o .:  "dateFrom")
      <*> (o .:  "dateTo")
      <*> (o .:? "statuses")
      <*> (o .:? "orderIds")
      <*> (o .:? "cancelledOrders")

-- | ToJSON SearchShipmentsRequest
instance A.ToJSON SearchShipmentsRequest where
  toJSON SearchShipmentsRequest {..} =
   _omitNulls
      [ "dateFrom" .= searchShipmentsRequestDateFrom
      , "dateTo" .= searchShipmentsRequestDateTo
      , "statuses" .= searchShipmentsRequestStatuses
      , "orderIds" .= searchShipmentsRequestOrderIds
      , "cancelledOrders" .= searchShipmentsRequestCancelledOrders
      ]


-- | Construct a value of type 'SearchShipmentsRequest' (by applying it's required fields, if any)
mkSearchShipmentsRequest
  :: Date -- ^ 'searchShipmentsRequestDateFrom': Начальная дата для фильтрации по дате отгрузки (включительно).  Формат даты: `ДД-ММ-ГГГГ`. 
  -> Date -- ^ 'searchShipmentsRequestDateTo': Конечная дата для фильтрации по дате отгрузки (включительно).  Формат даты: `ДД-ММ-ГГГГ`. 
  -> SearchShipmentsRequest
mkSearchShipmentsRequest searchShipmentsRequestDateFrom searchShipmentsRequestDateTo =
  SearchShipmentsRequest
  { searchShipmentsRequestDateFrom
  , searchShipmentsRequestDateTo
  , searchShipmentsRequestStatuses = Nothing
  , searchShipmentsRequestOrderIds = Nothing
  , searchShipmentsRequestCancelledOrders = Nothing
  }

-- ** SearchShipmentsResponse
-- | SearchShipmentsResponse
-- Ответ на запрос информации об отгрузках.
data SearchShipmentsResponse = SearchShipmentsResponse
  { searchShipmentsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , searchShipmentsResponseResult :: !(Maybe SearchShipmentsResponseDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchShipmentsResponse
instance A.FromJSON SearchShipmentsResponse where
  parseJSON = A.withObject "SearchShipmentsResponse" $ \o ->
    SearchShipmentsResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON SearchShipmentsResponse
instance A.ToJSON SearchShipmentsResponse where
  toJSON SearchShipmentsResponse {..} =
   _omitNulls
      [ "status" .= searchShipmentsResponseStatus
      , "result" .= searchShipmentsResponseResult
      ]


-- | Construct a value of type 'SearchShipmentsResponse' (by applying it's required fields, if any)
mkSearchShipmentsResponse
  :: SearchShipmentsResponse
mkSearchShipmentsResponse =
  SearchShipmentsResponse
  { searchShipmentsResponseStatus = Nothing
  , searchShipmentsResponseResult = Nothing
  }

-- ** SearchShipmentsResponseDTO
-- | SearchShipmentsResponseDTO
-- Информация об отгрузках.
data SearchShipmentsResponseDTO = SearchShipmentsResponseDTO
  { searchShipmentsResponseDTOShipments :: !([ShipmentInfoDTO]) -- ^ /Required/ "shipments" - Список с информацией об отгрузках.
  , searchShipmentsResponseDTOPaging :: !(Maybe ForwardScrollingPagerDTO) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchShipmentsResponseDTO
instance A.FromJSON SearchShipmentsResponseDTO where
  parseJSON = A.withObject "SearchShipmentsResponseDTO" $ \o ->
    SearchShipmentsResponseDTO
      <$> (o .:  "shipments")
      <*> (o .:? "paging")

-- | ToJSON SearchShipmentsResponseDTO
instance A.ToJSON SearchShipmentsResponseDTO where
  toJSON SearchShipmentsResponseDTO {..} =
   _omitNulls
      [ "shipments" .= searchShipmentsResponseDTOShipments
      , "paging" .= searchShipmentsResponseDTOPaging
      ]


-- | Construct a value of type 'SearchShipmentsResponseDTO' (by applying it's required fields, if any)
mkSearchShipmentsResponseDTO
  :: [ShipmentInfoDTO] -- ^ 'searchShipmentsResponseDTOShipments': Список с информацией об отгрузках.
  -> SearchShipmentsResponseDTO
mkSearchShipmentsResponseDTO searchShipmentsResponseDTOShipments =
  SearchShipmentsResponseDTO
  { searchShipmentsResponseDTOShipments
  , searchShipmentsResponseDTOPaging = Nothing
  }

-- ** SendMessageToChatRequest
-- | SendMessageToChatRequest
-- В какой чат нужно отправить сообщение и текст сообщения.
data SendMessageToChatRequest = SendMessageToChatRequest
  { sendMessageToChatRequestMessage :: !(Text) -- ^ /Required/ "message" - Текст сообщения. Максимальная длина — 4096 символа.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendMessageToChatRequest
instance A.FromJSON SendMessageToChatRequest where
  parseJSON = A.withObject "SendMessageToChatRequest" $ \o ->
    SendMessageToChatRequest
      <$> (o .:  "message")

-- | ToJSON SendMessageToChatRequest
instance A.ToJSON SendMessageToChatRequest where
  toJSON SendMessageToChatRequest {..} =
   _omitNulls
      [ "message" .= sendMessageToChatRequestMessage
      ]


-- | Construct a value of type 'SendMessageToChatRequest' (by applying it's required fields, if any)
mkSendMessageToChatRequest
  :: Text -- ^ 'sendMessageToChatRequestMessage': Текст сообщения. Максимальная длина — 4096 символа.
  -> SendMessageToChatRequest
mkSendMessageToChatRequest sendMessageToChatRequestMessage =
  SendMessageToChatRequest
  { sendMessageToChatRequestMessage
  }

-- ** SetFeedParamsRequest
-- | SetFeedParamsRequest
-- Запрос на обновление изменение параметров прайс-листа.
data SetFeedParamsRequest = SetFeedParamsRequest
  { setFeedParamsRequestParameters :: !([FeedParameterDTO]) -- ^ /Required/ "parameters" - Параметры прайс-листа.  Обязательный параметр. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SetFeedParamsRequest
instance A.FromJSON SetFeedParamsRequest where
  parseJSON = A.withObject "SetFeedParamsRequest" $ \o ->
    SetFeedParamsRequest
      <$> (o .:  "parameters")

-- | ToJSON SetFeedParamsRequest
instance A.ToJSON SetFeedParamsRequest where
  toJSON SetFeedParamsRequest {..} =
   _omitNulls
      [ "parameters" .= setFeedParamsRequestParameters
      ]


-- | Construct a value of type 'SetFeedParamsRequest' (by applying it's required fields, if any)
mkSetFeedParamsRequest
  :: [FeedParameterDTO] -- ^ 'setFeedParamsRequestParameters': Параметры прайс-листа.  Обязательный параметр. 
  -> SetFeedParamsRequest
mkSetFeedParamsRequest setFeedParamsRequestParameters =
  SetFeedParamsRequest
  { setFeedParamsRequestParameters
  }

-- ** SetOrderBoxLayoutRequest
-- | SetOrderBoxLayoutRequest
data SetOrderBoxLayoutRequest = SetOrderBoxLayoutRequest
  { setOrderBoxLayoutRequestBoxes :: !([OrderBoxLayoutDTO]) -- ^ /Required/ "boxes" - Список коробок.
  , setOrderBoxLayoutRequestAllowRemove :: !(Maybe Bool) -- ^ "allowRemove" - Передайте &#x60;true&#x60;, если вы собираетесь удалить часть товаров из заказа.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SetOrderBoxLayoutRequest
instance A.FromJSON SetOrderBoxLayoutRequest where
  parseJSON = A.withObject "SetOrderBoxLayoutRequest" $ \o ->
    SetOrderBoxLayoutRequest
      <$> (o .:  "boxes")
      <*> (o .:? "allowRemove")

-- | ToJSON SetOrderBoxLayoutRequest
instance A.ToJSON SetOrderBoxLayoutRequest where
  toJSON SetOrderBoxLayoutRequest {..} =
   _omitNulls
      [ "boxes" .= setOrderBoxLayoutRequestBoxes
      , "allowRemove" .= setOrderBoxLayoutRequestAllowRemove
      ]


-- | Construct a value of type 'SetOrderBoxLayoutRequest' (by applying it's required fields, if any)
mkSetOrderBoxLayoutRequest
  :: [OrderBoxLayoutDTO] -- ^ 'setOrderBoxLayoutRequestBoxes': Список коробок.
  -> SetOrderBoxLayoutRequest
mkSetOrderBoxLayoutRequest setOrderBoxLayoutRequestBoxes =
  SetOrderBoxLayoutRequest
  { setOrderBoxLayoutRequestBoxes
  , setOrderBoxLayoutRequestAllowRemove = Nothing
  }

-- ** SetOrderBoxLayoutResponse
-- | SetOrderBoxLayoutResponse
data SetOrderBoxLayoutResponse = SetOrderBoxLayoutResponse
  { setOrderBoxLayoutResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , setOrderBoxLayoutResponseResult :: !(Maybe OrderBoxesLayoutDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SetOrderBoxLayoutResponse
instance A.FromJSON SetOrderBoxLayoutResponse where
  parseJSON = A.withObject "SetOrderBoxLayoutResponse" $ \o ->
    SetOrderBoxLayoutResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON SetOrderBoxLayoutResponse
instance A.ToJSON SetOrderBoxLayoutResponse where
  toJSON SetOrderBoxLayoutResponse {..} =
   _omitNulls
      [ "status" .= setOrderBoxLayoutResponseStatus
      , "result" .= setOrderBoxLayoutResponseResult
      ]


-- | Construct a value of type 'SetOrderBoxLayoutResponse' (by applying it's required fields, if any)
mkSetOrderBoxLayoutResponse
  :: SetOrderBoxLayoutResponse
mkSetOrderBoxLayoutResponse =
  SetOrderBoxLayoutResponse
  { setOrderBoxLayoutResponseStatus = Nothing
  , setOrderBoxLayoutResponseResult = Nothing
  }

-- ** SetOrderDeliveryDateRequest
-- | SetOrderDeliveryDateRequest
data SetOrderDeliveryDateRequest = SetOrderDeliveryDateRequest
  { setOrderDeliveryDateRequestDates :: !(OrderDeliveryDateDTO) -- ^ /Required/ "dates"
  , setOrderDeliveryDateRequestReason :: !(OrderDeliveryDateReasonType) -- ^ /Required/ "reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SetOrderDeliveryDateRequest
instance A.FromJSON SetOrderDeliveryDateRequest where
  parseJSON = A.withObject "SetOrderDeliveryDateRequest" $ \o ->
    SetOrderDeliveryDateRequest
      <$> (o .:  "dates")
      <*> (o .:  "reason")

-- | ToJSON SetOrderDeliveryDateRequest
instance A.ToJSON SetOrderDeliveryDateRequest where
  toJSON SetOrderDeliveryDateRequest {..} =
   _omitNulls
      [ "dates" .= setOrderDeliveryDateRequestDates
      , "reason" .= setOrderDeliveryDateRequestReason
      ]


-- | Construct a value of type 'SetOrderDeliveryDateRequest' (by applying it's required fields, if any)
mkSetOrderDeliveryDateRequest
  :: OrderDeliveryDateDTO -- ^ 'setOrderDeliveryDateRequestDates' 
  -> OrderDeliveryDateReasonType -- ^ 'setOrderDeliveryDateRequestReason' 
  -> SetOrderDeliveryDateRequest
mkSetOrderDeliveryDateRequest setOrderDeliveryDateRequestDates setOrderDeliveryDateRequestReason =
  SetOrderDeliveryDateRequest
  { setOrderDeliveryDateRequestDates
  , setOrderDeliveryDateRequestReason
  }

-- ** SetOrderDeliveryTrackCodeRequest
-- | SetOrderDeliveryTrackCodeRequest
data SetOrderDeliveryTrackCodeRequest = SetOrderDeliveryTrackCodeRequest
  { setOrderDeliveryTrackCodeRequestTrackCode :: !(Text) -- ^ /Required/ "trackCode" - Трек‑номер посылки.
  , setOrderDeliveryTrackCodeRequestDeliveryServiceId :: !(Integer) -- ^ /Required/ "deliveryServiceId" - Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SetOrderDeliveryTrackCodeRequest
instance A.FromJSON SetOrderDeliveryTrackCodeRequest where
  parseJSON = A.withObject "SetOrderDeliveryTrackCodeRequest" $ \o ->
    SetOrderDeliveryTrackCodeRequest
      <$> (o .:  "trackCode")
      <*> (o .:  "deliveryServiceId")

-- | ToJSON SetOrderDeliveryTrackCodeRequest
instance A.ToJSON SetOrderDeliveryTrackCodeRequest where
  toJSON SetOrderDeliveryTrackCodeRequest {..} =
   _omitNulls
      [ "trackCode" .= setOrderDeliveryTrackCodeRequestTrackCode
      , "deliveryServiceId" .= setOrderDeliveryTrackCodeRequestDeliveryServiceId
      ]


-- | Construct a value of type 'SetOrderDeliveryTrackCodeRequest' (by applying it's required fields, if any)
mkSetOrderDeliveryTrackCodeRequest
  :: Text -- ^ 'setOrderDeliveryTrackCodeRequestTrackCode': Трек‑номер посылки.
  -> Integer -- ^ 'setOrderDeliveryTrackCodeRequestDeliveryServiceId': Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
  -> SetOrderDeliveryTrackCodeRequest
mkSetOrderDeliveryTrackCodeRequest setOrderDeliveryTrackCodeRequestTrackCode setOrderDeliveryTrackCodeRequestDeliveryServiceId =
  SetOrderDeliveryTrackCodeRequest
  { setOrderDeliveryTrackCodeRequestTrackCode
  , setOrderDeliveryTrackCodeRequestDeliveryServiceId
  }

-- ** SetOrderShipmentBoxesRequest
-- | SetOrderShipmentBoxesRequest
data SetOrderShipmentBoxesRequest = SetOrderShipmentBoxesRequest
  { setOrderShipmentBoxesRequestBoxes :: !([ParcelBoxDTO]) -- ^ /Required/ "boxes" - Список грузовых мест. Маркет определяет количество мест по длине этого списка.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SetOrderShipmentBoxesRequest
instance A.FromJSON SetOrderShipmentBoxesRequest where
  parseJSON = A.withObject "SetOrderShipmentBoxesRequest" $ \o ->
    SetOrderShipmentBoxesRequest
      <$> (o .:  "boxes")

-- | ToJSON SetOrderShipmentBoxesRequest
instance A.ToJSON SetOrderShipmentBoxesRequest where
  toJSON SetOrderShipmentBoxesRequest {..} =
   _omitNulls
      [ "boxes" .= setOrderShipmentBoxesRequestBoxes
      ]


-- | Construct a value of type 'SetOrderShipmentBoxesRequest' (by applying it's required fields, if any)
mkSetOrderShipmentBoxesRequest
  :: [ParcelBoxDTO] -- ^ 'setOrderShipmentBoxesRequestBoxes': Список грузовых мест. Маркет определяет количество мест по длине этого списка.
  -> SetOrderShipmentBoxesRequest
mkSetOrderShipmentBoxesRequest setOrderShipmentBoxesRequestBoxes =
  SetOrderShipmentBoxesRequest
  { setOrderShipmentBoxesRequestBoxes
  }

-- ** SetOrderShipmentBoxesResponse
-- | SetOrderShipmentBoxesResponse
data SetOrderShipmentBoxesResponse = SetOrderShipmentBoxesResponse
  { setOrderShipmentBoxesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , setOrderShipmentBoxesResponseResult :: !(Maybe ShipmentBoxesDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SetOrderShipmentBoxesResponse
instance A.FromJSON SetOrderShipmentBoxesResponse where
  parseJSON = A.withObject "SetOrderShipmentBoxesResponse" $ \o ->
    SetOrderShipmentBoxesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON SetOrderShipmentBoxesResponse
instance A.ToJSON SetOrderShipmentBoxesResponse where
  toJSON SetOrderShipmentBoxesResponse {..} =
   _omitNulls
      [ "status" .= setOrderShipmentBoxesResponseStatus
      , "result" .= setOrderShipmentBoxesResponseResult
      ]


-- | Construct a value of type 'SetOrderShipmentBoxesResponse' (by applying it's required fields, if any)
mkSetOrderShipmentBoxesResponse
  :: SetOrderShipmentBoxesResponse
mkSetOrderShipmentBoxesResponse =
  SetOrderShipmentBoxesResponse
  { setOrderShipmentBoxesResponseStatus = Nothing
  , setOrderShipmentBoxesResponseResult = Nothing
  }

-- ** SetReturnDecisionRequest
-- | SetReturnDecisionRequest
-- Решения по позиции в возврате.
data SetReturnDecisionRequest = SetReturnDecisionRequest
  { setReturnDecisionRequestReturnItemId :: !(Integer) -- ^ /Required/ "returnItemId" - Идентификатор товара в возврате.
  , setReturnDecisionRequestDecisionType :: !(ReturnRequestDecisionType) -- ^ /Required/ "decisionType"
  , setReturnDecisionRequestComment :: !(Maybe Text) -- ^ "comment" - Комментарий к решению. Укажите:  * для &#x60;REFUND_MONEY_INCLUDING_SHIPMENT&#x60;— стоимость обратной пересылки;  * для &#x60;REPAIR&#x60; — когда вы устраните недостатки товара;  * для &#x60;DECLINE_REFUND&#x60; — причину отказа;  * для &#x60;OTHER_DECISION&#x60; — какое решение вы предлагаете. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SetReturnDecisionRequest
instance A.FromJSON SetReturnDecisionRequest where
  parseJSON = A.withObject "SetReturnDecisionRequest" $ \o ->
    SetReturnDecisionRequest
      <$> (o .:  "returnItemId")
      <*> (o .:  "decisionType")
      <*> (o .:? "comment")

-- | ToJSON SetReturnDecisionRequest
instance A.ToJSON SetReturnDecisionRequest where
  toJSON SetReturnDecisionRequest {..} =
   _omitNulls
      [ "returnItemId" .= setReturnDecisionRequestReturnItemId
      , "decisionType" .= setReturnDecisionRequestDecisionType
      , "comment" .= setReturnDecisionRequestComment
      ]


-- | Construct a value of type 'SetReturnDecisionRequest' (by applying it's required fields, if any)
mkSetReturnDecisionRequest
  :: Integer -- ^ 'setReturnDecisionRequestReturnItemId': Идентификатор товара в возврате.
  -> ReturnRequestDecisionType -- ^ 'setReturnDecisionRequestDecisionType' 
  -> SetReturnDecisionRequest
mkSetReturnDecisionRequest setReturnDecisionRequestReturnItemId setReturnDecisionRequestDecisionType =
  SetReturnDecisionRequest
  { setReturnDecisionRequestReturnItemId
  , setReturnDecisionRequestDecisionType
  , setReturnDecisionRequestComment = Nothing
  }

-- ** SetShipmentPalletsCountRequest
-- | SetShipmentPalletsCountRequest
-- Запрос на передачу количества упаковок в отгрузке.
data SetShipmentPalletsCountRequest = SetShipmentPalletsCountRequest
  { setShipmentPalletsCountRequestPlacesCount :: !(Int) -- ^ /Required/ "placesCount" - Количество упаковок в отгрузке.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SetShipmentPalletsCountRequest
instance A.FromJSON SetShipmentPalletsCountRequest where
  parseJSON = A.withObject "SetShipmentPalletsCountRequest" $ \o ->
    SetShipmentPalletsCountRequest
      <$> (o .:  "placesCount")

-- | ToJSON SetShipmentPalletsCountRequest
instance A.ToJSON SetShipmentPalletsCountRequest where
  toJSON SetShipmentPalletsCountRequest {..} =
   _omitNulls
      [ "placesCount" .= setShipmentPalletsCountRequestPlacesCount
      ]


-- | Construct a value of type 'SetShipmentPalletsCountRequest' (by applying it's required fields, if any)
mkSetShipmentPalletsCountRequest
  :: Int -- ^ 'setShipmentPalletsCountRequestPlacesCount': Количество упаковок в отгрузке.
  -> SetShipmentPalletsCountRequest
mkSetShipmentPalletsCountRequest setShipmentPalletsCountRequestPlacesCount =
  SetShipmentPalletsCountRequest
  { setShipmentPalletsCountRequestPlacesCount
  }

-- ** ShipmentBoxesDTO
-- | ShipmentBoxesDTO
-- В ответе Маркет возвращает переданный вами список грузовых мест. Не обращайте на это поле внимания. 
data ShipmentBoxesDTO = ShipmentBoxesDTO
  { shipmentBoxesDTOBoxes :: !([ParcelBoxDTO]) -- ^ /Required/ "boxes" - Список грузовых мест. Маркет определил количество мест по длине этого списка. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ShipmentBoxesDTO
instance A.FromJSON ShipmentBoxesDTO where
  parseJSON = A.withObject "ShipmentBoxesDTO" $ \o ->
    ShipmentBoxesDTO
      <$> (o .:  "boxes")

-- | ToJSON ShipmentBoxesDTO
instance A.ToJSON ShipmentBoxesDTO where
  toJSON ShipmentBoxesDTO {..} =
   _omitNulls
      [ "boxes" .= shipmentBoxesDTOBoxes
      ]


-- | Construct a value of type 'ShipmentBoxesDTO' (by applying it's required fields, if any)
mkShipmentBoxesDTO
  :: [ParcelBoxDTO] -- ^ 'shipmentBoxesDTOBoxes': Список грузовых мест. Маркет определил количество мест по длине этого списка. 
  -> ShipmentBoxesDTO
mkShipmentBoxesDTO shipmentBoxesDTOBoxes =
  ShipmentBoxesDTO
  { shipmentBoxesDTOBoxes
  }

-- ** ShipmentDTO
-- | ShipmentDTO
-- Информация об отгрузке.
data ShipmentDTO = ShipmentDTO
  { shipmentDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор отгрузки.
  , shipmentDTOPlanIntervalFrom :: !(Maybe DateTime) -- ^ "planIntervalFrom" - Начало планового интервала отгрузки.
  , shipmentDTOPlanIntervalTo :: !(Maybe DateTime) -- ^ "planIntervalTo" - Конец планового интервала отгрузки.
  , shipmentDTOShipmentType :: !(Maybe ShipmentType) -- ^ "shipmentType"
  , shipmentDTOWarehouse :: !(Maybe PartnerShipmentWarehouseDTO) -- ^ "warehouse"
  , shipmentDTOWarehouseTo :: !(Maybe PartnerShipmentWarehouseDTO) -- ^ "warehouseTo"
  , shipmentDTOExternalId :: !(Maybe Text) -- ^ "externalId" - Идентификатор отгрузки в вашей системе. Если вы еще не передавали идентификатор, вернется идентификатор из параметра &#x60;id&#x60;.
  , shipmentDTODeliveryService :: !(Maybe DeliveryServiceDTO) -- ^ "deliveryService"
  , shipmentDTOPalletsCount :: !(Maybe PalletsCountDTO) -- ^ "palletsCount"
  , shipmentDTOOrderIds :: !([Integer]) -- ^ /Required/ "orderIds" - Идентификаторы заказов в отгрузке.
  , shipmentDTODraftCount :: !(Maybe Int) -- ^ "draftCount" - Количество заказов, которое Маркет запланировал к отгрузке.
  , shipmentDTOPlannedCount :: !(Maybe Int) -- ^ "plannedCount" - Количество заказов, которое Маркет подтвердил к отгрузке.
  , shipmentDTOFactCount :: !(Maybe Int) -- ^ "factCount" - Количество заказов, принятых в сортировочном центре или пункте приема.
  , shipmentDTOCurrentStatus :: !(Maybe ShipmentStatusChangeDTO) -- ^ "currentStatus"
  , shipmentDTOAvailableActions :: !([ShipmentActionType]) -- ^ /Required/ "availableActions" - Доступные действия над отгрузкой.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ShipmentDTO
instance A.FromJSON ShipmentDTO where
  parseJSON = A.withObject "ShipmentDTO" $ \o ->
    ShipmentDTO
      <$> (o .:? "id")
      <*> (o .:? "planIntervalFrom")
      <*> (o .:? "planIntervalTo")
      <*> (o .:? "shipmentType")
      <*> (o .:? "warehouse")
      <*> (o .:? "warehouseTo")
      <*> (o .:? "externalId")
      <*> (o .:? "deliveryService")
      <*> (o .:? "palletsCount")
      <*> (o .:  "orderIds")
      <*> (o .:? "draftCount")
      <*> (o .:? "plannedCount")
      <*> (o .:? "factCount")
      <*> (o .:? "currentStatus")
      <*> (o .:  "availableActions")

-- | ToJSON ShipmentDTO
instance A.ToJSON ShipmentDTO where
  toJSON ShipmentDTO {..} =
   _omitNulls
      [ "id" .= shipmentDTOId
      , "planIntervalFrom" .= shipmentDTOPlanIntervalFrom
      , "planIntervalTo" .= shipmentDTOPlanIntervalTo
      , "shipmentType" .= shipmentDTOShipmentType
      , "warehouse" .= shipmentDTOWarehouse
      , "warehouseTo" .= shipmentDTOWarehouseTo
      , "externalId" .= shipmentDTOExternalId
      , "deliveryService" .= shipmentDTODeliveryService
      , "palletsCount" .= shipmentDTOPalletsCount
      , "orderIds" .= shipmentDTOOrderIds
      , "draftCount" .= shipmentDTODraftCount
      , "plannedCount" .= shipmentDTOPlannedCount
      , "factCount" .= shipmentDTOFactCount
      , "currentStatus" .= shipmentDTOCurrentStatus
      , "availableActions" .= shipmentDTOAvailableActions
      ]


-- | Construct a value of type 'ShipmentDTO' (by applying it's required fields, if any)
mkShipmentDTO
  :: [Integer] -- ^ 'shipmentDTOOrderIds': Идентификаторы заказов в отгрузке.
  -> [ShipmentActionType] -- ^ 'shipmentDTOAvailableActions': Доступные действия над отгрузкой.
  -> ShipmentDTO
mkShipmentDTO shipmentDTOOrderIds shipmentDTOAvailableActions =
  ShipmentDTO
  { shipmentDTOId = Nothing
  , shipmentDTOPlanIntervalFrom = Nothing
  , shipmentDTOPlanIntervalTo = Nothing
  , shipmentDTOShipmentType = Nothing
  , shipmentDTOWarehouse = Nothing
  , shipmentDTOWarehouseTo = Nothing
  , shipmentDTOExternalId = Nothing
  , shipmentDTODeliveryService = Nothing
  , shipmentDTOPalletsCount = Nothing
  , shipmentDTOOrderIds
  , shipmentDTODraftCount = Nothing
  , shipmentDTOPlannedCount = Nothing
  , shipmentDTOFactCount = Nothing
  , shipmentDTOCurrentStatus = Nothing
  , shipmentDTOAvailableActions
  }

-- ** ShipmentInfoDTO
-- | ShipmentInfoDTO
-- Список с информацией об отгрузках.
data ShipmentInfoDTO = ShipmentInfoDTO
  { shipmentInfoDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор отгрузки.
  , shipmentInfoDTOPlanIntervalFrom :: !(Maybe DateTime) -- ^ "planIntervalFrom" - Начало планового интервала отгрузки.
  , shipmentInfoDTOPlanIntervalTo :: !(Maybe DateTime) -- ^ "planIntervalTo" - Конец планового интервала отгрузки.
  , shipmentInfoDTOShipmentType :: !(Maybe ShipmentType) -- ^ "shipmentType"
  , shipmentInfoDTOWarehouse :: !(Maybe PartnerShipmentWarehouseDTO) -- ^ "warehouse"
  , shipmentInfoDTOWarehouseTo :: !(Maybe PartnerShipmentWarehouseDTO) -- ^ "warehouseTo"
  , shipmentInfoDTOExternalId :: !(Maybe Text) -- ^ "externalId" - Идентификатор отгрузки в вашей системе. Если вы еще не передавали идентификатор, вернется идентификатор из параметра &#x60;id&#x60;.
  , shipmentInfoDTODeliveryService :: !(Maybe DeliveryServiceDTO) -- ^ "deliveryService"
  , shipmentInfoDTOPalletsCount :: !(Maybe PalletsCountDTO) -- ^ "palletsCount"
  , shipmentInfoDTOOrderIds :: !([Integer]) -- ^ /Required/ "orderIds" - Идентификаторы заказов в отгрузке.
  , shipmentInfoDTODraftCount :: !(Maybe Int) -- ^ "draftCount" - Количество заказов, которое Маркет запланировал к отгрузке.
  , shipmentInfoDTOPlannedCount :: !(Maybe Int) -- ^ "plannedCount" - Количество заказов, которое Маркет подтвердил к отгрузке.
  , shipmentInfoDTOFactCount :: !(Maybe Int) -- ^ "factCount" - Количество заказов, принятых в сортировочном центре или пункте приема.
  , shipmentInfoDTOStatus :: !(Maybe ShipmentStatusType) -- ^ "status"
  , shipmentInfoDTOStatusDescription :: !(Maybe Text) -- ^ "statusDescription" - Описание статуса отгрузки.
  , shipmentInfoDTOStatusUpdateTime :: !(Maybe DateTime) -- ^ "statusUpdateTime" - Время последнего изменения статуса отгрузки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ShipmentInfoDTO
instance A.FromJSON ShipmentInfoDTO where
  parseJSON = A.withObject "ShipmentInfoDTO" $ \o ->
    ShipmentInfoDTO
      <$> (o .:? "id")
      <*> (o .:? "planIntervalFrom")
      <*> (o .:? "planIntervalTo")
      <*> (o .:? "shipmentType")
      <*> (o .:? "warehouse")
      <*> (o .:? "warehouseTo")
      <*> (o .:? "externalId")
      <*> (o .:? "deliveryService")
      <*> (o .:? "palletsCount")
      <*> (o .:  "orderIds")
      <*> (o .:? "draftCount")
      <*> (o .:? "plannedCount")
      <*> (o .:? "factCount")
      <*> (o .:? "status")
      <*> (o .:? "statusDescription")
      <*> (o .:? "statusUpdateTime")

-- | ToJSON ShipmentInfoDTO
instance A.ToJSON ShipmentInfoDTO where
  toJSON ShipmentInfoDTO {..} =
   _omitNulls
      [ "id" .= shipmentInfoDTOId
      , "planIntervalFrom" .= shipmentInfoDTOPlanIntervalFrom
      , "planIntervalTo" .= shipmentInfoDTOPlanIntervalTo
      , "shipmentType" .= shipmentInfoDTOShipmentType
      , "warehouse" .= shipmentInfoDTOWarehouse
      , "warehouseTo" .= shipmentInfoDTOWarehouseTo
      , "externalId" .= shipmentInfoDTOExternalId
      , "deliveryService" .= shipmentInfoDTODeliveryService
      , "palletsCount" .= shipmentInfoDTOPalletsCount
      , "orderIds" .= shipmentInfoDTOOrderIds
      , "draftCount" .= shipmentInfoDTODraftCount
      , "plannedCount" .= shipmentInfoDTOPlannedCount
      , "factCount" .= shipmentInfoDTOFactCount
      , "status" .= shipmentInfoDTOStatus
      , "statusDescription" .= shipmentInfoDTOStatusDescription
      , "statusUpdateTime" .= shipmentInfoDTOStatusUpdateTime
      ]


-- | Construct a value of type 'ShipmentInfoDTO' (by applying it's required fields, if any)
mkShipmentInfoDTO
  :: [Integer] -- ^ 'shipmentInfoDTOOrderIds': Идентификаторы заказов в отгрузке.
  -> ShipmentInfoDTO
mkShipmentInfoDTO shipmentInfoDTOOrderIds =
  ShipmentInfoDTO
  { shipmentInfoDTOId = Nothing
  , shipmentInfoDTOPlanIntervalFrom = Nothing
  , shipmentInfoDTOPlanIntervalTo = Nothing
  , shipmentInfoDTOShipmentType = Nothing
  , shipmentInfoDTOWarehouse = Nothing
  , shipmentInfoDTOWarehouseTo = Nothing
  , shipmentInfoDTOExternalId = Nothing
  , shipmentInfoDTODeliveryService = Nothing
  , shipmentInfoDTOPalletsCount = Nothing
  , shipmentInfoDTOOrderIds
  , shipmentInfoDTODraftCount = Nothing
  , shipmentInfoDTOPlannedCount = Nothing
  , shipmentInfoDTOFactCount = Nothing
  , shipmentInfoDTOStatus = Nothing
  , shipmentInfoDTOStatusDescription = Nothing
  , shipmentInfoDTOStatusUpdateTime = Nothing
  }

-- ** ShipmentStatusChangeDTO
-- | ShipmentStatusChangeDTO
-- Статус отгрузки.
data ShipmentStatusChangeDTO = ShipmentStatusChangeDTO
  { shipmentStatusChangeDTOStatus :: !(Maybe ShipmentStatusType) -- ^ "status"
  , shipmentStatusChangeDTODescription :: !(Maybe Text) -- ^ "description" - Описание статуса отгрузки.
  , shipmentStatusChangeDTOUpdateTime :: !(Maybe DateTime) -- ^ "updateTime" - Время последнего изменения статуса отгрузки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ShipmentStatusChangeDTO
instance A.FromJSON ShipmentStatusChangeDTO where
  parseJSON = A.withObject "ShipmentStatusChangeDTO" $ \o ->
    ShipmentStatusChangeDTO
      <$> (o .:? "status")
      <*> (o .:? "description")
      <*> (o .:? "updateTime")

-- | ToJSON ShipmentStatusChangeDTO
instance A.ToJSON ShipmentStatusChangeDTO where
  toJSON ShipmentStatusChangeDTO {..} =
   _omitNulls
      [ "status" .= shipmentStatusChangeDTOStatus
      , "description" .= shipmentStatusChangeDTODescription
      , "updateTime" .= shipmentStatusChangeDTOUpdateTime
      ]


-- | Construct a value of type 'ShipmentStatusChangeDTO' (by applying it's required fields, if any)
mkShipmentStatusChangeDTO
  :: ShipmentStatusChangeDTO
mkShipmentStatusChangeDTO =
  ShipmentStatusChangeDTO
  { shipmentStatusChangeDTOStatus = Nothing
  , shipmentStatusChangeDTODescription = Nothing
  , shipmentStatusChangeDTOUpdateTime = Nothing
  }

-- ** SkipGoodsFeedbackReactionRequest
-- | SkipGoodsFeedbackReactionRequest
-- Идентификаторы отзывов.
data SkipGoodsFeedbackReactionRequest = SkipGoodsFeedbackReactionRequest
  { skipGoodsFeedbackReactionRequestFeedbackIds :: !([Integer]) -- ^ /Required/ "feedbackIds" - Список идентификаторов отзывов, на которые магазин не будет отвечать.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SkipGoodsFeedbackReactionRequest
instance A.FromJSON SkipGoodsFeedbackReactionRequest where
  parseJSON = A.withObject "SkipGoodsFeedbackReactionRequest" $ \o ->
    SkipGoodsFeedbackReactionRequest
      <$> (o .:  "feedbackIds")

-- | ToJSON SkipGoodsFeedbackReactionRequest
instance A.ToJSON SkipGoodsFeedbackReactionRequest where
  toJSON SkipGoodsFeedbackReactionRequest {..} =
   _omitNulls
      [ "feedbackIds" .= skipGoodsFeedbackReactionRequestFeedbackIds
      ]


-- | Construct a value of type 'SkipGoodsFeedbackReactionRequest' (by applying it's required fields, if any)
mkSkipGoodsFeedbackReactionRequest
  :: [Integer] -- ^ 'skipGoodsFeedbackReactionRequestFeedbackIds': Список идентификаторов отзывов, на которые магазин не будет отвечать.
  -> SkipGoodsFeedbackReactionRequest
mkSkipGoodsFeedbackReactionRequest skipGoodsFeedbackReactionRequestFeedbackIds =
  SkipGoodsFeedbackReactionRequest
  { skipGoodsFeedbackReactionRequestFeedbackIds
  }

-- ** SkuBidItemDTO
-- | SkuBidItemDTO
-- Список товаров и ставок на них.
data SkuBidItemDTO = SkuBidItemDTO
  { skuBidItemDTOSku :: !(Text) -- ^ /Required/ "sku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , skuBidItemDTOBid :: !(Int) -- ^ /Required/ "bid" - Значение ставки.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SkuBidItemDTO
instance A.FromJSON SkuBidItemDTO where
  parseJSON = A.withObject "SkuBidItemDTO" $ \o ->
    SkuBidItemDTO
      <$> (o .:  "sku")
      <*> (o .:  "bid")

-- | ToJSON SkuBidItemDTO
instance A.ToJSON SkuBidItemDTO where
  toJSON SkuBidItemDTO {..} =
   _omitNulls
      [ "sku" .= skuBidItemDTOSku
      , "bid" .= skuBidItemDTOBid
      ]


-- | Construct a value of type 'SkuBidItemDTO' (by applying it's required fields, if any)
mkSkuBidItemDTO
  :: Text -- ^ 'skuBidItemDTOSku': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> Int -- ^ 'skuBidItemDTOBid': Значение ставки.
  -> SkuBidItemDTO
mkSkuBidItemDTO skuBidItemDTOSku skuBidItemDTOBid =
  SkuBidItemDTO
  { skuBidItemDTOSku
  , skuBidItemDTOBid
  }

-- ** SkuBidRecommendationItemDTO
-- | SkuBidRecommendationItemDTO
-- Список товаров с рекомендованными ставками.
data SkuBidRecommendationItemDTO = SkuBidRecommendationItemDTO
  { skuBidRecommendationItemDTOSku :: !(Text) -- ^ /Required/ "sku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , skuBidRecommendationItemDTOBid :: !(Int) -- ^ /Required/ "bid" - Значение ставки.
  , skuBidRecommendationItemDTOBidRecommendations :: !(Maybe [BidRecommendationItemDTO]) -- ^ "bidRecommendations" - Список рекомендованных ставок с соответствующими долями показов. Чем больше ставка, тем большую долю показов она помогает получить. 
  , skuBidRecommendationItemDTOPriceRecommendations :: !(Maybe [PriceRecommendationItemDTO]) -- ^ "priceRecommendations" - Рекомендованные цены.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SkuBidRecommendationItemDTO
instance A.FromJSON SkuBidRecommendationItemDTO where
  parseJSON = A.withObject "SkuBidRecommendationItemDTO" $ \o ->
    SkuBidRecommendationItemDTO
      <$> (o .:  "sku")
      <*> (o .:  "bid")
      <*> (o .:? "bidRecommendations")
      <*> (o .:? "priceRecommendations")

-- | ToJSON SkuBidRecommendationItemDTO
instance A.ToJSON SkuBidRecommendationItemDTO where
  toJSON SkuBidRecommendationItemDTO {..} =
   _omitNulls
      [ "sku" .= skuBidRecommendationItemDTOSku
      , "bid" .= skuBidRecommendationItemDTOBid
      , "bidRecommendations" .= skuBidRecommendationItemDTOBidRecommendations
      , "priceRecommendations" .= skuBidRecommendationItemDTOPriceRecommendations
      ]


-- | Construct a value of type 'SkuBidRecommendationItemDTO' (by applying it's required fields, if any)
mkSkuBidRecommendationItemDTO
  :: Text -- ^ 'skuBidRecommendationItemDTOSku': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> Int -- ^ 'skuBidRecommendationItemDTOBid': Значение ставки.
  -> SkuBidRecommendationItemDTO
mkSkuBidRecommendationItemDTO skuBidRecommendationItemDTOSku skuBidRecommendationItemDTOBid =
  SkuBidRecommendationItemDTO
  { skuBidRecommendationItemDTOSku
  , skuBidRecommendationItemDTOBid
  , skuBidRecommendationItemDTOBidRecommendations = Nothing
  , skuBidRecommendationItemDTOPriceRecommendations = Nothing
  }

-- ** SuggestOfferPriceDTO
-- | SuggestOfferPriceDTO
-- Товар, для которого требуется получить цены для продвижения.
data SuggestOfferPriceDTO = SuggestOfferPriceDTO
  { suggestOfferPriceDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , suggestOfferPriceDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SuggestOfferPriceDTO
instance A.FromJSON SuggestOfferPriceDTO where
  parseJSON = A.withObject "SuggestOfferPriceDTO" $ \o ->
    SuggestOfferPriceDTO
      <$> (o .:? "offerId")
      <*> (o .:? "marketSku")

-- | ToJSON SuggestOfferPriceDTO
instance A.ToJSON SuggestOfferPriceDTO where
  toJSON SuggestOfferPriceDTO {..} =
   _omitNulls
      [ "offerId" .= suggestOfferPriceDTOOfferId
      , "marketSku" .= suggestOfferPriceDTOMarketSku
      ]


-- | Construct a value of type 'SuggestOfferPriceDTO' (by applying it's required fields, if any)
mkSuggestOfferPriceDTO
  :: SuggestOfferPriceDTO
mkSuggestOfferPriceDTO =
  SuggestOfferPriceDTO
  { suggestOfferPriceDTOOfferId = Nothing
  , suggestOfferPriceDTOMarketSku = Nothing
  }

-- ** SuggestPricesRequest
-- | SuggestPricesRequest
-- Запрос на получение списка цен для продвижения.
data SuggestPricesRequest = SuggestPricesRequest
  { suggestPricesRequestOffers :: !([SuggestOfferPriceDTO]) -- ^ /Required/ "offers" - Список товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SuggestPricesRequest
instance A.FromJSON SuggestPricesRequest where
  parseJSON = A.withObject "SuggestPricesRequest" $ \o ->
    SuggestPricesRequest
      <$> (o .:  "offers")

-- | ToJSON SuggestPricesRequest
instance A.ToJSON SuggestPricesRequest where
  toJSON SuggestPricesRequest {..} =
   _omitNulls
      [ "offers" .= suggestPricesRequestOffers
      ]


-- | Construct a value of type 'SuggestPricesRequest' (by applying it's required fields, if any)
mkSuggestPricesRequest
  :: [SuggestOfferPriceDTO] -- ^ 'suggestPricesRequestOffers': Список товаров.
  -> SuggestPricesRequest
mkSuggestPricesRequest suggestPricesRequestOffers =
  SuggestPricesRequest
  { suggestPricesRequestOffers
  }

-- ** SuggestPricesResponse
-- | SuggestPricesResponse
-- Ответ на запрос списка цен для продвижения.
data SuggestPricesResponse = SuggestPricesResponse
  { suggestPricesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , suggestPricesResponseResult :: !(Maybe SuggestPricesResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SuggestPricesResponse
instance A.FromJSON SuggestPricesResponse where
  parseJSON = A.withObject "SuggestPricesResponse" $ \o ->
    SuggestPricesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON SuggestPricesResponse
instance A.ToJSON SuggestPricesResponse where
  toJSON SuggestPricesResponse {..} =
   _omitNulls
      [ "status" .= suggestPricesResponseStatus
      , "result" .= suggestPricesResponseResult
      ]


-- | Construct a value of type 'SuggestPricesResponse' (by applying it's required fields, if any)
mkSuggestPricesResponse
  :: SuggestPricesResponse
mkSuggestPricesResponse =
  SuggestPricesResponse
  { suggestPricesResponseStatus = Nothing
  , suggestPricesResponseResult = Nothing
  }

-- ** SuggestPricesResultDTO
-- | SuggestPricesResultDTO
-- Результат запроса цен для продвижения.
data SuggestPricesResultDTO = SuggestPricesResultDTO
  { suggestPricesResultDTOOffers :: !([PriceSuggestOfferDTO]) -- ^ /Required/ "offers" - Список товаров с ценами для продвижения.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SuggestPricesResultDTO
instance A.FromJSON SuggestPricesResultDTO where
  parseJSON = A.withObject "SuggestPricesResultDTO" $ \o ->
    SuggestPricesResultDTO
      <$> (o .:  "offers")

-- | ToJSON SuggestPricesResultDTO
instance A.ToJSON SuggestPricesResultDTO where
  toJSON SuggestPricesResultDTO {..} =
   _omitNulls
      [ "offers" .= suggestPricesResultDTOOffers
      ]


-- | Construct a value of type 'SuggestPricesResultDTO' (by applying it's required fields, if any)
mkSuggestPricesResultDTO
  :: [PriceSuggestOfferDTO] -- ^ 'suggestPricesResultDTOOffers': Список товаров с ценами для продвижения.
  -> SuggestPricesResultDTO
mkSuggestPricesResultDTO suggestPricesResultDTOOffers =
  SuggestPricesResultDTO
  { suggestPricesResultDTOOffers
  }

-- ** SuggestedOfferDTO
-- | SuggestedOfferDTO
-- Информация о товаре.
data SuggestedOfferDTO = SuggestedOfferDTO
  { suggestedOfferDTOOfferId :: !(Maybe Text) -- ^ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , suggestedOfferDTOName :: !(Maybe Text) -- ^ "name" - Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
  , suggestedOfferDTOCategory :: !(Maybe Text) -- ^ "category" - Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;. 
  , suggestedOfferDTOVendor :: !(Maybe Text) -- ^ "vendor" - Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
  , suggestedOfferDTOBarcodes :: !(Maybe [Text]) -- ^ "barcodes" - Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
  , suggestedOfferDTODescription :: !(Maybe Text) -- ^ "description" - Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\&lt;h&gt;, \\&lt;h1&gt;, \\&lt;h2&gt; и так далее — для заголовков; * \\&lt;br&gt; и \\&lt;p&gt; — для переноса строки; * \\&lt;ol&gt; — для нумерованного списка; * \\&lt;ul&gt; — для маркированного списка; * \\&lt;li&gt; — для создания элементов списка (должен находиться внутри \\&lt;ol&gt; или \\&lt;ul&gt;); * \\&lt;div&gt; — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
  , suggestedOfferDTOVendorCode :: !(Maybe Text) -- ^ "vendorCode" - Артикул товара от производителя.
  , suggestedOfferDTOBasicPrice :: !(Maybe BasePriceDTO) -- ^ "basicPrice"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SuggestedOfferDTO
instance A.FromJSON SuggestedOfferDTO where
  parseJSON = A.withObject "SuggestedOfferDTO" $ \o ->
    SuggestedOfferDTO
      <$> (o .:? "offerId")
      <*> (o .:? "name")
      <*> (o .:? "category")
      <*> (o .:? "vendor")
      <*> (o .:? "barcodes")
      <*> (o .:? "description")
      <*> (o .:? "vendorCode")
      <*> (o .:? "basicPrice")

-- | ToJSON SuggestedOfferDTO
instance A.ToJSON SuggestedOfferDTO where
  toJSON SuggestedOfferDTO {..} =
   _omitNulls
      [ "offerId" .= suggestedOfferDTOOfferId
      , "name" .= suggestedOfferDTOName
      , "category" .= suggestedOfferDTOCategory
      , "vendor" .= suggestedOfferDTOVendor
      , "barcodes" .= suggestedOfferDTOBarcodes
      , "description" .= suggestedOfferDTODescription
      , "vendorCode" .= suggestedOfferDTOVendorCode
      , "basicPrice" .= suggestedOfferDTOBasicPrice
      ]


-- | Construct a value of type 'SuggestedOfferDTO' (by applying it's required fields, if any)
mkSuggestedOfferDTO
  :: SuggestedOfferDTO
mkSuggestedOfferDTO =
  SuggestedOfferDTO
  { suggestedOfferDTOOfferId = Nothing
  , suggestedOfferDTOName = Nothing
  , suggestedOfferDTOCategory = Nothing
  , suggestedOfferDTOVendor = Nothing
  , suggestedOfferDTOBarcodes = Nothing
  , suggestedOfferDTODescription = Nothing
  , suggestedOfferDTOVendorCode = Nothing
  , suggestedOfferDTOBasicPrice = Nothing
  }

-- ** SuggestedOfferMappingDTO
-- | SuggestedOfferMappingDTO
-- Товар с соответствующей карточкой на Маркете.
data SuggestedOfferMappingDTO = SuggestedOfferMappingDTO
  { suggestedOfferMappingDTOOffer :: !(Maybe SuggestedOfferDTO) -- ^ "offer"
  , suggestedOfferMappingDTOMapping :: !(Maybe GetMappingDTO) -- ^ "mapping"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SuggestedOfferMappingDTO
instance A.FromJSON SuggestedOfferMappingDTO where
  parseJSON = A.withObject "SuggestedOfferMappingDTO" $ \o ->
    SuggestedOfferMappingDTO
      <$> (o .:? "offer")
      <*> (o .:? "mapping")

-- | ToJSON SuggestedOfferMappingDTO
instance A.ToJSON SuggestedOfferMappingDTO where
  toJSON SuggestedOfferMappingDTO {..} =
   _omitNulls
      [ "offer" .= suggestedOfferMappingDTOOffer
      , "mapping" .= suggestedOfferMappingDTOMapping
      ]


-- | Construct a value of type 'SuggestedOfferMappingDTO' (by applying it's required fields, if any)
mkSuggestedOfferMappingDTO
  :: SuggestedOfferMappingDTO
mkSuggestedOfferMappingDTO =
  SuggestedOfferMappingDTO
  { suggestedOfferMappingDTOOffer = Nothing
  , suggestedOfferMappingDTOMapping = Nothing
  }

-- ** TariffDTO
-- | TariffDTO
-- Информация о тарифах, по которым нужно заплатить за услуги Маркета.
data TariffDTO = TariffDTO
  { tariffDTOType :: !(TariffType) -- ^ /Required/ "type"
  , tariffDTOPercent :: !(Maybe Double) -- ^ "percent" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Значение тарифа в процентах. 
  , tariffDTOAmount :: !(Double) -- ^ /Required/ "amount" - Значение тарифа в рублях.
  , tariffDTOParameters :: !([TariffParameterDTO]) -- ^ /Required/ "parameters" - Параметры расчета тарифа.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TariffDTO
instance A.FromJSON TariffDTO where
  parseJSON = A.withObject "TariffDTO" $ \o ->
    TariffDTO
      <$> (o .:  "type")
      <*> (o .:? "percent")
      <*> (o .:  "amount")
      <*> (o .:  "parameters")

-- | ToJSON TariffDTO
instance A.ToJSON TariffDTO where
  toJSON TariffDTO {..} =
   _omitNulls
      [ "type" .= tariffDTOType
      , "percent" .= tariffDTOPercent
      , "amount" .= tariffDTOAmount
      , "parameters" .= tariffDTOParameters
      ]


-- | Construct a value of type 'TariffDTO' (by applying it's required fields, if any)
mkTariffDTO
  :: TariffType -- ^ 'tariffDTOType' 
  -> Double -- ^ 'tariffDTOAmount': Значение тарифа в рублях.
  -> [TariffParameterDTO] -- ^ 'tariffDTOParameters': Параметры расчета тарифа.
  -> TariffDTO
mkTariffDTO tariffDTOType tariffDTOAmount tariffDTOParameters =
  TariffDTO
  { tariffDTOType
  , tariffDTOPercent = Nothing
  , tariffDTOAmount
  , tariffDTOParameters
  }

-- ** TariffParameterDTO
-- | TariffParameterDTO
-- Детали расчета конкретной услуги Маркета.
data TariffParameterDTO = TariffParameterDTO
  { tariffParameterDTOName :: !(Text) -- ^ /Required/ "name" - Название параметра.
  , tariffParameterDTOValue :: !(Text) -- ^ /Required/ "value" - Значение параметра.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TariffParameterDTO
instance A.FromJSON TariffParameterDTO where
  parseJSON = A.withObject "TariffParameterDTO" $ \o ->
    TariffParameterDTO
      <$> (o .:  "name")
      <*> (o .:  "value")

-- | ToJSON TariffParameterDTO
instance A.ToJSON TariffParameterDTO where
  toJSON TariffParameterDTO {..} =
   _omitNulls
      [ "name" .= tariffParameterDTOName
      , "value" .= tariffParameterDTOValue
      ]


-- | Construct a value of type 'TariffParameterDTO' (by applying it's required fields, if any)
mkTariffParameterDTO
  :: Text -- ^ 'tariffParameterDTOName': Название параметра.
  -> Text -- ^ 'tariffParameterDTOValue': Значение параметра.
  -> TariffParameterDTO
mkTariffParameterDTO tariffParameterDTOName tariffParameterDTOValue =
  TariffParameterDTO
  { tariffParameterDTOName
  , tariffParameterDTOValue
  }

-- ** TimePeriodDTO
-- | TimePeriodDTO
-- Временной отрезок с комментарием. Требования к содержанию комментария зависят от контекста использования параметра и указаны в описании поля, которое его содержит.
data TimePeriodDTO = TimePeriodDTO
  { timePeriodDTOTimePeriod :: !(Int) -- ^ /Required/ "timePeriod" - Продолжительность в указанных единицах.
  , timePeriodDTOTimeUnit :: !(TimeUnitType) -- ^ /Required/ "timeUnit"
  , timePeriodDTOComment :: !(Maybe Text) -- ^ "comment" - Комментарий.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TimePeriodDTO
instance A.FromJSON TimePeriodDTO where
  parseJSON = A.withObject "TimePeriodDTO" $ \o ->
    TimePeriodDTO
      <$> (o .:  "timePeriod")
      <*> (o .:  "timeUnit")
      <*> (o .:? "comment")

-- | ToJSON TimePeriodDTO
instance A.ToJSON TimePeriodDTO where
  toJSON TimePeriodDTO {..} =
   _omitNulls
      [ "timePeriod" .= timePeriodDTOTimePeriod
      , "timeUnit" .= timePeriodDTOTimeUnit
      , "comment" .= timePeriodDTOComment
      ]


-- | Construct a value of type 'TimePeriodDTO' (by applying it's required fields, if any)
mkTimePeriodDTO
  :: Int -- ^ 'timePeriodDTOTimePeriod': Продолжительность в указанных единицах.
  -> TimeUnitType -- ^ 'timePeriodDTOTimeUnit' 
  -> TimePeriodDTO
mkTimePeriodDTO timePeriodDTOTimePeriod timePeriodDTOTimeUnit =
  TimePeriodDTO
  { timePeriodDTOTimePeriod
  , timePeriodDTOTimeUnit
  , timePeriodDTOComment = Nothing
  }

-- ** TrackDTO
-- | TrackDTO
-- Информация о трек-номерах.
data TrackDTO = TrackDTO
  { trackDTOTrackCode :: !(Maybe Text) -- ^ "trackCode" - Трек-код почтового отправления.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TrackDTO
instance A.FromJSON TrackDTO where
  parseJSON = A.withObject "TrackDTO" $ \o ->
    TrackDTO
      <$> (o .:? "trackCode")

-- | ToJSON TrackDTO
instance A.ToJSON TrackDTO where
  toJSON TrackDTO {..} =
   _omitNulls
      [ "trackCode" .= trackDTOTrackCode
      ]


-- | Construct a value of type 'TrackDTO' (by applying it's required fields, if any)
mkTrackDTO
  :: TrackDTO
mkTrackDTO =
  TrackDTO
  { trackDTOTrackCode = Nothing
  }

-- ** TransferOrdersFromShipmentRequest
-- | TransferOrdersFromShipmentRequest
-- Запрос переноса заказов из отгрузки.
data TransferOrdersFromShipmentRequest = TransferOrdersFromShipmentRequest
  { transferOrdersFromShipmentRequestOrderIds :: !([Integer]) -- ^ /Required/ "orderIds" - Список заказов, которые вы не успеваете подготовить.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransferOrdersFromShipmentRequest
instance A.FromJSON TransferOrdersFromShipmentRequest where
  parseJSON = A.withObject "TransferOrdersFromShipmentRequest" $ \o ->
    TransferOrdersFromShipmentRequest
      <$> (o .:  "orderIds")

-- | ToJSON TransferOrdersFromShipmentRequest
instance A.ToJSON TransferOrdersFromShipmentRequest where
  toJSON TransferOrdersFromShipmentRequest {..} =
   _omitNulls
      [ "orderIds" .= transferOrdersFromShipmentRequestOrderIds
      ]


-- | Construct a value of type 'TransferOrdersFromShipmentRequest' (by applying it's required fields, if any)
mkTransferOrdersFromShipmentRequest
  :: [Integer] -- ^ 'transferOrdersFromShipmentRequestOrderIds': Список заказов, которые вы не успеваете подготовить.
  -> TransferOrdersFromShipmentRequest
mkTransferOrdersFromShipmentRequest transferOrdersFromShipmentRequestOrderIds =
  TransferOrdersFromShipmentRequest
  { transferOrdersFromShipmentRequestOrderIds
  }

-- ** TurnoverDTO
-- | TurnoverDTO
-- Информация об оборачиваемости товара.
data TurnoverDTO = TurnoverDTO
  { turnoverDTOTurnover :: !(TurnoverType) -- ^ /Required/ "turnover"
  , turnoverDTOTurnoverDays :: !(Maybe Double) -- ^ "turnoverDays" - Значение в днях. [Что это за число?](https://yandex.ru/support/marketplace/analytics/turnover.html)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TurnoverDTO
instance A.FromJSON TurnoverDTO where
  parseJSON = A.withObject "TurnoverDTO" $ \o ->
    TurnoverDTO
      <$> (o .:  "turnover")
      <*> (o .:? "turnoverDays")

-- | ToJSON TurnoverDTO
instance A.ToJSON TurnoverDTO where
  toJSON TurnoverDTO {..} =
   _omitNulls
      [ "turnover" .= turnoverDTOTurnover
      , "turnoverDays" .= turnoverDTOTurnoverDays
      ]


-- | Construct a value of type 'TurnoverDTO' (by applying it's required fields, if any)
mkTurnoverDTO
  :: TurnoverType -- ^ 'turnoverDTOTurnover' 
  -> TurnoverDTO
mkTurnoverDTO turnoverDTOTurnover =
  TurnoverDTO
  { turnoverDTOTurnover
  , turnoverDTOTurnoverDays = Nothing
  }

-- ** UnitDTO
-- | UnitDTO
-- Единица измерения.
data UnitDTO = UnitDTO
  { unitDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор единицы измерения.
  , unitDTOName :: !(Text) -- ^ /Required/ "name" - Сокращенное название единицы измерения.
  , unitDTOFullName :: !(Text) -- ^ /Required/ "fullName" - Полное название единицы измерения.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UnitDTO
instance A.FromJSON UnitDTO where
  parseJSON = A.withObject "UnitDTO" $ \o ->
    UnitDTO
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "fullName")

-- | ToJSON UnitDTO
instance A.ToJSON UnitDTO where
  toJSON UnitDTO {..} =
   _omitNulls
      [ "id" .= unitDTOId
      , "name" .= unitDTOName
      , "fullName" .= unitDTOFullName
      ]


-- | Construct a value of type 'UnitDTO' (by applying it's required fields, if any)
mkUnitDTO
  :: Integer -- ^ 'unitDTOId': Идентификатор единицы измерения.
  -> Text -- ^ 'unitDTOName': Сокращенное название единицы измерения.
  -> Text -- ^ 'unitDTOFullName': Полное название единицы измерения.
  -> UnitDTO
mkUnitDTO unitDTOId unitDTOName unitDTOFullName =
  UnitDTO
  { unitDTOId
  , unitDTOName
  , unitDTOFullName
  }

-- ** UpdateBusinessOfferPriceDTO
-- | UpdateBusinessOfferPriceDTO
-- Товар с новой ценой.
data UpdateBusinessOfferPriceDTO = UpdateBusinessOfferPriceDTO
  { updateBusinessOfferPriceDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , updateBusinessOfferPriceDTOPrice :: !(UpdatePriceWithDiscountDTO) -- ^ /Required/ "price"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateBusinessOfferPriceDTO
instance A.FromJSON UpdateBusinessOfferPriceDTO where
  parseJSON = A.withObject "UpdateBusinessOfferPriceDTO" $ \o ->
    UpdateBusinessOfferPriceDTO
      <$> (o .:  "offerId")
      <*> (o .:  "price")

-- | ToJSON UpdateBusinessOfferPriceDTO
instance A.ToJSON UpdateBusinessOfferPriceDTO where
  toJSON UpdateBusinessOfferPriceDTO {..} =
   _omitNulls
      [ "offerId" .= updateBusinessOfferPriceDTOOfferId
      , "price" .= updateBusinessOfferPriceDTOPrice
      ]


-- | Construct a value of type 'UpdateBusinessOfferPriceDTO' (by applying it's required fields, if any)
mkUpdateBusinessOfferPriceDTO
  :: Text -- ^ 'updateBusinessOfferPriceDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> UpdatePriceWithDiscountDTO -- ^ 'updateBusinessOfferPriceDTOPrice' 
  -> UpdateBusinessOfferPriceDTO
mkUpdateBusinessOfferPriceDTO updateBusinessOfferPriceDTOOfferId updateBusinessOfferPriceDTOPrice =
  UpdateBusinessOfferPriceDTO
  { updateBusinessOfferPriceDTOOfferId
  , updateBusinessOfferPriceDTOPrice
  }

-- ** UpdateBusinessPricesRequest
-- | UpdateBusinessPricesRequest
-- Запрос на установку базовых цен на товары.
data UpdateBusinessPricesRequest = UpdateBusinessPricesRequest
  { updateBusinessPricesRequestOffers :: !([UpdateBusinessOfferPriceDTO]) -- ^ /Required/ "offers" - Список товаров с ценами.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateBusinessPricesRequest
instance A.FromJSON UpdateBusinessPricesRequest where
  parseJSON = A.withObject "UpdateBusinessPricesRequest" $ \o ->
    UpdateBusinessPricesRequest
      <$> (o .:  "offers")

-- | ToJSON UpdateBusinessPricesRequest
instance A.ToJSON UpdateBusinessPricesRequest where
  toJSON UpdateBusinessPricesRequest {..} =
   _omitNulls
      [ "offers" .= updateBusinessPricesRequestOffers
      ]


-- | Construct a value of type 'UpdateBusinessPricesRequest' (by applying it's required fields, if any)
mkUpdateBusinessPricesRequest
  :: [UpdateBusinessOfferPriceDTO] -- ^ 'updateBusinessPricesRequestOffers': Список товаров с ценами.
  -> UpdateBusinessPricesRequest
mkUpdateBusinessPricesRequest updateBusinessPricesRequestOffers =
  UpdateBusinessPricesRequest
  { updateBusinessPricesRequestOffers
  }

-- ** UpdateCampaignOfferDTO
-- | UpdateCampaignOfferDTO
-- Параметры размещения товара в магазине.
data UpdateCampaignOfferDTO = UpdateCampaignOfferDTO
  { updateCampaignOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , updateCampaignOfferDTOQuantum :: !(Maybe QuantumDTO) -- ^ "quantum"
  , updateCampaignOfferDTOAvailable :: !(Maybe Bool) -- ^ "available" - Есть ли товар в продаже. 
  , updateCampaignOfferDTOVat :: !(Maybe Int) -- ^ "vat" - Ставка НДС, применяемая для товара. Задается цифрой:  * &#x60;2&#x60; — 10%. * &#x60;5&#x60; — 0%. * &#x60;6&#x60; — не облагается НДС. * &#x60;7&#x60; — 20%.  Если параметр не указан, используется ставка НДС, установленная в кабинете продавца на Маркете. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateCampaignOfferDTO
instance A.FromJSON UpdateCampaignOfferDTO where
  parseJSON = A.withObject "UpdateCampaignOfferDTO" $ \o ->
    UpdateCampaignOfferDTO
      <$> (o .:  "offerId")
      <*> (o .:? "quantum")
      <*> (o .:? "available")
      <*> (o .:? "vat")

-- | ToJSON UpdateCampaignOfferDTO
instance A.ToJSON UpdateCampaignOfferDTO where
  toJSON UpdateCampaignOfferDTO {..} =
   _omitNulls
      [ "offerId" .= updateCampaignOfferDTOOfferId
      , "quantum" .= updateCampaignOfferDTOQuantum
      , "available" .= updateCampaignOfferDTOAvailable
      , "vat" .= updateCampaignOfferDTOVat
      ]


-- | Construct a value of type 'UpdateCampaignOfferDTO' (by applying it's required fields, if any)
mkUpdateCampaignOfferDTO
  :: Text -- ^ 'updateCampaignOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> UpdateCampaignOfferDTO
mkUpdateCampaignOfferDTO updateCampaignOfferDTOOfferId =
  UpdateCampaignOfferDTO
  { updateCampaignOfferDTOOfferId
  , updateCampaignOfferDTOQuantum = Nothing
  , updateCampaignOfferDTOAvailable = Nothing
  , updateCampaignOfferDTOVat = Nothing
  }

-- ** UpdateCampaignOffersRequest
-- | UpdateCampaignOffersRequest
-- Запрос на обновление предложений товаров магазина.
data UpdateCampaignOffersRequest = UpdateCampaignOffersRequest
  { updateCampaignOffersRequestOffers :: !([UpdateCampaignOfferDTO]) -- ^ /Required/ "offers" - Параметры размещения товаров в заданном магазине.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateCampaignOffersRequest
instance A.FromJSON UpdateCampaignOffersRequest where
  parseJSON = A.withObject "UpdateCampaignOffersRequest" $ \o ->
    UpdateCampaignOffersRequest
      <$> (o .:  "offers")

-- | ToJSON UpdateCampaignOffersRequest
instance A.ToJSON UpdateCampaignOffersRequest where
  toJSON UpdateCampaignOffersRequest {..} =
   _omitNulls
      [ "offers" .= updateCampaignOffersRequestOffers
      ]


-- | Construct a value of type 'UpdateCampaignOffersRequest' (by applying it's required fields, if any)
mkUpdateCampaignOffersRequest
  :: [UpdateCampaignOfferDTO] -- ^ 'updateCampaignOffersRequestOffers': Параметры размещения товаров в заданном магазине.
  -> UpdateCampaignOffersRequest
mkUpdateCampaignOffersRequest updateCampaignOffersRequestOffers =
  UpdateCampaignOffersRequest
  { updateCampaignOffersRequestOffers
  }

-- ** UpdateGoodsFeedbackCommentDTO
-- | UpdateGoodsFeedbackCommentDTO
-- Комментарий к отзыву или другому комментарию.
data UpdateGoodsFeedbackCommentDTO = UpdateGoodsFeedbackCommentDTO
  { updateGoodsFeedbackCommentDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор комментария к отзыву. 
  , updateGoodsFeedbackCommentDTOParentId :: !(Maybe Integer) -- ^ "parentId" - Идентификатор комментария к отзыву. 
  , updateGoodsFeedbackCommentDTOText :: !(Text) -- ^ /Required/ "text" - Текст комментария.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateGoodsFeedbackCommentDTO
instance A.FromJSON UpdateGoodsFeedbackCommentDTO where
  parseJSON = A.withObject "UpdateGoodsFeedbackCommentDTO" $ \o ->
    UpdateGoodsFeedbackCommentDTO
      <$> (o .:? "id")
      <*> (o .:? "parentId")
      <*> (o .:  "text")

-- | ToJSON UpdateGoodsFeedbackCommentDTO
instance A.ToJSON UpdateGoodsFeedbackCommentDTO where
  toJSON UpdateGoodsFeedbackCommentDTO {..} =
   _omitNulls
      [ "id" .= updateGoodsFeedbackCommentDTOId
      , "parentId" .= updateGoodsFeedbackCommentDTOParentId
      , "text" .= updateGoodsFeedbackCommentDTOText
      ]


-- | Construct a value of type 'UpdateGoodsFeedbackCommentDTO' (by applying it's required fields, if any)
mkUpdateGoodsFeedbackCommentDTO
  :: Text -- ^ 'updateGoodsFeedbackCommentDTOText': Текст комментария.
  -> UpdateGoodsFeedbackCommentDTO
mkUpdateGoodsFeedbackCommentDTO updateGoodsFeedbackCommentDTOText =
  UpdateGoodsFeedbackCommentDTO
  { updateGoodsFeedbackCommentDTOId = Nothing
  , updateGoodsFeedbackCommentDTOParentId = Nothing
  , updateGoodsFeedbackCommentDTOText
  }

-- ** UpdateGoodsFeedbackCommentRequest
-- | UpdateGoodsFeedbackCommentRequest
-- Комментарий к отзыву.
data UpdateGoodsFeedbackCommentRequest = UpdateGoodsFeedbackCommentRequest
  { updateGoodsFeedbackCommentRequestFeedbackId :: !(Integer) -- ^ /Required/ "feedbackId" - Идентификатор отзыва. 
  , updateGoodsFeedbackCommentRequestComment :: !(UpdateGoodsFeedbackCommentDTO) -- ^ /Required/ "comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateGoodsFeedbackCommentRequest
instance A.FromJSON UpdateGoodsFeedbackCommentRequest where
  parseJSON = A.withObject "UpdateGoodsFeedbackCommentRequest" $ \o ->
    UpdateGoodsFeedbackCommentRequest
      <$> (o .:  "feedbackId")
      <*> (o .:  "comment")

-- | ToJSON UpdateGoodsFeedbackCommentRequest
instance A.ToJSON UpdateGoodsFeedbackCommentRequest where
  toJSON UpdateGoodsFeedbackCommentRequest {..} =
   _omitNulls
      [ "feedbackId" .= updateGoodsFeedbackCommentRequestFeedbackId
      , "comment" .= updateGoodsFeedbackCommentRequestComment
      ]


-- | Construct a value of type 'UpdateGoodsFeedbackCommentRequest' (by applying it's required fields, if any)
mkUpdateGoodsFeedbackCommentRequest
  :: Integer -- ^ 'updateGoodsFeedbackCommentRequestFeedbackId': Идентификатор отзыва. 
  -> UpdateGoodsFeedbackCommentDTO -- ^ 'updateGoodsFeedbackCommentRequestComment' 
  -> UpdateGoodsFeedbackCommentRequest
mkUpdateGoodsFeedbackCommentRequest updateGoodsFeedbackCommentRequestFeedbackId updateGoodsFeedbackCommentRequestComment =
  UpdateGoodsFeedbackCommentRequest
  { updateGoodsFeedbackCommentRequestFeedbackId
  , updateGoodsFeedbackCommentRequestComment
  }

-- ** UpdateGoodsFeedbackCommentResponse
-- | UpdateGoodsFeedbackCommentResponse
data UpdateGoodsFeedbackCommentResponse = UpdateGoodsFeedbackCommentResponse
  { updateGoodsFeedbackCommentResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , updateGoodsFeedbackCommentResponseResult :: !(Maybe GoodsFeedbackCommentDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateGoodsFeedbackCommentResponse
instance A.FromJSON UpdateGoodsFeedbackCommentResponse where
  parseJSON = A.withObject "UpdateGoodsFeedbackCommentResponse" $ \o ->
    UpdateGoodsFeedbackCommentResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON UpdateGoodsFeedbackCommentResponse
instance A.ToJSON UpdateGoodsFeedbackCommentResponse where
  toJSON UpdateGoodsFeedbackCommentResponse {..} =
   _omitNulls
      [ "status" .= updateGoodsFeedbackCommentResponseStatus
      , "result" .= updateGoodsFeedbackCommentResponseResult
      ]


-- | Construct a value of type 'UpdateGoodsFeedbackCommentResponse' (by applying it's required fields, if any)
mkUpdateGoodsFeedbackCommentResponse
  :: UpdateGoodsFeedbackCommentResponse
mkUpdateGoodsFeedbackCommentResponse =
  UpdateGoodsFeedbackCommentResponse
  { updateGoodsFeedbackCommentResponseStatus = Nothing
  , updateGoodsFeedbackCommentResponseResult = Nothing
  }

-- ** UpdateMappingDTO
-- | UpdateMappingDTO
-- Карточка на Маркете, которая, с вашей точки зрения, подходит товару. Чтобы определить идентификатор подходящей карточки, воспользуйтесь поиском в кабинете (**Товары** → **Каталог** → **Загрузить товары**).  По результатам проверки Маркет может привязать товар к более подходящей карточке. 
data UpdateMappingDTO = UpdateMappingDTO
  { updateMappingDTOMarketSku :: !(Maybe Integer) -- ^ "marketSku" - SKU на Маркете.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateMappingDTO
instance A.FromJSON UpdateMappingDTO where
  parseJSON = A.withObject "UpdateMappingDTO" $ \o ->
    UpdateMappingDTO
      <$> (o .:? "marketSku")

-- | ToJSON UpdateMappingDTO
instance A.ToJSON UpdateMappingDTO where
  toJSON UpdateMappingDTO {..} =
   _omitNulls
      [ "marketSku" .= updateMappingDTOMarketSku
      ]


-- | Construct a value of type 'UpdateMappingDTO' (by applying it's required fields, if any)
mkUpdateMappingDTO
  :: UpdateMappingDTO
mkUpdateMappingDTO =
  UpdateMappingDTO
  { updateMappingDTOMarketSku = Nothing
  }

-- ** UpdateMappingsOfferDTO
-- | UpdateMappingsOfferDTO
-- Информация о товарах в каталоге.
data UpdateMappingsOfferDTO = UpdateMappingsOfferDTO
  { updateMappingsOfferDTOName :: !(Maybe Text) -- ^ "name" - Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
  , updateMappingsOfferDTOShopSku :: !(Maybe Text) -- ^ "shopSku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , updateMappingsOfferDTOCategory :: !(Maybe Text) -- ^ "category" - Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;. 
  , updateMappingsOfferDTOVendor :: !(Maybe Text) -- ^ "vendor" - Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
  , updateMappingsOfferDTOVendorCode :: !(Maybe Text) -- ^ "vendorCode" - Артикул товара от производителя.
  , updateMappingsOfferDTODescription :: !(Maybe Text) -- ^ "description" - Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\&lt;h&gt;, \\&lt;h1&gt;, \\&lt;h2&gt; и так далее — для заголовков; * \\&lt;br&gt; и \\&lt;p&gt; — для переноса строки; * \\&lt;ol&gt; — для нумерованного списка; * \\&lt;ul&gt; — для маркированного списка; * \\&lt;li&gt; — для создания элементов списка (должен находиться внутри \\&lt;ol&gt; или \\&lt;ul&gt;); * \\&lt;div&gt; — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
  , updateMappingsOfferDTOId :: !(Maybe Text) -- ^ "id" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , updateMappingsOfferDTOFeedId :: !(Maybe Integer) -- ^ "feedId" - Идентификатор фида.
  , updateMappingsOfferDTOBarcodes :: !(Maybe [Text]) -- ^ "barcodes" - Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
  , updateMappingsOfferDTOUrls :: !(Maybe [Text]) -- ^ "urls" - URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
  , updateMappingsOfferDTOPictures :: !(Maybe [Text]) -- ^ "pictures" - Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр &#x60;picture&#x60;. 
  , updateMappingsOfferDTOManufacturer :: !(Maybe Text) -- ^ "manufacturer" - Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
  , updateMappingsOfferDTOManufacturerCountries :: !(Maybe [Text]) -- ^ "manufacturerCountries" - Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
  , updateMappingsOfferDTOMinShipment :: !(Maybe Int) -- ^ "minShipment" - Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
  , updateMappingsOfferDTOTransportUnitSize :: !(Maybe Int) -- ^ "transportUnitSize" - Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
  , updateMappingsOfferDTOQuantumOfSupply :: !(Maybe Int) -- ^ "quantumOfSupply" - Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
  , updateMappingsOfferDTODeliveryDurationDays :: !(Maybe Int) -- ^ "deliveryDurationDays" - Срок, за который продавец поставляет товары на склад, в днях.
  , updateMappingsOfferDTOBoxCount :: !(Maybe Int) -- ^ "boxCount" - Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
  , updateMappingsOfferDTOCustomsCommodityCodes :: !(Maybe [Text]) -- ^ "customsCommodityCodes" - Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
  , updateMappingsOfferDTOWeightDimensions :: !(Maybe OfferWeightDimensionsDTO) -- ^ "weightDimensions"
  , updateMappingsOfferDTOSupplyScheduleDays :: !(Maybe [DayOfWeekType]) -- ^ "supplyScheduleDays" - Дни недели, в которые продавец поставляет товары на склад.
  , updateMappingsOfferDTOShelfLifeDays :: !(Maybe Int) -- ^ "shelfLifeDays" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Вместо него используйте &#x60;shelfLife&#x60;. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
  , updateMappingsOfferDTOLifeTimeDays :: !(Maybe Int) -- ^ "lifeTimeDays" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. Вместо него используйте &#x60;lifeTime&#x60;. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
  , updateMappingsOfferDTOGuaranteePeriodDays :: !(Maybe Int) -- ^ "guaranteePeriodDays" - Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
  , updateMappingsOfferDTOProcessingState :: !(Maybe OfferProcessingStateDTO) -- ^ "processingState"
  , updateMappingsOfferDTOAvailability :: !(Maybe OfferAvailabilityStatusType) -- ^ "availability"
  , updateMappingsOfferDTOShelfLife :: !(Maybe TimePeriodDTO) -- ^ "shelfLife"
  , updateMappingsOfferDTOLifeTime :: !(Maybe TimePeriodDTO) -- ^ "lifeTime"
  , updateMappingsOfferDTOGuaranteePeriod :: !(Maybe TimePeriodDTO) -- ^ "guaranteePeriod"
  , updateMappingsOfferDTOCertificate :: !(Maybe Text) -- ^ "certificate" - Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateMappingsOfferDTO
instance A.FromJSON UpdateMappingsOfferDTO where
  parseJSON = A.withObject "UpdateMappingsOfferDTO" $ \o ->
    UpdateMappingsOfferDTO
      <$> (o .:? "name")
      <*> (o .:? "shopSku")
      <*> (o .:? "category")
      <*> (o .:? "vendor")
      <*> (o .:? "vendorCode")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "feedId")
      <*> (o .:? "barcodes")
      <*> (o .:? "urls")
      <*> (o .:? "pictures")
      <*> (o .:? "manufacturer")
      <*> (o .:? "manufacturerCountries")
      <*> (o .:? "minShipment")
      <*> (o .:? "transportUnitSize")
      <*> (o .:? "quantumOfSupply")
      <*> (o .:? "deliveryDurationDays")
      <*> (o .:? "boxCount")
      <*> (o .:? "customsCommodityCodes")
      <*> (o .:? "weightDimensions")
      <*> (o .:? "supplyScheduleDays")
      <*> (o .:? "shelfLifeDays")
      <*> (o .:? "lifeTimeDays")
      <*> (o .:? "guaranteePeriodDays")
      <*> (o .:? "processingState")
      <*> (o .:? "availability")
      <*> (o .:? "shelfLife")
      <*> (o .:? "lifeTime")
      <*> (o .:? "guaranteePeriod")
      <*> (o .:? "certificate")

-- | ToJSON UpdateMappingsOfferDTO
instance A.ToJSON UpdateMappingsOfferDTO where
  toJSON UpdateMappingsOfferDTO {..} =
   _omitNulls
      [ "name" .= updateMappingsOfferDTOName
      , "shopSku" .= updateMappingsOfferDTOShopSku
      , "category" .= updateMappingsOfferDTOCategory
      , "vendor" .= updateMappingsOfferDTOVendor
      , "vendorCode" .= updateMappingsOfferDTOVendorCode
      , "description" .= updateMappingsOfferDTODescription
      , "id" .= updateMappingsOfferDTOId
      , "feedId" .= updateMappingsOfferDTOFeedId
      , "barcodes" .= updateMappingsOfferDTOBarcodes
      , "urls" .= updateMappingsOfferDTOUrls
      , "pictures" .= updateMappingsOfferDTOPictures
      , "manufacturer" .= updateMappingsOfferDTOManufacturer
      , "manufacturerCountries" .= updateMappingsOfferDTOManufacturerCountries
      , "minShipment" .= updateMappingsOfferDTOMinShipment
      , "transportUnitSize" .= updateMappingsOfferDTOTransportUnitSize
      , "quantumOfSupply" .= updateMappingsOfferDTOQuantumOfSupply
      , "deliveryDurationDays" .= updateMappingsOfferDTODeliveryDurationDays
      , "boxCount" .= updateMappingsOfferDTOBoxCount
      , "customsCommodityCodes" .= updateMappingsOfferDTOCustomsCommodityCodes
      , "weightDimensions" .= updateMappingsOfferDTOWeightDimensions
      , "supplyScheduleDays" .= updateMappingsOfferDTOSupplyScheduleDays
      , "shelfLifeDays" .= updateMappingsOfferDTOShelfLifeDays
      , "lifeTimeDays" .= updateMappingsOfferDTOLifeTimeDays
      , "guaranteePeriodDays" .= updateMappingsOfferDTOGuaranteePeriodDays
      , "processingState" .= updateMappingsOfferDTOProcessingState
      , "availability" .= updateMappingsOfferDTOAvailability
      , "shelfLife" .= updateMappingsOfferDTOShelfLife
      , "lifeTime" .= updateMappingsOfferDTOLifeTime
      , "guaranteePeriod" .= updateMappingsOfferDTOGuaranteePeriod
      , "certificate" .= updateMappingsOfferDTOCertificate
      ]


-- | Construct a value of type 'UpdateMappingsOfferDTO' (by applying it's required fields, if any)
mkUpdateMappingsOfferDTO
  :: UpdateMappingsOfferDTO
mkUpdateMappingsOfferDTO =
  UpdateMappingsOfferDTO
  { updateMappingsOfferDTOName = Nothing
  , updateMappingsOfferDTOShopSku = Nothing
  , updateMappingsOfferDTOCategory = Nothing
  , updateMappingsOfferDTOVendor = Nothing
  , updateMappingsOfferDTOVendorCode = Nothing
  , updateMappingsOfferDTODescription = Nothing
  , updateMappingsOfferDTOId = Nothing
  , updateMappingsOfferDTOFeedId = Nothing
  , updateMappingsOfferDTOBarcodes = Nothing
  , updateMappingsOfferDTOUrls = Nothing
  , updateMappingsOfferDTOPictures = Nothing
  , updateMappingsOfferDTOManufacturer = Nothing
  , updateMappingsOfferDTOManufacturerCountries = Nothing
  , updateMappingsOfferDTOMinShipment = Nothing
  , updateMappingsOfferDTOTransportUnitSize = Nothing
  , updateMappingsOfferDTOQuantumOfSupply = Nothing
  , updateMappingsOfferDTODeliveryDurationDays = Nothing
  , updateMappingsOfferDTOBoxCount = Nothing
  , updateMappingsOfferDTOCustomsCommodityCodes = Nothing
  , updateMappingsOfferDTOWeightDimensions = Nothing
  , updateMappingsOfferDTOSupplyScheduleDays = Nothing
  , updateMappingsOfferDTOShelfLifeDays = Nothing
  , updateMappingsOfferDTOLifeTimeDays = Nothing
  , updateMappingsOfferDTOGuaranteePeriodDays = Nothing
  , updateMappingsOfferDTOProcessingState = Nothing
  , updateMappingsOfferDTOAvailability = Nothing
  , updateMappingsOfferDTOShelfLife = Nothing
  , updateMappingsOfferDTOLifeTime = Nothing
  , updateMappingsOfferDTOGuaranteePeriod = Nothing
  , updateMappingsOfferDTOCertificate = Nothing
  }

-- ** UpdateOfferContentRequest
-- | UpdateOfferContentRequest
-- Запрос на установку новых значений для параметров.
data UpdateOfferContentRequest = UpdateOfferContentRequest
  { updateOfferContentRequestOffersContent :: !([OfferContentDTO]) -- ^ /Required/ "offersContent" - Список товаров с указанными характеристиками.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferContentRequest
instance A.FromJSON UpdateOfferContentRequest where
  parseJSON = A.withObject "UpdateOfferContentRequest" $ \o ->
    UpdateOfferContentRequest
      <$> (o .:  "offersContent")

-- | ToJSON UpdateOfferContentRequest
instance A.ToJSON UpdateOfferContentRequest where
  toJSON UpdateOfferContentRequest {..} =
   _omitNulls
      [ "offersContent" .= updateOfferContentRequestOffersContent
      ]


-- | Construct a value of type 'UpdateOfferContentRequest' (by applying it's required fields, if any)
mkUpdateOfferContentRequest
  :: [OfferContentDTO] -- ^ 'updateOfferContentRequestOffersContent': Список товаров с указанными характеристиками.
  -> UpdateOfferContentRequest
mkUpdateOfferContentRequest updateOfferContentRequestOffersContent =
  UpdateOfferContentRequest
  { updateOfferContentRequestOffersContent
  }

-- ** UpdateOfferContentResponse
-- | UpdateOfferContentResponse
-- Описывает проблемы, которые появились при сохранении товара.
data UpdateOfferContentResponse = UpdateOfferContentResponse
  { updateOfferContentResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , updateOfferContentResponseResults :: !(Maybe [UpdateOfferContentResultDTO]) -- ^ "results" - Ошибки и предупреждения, которые появились при обработке переданных значений. Каждый элемент списка соответствует одному товару.  Если ошибок и предупреждений нет, поле не передается. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferContentResponse
instance A.FromJSON UpdateOfferContentResponse where
  parseJSON = A.withObject "UpdateOfferContentResponse" $ \o ->
    UpdateOfferContentResponse
      <$> (o .:? "status")
      <*> (o .:? "results")

-- | ToJSON UpdateOfferContentResponse
instance A.ToJSON UpdateOfferContentResponse where
  toJSON UpdateOfferContentResponse {..} =
   _omitNulls
      [ "status" .= updateOfferContentResponseStatus
      , "results" .= updateOfferContentResponseResults
      ]


-- | Construct a value of type 'UpdateOfferContentResponse' (by applying it's required fields, if any)
mkUpdateOfferContentResponse
  :: UpdateOfferContentResponse
mkUpdateOfferContentResponse =
  UpdateOfferContentResponse
  { updateOfferContentResponseStatus = Nothing
  , updateOfferContentResponseResults = Nothing
  }

-- ** UpdateOfferContentResultDTO
-- | UpdateOfferContentResultDTO
-- Ошибки и предупреждения, которые появились из-за переданных характеристик.
data UpdateOfferContentResultDTO = UpdateOfferContentResultDTO
  { updateOfferContentResultDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , updateOfferContentResultDTOErrors :: !(Maybe [OfferContentErrorDTO]) -- ^ "errors" - Ошибки — информация в каталоге не обновится.
  , updateOfferContentResultDTOWarnings :: !(Maybe [OfferContentErrorDTO]) -- ^ "warnings" - Предупреждения — информация в каталоге обновится.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferContentResultDTO
instance A.FromJSON UpdateOfferContentResultDTO where
  parseJSON = A.withObject "UpdateOfferContentResultDTO" $ \o ->
    UpdateOfferContentResultDTO
      <$> (o .:  "offerId")
      <*> (o .:? "errors")
      <*> (o .:? "warnings")

-- | ToJSON UpdateOfferContentResultDTO
instance A.ToJSON UpdateOfferContentResultDTO where
  toJSON UpdateOfferContentResultDTO {..} =
   _omitNulls
      [ "offerId" .= updateOfferContentResultDTOOfferId
      , "errors" .= updateOfferContentResultDTOErrors
      , "warnings" .= updateOfferContentResultDTOWarnings
      ]


-- | Construct a value of type 'UpdateOfferContentResultDTO' (by applying it's required fields, if any)
mkUpdateOfferContentResultDTO
  :: Text -- ^ 'updateOfferContentResultDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> UpdateOfferContentResultDTO
mkUpdateOfferContentResultDTO updateOfferContentResultDTOOfferId =
  UpdateOfferContentResultDTO
  { updateOfferContentResultDTOOfferId
  , updateOfferContentResultDTOErrors = Nothing
  , updateOfferContentResultDTOWarnings = Nothing
  }

-- ** UpdateOfferDTO
-- | UpdateOfferDTO
-- Параметры товара.
data UpdateOfferDTO = UpdateOfferDTO
  { updateOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , updateOfferDTOName :: !(Maybe Text) -- ^ "name" - Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
  , updateOfferDTOMarketCategoryId :: !(Maybe Integer) -- ^ "marketCategoryId" - Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать &#x60;marketCategoryId&#x60;, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
  , updateOfferDTOCategory :: !(Maybe Text) -- ^ "category" - Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре &#x60;marketCategoryId&#x60;. 
  , updateOfferDTOPictures :: !(Maybe [Text]) -- ^ "pictures" - Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ &#x60;https://example-shop.ru/images/sku12345.jpg&#x60;  ✅ &#x60;https://yadi.sk/i/NaBoRsimVOLov&#x60;  ❌ &#x60;/images/sku12345.jpg&#x60;  ❌ &#x60;https://www.dropbox.com/s/818f/tovar.jpg&#x60;  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html) 
  , updateOfferDTOVideos :: !(Maybe [Text]) -- ^ "videos" - Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ &#x60;https://example-shop.ru/video/sku12345.avi&#x60;  ✅ &#x60;https://yadi.sk/i/NaBoRsimVOLov&#x60;  ❌ &#x60;/video/sku12345.avi&#x60;  ❌ &#x60;https://www.dropbox.com/s/818f/super-tovar.avi&#x60;  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html) 
  , updateOfferDTOManuals :: !(Maybe [OfferManualDTO]) -- ^ "manuals" - Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле &#x60;manuals&#x60;, загруженные ранее инструкции удалятся. 
  , updateOfferDTOVendor :: !(Maybe Text) -- ^ "vendor" - Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
  , updateOfferDTOBarcodes :: !(Maybe [Text]) -- ^ "barcodes" - Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
  , updateOfferDTODescription :: !(Maybe Text) -- ^ "description" - Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\&lt;h&gt;, \\&lt;h1&gt;, \\&lt;h2&gt; и так далее — для заголовков; * \\&lt;br&gt; и \\&lt;p&gt; — для переноса строки; * \\&lt;ol&gt; — для нумерованного списка; * \\&lt;ul&gt; — для маркированного списка; * \\&lt;li&gt; — для создания элементов списка (должен находиться внутри \\&lt;ol&gt; или \\&lt;ul&gt;); * \\&lt;div&gt; — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
  , updateOfferDTOManufacturerCountries :: !(Maybe [Text]) -- ^ "manufacturerCountries" - Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx). 
  , updateOfferDTOWeightDimensions :: !(Maybe OfferWeightDimensionsDTO) -- ^ "weightDimensions"
  , updateOfferDTOVendorCode :: !(Maybe Text) -- ^ "vendorCode" - Артикул товара от производителя.
  , updateOfferDTOTags :: !(Maybe [Text]) -- ^ "tags" - Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов. 
  , updateOfferDTOShelfLife :: !(Maybe TimePeriodDTO) -- ^ "shelfLife"
  , updateOfferDTOLifeTime :: !(Maybe TimePeriodDTO) -- ^ "lifeTime"
  , updateOfferDTOGuaranteePeriod :: !(Maybe TimePeriodDTO) -- ^ "guaranteePeriod"
  , updateOfferDTOCustomsCommodityCode :: !(Maybe Text) -- ^ "customsCommodityCode" - Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть. 
  , updateOfferDTOCertificates :: !(Maybe [Text]) -- ^ "certificates" - Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html). 
  , updateOfferDTOBoxCount :: !(Maybe Int) -- ^ "boxCount" - Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр. 
  , updateOfferDTOCondition :: !(Maybe OfferConditionDTO) -- ^ "condition"
  , updateOfferDTOType :: !(Maybe OfferType) -- ^ "type"
  , updateOfferDTODownloadable :: !(Maybe Bool) -- ^ "downloadable" - Признак цифрового товара. Укажите &#x60;true&#x60;, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md) 
  , updateOfferDTOAdult :: !(Maybe Bool) -- ^ "adult" - Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей. 
  , updateOfferDTOAge :: !(Maybe AgeDTO) -- ^ "age"
  , updateOfferDTOParams :: !(Maybe [OfferParamDTO]) -- ^ "params" - {% note warning \&quot;\&quot; %}  Этот параметр устарел. При передаче характеристик используйте &#x60;parameterValues&#x60;.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви. 
  , updateOfferDTOParameterValues :: !(Maybe [ParameterValueDTO]) -- ^ "parameterValues" - Список характеристик с их значениями.  С &#x60;parameterValues&#x60; обязательно передавайте &#x60;marketCategoryId&#x60; — идентификатор категории на Маркете, к которой относятся указанные характеристики товара.  При **изменении** характеристик передавайте только те, значение которых нужно обновить.  Чтобы **удалить** значение заданной характеристики, передайте ее &#x60;parameterId&#x60; с пустым &#x60;value&#x60;.  Максимальное количество характеристик — 300. 
  , updateOfferDTOBasicPrice :: !(Maybe UpdatePriceWithDiscountDTO) -- ^ "basicPrice"
  , updateOfferDTOPurchasePrice :: !(Maybe BasePriceDTO) -- ^ "purchasePrice"
  , updateOfferDTOAdditionalExpenses :: !(Maybe BasePriceDTO) -- ^ "additionalExpenses"
  , updateOfferDTOCofinancePrice :: !(Maybe BasePriceDTO) -- ^ "cofinancePrice"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferDTO
instance A.FromJSON UpdateOfferDTO where
  parseJSON = A.withObject "UpdateOfferDTO" $ \o ->
    UpdateOfferDTO
      <$> (o .:  "offerId")
      <*> (o .:? "name")
      <*> (o .:? "marketCategoryId")
      <*> (o .:? "category")
      <*> (o .:? "pictures")
      <*> (o .:? "videos")
      <*> (o .:? "manuals")
      <*> (o .:? "vendor")
      <*> (o .:? "barcodes")
      <*> (o .:? "description")
      <*> (o .:? "manufacturerCountries")
      <*> (o .:? "weightDimensions")
      <*> (o .:? "vendorCode")
      <*> (o .:? "tags")
      <*> (o .:? "shelfLife")
      <*> (o .:? "lifeTime")
      <*> (o .:? "guaranteePeriod")
      <*> (o .:? "customsCommodityCode")
      <*> (o .:? "certificates")
      <*> (o .:? "boxCount")
      <*> (o .:? "condition")
      <*> (o .:? "type")
      <*> (o .:? "downloadable")
      <*> (o .:? "adult")
      <*> (o .:? "age")
      <*> (o .:? "params")
      <*> (o .:? "parameterValues")
      <*> (o .:? "basicPrice")
      <*> (o .:? "purchasePrice")
      <*> (o .:? "additionalExpenses")
      <*> (o .:? "cofinancePrice")

-- | ToJSON UpdateOfferDTO
instance A.ToJSON UpdateOfferDTO where
  toJSON UpdateOfferDTO {..} =
   _omitNulls
      [ "offerId" .= updateOfferDTOOfferId
      , "name" .= updateOfferDTOName
      , "marketCategoryId" .= updateOfferDTOMarketCategoryId
      , "category" .= updateOfferDTOCategory
      , "pictures" .= updateOfferDTOPictures
      , "videos" .= updateOfferDTOVideos
      , "manuals" .= updateOfferDTOManuals
      , "vendor" .= updateOfferDTOVendor
      , "barcodes" .= updateOfferDTOBarcodes
      , "description" .= updateOfferDTODescription
      , "manufacturerCountries" .= updateOfferDTOManufacturerCountries
      , "weightDimensions" .= updateOfferDTOWeightDimensions
      , "vendorCode" .= updateOfferDTOVendorCode
      , "tags" .= updateOfferDTOTags
      , "shelfLife" .= updateOfferDTOShelfLife
      , "lifeTime" .= updateOfferDTOLifeTime
      , "guaranteePeriod" .= updateOfferDTOGuaranteePeriod
      , "customsCommodityCode" .= updateOfferDTOCustomsCommodityCode
      , "certificates" .= updateOfferDTOCertificates
      , "boxCount" .= updateOfferDTOBoxCount
      , "condition" .= updateOfferDTOCondition
      , "type" .= updateOfferDTOType
      , "downloadable" .= updateOfferDTODownloadable
      , "adult" .= updateOfferDTOAdult
      , "age" .= updateOfferDTOAge
      , "params" .= updateOfferDTOParams
      , "parameterValues" .= updateOfferDTOParameterValues
      , "basicPrice" .= updateOfferDTOBasicPrice
      , "purchasePrice" .= updateOfferDTOPurchasePrice
      , "additionalExpenses" .= updateOfferDTOAdditionalExpenses
      , "cofinancePrice" .= updateOfferDTOCofinancePrice
      ]


-- | Construct a value of type 'UpdateOfferDTO' (by applying it's required fields, if any)
mkUpdateOfferDTO
  :: Text -- ^ 'updateOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> UpdateOfferDTO
mkUpdateOfferDTO updateOfferDTOOfferId =
  UpdateOfferDTO
  { updateOfferDTOOfferId
  , updateOfferDTOName = Nothing
  , updateOfferDTOMarketCategoryId = Nothing
  , updateOfferDTOCategory = Nothing
  , updateOfferDTOPictures = Nothing
  , updateOfferDTOVideos = Nothing
  , updateOfferDTOManuals = Nothing
  , updateOfferDTOVendor = Nothing
  , updateOfferDTOBarcodes = Nothing
  , updateOfferDTODescription = Nothing
  , updateOfferDTOManufacturerCountries = Nothing
  , updateOfferDTOWeightDimensions = Nothing
  , updateOfferDTOVendorCode = Nothing
  , updateOfferDTOTags = Nothing
  , updateOfferDTOShelfLife = Nothing
  , updateOfferDTOLifeTime = Nothing
  , updateOfferDTOGuaranteePeriod = Nothing
  , updateOfferDTOCustomsCommodityCode = Nothing
  , updateOfferDTOCertificates = Nothing
  , updateOfferDTOBoxCount = Nothing
  , updateOfferDTOCondition = Nothing
  , updateOfferDTOType = Nothing
  , updateOfferDTODownloadable = Nothing
  , updateOfferDTOAdult = Nothing
  , updateOfferDTOAge = Nothing
  , updateOfferDTOParams = Nothing
  , updateOfferDTOParameterValues = Nothing
  , updateOfferDTOBasicPrice = Nothing
  , updateOfferDTOPurchasePrice = Nothing
  , updateOfferDTOAdditionalExpenses = Nothing
  , updateOfferDTOCofinancePrice = Nothing
  }

-- ** UpdateOfferMappingDTO
-- | UpdateOfferMappingDTO
-- Информация о товаре.
data UpdateOfferMappingDTO = UpdateOfferMappingDTO
  { updateOfferMappingDTOOffer :: !(UpdateOfferDTO) -- ^ /Required/ "offer"
  , updateOfferMappingDTOMapping :: !(Maybe UpdateMappingDTO) -- ^ "mapping"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferMappingDTO
instance A.FromJSON UpdateOfferMappingDTO where
  parseJSON = A.withObject "UpdateOfferMappingDTO" $ \o ->
    UpdateOfferMappingDTO
      <$> (o .:  "offer")
      <*> (o .:? "mapping")

-- | ToJSON UpdateOfferMappingDTO
instance A.ToJSON UpdateOfferMappingDTO where
  toJSON UpdateOfferMappingDTO {..} =
   _omitNulls
      [ "offer" .= updateOfferMappingDTOOffer
      , "mapping" .= updateOfferMappingDTOMapping
      ]


-- | Construct a value of type 'UpdateOfferMappingDTO' (by applying it's required fields, if any)
mkUpdateOfferMappingDTO
  :: UpdateOfferDTO -- ^ 'updateOfferMappingDTOOffer' 
  -> UpdateOfferMappingDTO
mkUpdateOfferMappingDTO updateOfferMappingDTOOffer =
  UpdateOfferMappingDTO
  { updateOfferMappingDTOOffer
  , updateOfferMappingDTOMapping = Nothing
  }

-- ** UpdateOfferMappingEntryDTO
-- | UpdateOfferMappingEntryDTO
-- Список товаров.  В теле запроса можно передать от одного до 500 товаров.  Обязательный параметр. 
data UpdateOfferMappingEntryDTO = UpdateOfferMappingEntryDTO
  { updateOfferMappingEntryDTOMapping :: !(Maybe OfferMappingDTO) -- ^ "mapping"
  , updateOfferMappingEntryDTOAwaitingModerationMapping :: !(Maybe OfferMappingDTO) -- ^ "awaitingModerationMapping"
  , updateOfferMappingEntryDTORejectedMapping :: !(Maybe OfferMappingDTO) -- ^ "rejectedMapping"
  , updateOfferMappingEntryDTOOffer :: !(Maybe UpdateMappingsOfferDTO) -- ^ "offer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferMappingEntryDTO
instance A.FromJSON UpdateOfferMappingEntryDTO where
  parseJSON = A.withObject "UpdateOfferMappingEntryDTO" $ \o ->
    UpdateOfferMappingEntryDTO
      <$> (o .:? "mapping")
      <*> (o .:? "awaitingModerationMapping")
      <*> (o .:? "rejectedMapping")
      <*> (o .:? "offer")

-- | ToJSON UpdateOfferMappingEntryDTO
instance A.ToJSON UpdateOfferMappingEntryDTO where
  toJSON UpdateOfferMappingEntryDTO {..} =
   _omitNulls
      [ "mapping" .= updateOfferMappingEntryDTOMapping
      , "awaitingModerationMapping" .= updateOfferMappingEntryDTOAwaitingModerationMapping
      , "rejectedMapping" .= updateOfferMappingEntryDTORejectedMapping
      , "offer" .= updateOfferMappingEntryDTOOffer
      ]


-- | Construct a value of type 'UpdateOfferMappingEntryDTO' (by applying it's required fields, if any)
mkUpdateOfferMappingEntryDTO
  :: UpdateOfferMappingEntryDTO
mkUpdateOfferMappingEntryDTO =
  UpdateOfferMappingEntryDTO
  { updateOfferMappingEntryDTOMapping = Nothing
  , updateOfferMappingEntryDTOAwaitingModerationMapping = Nothing
  , updateOfferMappingEntryDTORejectedMapping = Nothing
  , updateOfferMappingEntryDTOOffer = Nothing
  }

-- ** UpdateOfferMappingEntryRequest
-- | UpdateOfferMappingEntryRequest
-- Запрос на обновление товаров.
data UpdateOfferMappingEntryRequest = UpdateOfferMappingEntryRequest
  { updateOfferMappingEntryRequestOfferMappingEntries :: !([UpdateOfferMappingEntryDTO]) -- ^ /Required/ "offerMappingEntries" - Информация о товарах в каталоге.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferMappingEntryRequest
instance A.FromJSON UpdateOfferMappingEntryRequest where
  parseJSON = A.withObject "UpdateOfferMappingEntryRequest" $ \o ->
    UpdateOfferMappingEntryRequest
      <$> (o .:  "offerMappingEntries")

-- | ToJSON UpdateOfferMappingEntryRequest
instance A.ToJSON UpdateOfferMappingEntryRequest where
  toJSON UpdateOfferMappingEntryRequest {..} =
   _omitNulls
      [ "offerMappingEntries" .= updateOfferMappingEntryRequestOfferMappingEntries
      ]


-- | Construct a value of type 'UpdateOfferMappingEntryRequest' (by applying it's required fields, if any)
mkUpdateOfferMappingEntryRequest
  :: [UpdateOfferMappingEntryDTO] -- ^ 'updateOfferMappingEntryRequestOfferMappingEntries': Информация о товарах в каталоге.
  -> UpdateOfferMappingEntryRequest
mkUpdateOfferMappingEntryRequest updateOfferMappingEntryRequestOfferMappingEntries =
  UpdateOfferMappingEntryRequest
  { updateOfferMappingEntryRequestOfferMappingEntries
  }

-- ** UpdateOfferMappingResultDTO
-- | UpdateOfferMappingResultDTO
-- Ошибки и предупреждения, которые появились из-за переданных характеристик.
data UpdateOfferMappingResultDTO = UpdateOfferMappingResultDTO
  { updateOfferMappingResultDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , updateOfferMappingResultDTOErrors :: !(Maybe [OfferMappingErrorDTO]) -- ^ "errors" - Ошибки — информация в каталоге не обновится.
  , updateOfferMappingResultDTOWarnings :: !(Maybe [OfferMappingErrorDTO]) -- ^ "warnings" - Предупреждения — информация в каталоге обновится.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferMappingResultDTO
instance A.FromJSON UpdateOfferMappingResultDTO where
  parseJSON = A.withObject "UpdateOfferMappingResultDTO" $ \o ->
    UpdateOfferMappingResultDTO
      <$> (o .:  "offerId")
      <*> (o .:? "errors")
      <*> (o .:? "warnings")

-- | ToJSON UpdateOfferMappingResultDTO
instance A.ToJSON UpdateOfferMappingResultDTO where
  toJSON UpdateOfferMappingResultDTO {..} =
   _omitNulls
      [ "offerId" .= updateOfferMappingResultDTOOfferId
      , "errors" .= updateOfferMappingResultDTOErrors
      , "warnings" .= updateOfferMappingResultDTOWarnings
      ]


-- | Construct a value of type 'UpdateOfferMappingResultDTO' (by applying it's required fields, if any)
mkUpdateOfferMappingResultDTO
  :: Text -- ^ 'updateOfferMappingResultDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> UpdateOfferMappingResultDTO
mkUpdateOfferMappingResultDTO updateOfferMappingResultDTOOfferId =
  UpdateOfferMappingResultDTO
  { updateOfferMappingResultDTOOfferId
  , updateOfferMappingResultDTOErrors = Nothing
  , updateOfferMappingResultDTOWarnings = Nothing
  }

-- ** UpdateOfferMappingsRequest
-- | UpdateOfferMappingsRequest
data UpdateOfferMappingsRequest = UpdateOfferMappingsRequest
  { updateOfferMappingsRequestOfferMappings :: !([UpdateOfferMappingDTO]) -- ^ /Required/ "offerMappings" - Перечень товаров, которые нужно добавить или обновить.
  , updateOfferMappingsRequestOnlyPartnerMediaContent :: !(Maybe Bool) -- ^ "onlyPartnerMediaContent" - Будут использоваться только переданные вами изображения товаров.  Значение по умолчанию — &#x60;false&#x60;. Если вы хотите заменить изображения, которые добавил Маркет, передайте значение &#x60;true&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferMappingsRequest
instance A.FromJSON UpdateOfferMappingsRequest where
  parseJSON = A.withObject "UpdateOfferMappingsRequest" $ \o ->
    UpdateOfferMappingsRequest
      <$> (o .:  "offerMappings")
      <*> (o .:? "onlyPartnerMediaContent")

-- | ToJSON UpdateOfferMappingsRequest
instance A.ToJSON UpdateOfferMappingsRequest where
  toJSON UpdateOfferMappingsRequest {..} =
   _omitNulls
      [ "offerMappings" .= updateOfferMappingsRequestOfferMappings
      , "onlyPartnerMediaContent" .= updateOfferMappingsRequestOnlyPartnerMediaContent
      ]


-- | Construct a value of type 'UpdateOfferMappingsRequest' (by applying it's required fields, if any)
mkUpdateOfferMappingsRequest
  :: [UpdateOfferMappingDTO] -- ^ 'updateOfferMappingsRequestOfferMappings': Перечень товаров, которые нужно добавить или обновить.
  -> UpdateOfferMappingsRequest
mkUpdateOfferMappingsRequest updateOfferMappingsRequestOfferMappings =
  UpdateOfferMappingsRequest
  { updateOfferMappingsRequestOfferMappings
  , updateOfferMappingsRequestOnlyPartnerMediaContent = Nothing
  }

-- ** UpdateOfferMappingsResponse
-- | UpdateOfferMappingsResponse
-- Описывает проблемы, возникшие при сохранении товара.
data UpdateOfferMappingsResponse = UpdateOfferMappingsResponse
  { updateOfferMappingsResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , updateOfferMappingsResponseResults :: !(Maybe [UpdateOfferMappingResultDTO]) -- ^ "results" - Ошибки и предупреждения, которые появились при обработке списка характеристик. Каждый элемент списка соответствует одному товару.  Если ошибок и предупреждений нет, поле не передается. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOfferMappingsResponse
instance A.FromJSON UpdateOfferMappingsResponse where
  parseJSON = A.withObject "UpdateOfferMappingsResponse" $ \o ->
    UpdateOfferMappingsResponse
      <$> (o .:? "status")
      <*> (o .:? "results")

-- | ToJSON UpdateOfferMappingsResponse
instance A.ToJSON UpdateOfferMappingsResponse where
  toJSON UpdateOfferMappingsResponse {..} =
   _omitNulls
      [ "status" .= updateOfferMappingsResponseStatus
      , "results" .= updateOfferMappingsResponseResults
      ]


-- | Construct a value of type 'UpdateOfferMappingsResponse' (by applying it's required fields, if any)
mkUpdateOfferMappingsResponse
  :: UpdateOfferMappingsResponse
mkUpdateOfferMappingsResponse =
  UpdateOfferMappingsResponse
  { updateOfferMappingsResponseStatus = Nothing
  , updateOfferMappingsResponseResults = Nothing
  }

-- ** UpdateOrderItemRequest
-- | UpdateOrderItemRequest
-- Запрос на обновление состава заказа.
data UpdateOrderItemRequest = UpdateOrderItemRequest
  { updateOrderItemRequestItems :: !([OrderItemModificationDTO]) -- ^ /Required/ "items" - Список товаров в заказе.  Если магазин не передал информацию о товаре во входных данных, он будет удален из заказа.  Обязательный параметр. 
  , updateOrderItemRequestReason :: !(Maybe OrderItemsModificationRequestReasonType) -- ^ "reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOrderItemRequest
instance A.FromJSON UpdateOrderItemRequest where
  parseJSON = A.withObject "UpdateOrderItemRequest" $ \o ->
    UpdateOrderItemRequest
      <$> (o .:  "items")
      <*> (o .:? "reason")

-- | ToJSON UpdateOrderItemRequest
instance A.ToJSON UpdateOrderItemRequest where
  toJSON UpdateOrderItemRequest {..} =
   _omitNulls
      [ "items" .= updateOrderItemRequestItems
      , "reason" .= updateOrderItemRequestReason
      ]


-- | Construct a value of type 'UpdateOrderItemRequest' (by applying it's required fields, if any)
mkUpdateOrderItemRequest
  :: [OrderItemModificationDTO] -- ^ 'updateOrderItemRequestItems': Список товаров в заказе.  Если магазин не передал информацию о товаре во входных данных, он будет удален из заказа.  Обязательный параметр. 
  -> UpdateOrderItemRequest
mkUpdateOrderItemRequest updateOrderItemRequestItems =
  UpdateOrderItemRequest
  { updateOrderItemRequestItems
  , updateOrderItemRequestReason = Nothing
  }

-- ** UpdateOrderStatusDTO
-- | UpdateOrderStatusDTO
-- Список заказов.
data UpdateOrderStatusDTO = UpdateOrderStatusDTO
  { updateOrderStatusDTOId :: !(Maybe Integer) -- ^ "id" - Идентификатор заказа.
  , updateOrderStatusDTOStatus :: !(Maybe OrderStatusType) -- ^ "status"
  , updateOrderStatusDTOSubstatus :: !(Maybe OrderSubstatusType) -- ^ "substatus"
  , updateOrderStatusDTOUpdateStatus :: !(Maybe OrderUpdateStatusType) -- ^ "updateStatus"
  , updateOrderStatusDTOErrorDetails :: !(Maybe Text) -- ^ "errorDetails" - Ошибка при изменении статуса заказа. Содержит описание ошибки и идентификатор заказа.  Возвращается, если параметр &#x60;updateStatus&#x60; принимает значение &#x60;ERROR&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOrderStatusDTO
instance A.FromJSON UpdateOrderStatusDTO where
  parseJSON = A.withObject "UpdateOrderStatusDTO" $ \o ->
    UpdateOrderStatusDTO
      <$> (o .:? "id")
      <*> (o .:? "status")
      <*> (o .:? "substatus")
      <*> (o .:? "updateStatus")
      <*> (o .:? "errorDetails")

-- | ToJSON UpdateOrderStatusDTO
instance A.ToJSON UpdateOrderStatusDTO where
  toJSON UpdateOrderStatusDTO {..} =
   _omitNulls
      [ "id" .= updateOrderStatusDTOId
      , "status" .= updateOrderStatusDTOStatus
      , "substatus" .= updateOrderStatusDTOSubstatus
      , "updateStatus" .= updateOrderStatusDTOUpdateStatus
      , "errorDetails" .= updateOrderStatusDTOErrorDetails
      ]


-- | Construct a value of type 'UpdateOrderStatusDTO' (by applying it's required fields, if any)
mkUpdateOrderStatusDTO
  :: UpdateOrderStatusDTO
mkUpdateOrderStatusDTO =
  UpdateOrderStatusDTO
  { updateOrderStatusDTOId = Nothing
  , updateOrderStatusDTOStatus = Nothing
  , updateOrderStatusDTOSubstatus = Nothing
  , updateOrderStatusDTOUpdateStatus = Nothing
  , updateOrderStatusDTOErrorDetails = Nothing
  }

-- ** UpdateOrderStatusRequest
-- | UpdateOrderStatusRequest
data UpdateOrderStatusRequest = UpdateOrderStatusRequest
  { updateOrderStatusRequestOrder :: !(OrderStatusChangeDTO) -- ^ /Required/ "order"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOrderStatusRequest
instance A.FromJSON UpdateOrderStatusRequest where
  parseJSON = A.withObject "UpdateOrderStatusRequest" $ \o ->
    UpdateOrderStatusRequest
      <$> (o .:  "order")

-- | ToJSON UpdateOrderStatusRequest
instance A.ToJSON UpdateOrderStatusRequest where
  toJSON UpdateOrderStatusRequest {..} =
   _omitNulls
      [ "order" .= updateOrderStatusRequestOrder
      ]


-- | Construct a value of type 'UpdateOrderStatusRequest' (by applying it's required fields, if any)
mkUpdateOrderStatusRequest
  :: OrderStatusChangeDTO -- ^ 'updateOrderStatusRequestOrder' 
  -> UpdateOrderStatusRequest
mkUpdateOrderStatusRequest updateOrderStatusRequestOrder =
  UpdateOrderStatusRequest
  { updateOrderStatusRequestOrder
  }

-- ** UpdateOrderStatusResponse
-- | UpdateOrderStatusResponse
-- Информация об изменении статуса заказа.
data UpdateOrderStatusResponse = UpdateOrderStatusResponse
  { updateOrderStatusResponseOrder :: !(Maybe OrderDTO) -- ^ "order"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOrderStatusResponse
instance A.FromJSON UpdateOrderStatusResponse where
  parseJSON = A.withObject "UpdateOrderStatusResponse" $ \o ->
    UpdateOrderStatusResponse
      <$> (o .:? "order")

-- | ToJSON UpdateOrderStatusResponse
instance A.ToJSON UpdateOrderStatusResponse where
  toJSON UpdateOrderStatusResponse {..} =
   _omitNulls
      [ "order" .= updateOrderStatusResponseOrder
      ]


-- | Construct a value of type 'UpdateOrderStatusResponse' (by applying it's required fields, if any)
mkUpdateOrderStatusResponse
  :: UpdateOrderStatusResponse
mkUpdateOrderStatusResponse =
  UpdateOrderStatusResponse
  { updateOrderStatusResponseOrder = Nothing
  }

-- ** UpdateOrderStatusesDTO
-- | UpdateOrderStatusesDTO
-- Список заказов, статус которых обновился.
data UpdateOrderStatusesDTO = UpdateOrderStatusesDTO
  { updateOrderStatusesDTOOrders :: !([UpdateOrderStatusDTO]) -- ^ /Required/ "orders" - Список с обновленными заказами.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOrderStatusesDTO
instance A.FromJSON UpdateOrderStatusesDTO where
  parseJSON = A.withObject "UpdateOrderStatusesDTO" $ \o ->
    UpdateOrderStatusesDTO
      <$> (o .:  "orders")

-- | ToJSON UpdateOrderStatusesDTO
instance A.ToJSON UpdateOrderStatusesDTO where
  toJSON UpdateOrderStatusesDTO {..} =
   _omitNulls
      [ "orders" .= updateOrderStatusesDTOOrders
      ]


-- | Construct a value of type 'UpdateOrderStatusesDTO' (by applying it's required fields, if any)
mkUpdateOrderStatusesDTO
  :: [UpdateOrderStatusDTO] -- ^ 'updateOrderStatusesDTOOrders': Список с обновленными заказами.
  -> UpdateOrderStatusesDTO
mkUpdateOrderStatusesDTO updateOrderStatusesDTOOrders =
  UpdateOrderStatusesDTO
  { updateOrderStatusesDTOOrders
  }

-- ** UpdateOrderStatusesRequest
-- | UpdateOrderStatusesRequest
-- Список заказов.
data UpdateOrderStatusesRequest = UpdateOrderStatusesRequest
  { updateOrderStatusesRequestOrders :: !([OrderStateDTO]) -- ^ /Required/ "orders" - Список заказов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOrderStatusesRequest
instance A.FromJSON UpdateOrderStatusesRequest where
  parseJSON = A.withObject "UpdateOrderStatusesRequest" $ \o ->
    UpdateOrderStatusesRequest
      <$> (o .:  "orders")

-- | ToJSON UpdateOrderStatusesRequest
instance A.ToJSON UpdateOrderStatusesRequest where
  toJSON UpdateOrderStatusesRequest {..} =
   _omitNulls
      [ "orders" .= updateOrderStatusesRequestOrders
      ]


-- | Construct a value of type 'UpdateOrderStatusesRequest' (by applying it's required fields, if any)
mkUpdateOrderStatusesRequest
  :: [OrderStateDTO] -- ^ 'updateOrderStatusesRequestOrders': Список заказов.
  -> UpdateOrderStatusesRequest
mkUpdateOrderStatusesRequest updateOrderStatusesRequestOrders =
  UpdateOrderStatusesRequest
  { updateOrderStatusesRequestOrders
  }

-- ** UpdateOrderStatusesResponse
-- | UpdateOrderStatusesResponse
data UpdateOrderStatusesResponse = UpdateOrderStatusesResponse
  { updateOrderStatusesResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , updateOrderStatusesResponseResult :: !(Maybe UpdateOrderStatusesDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOrderStatusesResponse
instance A.FromJSON UpdateOrderStatusesResponse where
  parseJSON = A.withObject "UpdateOrderStatusesResponse" $ \o ->
    UpdateOrderStatusesResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON UpdateOrderStatusesResponse
instance A.ToJSON UpdateOrderStatusesResponse where
  toJSON UpdateOrderStatusesResponse {..} =
   _omitNulls
      [ "status" .= updateOrderStatusesResponseStatus
      , "result" .= updateOrderStatusesResponseResult
      ]


-- | Construct a value of type 'UpdateOrderStatusesResponse' (by applying it's required fields, if any)
mkUpdateOrderStatusesResponse
  :: UpdateOrderStatusesResponse
mkUpdateOrderStatusesResponse =
  UpdateOrderStatusesResponse
  { updateOrderStatusesResponseStatus = Nothing
  , updateOrderStatusesResponseResult = Nothing
  }

-- ** UpdateOrderStorageLimitRequest
-- | UpdateOrderStorageLimitRequest
-- Запрос на обновление срока хранения заказа в ПВЗ.
data UpdateOrderStorageLimitRequest = UpdateOrderStorageLimitRequest
  { updateOrderStorageLimitRequestNewDate :: !(Date) -- ^ /Required/ "newDate" - Новая дата, до которой заказ будет храниться в пункте выдачи.  Срок хранения можно увеличить не больше, чем на 30 дней.  Формат даты: &#x60;ГГГГ-ММ-ДД&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOrderStorageLimitRequest
instance A.FromJSON UpdateOrderStorageLimitRequest where
  parseJSON = A.withObject "UpdateOrderStorageLimitRequest" $ \o ->
    UpdateOrderStorageLimitRequest
      <$> (o .:  "newDate")

-- | ToJSON UpdateOrderStorageLimitRequest
instance A.ToJSON UpdateOrderStorageLimitRequest where
  toJSON UpdateOrderStorageLimitRequest {..} =
   _omitNulls
      [ "newDate" .= updateOrderStorageLimitRequestNewDate
      ]


-- | Construct a value of type 'UpdateOrderStorageLimitRequest' (by applying it's required fields, if any)
mkUpdateOrderStorageLimitRequest
  :: Date -- ^ 'updateOrderStorageLimitRequestNewDate': Новая дата, до которой заказ будет храниться в пункте выдачи.  Срок хранения можно увеличить не больше, чем на 30 дней.  Формат даты: `ГГГГ-ММ-ДД`. 
  -> UpdateOrderStorageLimitRequest
mkUpdateOrderStorageLimitRequest updateOrderStorageLimitRequestNewDate =
  UpdateOrderStorageLimitRequest
  { updateOrderStorageLimitRequestNewDate
  }

-- ** UpdateOutletLicenseRequest
-- | UpdateOutletLicenseRequest
-- Запрос на создание или изменение лицензий для точек продаж.
data UpdateOutletLicenseRequest = UpdateOutletLicenseRequest
  { updateOutletLicenseRequestLicenses :: !([OutletLicenseDTO]) -- ^ /Required/ "licenses" - Список лицензий. Обязательный параметр, должен содержать информацию хотя бы об одной лицензии. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateOutletLicenseRequest
instance A.FromJSON UpdateOutletLicenseRequest where
  parseJSON = A.withObject "UpdateOutletLicenseRequest" $ \o ->
    UpdateOutletLicenseRequest
      <$> (o .:  "licenses")

-- | ToJSON UpdateOutletLicenseRequest
instance A.ToJSON UpdateOutletLicenseRequest where
  toJSON UpdateOutletLicenseRequest {..} =
   _omitNulls
      [ "licenses" .= updateOutletLicenseRequestLicenses
      ]


-- | Construct a value of type 'UpdateOutletLicenseRequest' (by applying it's required fields, if any)
mkUpdateOutletLicenseRequest
  :: [OutletLicenseDTO] -- ^ 'updateOutletLicenseRequestLicenses': Список лицензий. Обязательный параметр, должен содержать информацию хотя бы об одной лицензии. 
  -> UpdateOutletLicenseRequest
mkUpdateOutletLicenseRequest updateOutletLicenseRequestLicenses =
  UpdateOutletLicenseRequest
  { updateOutletLicenseRequestLicenses
  }

-- ** UpdatePriceWithDiscountDTO
-- | UpdatePriceWithDiscountDTO
-- Цена с указанием скидки.
data UpdatePriceWithDiscountDTO = UpdatePriceWithDiscountDTO
  { updatePriceWithDiscountDTOValue :: !(Double) -- ^ /Required/ "value" - Значение.
  , updatePriceWithDiscountDTOCurrencyId :: !(CurrencyType) -- ^ /Required/ "currencyId"
  , updatePriceWithDiscountDTODiscountBase :: !(Maybe Double) -- ^ "discountBase" - Цена до скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatePriceWithDiscountDTO
instance A.FromJSON UpdatePriceWithDiscountDTO where
  parseJSON = A.withObject "UpdatePriceWithDiscountDTO" $ \o ->
    UpdatePriceWithDiscountDTO
      <$> (o .:  "value")
      <*> (o .:  "currencyId")
      <*> (o .:? "discountBase")

-- | ToJSON UpdatePriceWithDiscountDTO
instance A.ToJSON UpdatePriceWithDiscountDTO where
  toJSON UpdatePriceWithDiscountDTO {..} =
   _omitNulls
      [ "value" .= updatePriceWithDiscountDTOValue
      , "currencyId" .= updatePriceWithDiscountDTOCurrencyId
      , "discountBase" .= updatePriceWithDiscountDTODiscountBase
      ]


-- | Construct a value of type 'UpdatePriceWithDiscountDTO' (by applying it's required fields, if any)
mkUpdatePriceWithDiscountDTO
  :: Double -- ^ 'updatePriceWithDiscountDTOValue': Значение.
  -> CurrencyType -- ^ 'updatePriceWithDiscountDTOCurrencyId' 
  -> UpdatePriceWithDiscountDTO
mkUpdatePriceWithDiscountDTO updatePriceWithDiscountDTOValue updatePriceWithDiscountDTOCurrencyId =
  UpdatePriceWithDiscountDTO
  { updatePriceWithDiscountDTOValue
  , updatePriceWithDiscountDTOCurrencyId
  , updatePriceWithDiscountDTODiscountBase = Nothing
  }

-- ** UpdatePricesRequest
-- | UpdatePricesRequest
-- Запрос на установку цен на товары.
data UpdatePricesRequest = UpdatePricesRequest
  { updatePricesRequestOffers :: !([OfferPriceDTO]) -- ^ /Required/ "offers" - Список товаров.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatePricesRequest
instance A.FromJSON UpdatePricesRequest where
  parseJSON = A.withObject "UpdatePricesRequest" $ \o ->
    UpdatePricesRequest
      <$> (o .:  "offers")

-- | ToJSON UpdatePricesRequest
instance A.ToJSON UpdatePricesRequest where
  toJSON UpdatePricesRequest {..} =
   _omitNulls
      [ "offers" .= updatePricesRequestOffers
      ]


-- | Construct a value of type 'UpdatePricesRequest' (by applying it's required fields, if any)
mkUpdatePricesRequest
  :: [OfferPriceDTO] -- ^ 'updatePricesRequestOffers': Список товаров.
  -> UpdatePricesRequest
mkUpdatePricesRequest updatePricesRequestOffers =
  UpdatePricesRequest
  { updatePricesRequestOffers
  }

-- ** UpdatePromoOfferDTO
-- | UpdatePromoOfferDTO
-- Описание товаров, которые участвуют в акции.
data UpdatePromoOfferDTO = UpdatePromoOfferDTO
  { updatePromoOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , updatePromoOfferDTOParams :: !(Maybe UpdatePromoOfferParamsDTO) -- ^ "params"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatePromoOfferDTO
instance A.FromJSON UpdatePromoOfferDTO where
  parseJSON = A.withObject "UpdatePromoOfferDTO" $ \o ->
    UpdatePromoOfferDTO
      <$> (o .:  "offerId")
      <*> (o .:? "params")

-- | ToJSON UpdatePromoOfferDTO
instance A.ToJSON UpdatePromoOfferDTO where
  toJSON UpdatePromoOfferDTO {..} =
   _omitNulls
      [ "offerId" .= updatePromoOfferDTOOfferId
      , "params" .= updatePromoOfferDTOParams
      ]


-- | Construct a value of type 'UpdatePromoOfferDTO' (by applying it's required fields, if any)
mkUpdatePromoOfferDTO
  :: Text -- ^ 'updatePromoOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> UpdatePromoOfferDTO
mkUpdatePromoOfferDTO updatePromoOfferDTOOfferId =
  UpdatePromoOfferDTO
  { updatePromoOfferDTOOfferId
  , updatePromoOfferDTOParams = Nothing
  }

-- ** UpdatePromoOfferDiscountParamsDTO
-- | UpdatePromoOfferDiscountParamsDTO
-- Параметры товара в акции с типом `DIRECT_DISCOUNT` или `BLUE_FLASH`.  Обязательный параметр для акций с этими типами. 
data UpdatePromoOfferDiscountParamsDTO = UpdatePromoOfferDiscountParamsDTO
  { updatePromoOfferDiscountParamsDTOPrice :: !(Maybe Integer) -- ^ "price" - Зачеркнутая цена — та, по которой товар продавался до акции.  Указывается в рублях.  Число должно быть целым. 
  , updatePromoOfferDiscountParamsDTOPromoPrice :: !(Maybe Integer) -- ^ "promoPrice" - Цена по акции — та, по которой вы хотите продавать товар.  Указывается в рублях.  Число должно быть целым. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatePromoOfferDiscountParamsDTO
instance A.FromJSON UpdatePromoOfferDiscountParamsDTO where
  parseJSON = A.withObject "UpdatePromoOfferDiscountParamsDTO" $ \o ->
    UpdatePromoOfferDiscountParamsDTO
      <$> (o .:? "price")
      <*> (o .:? "promoPrice")

-- | ToJSON UpdatePromoOfferDiscountParamsDTO
instance A.ToJSON UpdatePromoOfferDiscountParamsDTO where
  toJSON UpdatePromoOfferDiscountParamsDTO {..} =
   _omitNulls
      [ "price" .= updatePromoOfferDiscountParamsDTOPrice
      , "promoPrice" .= updatePromoOfferDiscountParamsDTOPromoPrice
      ]


-- | Construct a value of type 'UpdatePromoOfferDiscountParamsDTO' (by applying it's required fields, if any)
mkUpdatePromoOfferDiscountParamsDTO
  :: UpdatePromoOfferDiscountParamsDTO
mkUpdatePromoOfferDiscountParamsDTO =
  UpdatePromoOfferDiscountParamsDTO
  { updatePromoOfferDiscountParamsDTOPrice = Nothing
  , updatePromoOfferDiscountParamsDTOPromoPrice = Nothing
  }

-- ** UpdatePromoOfferParamsDTO
-- | UpdatePromoOfferParamsDTO
-- Параметры товара, который участвует в акции.
data UpdatePromoOfferParamsDTO = UpdatePromoOfferParamsDTO
  { updatePromoOfferParamsDTODiscountParams :: !(Maybe UpdatePromoOfferDiscountParamsDTO) -- ^ "discountParams"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatePromoOfferParamsDTO
instance A.FromJSON UpdatePromoOfferParamsDTO where
  parseJSON = A.withObject "UpdatePromoOfferParamsDTO" $ \o ->
    UpdatePromoOfferParamsDTO
      <$> (o .:? "discountParams")

-- | ToJSON UpdatePromoOfferParamsDTO
instance A.ToJSON UpdatePromoOfferParamsDTO where
  toJSON UpdatePromoOfferParamsDTO {..} =
   _omitNulls
      [ "discountParams" .= updatePromoOfferParamsDTODiscountParams
      ]


-- | Construct a value of type 'UpdatePromoOfferParamsDTO' (by applying it's required fields, if any)
mkUpdatePromoOfferParamsDTO
  :: UpdatePromoOfferParamsDTO
mkUpdatePromoOfferParamsDTO =
  UpdatePromoOfferParamsDTO
  { updatePromoOfferParamsDTODiscountParams = Nothing
  }

-- ** UpdatePromoOffersRequest
-- | UpdatePromoOffersRequest
-- Добавление товаров в акцию или обновление их параметров.  Чтобы добавить товары в акцию или обновить параметры каких-то товаров, передайте их в параметре `offers`. 
data UpdatePromoOffersRequest = UpdatePromoOffersRequest
  { updatePromoOffersRequestPromoId :: !(Text) -- ^ /Required/ "promoId" - Идентификатор акции.
  , updatePromoOffersRequestOffers :: !([UpdatePromoOfferDTO]) -- ^ /Required/ "offers" - Товары, которые необходимо добавить в акцию или цены которых нужно изменить.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatePromoOffersRequest
instance A.FromJSON UpdatePromoOffersRequest where
  parseJSON = A.withObject "UpdatePromoOffersRequest" $ \o ->
    UpdatePromoOffersRequest
      <$> (o .:  "promoId")
      <*> (o .:  "offers")

-- | ToJSON UpdatePromoOffersRequest
instance A.ToJSON UpdatePromoOffersRequest where
  toJSON UpdatePromoOffersRequest {..} =
   _omitNulls
      [ "promoId" .= updatePromoOffersRequestPromoId
      , "offers" .= updatePromoOffersRequestOffers
      ]


-- | Construct a value of type 'UpdatePromoOffersRequest' (by applying it's required fields, if any)
mkUpdatePromoOffersRequest
  :: Text -- ^ 'updatePromoOffersRequestPromoId': Идентификатор акции.
  -> [UpdatePromoOfferDTO] -- ^ 'updatePromoOffersRequestOffers': Товары, которые необходимо добавить в акцию или цены которых нужно изменить.
  -> UpdatePromoOffersRequest
mkUpdatePromoOffersRequest updatePromoOffersRequestPromoId updatePromoOffersRequestOffers =
  UpdatePromoOffersRequest
  { updatePromoOffersRequestPromoId
  , updatePromoOffersRequestOffers
  }

-- ** UpdatePromoOffersResponse
-- | UpdatePromoOffersResponse
-- Результат добавления товаров в акцию.
data UpdatePromoOffersResponse = UpdatePromoOffersResponse
  { updatePromoOffersResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , updatePromoOffersResponseResult :: !(Maybe UpdatePromoOffersResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatePromoOffersResponse
instance A.FromJSON UpdatePromoOffersResponse where
  parseJSON = A.withObject "UpdatePromoOffersResponse" $ \o ->
    UpdatePromoOffersResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON UpdatePromoOffersResponse
instance A.ToJSON UpdatePromoOffersResponse where
  toJSON UpdatePromoOffersResponse {..} =
   _omitNulls
      [ "status" .= updatePromoOffersResponseStatus
      , "result" .= updatePromoOffersResponseResult
      ]


-- | Construct a value of type 'UpdatePromoOffersResponse' (by applying it's required fields, if any)
mkUpdatePromoOffersResponse
  :: UpdatePromoOffersResponse
mkUpdatePromoOffersResponse =
  UpdatePromoOffersResponse
  { updatePromoOffersResponseStatus = Nothing
  , updatePromoOffersResponseResult = Nothing
  }

-- ** UpdatePromoOffersResultDTO
-- | UpdatePromoOffersResultDTO
-- Ошибки и предупреждения, которые появились при добавлении товаров в акцию.
data UpdatePromoOffersResultDTO = UpdatePromoOffersResultDTO
  { updatePromoOffersResultDTORejectedOffers :: !(Maybe [RejectedPromoOfferUpdateDTO]) -- ^ "rejectedOffers" - Изменения, которые были отклонены.  Возвращается, только если есть отклоненные изменения. 
  , updatePromoOffersResultDTOWarningOffers :: !(Maybe [WarningPromoOfferUpdateDTO]) -- ^ "warningOffers" - Изменения, по которым есть предупреждения. Они информируют о возможных проблемах. Информация о товарах обновится.  Возвращается, только если есть предупреждения. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatePromoOffersResultDTO
instance A.FromJSON UpdatePromoOffersResultDTO where
  parseJSON = A.withObject "UpdatePromoOffersResultDTO" $ \o ->
    UpdatePromoOffersResultDTO
      <$> (o .:? "rejectedOffers")
      <*> (o .:? "warningOffers")

-- | ToJSON UpdatePromoOffersResultDTO
instance A.ToJSON UpdatePromoOffersResultDTO where
  toJSON UpdatePromoOffersResultDTO {..} =
   _omitNulls
      [ "rejectedOffers" .= updatePromoOffersResultDTORejectedOffers
      , "warningOffers" .= updatePromoOffersResultDTOWarningOffers
      ]


-- | Construct a value of type 'UpdatePromoOffersResultDTO' (by applying it's required fields, if any)
mkUpdatePromoOffersResultDTO
  :: UpdatePromoOffersResultDTO
mkUpdatePromoOffersResultDTO =
  UpdatePromoOffersResultDTO
  { updatePromoOffersResultDTORejectedOffers = Nothing
  , updatePromoOffersResultDTOWarningOffers = Nothing
  }

-- ** UpdateStockDTO
-- | UpdateStockDTO
-- Информация об остатках одного товара на одном из складов.
data UpdateStockDTO = UpdateStockDTO
  { updateStockDTOSku :: !(Text) -- ^ /Required/ "sku" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , updateStockDTOItems :: !([UpdateStockItemDTO]) -- ^ /Required/ "items" - Информация об остатках товара. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateStockDTO
instance A.FromJSON UpdateStockDTO where
  parseJSON = A.withObject "UpdateStockDTO" $ \o ->
    UpdateStockDTO
      <$> (o .:  "sku")
      <*> (o .:  "items")

-- | ToJSON UpdateStockDTO
instance A.ToJSON UpdateStockDTO where
  toJSON UpdateStockDTO {..} =
   _omitNulls
      [ "sku" .= updateStockDTOSku
      , "items" .= updateStockDTOItems
      ]


-- | Construct a value of type 'UpdateStockDTO' (by applying it's required fields, if any)
mkUpdateStockDTO
  :: Text -- ^ 'updateStockDTOSku': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> [UpdateStockItemDTO] -- ^ 'updateStockDTOItems': Информация об остатках товара. 
  -> UpdateStockDTO
mkUpdateStockDTO updateStockDTOSku updateStockDTOItems =
  UpdateStockDTO
  { updateStockDTOSku
  , updateStockDTOItems
  }

-- ** UpdateStockItemDTO
-- | UpdateStockItemDTO
-- Информация об остатках товара. 
data UpdateStockItemDTO = UpdateStockItemDTO
  { updateStockItemDTOCount :: !(Integer) -- ^ /Required/ "count" - Количество доступного товара. 
  , updateStockItemDTOUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt" - Дата и время последнего обновления информации об остатках. &lt;br&gt;&lt;br&gt; Если вы не передали параметр &#x60;updatedAt&#x60;, используется текущее время. &lt;br&gt;&lt;br&gt; Формат даты и времени: ISO 8601 со смещением относительно UTC. Например, &#x60;2017-11-21T00:42:42+03:00&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateStockItemDTO
instance A.FromJSON UpdateStockItemDTO where
  parseJSON = A.withObject "UpdateStockItemDTO" $ \o ->
    UpdateStockItemDTO
      <$> (o .:  "count")
      <*> (o .:? "updatedAt")

-- | ToJSON UpdateStockItemDTO
instance A.ToJSON UpdateStockItemDTO where
  toJSON UpdateStockItemDTO {..} =
   _omitNulls
      [ "count" .= updateStockItemDTOCount
      , "updatedAt" .= updateStockItemDTOUpdatedAt
      ]


-- | Construct a value of type 'UpdateStockItemDTO' (by applying it's required fields, if any)
mkUpdateStockItemDTO
  :: Integer -- ^ 'updateStockItemDTOCount': Количество доступного товара. 
  -> UpdateStockItemDTO
mkUpdateStockItemDTO updateStockItemDTOCount =
  UpdateStockItemDTO
  { updateStockItemDTOCount
  , updateStockItemDTOUpdatedAt = Nothing
  }

-- ** UpdateStocksRequest
-- | UpdateStocksRequest
-- Запрос на изменение информации по остаткам товаров.
data UpdateStocksRequest = UpdateStocksRequest
  { updateStocksRequestSkus :: !([UpdateStockDTO]) -- ^ /Required/ "skus" - Данные об остатках товаров. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateStocksRequest
instance A.FromJSON UpdateStocksRequest where
  parseJSON = A.withObject "UpdateStocksRequest" $ \o ->
    UpdateStocksRequest
      <$> (o .:  "skus")

-- | ToJSON UpdateStocksRequest
instance A.ToJSON UpdateStocksRequest where
  toJSON UpdateStocksRequest {..} =
   _omitNulls
      [ "skus" .= updateStocksRequestSkus
      ]


-- | Construct a value of type 'UpdateStocksRequest' (by applying it's required fields, if any)
mkUpdateStocksRequest
  :: [UpdateStockDTO] -- ^ 'updateStocksRequestSkus': Данные об остатках товаров. 
  -> UpdateStocksRequest
mkUpdateStocksRequest updateStocksRequestSkus =
  UpdateStocksRequest
  { updateStocksRequestSkus
  }

-- ** UpdateTimeDTO
-- | UpdateTimeDTO
-- Время последнего обновления.
data UpdateTimeDTO = UpdateTimeDTO
  { updateTimeDTOUpdatedAt :: !(DateTime) -- ^ /Required/ "updatedAt" - Время последнего обновления.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateTimeDTO
instance A.FromJSON UpdateTimeDTO where
  parseJSON = A.withObject "UpdateTimeDTO" $ \o ->
    UpdateTimeDTO
      <$> (o .:  "updatedAt")

-- | ToJSON UpdateTimeDTO
instance A.ToJSON UpdateTimeDTO where
  toJSON UpdateTimeDTO {..} =
   _omitNulls
      [ "updatedAt" .= updateTimeDTOUpdatedAt
      ]


-- | Construct a value of type 'UpdateTimeDTO' (by applying it's required fields, if any)
mkUpdateTimeDTO
  :: DateTime -- ^ 'updateTimeDTOUpdatedAt': Время последнего обновления.
  -> UpdateTimeDTO
mkUpdateTimeDTO updateTimeDTOUpdatedAt =
  UpdateTimeDTO
  { updateTimeDTOUpdatedAt
  }

-- ** ValueRestrictionDTO
-- | ValueRestrictionDTO
-- Ограничение на возможные значения, накладываемое другой характеристикой.  Если ограничивающая характеристика принимает определенное значение, список возможных значений ограничиваемой характеристики сокращается.  **Пример**  Характеристика **размер** сама по себе может принимать девять разных значений: `S`, `M`, `L`, `44`, `46`, `48`, `42/164`, `46/176`, `44S`.  Если ограничивающая характеристика **размерная сетка** принимает значение `RU`, список возможных значений размера сокращается до `44`, `46`, `48`. 
data ValueRestrictionDTO = ValueRestrictionDTO
  { valueRestrictionDTOLimitingParameterId :: !(Integer) -- ^ /Required/ "limitingParameterId" - Идентификатор ограничивающей характеристики.
  , valueRestrictionDTOLimitedValues :: !([OptionValuesLimitedDTO]) -- ^ /Required/ "limitedValues" - Значения ограничивающей характеристики и соответствующие допустимые значения текущей характеристики.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ValueRestrictionDTO
instance A.FromJSON ValueRestrictionDTO where
  parseJSON = A.withObject "ValueRestrictionDTO" $ \o ->
    ValueRestrictionDTO
      <$> (o .:  "limitingParameterId")
      <*> (o .:  "limitedValues")

-- | ToJSON ValueRestrictionDTO
instance A.ToJSON ValueRestrictionDTO where
  toJSON ValueRestrictionDTO {..} =
   _omitNulls
      [ "limitingParameterId" .= valueRestrictionDTOLimitingParameterId
      , "limitedValues" .= valueRestrictionDTOLimitedValues
      ]


-- | Construct a value of type 'ValueRestrictionDTO' (by applying it's required fields, if any)
mkValueRestrictionDTO
  :: Integer -- ^ 'valueRestrictionDTOLimitingParameterId': Идентификатор ограничивающей характеристики.
  -> [OptionValuesLimitedDTO] -- ^ 'valueRestrictionDTOLimitedValues': Значения ограничивающей характеристики и соответствующие допустимые значения текущей характеристики.
  -> ValueRestrictionDTO
mkValueRestrictionDTO valueRestrictionDTOLimitingParameterId valueRestrictionDTOLimitedValues =
  ValueRestrictionDTO
  { valueRestrictionDTOLimitingParameterId
  , valueRestrictionDTOLimitedValues
  }

-- ** VerifyOrderEacRequest
-- | VerifyOrderEacRequest
data VerifyOrderEacRequest = VerifyOrderEacRequest
  { verifyOrderEacRequestCode :: !(Maybe Text) -- ^ "code" - Код для подтверждения ЭАПП.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerifyOrderEacRequest
instance A.FromJSON VerifyOrderEacRequest where
  parseJSON = A.withObject "VerifyOrderEacRequest" $ \o ->
    VerifyOrderEacRequest
      <$> (o .:? "code")

-- | ToJSON VerifyOrderEacRequest
instance A.ToJSON VerifyOrderEacRequest where
  toJSON VerifyOrderEacRequest {..} =
   _omitNulls
      [ "code" .= verifyOrderEacRequestCode
      ]


-- | Construct a value of type 'VerifyOrderEacRequest' (by applying it's required fields, if any)
mkVerifyOrderEacRequest
  :: VerifyOrderEacRequest
mkVerifyOrderEacRequest =
  VerifyOrderEacRequest
  { verifyOrderEacRequestCode = Nothing
  }

-- ** VerifyOrderEacResponse
-- | VerifyOrderEacResponse
data VerifyOrderEacResponse = VerifyOrderEacResponse
  { verifyOrderEacResponseStatus :: !(Maybe ApiResponseStatusType) -- ^ "status"
  , verifyOrderEacResponseResult :: !(Maybe EacVerificationResultDTO) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerifyOrderEacResponse
instance A.FromJSON VerifyOrderEacResponse where
  parseJSON = A.withObject "VerifyOrderEacResponse" $ \o ->
    VerifyOrderEacResponse
      <$> (o .:? "status")
      <*> (o .:? "result")

-- | ToJSON VerifyOrderEacResponse
instance A.ToJSON VerifyOrderEacResponse where
  toJSON VerifyOrderEacResponse {..} =
   _omitNulls
      [ "status" .= verifyOrderEacResponseStatus
      , "result" .= verifyOrderEacResponseResult
      ]


-- | Construct a value of type 'VerifyOrderEacResponse' (by applying it's required fields, if any)
mkVerifyOrderEacResponse
  :: VerifyOrderEacResponse
mkVerifyOrderEacResponse =
  VerifyOrderEacResponse
  { verifyOrderEacResponseStatus = Nothing
  , verifyOrderEacResponseResult = Nothing
  }

-- ** WarehouseAddressDTO
-- | WarehouseAddressDTO
-- Адрес склада.
data WarehouseAddressDTO = WarehouseAddressDTO
  { warehouseAddressDTOCity :: !(Text) -- ^ /Required/ "city" - Город.
  , warehouseAddressDTOStreet :: !(Maybe Text) -- ^ "street" - Улица.
  , warehouseAddressDTONumber :: !(Maybe Text) -- ^ "number" - Номер дома.
  , warehouseAddressDTOBuilding :: !(Maybe Text) -- ^ "building" - Номер строения.
  , warehouseAddressDTOBlock :: !(Maybe Text) -- ^ "block" - Номер корпуса.
  , warehouseAddressDTOGps :: !(GpsDTO) -- ^ /Required/ "gps"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WarehouseAddressDTO
instance A.FromJSON WarehouseAddressDTO where
  parseJSON = A.withObject "WarehouseAddressDTO" $ \o ->
    WarehouseAddressDTO
      <$> (o .:  "city")
      <*> (o .:? "street")
      <*> (o .:? "number")
      <*> (o .:? "building")
      <*> (o .:? "block")
      <*> (o .:  "gps")

-- | ToJSON WarehouseAddressDTO
instance A.ToJSON WarehouseAddressDTO where
  toJSON WarehouseAddressDTO {..} =
   _omitNulls
      [ "city" .= warehouseAddressDTOCity
      , "street" .= warehouseAddressDTOStreet
      , "number" .= warehouseAddressDTONumber
      , "building" .= warehouseAddressDTOBuilding
      , "block" .= warehouseAddressDTOBlock
      , "gps" .= warehouseAddressDTOGps
      ]


-- | Construct a value of type 'WarehouseAddressDTO' (by applying it's required fields, if any)
mkWarehouseAddressDTO
  :: Text -- ^ 'warehouseAddressDTOCity': Город.
  -> GpsDTO -- ^ 'warehouseAddressDTOGps' 
  -> WarehouseAddressDTO
mkWarehouseAddressDTO warehouseAddressDTOCity warehouseAddressDTOGps =
  WarehouseAddressDTO
  { warehouseAddressDTOCity
  , warehouseAddressDTOStreet = Nothing
  , warehouseAddressDTONumber = Nothing
  , warehouseAddressDTOBuilding = Nothing
  , warehouseAddressDTOBlock = Nothing
  , warehouseAddressDTOGps
  }

-- ** WarehouseDTO
-- | WarehouseDTO
-- Информация о складе.
data WarehouseDTO = WarehouseDTO
  { warehouseDTOId :: !(Integer) -- ^ /Required/ "id" - Идентификатор склада.
  , warehouseDTOName :: !(Text) -- ^ /Required/ "name" - Название склада.
  , warehouseDTOCampaignId :: !(Integer) -- ^ /Required/ "campaignId" - Идентификатор кампании в API и идентификатор магазина.
  , warehouseDTOExpress :: !(Bool) -- ^ /Required/ "express" - Возможна ли доставка по модели Экспресс.
  , warehouseDTOAddress :: !(Maybe WarehouseAddressDTO) -- ^ "address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WarehouseDTO
instance A.FromJSON WarehouseDTO where
  parseJSON = A.withObject "WarehouseDTO" $ \o ->
    WarehouseDTO
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "campaignId")
      <*> (o .:  "express")
      <*> (o .:? "address")

-- | ToJSON WarehouseDTO
instance A.ToJSON WarehouseDTO where
  toJSON WarehouseDTO {..} =
   _omitNulls
      [ "id" .= warehouseDTOId
      , "name" .= warehouseDTOName
      , "campaignId" .= warehouseDTOCampaignId
      , "express" .= warehouseDTOExpress
      , "address" .= warehouseDTOAddress
      ]


-- | Construct a value of type 'WarehouseDTO' (by applying it's required fields, if any)
mkWarehouseDTO
  :: Integer -- ^ 'warehouseDTOId': Идентификатор склада.
  -> Text -- ^ 'warehouseDTOName': Название склада.
  -> Integer -- ^ 'warehouseDTOCampaignId': Идентификатор кампании в API и идентификатор магазина.
  -> Bool -- ^ 'warehouseDTOExpress': Возможна ли доставка по модели Экспресс.
  -> WarehouseDTO
mkWarehouseDTO warehouseDTOId warehouseDTOName warehouseDTOCampaignId warehouseDTOExpress =
  WarehouseDTO
  { warehouseDTOId
  , warehouseDTOName
  , warehouseDTOCampaignId
  , warehouseDTOExpress
  , warehouseDTOAddress = Nothing
  }

-- ** WarehouseGroupDTO
-- | WarehouseGroupDTO
-- Информация о группе складов.
data WarehouseGroupDTO = WarehouseGroupDTO
  { warehouseGroupDTOName :: !(Text) -- ^ /Required/ "name" - Название группы складов.
  , warehouseGroupDTOMainWarehouse :: !(WarehouseDTO) -- ^ /Required/ "mainWarehouse"
  , warehouseGroupDTOWarehouses :: !([WarehouseDTO]) -- ^ /Required/ "warehouses" - Список складов, входящих в группу.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WarehouseGroupDTO
instance A.FromJSON WarehouseGroupDTO where
  parseJSON = A.withObject "WarehouseGroupDTO" $ \o ->
    WarehouseGroupDTO
      <$> (o .:  "name")
      <*> (o .:  "mainWarehouse")
      <*> (o .:  "warehouses")

-- | ToJSON WarehouseGroupDTO
instance A.ToJSON WarehouseGroupDTO where
  toJSON WarehouseGroupDTO {..} =
   _omitNulls
      [ "name" .= warehouseGroupDTOName
      , "mainWarehouse" .= warehouseGroupDTOMainWarehouse
      , "warehouses" .= warehouseGroupDTOWarehouses
      ]


-- | Construct a value of type 'WarehouseGroupDTO' (by applying it's required fields, if any)
mkWarehouseGroupDTO
  :: Text -- ^ 'warehouseGroupDTOName': Название группы складов.
  -> WarehouseDTO -- ^ 'warehouseGroupDTOMainWarehouse' 
  -> [WarehouseDTO] -- ^ 'warehouseGroupDTOWarehouses': Список складов, входящих в группу.
  -> WarehouseGroupDTO
mkWarehouseGroupDTO warehouseGroupDTOName warehouseGroupDTOMainWarehouse warehouseGroupDTOWarehouses =
  WarehouseGroupDTO
  { warehouseGroupDTOName
  , warehouseGroupDTOMainWarehouse
  , warehouseGroupDTOWarehouses
  }

-- ** WarehouseOfferDTO
-- | WarehouseOfferDTO
-- Информация об остатках товара.
data WarehouseOfferDTO = WarehouseOfferDTO
  { warehouseOfferDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , warehouseOfferDTOTurnoverSummary :: !(Maybe TurnoverDTO) -- ^ "turnoverSummary"
  , warehouseOfferDTOStocks :: !([WarehouseStockDTO]) -- ^ /Required/ "stocks" - Информация об остатках.
  , warehouseOfferDTOUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt" - Дата и время последнего обновления информации об остатках.  Формат даты и времени: ISO 8601 со смещением относительно UTC. Например, &#x60;2023-11-21T00:42:42+03:00&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WarehouseOfferDTO
instance A.FromJSON WarehouseOfferDTO where
  parseJSON = A.withObject "WarehouseOfferDTO" $ \o ->
    WarehouseOfferDTO
      <$> (o .:  "offerId")
      <*> (o .:? "turnoverSummary")
      <*> (o .:  "stocks")
      <*> (o .:? "updatedAt")

-- | ToJSON WarehouseOfferDTO
instance A.ToJSON WarehouseOfferDTO where
  toJSON WarehouseOfferDTO {..} =
   _omitNulls
      [ "offerId" .= warehouseOfferDTOOfferId
      , "turnoverSummary" .= warehouseOfferDTOTurnoverSummary
      , "stocks" .= warehouseOfferDTOStocks
      , "updatedAt" .= warehouseOfferDTOUpdatedAt
      ]


-- | Construct a value of type 'WarehouseOfferDTO' (by applying it's required fields, if any)
mkWarehouseOfferDTO
  :: Text -- ^ 'warehouseOfferDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> [WarehouseStockDTO] -- ^ 'warehouseOfferDTOStocks': Информация об остатках.
  -> WarehouseOfferDTO
mkWarehouseOfferDTO warehouseOfferDTOOfferId warehouseOfferDTOStocks =
  WarehouseOfferDTO
  { warehouseOfferDTOOfferId
  , warehouseOfferDTOTurnoverSummary = Nothing
  , warehouseOfferDTOStocks
  , warehouseOfferDTOUpdatedAt = Nothing
  }

-- ** WarehouseOffersDTO
-- | WarehouseOffersDTO
-- Информация об остатках товаров на складе.
data WarehouseOffersDTO = WarehouseOffersDTO
  { warehouseOffersDTOWarehouseId :: !(Integer) -- ^ /Required/ "warehouseId" - Идентификатор склада.
  , warehouseOffersDTOOffers :: !([WarehouseOfferDTO]) -- ^ /Required/ "offers" - Информация об остатках.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WarehouseOffersDTO
instance A.FromJSON WarehouseOffersDTO where
  parseJSON = A.withObject "WarehouseOffersDTO" $ \o ->
    WarehouseOffersDTO
      <$> (o .:  "warehouseId")
      <*> (o .:  "offers")

-- | ToJSON WarehouseOffersDTO
instance A.ToJSON WarehouseOffersDTO where
  toJSON WarehouseOffersDTO {..} =
   _omitNulls
      [ "warehouseId" .= warehouseOffersDTOWarehouseId
      , "offers" .= warehouseOffersDTOOffers
      ]


-- | Construct a value of type 'WarehouseOffersDTO' (by applying it's required fields, if any)
mkWarehouseOffersDTO
  :: Integer -- ^ 'warehouseOffersDTOWarehouseId': Идентификатор склада.
  -> [WarehouseOfferDTO] -- ^ 'warehouseOffersDTOOffers': Информация об остатках.
  -> WarehouseOffersDTO
mkWarehouseOffersDTO warehouseOffersDTOWarehouseId warehouseOffersDTOOffers =
  WarehouseOffersDTO
  { warehouseOffersDTOWarehouseId
  , warehouseOffersDTOOffers
  }

-- ** WarehouseStockDTO
-- | WarehouseStockDTO
-- Информация об остатках товара.
data WarehouseStockDTO = WarehouseStockDTO
  { warehouseStockDTOType :: !(WarehouseStockType) -- ^ /Required/ "type"
  , warehouseStockDTOCount :: !(Integer) -- ^ /Required/ "count" - Значение остатков.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WarehouseStockDTO
instance A.FromJSON WarehouseStockDTO where
  parseJSON = A.withObject "WarehouseStockDTO" $ \o ->
    WarehouseStockDTO
      <$> (o .:  "type")
      <*> (o .:  "count")

-- | ToJSON WarehouseStockDTO
instance A.ToJSON WarehouseStockDTO where
  toJSON WarehouseStockDTO {..} =
   _omitNulls
      [ "type" .= warehouseStockDTOType
      , "count" .= warehouseStockDTOCount
      ]


-- | Construct a value of type 'WarehouseStockDTO' (by applying it's required fields, if any)
mkWarehouseStockDTO
  :: WarehouseStockType -- ^ 'warehouseStockDTOType' 
  -> Integer -- ^ 'warehouseStockDTOCount': Значение остатков.
  -> WarehouseStockDTO
mkWarehouseStockDTO warehouseStockDTOType warehouseStockDTOCount =
  WarehouseStockDTO
  { warehouseStockDTOType
  , warehouseStockDTOCount
  }

-- ** WarehousesDTO
-- | WarehousesDTO
-- Информация о складах и группах складов.
data WarehousesDTO = WarehousesDTO
  { warehousesDTOWarehouses :: !([WarehouseDTO]) -- ^ /Required/ "warehouses" - Список складов, не входящих в группы.
  , warehousesDTOWarehouseGroups :: !([WarehouseGroupDTO]) -- ^ /Required/ "warehouseGroups" - Список групп складов.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WarehousesDTO
instance A.FromJSON WarehousesDTO where
  parseJSON = A.withObject "WarehousesDTO" $ \o ->
    WarehousesDTO
      <$> (o .:  "warehouses")
      <*> (o .:  "warehouseGroups")

-- | ToJSON WarehousesDTO
instance A.ToJSON WarehousesDTO where
  toJSON WarehousesDTO {..} =
   _omitNulls
      [ "warehouses" .= warehousesDTOWarehouses
      , "warehouseGroups" .= warehousesDTOWarehouseGroups
      ]


-- | Construct a value of type 'WarehousesDTO' (by applying it's required fields, if any)
mkWarehousesDTO
  :: [WarehouseDTO] -- ^ 'warehousesDTOWarehouses': Список складов, не входящих в группы.
  -> [WarehouseGroupDTO] -- ^ 'warehousesDTOWarehouseGroups': Список групп складов.
  -> WarehousesDTO
mkWarehousesDTO warehousesDTOWarehouses warehousesDTOWarehouseGroups =
  WarehousesDTO
  { warehousesDTOWarehouses
  , warehousesDTOWarehouseGroups
  }

-- ** WarningPromoOfferUpdateDTO
-- | WarningPromoOfferUpdateDTO
-- Описание предупреждения, которое появилось при добавлении товара.
data WarningPromoOfferUpdateDTO = WarningPromoOfferUpdateDTO
  { warningPromoOfferUpdateDTOOfferId :: !(Text) -- ^ /Required/ "offerId" - Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  , warningPromoOfferUpdateDTOWarnings :: !([PromoOfferUpdateWarningDTO]) -- ^ /Required/ "warnings" - Предупреждения, которые появились при добавлении товара в акцию или изменении его цен.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WarningPromoOfferUpdateDTO
instance A.FromJSON WarningPromoOfferUpdateDTO where
  parseJSON = A.withObject "WarningPromoOfferUpdateDTO" $ \o ->
    WarningPromoOfferUpdateDTO
      <$> (o .:  "offerId")
      <*> (o .:  "warnings")

-- | ToJSON WarningPromoOfferUpdateDTO
instance A.ToJSON WarningPromoOfferUpdateDTO where
  toJSON WarningPromoOfferUpdateDTO {..} =
   _omitNulls
      [ "offerId" .= warningPromoOfferUpdateDTOOfferId
      , "warnings" .= warningPromoOfferUpdateDTOWarnings
      ]


-- | Construct a value of type 'WarningPromoOfferUpdateDTO' (by applying it's required fields, if any)
mkWarningPromoOfferUpdateDTO
  :: Text -- ^ 'warningPromoOfferUpdateDTOOfferId': Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
  -> [PromoOfferUpdateWarningDTO] -- ^ 'warningPromoOfferUpdateDTOWarnings': Предупреждения, которые появились при добавлении товара в акцию или изменении его цен.
  -> WarningPromoOfferUpdateDTO
mkWarningPromoOfferUpdateDTO warningPromoOfferUpdateDTOOfferId warningPromoOfferUpdateDTOWarnings =
  WarningPromoOfferUpdateDTO
  { warningPromoOfferUpdateDTOOfferId
  , warningPromoOfferUpdateDTOWarnings
  }


-- * Enums


-- ** AddOffersToArchiveErrorType

-- | Enum of 'Text' .
-- Причина, по которой товар не удалось поместить в архив:  * `OFFER_HAS_STOCKS` — товар хранится на складе Маркета. 
data AddOffersToArchiveErrorType
  = AddOffersToArchiveErrorType'OFFER_HAS_STOCKS -- ^ @"OFFER_HAS_STOCKS"@
  | AddOffersToArchiveErrorType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AddOffersToArchiveErrorType where toJSON = A.toJSON . fromAddOffersToArchiveErrorType
instance A.FromJSON AddOffersToArchiveErrorType where parseJSON o = P.either P.fail (pure . P.id) . toAddOffersToArchiveErrorType =<< A.parseJSON o
instance WH.ToHttpApiData AddOffersToArchiveErrorType where toQueryParam = WH.toQueryParam . fromAddOffersToArchiveErrorType
instance WH.FromHttpApiData AddOffersToArchiveErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAddOffersToArchiveErrorType
instance MimeRender MimeMultipartFormData AddOffersToArchiveErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AddOffersToArchiveErrorType' enum
fromAddOffersToArchiveErrorType :: AddOffersToArchiveErrorType -> Text
fromAddOffersToArchiveErrorType = \case
  AddOffersToArchiveErrorType'OFFER_HAS_STOCKS -> "OFFER_HAS_STOCKS"
  AddOffersToArchiveErrorType'UNKNOWN -> "UNKNOWN"

-- | parse 'AddOffersToArchiveErrorType' enum
toAddOffersToArchiveErrorType :: Text -> P.Either String AddOffersToArchiveErrorType
toAddOffersToArchiveErrorType = \case
  "OFFER_HAS_STOCKS" -> P.Right AddOffersToArchiveErrorType'OFFER_HAS_STOCKS
  "UNKNOWN" -> P.Right AddOffersToArchiveErrorType'UNKNOWN
  s -> P.Left $ "toAddOffersToArchiveErrorType: enum parse failure: " P.++ P.show s


-- ** AffectedOrderQualityRatingComponentType

-- | Enum of 'Text' .
-- Составляющие индекса качества.  **Для модели DBS:** * `DBS_CANCELLATION_RATE` — доля отмененных товаров. * `DBS_LATE_DELIVERY_RATE` — доля заказов, доставленных после плановой даты.  **Для моделей FBS и Экспресс:** * `FBS_CANCELLATION_RATE` — доля отмененных товаров. * `FBS_LATE_SHIP_RATE` — доля не вовремя отгруженных заказов. 
data AffectedOrderQualityRatingComponentType
  = AffectedOrderQualityRatingComponentType'DBS_CANCELLATION_RATE -- ^ @"DBS_CANCELLATION_RATE"@
  | AffectedOrderQualityRatingComponentType'DBS_LATE_DELIVERY_RATE -- ^ @"DBS_LATE_DELIVERY_RATE"@
  | AffectedOrderQualityRatingComponentType'FBS_CANCELLATION_RATE -- ^ @"FBS_CANCELLATION_RATE"@
  | AffectedOrderQualityRatingComponentType'FBS_LATE_SHIP_RATE -- ^ @"FBS_LATE_SHIP_RATE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AffectedOrderQualityRatingComponentType where toJSON = A.toJSON . fromAffectedOrderQualityRatingComponentType
instance A.FromJSON AffectedOrderQualityRatingComponentType where parseJSON o = P.either P.fail (pure . P.id) . toAffectedOrderQualityRatingComponentType =<< A.parseJSON o
instance WH.ToHttpApiData AffectedOrderQualityRatingComponentType where toQueryParam = WH.toQueryParam . fromAffectedOrderQualityRatingComponentType
instance WH.FromHttpApiData AffectedOrderQualityRatingComponentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAffectedOrderQualityRatingComponentType
instance MimeRender MimeMultipartFormData AffectedOrderQualityRatingComponentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AffectedOrderQualityRatingComponentType' enum
fromAffectedOrderQualityRatingComponentType :: AffectedOrderQualityRatingComponentType -> Text
fromAffectedOrderQualityRatingComponentType = \case
  AffectedOrderQualityRatingComponentType'DBS_CANCELLATION_RATE -> "DBS_CANCELLATION_RATE"
  AffectedOrderQualityRatingComponentType'DBS_LATE_DELIVERY_RATE -> "DBS_LATE_DELIVERY_RATE"
  AffectedOrderQualityRatingComponentType'FBS_CANCELLATION_RATE -> "FBS_CANCELLATION_RATE"
  AffectedOrderQualityRatingComponentType'FBS_LATE_SHIP_RATE -> "FBS_LATE_SHIP_RATE"

-- | parse 'AffectedOrderQualityRatingComponentType' enum
toAffectedOrderQualityRatingComponentType :: Text -> P.Either String AffectedOrderQualityRatingComponentType
toAffectedOrderQualityRatingComponentType = \case
  "DBS_CANCELLATION_RATE" -> P.Right AffectedOrderQualityRatingComponentType'DBS_CANCELLATION_RATE
  "DBS_LATE_DELIVERY_RATE" -> P.Right AffectedOrderQualityRatingComponentType'DBS_LATE_DELIVERY_RATE
  "FBS_CANCELLATION_RATE" -> P.Right AffectedOrderQualityRatingComponentType'FBS_CANCELLATION_RATE
  "FBS_LATE_SHIP_RATE" -> P.Right AffectedOrderQualityRatingComponentType'FBS_LATE_SHIP_RATE
  s -> P.Left $ "toAffectedOrderQualityRatingComponentType: enum parse failure: " P.++ P.show s


-- ** AgeUnitType

-- | Enum of 'Text' .
-- Единицы измерения возраста:  * `YEAR` — год. * `MONTH` — месяц. 
data AgeUnitType
  = AgeUnitType'YEAR -- ^ @"YEAR"@
  | AgeUnitType'MONTH -- ^ @"MONTH"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AgeUnitType where toJSON = A.toJSON . fromAgeUnitType
instance A.FromJSON AgeUnitType where parseJSON o = P.either P.fail (pure . P.id) . toAgeUnitType =<< A.parseJSON o
instance WH.ToHttpApiData AgeUnitType where toQueryParam = WH.toQueryParam . fromAgeUnitType
instance WH.FromHttpApiData AgeUnitType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAgeUnitType
instance MimeRender MimeMultipartFormData AgeUnitType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AgeUnitType' enum
fromAgeUnitType :: AgeUnitType -> Text
fromAgeUnitType = \case
  AgeUnitType'YEAR -> "YEAR"
  AgeUnitType'MONTH -> "MONTH"

-- | parse 'AgeUnitType' enum
toAgeUnitType :: Text -> P.Either String AgeUnitType
toAgeUnitType = \case
  "YEAR" -> P.Right AgeUnitType'YEAR
  "MONTH" -> P.Right AgeUnitType'MONTH
  s -> P.Left $ "toAgeUnitType: enum parse failure: " P.++ P.show s


-- ** ApiResponseStatusType

-- | Enum of 'Text' .
-- Тип ответа.
data ApiResponseStatusType
  = ApiResponseStatusType'OK -- ^ @"OK"@
  | ApiResponseStatusType'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ApiResponseStatusType where toJSON = A.toJSON . fromApiResponseStatusType
instance A.FromJSON ApiResponseStatusType where parseJSON o = P.either P.fail (pure . P.id) . toApiResponseStatusType =<< A.parseJSON o
instance WH.ToHttpApiData ApiResponseStatusType where toQueryParam = WH.toQueryParam . fromApiResponseStatusType
instance WH.FromHttpApiData ApiResponseStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toApiResponseStatusType
instance MimeRender MimeMultipartFormData ApiResponseStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ApiResponseStatusType' enum
fromApiResponseStatusType :: ApiResponseStatusType -> Text
fromApiResponseStatusType = \case
  ApiResponseStatusType'OK -> "OK"
  ApiResponseStatusType'ERROR -> "ERROR"

-- | parse 'ApiResponseStatusType' enum
toApiResponseStatusType :: Text -> P.Either String ApiResponseStatusType
toApiResponseStatusType = \case
  "OK" -> P.Right ApiResponseStatusType'OK
  "ERROR" -> P.Right ApiResponseStatusType'ERROR
  s -> P.Left $ "toApiResponseStatusType: enum parse failure: " P.++ P.show s


-- ** CalculatedTariffType

-- | Enum of 'Text' .
-- Услуга Маркета:  * `AGENCY_COMMISSION` — прием платежа покупателя.  * `PAYMENT_TRANSFER` — перевод платежа покупателя.  * `FEE` — размещение товара на Маркете.  * `DELIVERY_TO_CUSTOMER` — доставка покупателю.  * `CROSSREGIONAL_DELIVERY` — доставка в федеральный округ, город или населенный пункт.  * `EXPRESS_DELIVERY` — экспресс-доставка покупателю.  * `SORTING` — обработка заказа.  * `MIDDLE_MILE` — средняя миля.  Подробнее об услугах Маркета читайте [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/introduction/rates/index.html). 
data CalculatedTariffType
  = CalculatedTariffType'AGENCY_COMMISSION -- ^ @"AGENCY_COMMISSION"@
  | CalculatedTariffType'PAYMENT_TRANSFER -- ^ @"PAYMENT_TRANSFER"@
  | CalculatedTariffType'FEE -- ^ @"FEE"@
  | CalculatedTariffType'DELIVERY_TO_CUSTOMER -- ^ @"DELIVERY_TO_CUSTOMER"@
  | CalculatedTariffType'CROSSREGIONAL_DELIVERY -- ^ @"CROSSREGIONAL_DELIVERY"@
  | CalculatedTariffType'EXPRESS_DELIVERY -- ^ @"EXPRESS_DELIVERY"@
  | CalculatedTariffType'SORTING -- ^ @"SORTING"@
  | CalculatedTariffType'MIDDLE_MILE -- ^ @"MIDDLE_MILE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON CalculatedTariffType where toJSON = A.toJSON . fromCalculatedTariffType
instance A.FromJSON CalculatedTariffType where parseJSON o = P.either P.fail (pure . P.id) . toCalculatedTariffType =<< A.parseJSON o
instance WH.ToHttpApiData CalculatedTariffType where toQueryParam = WH.toQueryParam . fromCalculatedTariffType
instance WH.FromHttpApiData CalculatedTariffType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toCalculatedTariffType
instance MimeRender MimeMultipartFormData CalculatedTariffType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'CalculatedTariffType' enum
fromCalculatedTariffType :: CalculatedTariffType -> Text
fromCalculatedTariffType = \case
  CalculatedTariffType'AGENCY_COMMISSION -> "AGENCY_COMMISSION"
  CalculatedTariffType'PAYMENT_TRANSFER -> "PAYMENT_TRANSFER"
  CalculatedTariffType'FEE -> "FEE"
  CalculatedTariffType'DELIVERY_TO_CUSTOMER -> "DELIVERY_TO_CUSTOMER"
  CalculatedTariffType'CROSSREGIONAL_DELIVERY -> "CROSSREGIONAL_DELIVERY"
  CalculatedTariffType'EXPRESS_DELIVERY -> "EXPRESS_DELIVERY"
  CalculatedTariffType'SORTING -> "SORTING"
  CalculatedTariffType'MIDDLE_MILE -> "MIDDLE_MILE"

-- | parse 'CalculatedTariffType' enum
toCalculatedTariffType :: Text -> P.Either String CalculatedTariffType
toCalculatedTariffType = \case
  "AGENCY_COMMISSION" -> P.Right CalculatedTariffType'AGENCY_COMMISSION
  "PAYMENT_TRANSFER" -> P.Right CalculatedTariffType'PAYMENT_TRANSFER
  "FEE" -> P.Right CalculatedTariffType'FEE
  "DELIVERY_TO_CUSTOMER" -> P.Right CalculatedTariffType'DELIVERY_TO_CUSTOMER
  "CROSSREGIONAL_DELIVERY" -> P.Right CalculatedTariffType'CROSSREGIONAL_DELIVERY
  "EXPRESS_DELIVERY" -> P.Right CalculatedTariffType'EXPRESS_DELIVERY
  "SORTING" -> P.Right CalculatedTariffType'SORTING
  "MIDDLE_MILE" -> P.Right CalculatedTariffType'MIDDLE_MILE
  s -> P.Left $ "toCalculatedTariffType: enum parse failure: " P.++ P.show s


-- ** CampaignSettingsScheduleSourceType

-- | Enum of 'Text' .
-- Источник информации о расписании работы службы доставки. Возможные значения: * `WEB` — информация получена из настроек кабинета продавца на Маркете. * `YML` — информация получена из прайс-листа магазина. 
data CampaignSettingsScheduleSourceType
  = CampaignSettingsScheduleSourceType'WEB -- ^ @"WEB"@
  | CampaignSettingsScheduleSourceType'YML -- ^ @"YML"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON CampaignSettingsScheduleSourceType where toJSON = A.toJSON . fromCampaignSettingsScheduleSourceType
instance A.FromJSON CampaignSettingsScheduleSourceType where parseJSON o = P.either P.fail (pure . P.id) . toCampaignSettingsScheduleSourceType =<< A.parseJSON o
instance WH.ToHttpApiData CampaignSettingsScheduleSourceType where toQueryParam = WH.toQueryParam . fromCampaignSettingsScheduleSourceType
instance WH.FromHttpApiData CampaignSettingsScheduleSourceType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toCampaignSettingsScheduleSourceType
instance MimeRender MimeMultipartFormData CampaignSettingsScheduleSourceType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'CampaignSettingsScheduleSourceType' enum
fromCampaignSettingsScheduleSourceType :: CampaignSettingsScheduleSourceType -> Text
fromCampaignSettingsScheduleSourceType = \case
  CampaignSettingsScheduleSourceType'WEB -> "WEB"
  CampaignSettingsScheduleSourceType'YML -> "YML"

-- | parse 'CampaignSettingsScheduleSourceType' enum
toCampaignSettingsScheduleSourceType :: Text -> P.Either String CampaignSettingsScheduleSourceType
toCampaignSettingsScheduleSourceType = \case
  "WEB" -> P.Right CampaignSettingsScheduleSourceType'WEB
  "YML" -> P.Right CampaignSettingsScheduleSourceType'YML
  s -> P.Left $ "toCampaignSettingsScheduleSourceType: enum parse failure: " P.++ P.show s


-- ** CategoryErrorType

-- | Enum of 'Text' .
-- Типы ошибок:  * `UNKNOWN_CATEGORY` — указана неизвестная категория. * `CATEGORY_IS_NOT_LEAF` — указана нелистовая категория. Укажите ту, которая не имеет дочерних категорий. 
data CategoryErrorType
  = CategoryErrorType'UNKNOWN_CATEGORY -- ^ @"UNKNOWN_CATEGORY"@
  | CategoryErrorType'CATEGORY_IS_NOT_LEAF -- ^ @"CATEGORY_IS_NOT_LEAF"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON CategoryErrorType where toJSON = A.toJSON . fromCategoryErrorType
instance A.FromJSON CategoryErrorType where parseJSON o = P.either P.fail (pure . P.id) . toCategoryErrorType =<< A.parseJSON o
instance WH.ToHttpApiData CategoryErrorType where toQueryParam = WH.toQueryParam . fromCategoryErrorType
instance WH.FromHttpApiData CategoryErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toCategoryErrorType
instance MimeRender MimeMultipartFormData CategoryErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'CategoryErrorType' enum
fromCategoryErrorType :: CategoryErrorType -> Text
fromCategoryErrorType = \case
  CategoryErrorType'UNKNOWN_CATEGORY -> "UNKNOWN_CATEGORY"
  CategoryErrorType'CATEGORY_IS_NOT_LEAF -> "CATEGORY_IS_NOT_LEAF"

-- | parse 'CategoryErrorType' enum
toCategoryErrorType :: Text -> P.Either String CategoryErrorType
toCategoryErrorType = \case
  "UNKNOWN_CATEGORY" -> P.Right CategoryErrorType'UNKNOWN_CATEGORY
  "CATEGORY_IS_NOT_LEAF" -> P.Right CategoryErrorType'CATEGORY_IS_NOT_LEAF
  s -> P.Left $ "toCategoryErrorType: enum parse failure: " P.++ P.show s


-- ** ChatMessageSenderType

-- | Enum of 'Text' .
-- Кто отправил сообщение:  * `PARTNER` — магазин. * `CUSTOMER` — покупатель. * `MARKET` — Маркет. * `SUPPORT` — сотрудник службы поддержки Маркета. 
data ChatMessageSenderType
  = ChatMessageSenderType'PARTNER -- ^ @"PARTNER"@
  | ChatMessageSenderType'CUSTOMER -- ^ @"CUSTOMER"@
  | ChatMessageSenderType'MARKET -- ^ @"MARKET"@
  | ChatMessageSenderType'SUPPORT -- ^ @"SUPPORT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ChatMessageSenderType where toJSON = A.toJSON . fromChatMessageSenderType
instance A.FromJSON ChatMessageSenderType where parseJSON o = P.either P.fail (pure . P.id) . toChatMessageSenderType =<< A.parseJSON o
instance WH.ToHttpApiData ChatMessageSenderType where toQueryParam = WH.toQueryParam . fromChatMessageSenderType
instance WH.FromHttpApiData ChatMessageSenderType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toChatMessageSenderType
instance MimeRender MimeMultipartFormData ChatMessageSenderType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ChatMessageSenderType' enum
fromChatMessageSenderType :: ChatMessageSenderType -> Text
fromChatMessageSenderType = \case
  ChatMessageSenderType'PARTNER -> "PARTNER"
  ChatMessageSenderType'CUSTOMER -> "CUSTOMER"
  ChatMessageSenderType'MARKET -> "MARKET"
  ChatMessageSenderType'SUPPORT -> "SUPPORT"

-- | parse 'ChatMessageSenderType' enum
toChatMessageSenderType :: Text -> P.Either String ChatMessageSenderType
toChatMessageSenderType = \case
  "PARTNER" -> P.Right ChatMessageSenderType'PARTNER
  "CUSTOMER" -> P.Right ChatMessageSenderType'CUSTOMER
  "MARKET" -> P.Right ChatMessageSenderType'MARKET
  "SUPPORT" -> P.Right ChatMessageSenderType'SUPPORT
  s -> P.Left $ "toChatMessageSenderType: enum parse failure: " P.++ P.show s


-- ** ChatStatusType

-- | Enum of 'Text' .
-- Статус чата:  * `NEW` — новый чат. * `WAITING_FOR_CUSTOMER` — нужен ответ покупателя. * `WAITING_FOR_PARTNER` — нужен ответ магазина. * `WAITING_FOR_ARBITER` — нужен ответ арбитра. * `WAITING_FOR_MARKET` — нужен ответ Маркета. * `FINISHED` — чат завершен. 
data ChatStatusType
  = ChatStatusType'NEW -- ^ @"NEW"@
  | ChatStatusType'WAITING_FOR_CUSTOMER -- ^ @"WAITING_FOR_CUSTOMER"@
  | ChatStatusType'WAITING_FOR_PARTNER -- ^ @"WAITING_FOR_PARTNER"@
  | ChatStatusType'WAITING_FOR_ARBITER -- ^ @"WAITING_FOR_ARBITER"@
  | ChatStatusType'WAITING_FOR_MARKET -- ^ @"WAITING_FOR_MARKET"@
  | ChatStatusType'FINISHED -- ^ @"FINISHED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ChatStatusType where toJSON = A.toJSON . fromChatStatusType
instance A.FromJSON ChatStatusType where parseJSON o = P.either P.fail (pure . P.id) . toChatStatusType =<< A.parseJSON o
instance WH.ToHttpApiData ChatStatusType where toQueryParam = WH.toQueryParam . fromChatStatusType
instance WH.FromHttpApiData ChatStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toChatStatusType
instance MimeRender MimeMultipartFormData ChatStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ChatStatusType' enum
fromChatStatusType :: ChatStatusType -> Text
fromChatStatusType = \case
  ChatStatusType'NEW -> "NEW"
  ChatStatusType'WAITING_FOR_CUSTOMER -> "WAITING_FOR_CUSTOMER"
  ChatStatusType'WAITING_FOR_PARTNER -> "WAITING_FOR_PARTNER"
  ChatStatusType'WAITING_FOR_ARBITER -> "WAITING_FOR_ARBITER"
  ChatStatusType'WAITING_FOR_MARKET -> "WAITING_FOR_MARKET"
  ChatStatusType'FINISHED -> "FINISHED"

-- | parse 'ChatStatusType' enum
toChatStatusType :: Text -> P.Either String ChatStatusType
toChatStatusType = \case
  "NEW" -> P.Right ChatStatusType'NEW
  "WAITING_FOR_CUSTOMER" -> P.Right ChatStatusType'WAITING_FOR_CUSTOMER
  "WAITING_FOR_PARTNER" -> P.Right ChatStatusType'WAITING_FOR_PARTNER
  "WAITING_FOR_ARBITER" -> P.Right ChatStatusType'WAITING_FOR_ARBITER
  "WAITING_FOR_MARKET" -> P.Right ChatStatusType'WAITING_FOR_MARKET
  "FINISHED" -> P.Right ChatStatusType'FINISHED
  s -> P.Left $ "toChatStatusType: enum parse failure: " P.++ P.show s


-- ** ChatType

-- | Enum of 'Text' .
-- Тип чата:  * `CHAT` — чат с покупателем. * `ARBITRAGE` — спор. 
data ChatType
  = ChatType'CHAT -- ^ @"CHAT"@
  | ChatType'ARBITRAGE -- ^ @"ARBITRAGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ChatType where toJSON = A.toJSON . fromChatType
instance A.FromJSON ChatType where parseJSON o = P.either P.fail (pure . P.id) . toChatType =<< A.parseJSON o
instance WH.ToHttpApiData ChatType where toQueryParam = WH.toQueryParam . fromChatType
instance WH.FromHttpApiData ChatType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toChatType
instance MimeRender MimeMultipartFormData ChatType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ChatType' enum
fromChatType :: ChatType -> Text
fromChatType = \case
  ChatType'CHAT -> "CHAT"
  ChatType'ARBITRAGE -> "ARBITRAGE"

-- | parse 'ChatType' enum
toChatType :: Text -> P.Either String ChatType
toChatType = \case
  "CHAT" -> P.Right ChatType'CHAT
  "ARBITRAGE" -> P.Right ChatType'ARBITRAGE
  s -> P.Left $ "toChatType: enum parse failure: " P.++ P.show s


-- ** CurrencyType

-- | Enum of 'Text' .
-- Коды валют. Возможные значения: * `BYR` — белорусский рубль. * `KZT` — казахстанский тенге. * `RUR` — российский рубль. * `UAH` — украинская гривна. 
data CurrencyType
  = CurrencyType'RUR -- ^ @"RUR"@
  | CurrencyType'USD -- ^ @"USD"@
  | CurrencyType'EUR -- ^ @"EUR"@
  | CurrencyType'UAH -- ^ @"UAH"@
  | CurrencyType'AUD -- ^ @"AUD"@
  | CurrencyType'GBP -- ^ @"GBP"@
  | CurrencyType'BYR -- ^ @"BYR"@
  | CurrencyType'BYN -- ^ @"BYN"@
  | CurrencyType'DKK -- ^ @"DKK"@
  | CurrencyType'ISK -- ^ @"ISK"@
  | CurrencyType'KZT -- ^ @"KZT"@
  | CurrencyType'CAD -- ^ @"CAD"@
  | CurrencyType'CNY -- ^ @"CNY"@
  | CurrencyType'NOK -- ^ @"NOK"@
  | CurrencyType'XDR -- ^ @"XDR"@
  | CurrencyType'SGD -- ^ @"SGD"@
  | CurrencyType'TRY -- ^ @"TRY"@
  | CurrencyType'SEK -- ^ @"SEK"@
  | CurrencyType'CHF -- ^ @"CHF"@
  | CurrencyType'JPY -- ^ @"JPY"@
  | CurrencyType'AZN -- ^ @"AZN"@
  | CurrencyType'ALL -- ^ @"ALL"@
  | CurrencyType'DZD -- ^ @"DZD"@
  | CurrencyType'AOA -- ^ @"AOA"@
  | CurrencyType'ARS -- ^ @"ARS"@
  | CurrencyType'AMD -- ^ @"AMD"@
  | CurrencyType'AFN -- ^ @"AFN"@
  | CurrencyType'BHD -- ^ @"BHD"@
  | CurrencyType'BGN -- ^ @"BGN"@
  | CurrencyType'BOB -- ^ @"BOB"@
  | CurrencyType'BWP -- ^ @"BWP"@
  | CurrencyType'BND -- ^ @"BND"@
  | CurrencyType'BRL -- ^ @"BRL"@
  | CurrencyType'BIF -- ^ @"BIF"@
  | CurrencyType'HUF -- ^ @"HUF"@
  | CurrencyType'VEF -- ^ @"VEF"@
  | CurrencyType'KPW -- ^ @"KPW"@
  | CurrencyType'VND -- ^ @"VND"@
  | CurrencyType'GMD -- ^ @"GMD"@
  | CurrencyType'GHS -- ^ @"GHS"@
  | CurrencyType'GNF -- ^ @"GNF"@
  | CurrencyType'HKD -- ^ @"HKD"@
  | CurrencyType'GEL -- ^ @"GEL"@
  | CurrencyType'AED -- ^ @"AED"@
  | CurrencyType'EGP -- ^ @"EGP"@
  | CurrencyType'ZMK -- ^ @"ZMK"@
  | CurrencyType'ILS -- ^ @"ILS"@
  | CurrencyType'INR -- ^ @"INR"@
  | CurrencyType'IDR -- ^ @"IDR"@
  | CurrencyType'JOD -- ^ @"JOD"@
  | CurrencyType'IQD -- ^ @"IQD"@
  | CurrencyType'IRR -- ^ @"IRR"@
  | CurrencyType'YER -- ^ @"YER"@
  | CurrencyType'QAR -- ^ @"QAR"@
  | CurrencyType'KES -- ^ @"KES"@
  | CurrencyType'KGS -- ^ @"KGS"@
  | CurrencyType'COP -- ^ @"COP"@
  | CurrencyType'CDF -- ^ @"CDF"@
  | CurrencyType'CRC -- ^ @"CRC"@
  | CurrencyType'KWD -- ^ @"KWD"@
  | CurrencyType'CUP -- ^ @"CUP"@
  | CurrencyType'LAK -- ^ @"LAK"@
  | CurrencyType'LVL -- ^ @"LVL"@
  | CurrencyType'SLL -- ^ @"SLL"@
  | CurrencyType'LBP -- ^ @"LBP"@
  | CurrencyType'LYD -- ^ @"LYD"@
  | CurrencyType'SZL -- ^ @"SZL"@
  | CurrencyType'LTL -- ^ @"LTL"@
  | CurrencyType'MUR -- ^ @"MUR"@
  | CurrencyType'MRO -- ^ @"MRO"@
  | CurrencyType'MKD -- ^ @"MKD"@
  | CurrencyType'MWK -- ^ @"MWK"@
  | CurrencyType'MGA -- ^ @"MGA"@
  | CurrencyType'MYR -- ^ @"MYR"@
  | CurrencyType'MAD -- ^ @"MAD"@
  | CurrencyType'MXN -- ^ @"MXN"@
  | CurrencyType'MZN -- ^ @"MZN"@
  | CurrencyType'MDL -- ^ @"MDL"@
  | CurrencyType'MNT -- ^ @"MNT"@
  | CurrencyType'NPR -- ^ @"NPR"@
  | CurrencyType'NGN -- ^ @"NGN"@
  | CurrencyType'NIO -- ^ @"NIO"@
  | CurrencyType'NZD -- ^ @"NZD"@
  | CurrencyType'OMR -- ^ @"OMR"@
  | CurrencyType'PKR -- ^ @"PKR"@
  | CurrencyType'PYG -- ^ @"PYG"@
  | CurrencyType'PEN -- ^ @"PEN"@
  | CurrencyType'PLN -- ^ @"PLN"@
  | CurrencyType'KHR -- ^ @"KHR"@
  | CurrencyType'SAR -- ^ @"SAR"@
  | CurrencyType'RON -- ^ @"RON"@
  | CurrencyType'SCR -- ^ @"SCR"@
  | CurrencyType'SYP -- ^ @"SYP"@
  | CurrencyType'SKK -- ^ @"SKK"@
  | CurrencyType'SOS -- ^ @"SOS"@
  | CurrencyType'SDG -- ^ @"SDG"@
  | CurrencyType'SRD -- ^ @"SRD"@
  | CurrencyType'TJS -- ^ @"TJS"@
  | CurrencyType'THB -- ^ @"THB"@
  | CurrencyType'TWD -- ^ @"TWD"@
  | CurrencyType'BDT -- ^ @"BDT"@
  | CurrencyType'TZS -- ^ @"TZS"@
  | CurrencyType'TND -- ^ @"TND"@
  | CurrencyType'TMM -- ^ @"TMM"@
  | CurrencyType'UGX -- ^ @"UGX"@
  | CurrencyType'UZS -- ^ @"UZS"@
  | CurrencyType'UYU -- ^ @"UYU"@
  | CurrencyType'PHP -- ^ @"PHP"@
  | CurrencyType'DJF -- ^ @"DJF"@
  | CurrencyType'XAF -- ^ @"XAF"@
  | CurrencyType'XOF -- ^ @"XOF"@
  | CurrencyType'HRK -- ^ @"HRK"@
  | CurrencyType'CZK -- ^ @"CZK"@
  | CurrencyType'CLP -- ^ @"CLP"@
  | CurrencyType'LKR -- ^ @"LKR"@
  | CurrencyType'EEK -- ^ @"EEK"@
  | CurrencyType'ETB -- ^ @"ETB"@
  | CurrencyType'RSD -- ^ @"RSD"@
  | CurrencyType'ZAR -- ^ @"ZAR"@
  | CurrencyType'KRW -- ^ @"KRW"@
  | CurrencyType'NAD -- ^ @"NAD"@
  | CurrencyType'TL -- ^ @"TL"@
  | CurrencyType'UE -- ^ @"UE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON CurrencyType where toJSON = A.toJSON . fromCurrencyType
instance A.FromJSON CurrencyType where parseJSON o = P.either P.fail (pure . P.id) . toCurrencyType =<< A.parseJSON o
instance WH.ToHttpApiData CurrencyType where toQueryParam = WH.toQueryParam . fromCurrencyType
instance WH.FromHttpApiData CurrencyType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toCurrencyType
instance MimeRender MimeMultipartFormData CurrencyType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'CurrencyType' enum
fromCurrencyType :: CurrencyType -> Text
fromCurrencyType = \case
  CurrencyType'RUR -> "RUR"
  CurrencyType'USD -> "USD"
  CurrencyType'EUR -> "EUR"
  CurrencyType'UAH -> "UAH"
  CurrencyType'AUD -> "AUD"
  CurrencyType'GBP -> "GBP"
  CurrencyType'BYR -> "BYR"
  CurrencyType'BYN -> "BYN"
  CurrencyType'DKK -> "DKK"
  CurrencyType'ISK -> "ISK"
  CurrencyType'KZT -> "KZT"
  CurrencyType'CAD -> "CAD"
  CurrencyType'CNY -> "CNY"
  CurrencyType'NOK -> "NOK"
  CurrencyType'XDR -> "XDR"
  CurrencyType'SGD -> "SGD"
  CurrencyType'TRY -> "TRY"
  CurrencyType'SEK -> "SEK"
  CurrencyType'CHF -> "CHF"
  CurrencyType'JPY -> "JPY"
  CurrencyType'AZN -> "AZN"
  CurrencyType'ALL -> "ALL"
  CurrencyType'DZD -> "DZD"
  CurrencyType'AOA -> "AOA"
  CurrencyType'ARS -> "ARS"
  CurrencyType'AMD -> "AMD"
  CurrencyType'AFN -> "AFN"
  CurrencyType'BHD -> "BHD"
  CurrencyType'BGN -> "BGN"
  CurrencyType'BOB -> "BOB"
  CurrencyType'BWP -> "BWP"
  CurrencyType'BND -> "BND"
  CurrencyType'BRL -> "BRL"
  CurrencyType'BIF -> "BIF"
  CurrencyType'HUF -> "HUF"
  CurrencyType'VEF -> "VEF"
  CurrencyType'KPW -> "KPW"
  CurrencyType'VND -> "VND"
  CurrencyType'GMD -> "GMD"
  CurrencyType'GHS -> "GHS"
  CurrencyType'GNF -> "GNF"
  CurrencyType'HKD -> "HKD"
  CurrencyType'GEL -> "GEL"
  CurrencyType'AED -> "AED"
  CurrencyType'EGP -> "EGP"
  CurrencyType'ZMK -> "ZMK"
  CurrencyType'ILS -> "ILS"
  CurrencyType'INR -> "INR"
  CurrencyType'IDR -> "IDR"
  CurrencyType'JOD -> "JOD"
  CurrencyType'IQD -> "IQD"
  CurrencyType'IRR -> "IRR"
  CurrencyType'YER -> "YER"
  CurrencyType'QAR -> "QAR"
  CurrencyType'KES -> "KES"
  CurrencyType'KGS -> "KGS"
  CurrencyType'COP -> "COP"
  CurrencyType'CDF -> "CDF"
  CurrencyType'CRC -> "CRC"
  CurrencyType'KWD -> "KWD"
  CurrencyType'CUP -> "CUP"
  CurrencyType'LAK -> "LAK"
  CurrencyType'LVL -> "LVL"
  CurrencyType'SLL -> "SLL"
  CurrencyType'LBP -> "LBP"
  CurrencyType'LYD -> "LYD"
  CurrencyType'SZL -> "SZL"
  CurrencyType'LTL -> "LTL"
  CurrencyType'MUR -> "MUR"
  CurrencyType'MRO -> "MRO"
  CurrencyType'MKD -> "MKD"
  CurrencyType'MWK -> "MWK"
  CurrencyType'MGA -> "MGA"
  CurrencyType'MYR -> "MYR"
  CurrencyType'MAD -> "MAD"
  CurrencyType'MXN -> "MXN"
  CurrencyType'MZN -> "MZN"
  CurrencyType'MDL -> "MDL"
  CurrencyType'MNT -> "MNT"
  CurrencyType'NPR -> "NPR"
  CurrencyType'NGN -> "NGN"
  CurrencyType'NIO -> "NIO"
  CurrencyType'NZD -> "NZD"
  CurrencyType'OMR -> "OMR"
  CurrencyType'PKR -> "PKR"
  CurrencyType'PYG -> "PYG"
  CurrencyType'PEN -> "PEN"
  CurrencyType'PLN -> "PLN"
  CurrencyType'KHR -> "KHR"
  CurrencyType'SAR -> "SAR"
  CurrencyType'RON -> "RON"
  CurrencyType'SCR -> "SCR"
  CurrencyType'SYP -> "SYP"
  CurrencyType'SKK -> "SKK"
  CurrencyType'SOS -> "SOS"
  CurrencyType'SDG -> "SDG"
  CurrencyType'SRD -> "SRD"
  CurrencyType'TJS -> "TJS"
  CurrencyType'THB -> "THB"
  CurrencyType'TWD -> "TWD"
  CurrencyType'BDT -> "BDT"
  CurrencyType'TZS -> "TZS"
  CurrencyType'TND -> "TND"
  CurrencyType'TMM -> "TMM"
  CurrencyType'UGX -> "UGX"
  CurrencyType'UZS -> "UZS"
  CurrencyType'UYU -> "UYU"
  CurrencyType'PHP -> "PHP"
  CurrencyType'DJF -> "DJF"
  CurrencyType'XAF -> "XAF"
  CurrencyType'XOF -> "XOF"
  CurrencyType'HRK -> "HRK"
  CurrencyType'CZK -> "CZK"
  CurrencyType'CLP -> "CLP"
  CurrencyType'LKR -> "LKR"
  CurrencyType'EEK -> "EEK"
  CurrencyType'ETB -> "ETB"
  CurrencyType'RSD -> "RSD"
  CurrencyType'ZAR -> "ZAR"
  CurrencyType'KRW -> "KRW"
  CurrencyType'NAD -> "NAD"
  CurrencyType'TL -> "TL"
  CurrencyType'UE -> "UE"

-- | parse 'CurrencyType' enum
toCurrencyType :: Text -> P.Either String CurrencyType
toCurrencyType = \case
  "RUR" -> P.Right CurrencyType'RUR
  "USD" -> P.Right CurrencyType'USD
  "EUR" -> P.Right CurrencyType'EUR
  "UAH" -> P.Right CurrencyType'UAH
  "AUD" -> P.Right CurrencyType'AUD
  "GBP" -> P.Right CurrencyType'GBP
  "BYR" -> P.Right CurrencyType'BYR
  "BYN" -> P.Right CurrencyType'BYN
  "DKK" -> P.Right CurrencyType'DKK
  "ISK" -> P.Right CurrencyType'ISK
  "KZT" -> P.Right CurrencyType'KZT
  "CAD" -> P.Right CurrencyType'CAD
  "CNY" -> P.Right CurrencyType'CNY
  "NOK" -> P.Right CurrencyType'NOK
  "XDR" -> P.Right CurrencyType'XDR
  "SGD" -> P.Right CurrencyType'SGD
  "TRY" -> P.Right CurrencyType'TRY
  "SEK" -> P.Right CurrencyType'SEK
  "CHF" -> P.Right CurrencyType'CHF
  "JPY" -> P.Right CurrencyType'JPY
  "AZN" -> P.Right CurrencyType'AZN
  "ALL" -> P.Right CurrencyType'ALL
  "DZD" -> P.Right CurrencyType'DZD
  "AOA" -> P.Right CurrencyType'AOA
  "ARS" -> P.Right CurrencyType'ARS
  "AMD" -> P.Right CurrencyType'AMD
  "AFN" -> P.Right CurrencyType'AFN
  "BHD" -> P.Right CurrencyType'BHD
  "BGN" -> P.Right CurrencyType'BGN
  "BOB" -> P.Right CurrencyType'BOB
  "BWP" -> P.Right CurrencyType'BWP
  "BND" -> P.Right CurrencyType'BND
  "BRL" -> P.Right CurrencyType'BRL
  "BIF" -> P.Right CurrencyType'BIF
  "HUF" -> P.Right CurrencyType'HUF
  "VEF" -> P.Right CurrencyType'VEF
  "KPW" -> P.Right CurrencyType'KPW
  "VND" -> P.Right CurrencyType'VND
  "GMD" -> P.Right CurrencyType'GMD
  "GHS" -> P.Right CurrencyType'GHS
  "GNF" -> P.Right CurrencyType'GNF
  "HKD" -> P.Right CurrencyType'HKD
  "GEL" -> P.Right CurrencyType'GEL
  "AED" -> P.Right CurrencyType'AED
  "EGP" -> P.Right CurrencyType'EGP
  "ZMK" -> P.Right CurrencyType'ZMK
  "ILS" -> P.Right CurrencyType'ILS
  "INR" -> P.Right CurrencyType'INR
  "IDR" -> P.Right CurrencyType'IDR
  "JOD" -> P.Right CurrencyType'JOD
  "IQD" -> P.Right CurrencyType'IQD
  "IRR" -> P.Right CurrencyType'IRR
  "YER" -> P.Right CurrencyType'YER
  "QAR" -> P.Right CurrencyType'QAR
  "KES" -> P.Right CurrencyType'KES
  "KGS" -> P.Right CurrencyType'KGS
  "COP" -> P.Right CurrencyType'COP
  "CDF" -> P.Right CurrencyType'CDF
  "CRC" -> P.Right CurrencyType'CRC
  "KWD" -> P.Right CurrencyType'KWD
  "CUP" -> P.Right CurrencyType'CUP
  "LAK" -> P.Right CurrencyType'LAK
  "LVL" -> P.Right CurrencyType'LVL
  "SLL" -> P.Right CurrencyType'SLL
  "LBP" -> P.Right CurrencyType'LBP
  "LYD" -> P.Right CurrencyType'LYD
  "SZL" -> P.Right CurrencyType'SZL
  "LTL" -> P.Right CurrencyType'LTL
  "MUR" -> P.Right CurrencyType'MUR
  "MRO" -> P.Right CurrencyType'MRO
  "MKD" -> P.Right CurrencyType'MKD
  "MWK" -> P.Right CurrencyType'MWK
  "MGA" -> P.Right CurrencyType'MGA
  "MYR" -> P.Right CurrencyType'MYR
  "MAD" -> P.Right CurrencyType'MAD
  "MXN" -> P.Right CurrencyType'MXN
  "MZN" -> P.Right CurrencyType'MZN
  "MDL" -> P.Right CurrencyType'MDL
  "MNT" -> P.Right CurrencyType'MNT
  "NPR" -> P.Right CurrencyType'NPR
  "NGN" -> P.Right CurrencyType'NGN
  "NIO" -> P.Right CurrencyType'NIO
  "NZD" -> P.Right CurrencyType'NZD
  "OMR" -> P.Right CurrencyType'OMR
  "PKR" -> P.Right CurrencyType'PKR
  "PYG" -> P.Right CurrencyType'PYG
  "PEN" -> P.Right CurrencyType'PEN
  "PLN" -> P.Right CurrencyType'PLN
  "KHR" -> P.Right CurrencyType'KHR
  "SAR" -> P.Right CurrencyType'SAR
  "RON" -> P.Right CurrencyType'RON
  "SCR" -> P.Right CurrencyType'SCR
  "SYP" -> P.Right CurrencyType'SYP
  "SKK" -> P.Right CurrencyType'SKK
  "SOS" -> P.Right CurrencyType'SOS
  "SDG" -> P.Right CurrencyType'SDG
  "SRD" -> P.Right CurrencyType'SRD
  "TJS" -> P.Right CurrencyType'TJS
  "THB" -> P.Right CurrencyType'THB
  "TWD" -> P.Right CurrencyType'TWD
  "BDT" -> P.Right CurrencyType'BDT
  "TZS" -> P.Right CurrencyType'TZS
  "TND" -> P.Right CurrencyType'TND
  "TMM" -> P.Right CurrencyType'TMM
  "UGX" -> P.Right CurrencyType'UGX
  "UZS" -> P.Right CurrencyType'UZS
  "UYU" -> P.Right CurrencyType'UYU
  "PHP" -> P.Right CurrencyType'PHP
  "DJF" -> P.Right CurrencyType'DJF
  "XAF" -> P.Right CurrencyType'XAF
  "XOF" -> P.Right CurrencyType'XOF
  "HRK" -> P.Right CurrencyType'HRK
  "CZK" -> P.Right CurrencyType'CZK
  "CLP" -> P.Right CurrencyType'CLP
  "LKR" -> P.Right CurrencyType'LKR
  "EEK" -> P.Right CurrencyType'EEK
  "ETB" -> P.Right CurrencyType'ETB
  "RSD" -> P.Right CurrencyType'RSD
  "ZAR" -> P.Right CurrencyType'ZAR
  "KRW" -> P.Right CurrencyType'KRW
  "NAD" -> P.Right CurrencyType'NAD
  "TL" -> P.Right CurrencyType'TL
  "UE" -> P.Right CurrencyType'UE
  s -> P.Left $ "toCurrencyType: enum parse failure: " P.++ P.show s


-- ** DayOfWeekType

-- | Enum of 'Text' .
-- День недели:  * `MONDAY` — понедельник. * `TUESDAY` — вторник. * `WEDNESDAY` — среда. * `THURSDAY` — четверг. * `FRIDAY` — пятница. * `SATURDAY` — суббота. * `SUNDAY` — воскресенье. 
data DayOfWeekType
  = DayOfWeekType'MONDAY -- ^ @"MONDAY"@
  | DayOfWeekType'TUESDAY -- ^ @"TUESDAY"@
  | DayOfWeekType'WEDNESDAY -- ^ @"WEDNESDAY"@
  | DayOfWeekType'THURSDAY -- ^ @"THURSDAY"@
  | DayOfWeekType'FRIDAY -- ^ @"FRIDAY"@
  | DayOfWeekType'SATURDAY -- ^ @"SATURDAY"@
  | DayOfWeekType'SUNDAY -- ^ @"SUNDAY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON DayOfWeekType where toJSON = A.toJSON . fromDayOfWeekType
instance A.FromJSON DayOfWeekType where parseJSON o = P.either P.fail (pure . P.id) . toDayOfWeekType =<< A.parseJSON o
instance WH.ToHttpApiData DayOfWeekType where toQueryParam = WH.toQueryParam . fromDayOfWeekType
instance WH.FromHttpApiData DayOfWeekType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toDayOfWeekType
instance MimeRender MimeMultipartFormData DayOfWeekType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'DayOfWeekType' enum
fromDayOfWeekType :: DayOfWeekType -> Text
fromDayOfWeekType = \case
  DayOfWeekType'MONDAY -> "MONDAY"
  DayOfWeekType'TUESDAY -> "TUESDAY"
  DayOfWeekType'WEDNESDAY -> "WEDNESDAY"
  DayOfWeekType'THURSDAY -> "THURSDAY"
  DayOfWeekType'FRIDAY -> "FRIDAY"
  DayOfWeekType'SATURDAY -> "SATURDAY"
  DayOfWeekType'SUNDAY -> "SUNDAY"

-- | parse 'DayOfWeekType' enum
toDayOfWeekType :: Text -> P.Either String DayOfWeekType
toDayOfWeekType = \case
  "MONDAY" -> P.Right DayOfWeekType'MONDAY
  "TUESDAY" -> P.Right DayOfWeekType'TUESDAY
  "WEDNESDAY" -> P.Right DayOfWeekType'WEDNESDAY
  "THURSDAY" -> P.Right DayOfWeekType'THURSDAY
  "FRIDAY" -> P.Right DayOfWeekType'FRIDAY
  "SATURDAY" -> P.Right DayOfWeekType'SATURDAY
  "SUNDAY" -> P.Right DayOfWeekType'SUNDAY
  s -> P.Left $ "toDayOfWeekType: enum parse failure: " P.++ P.show s


-- ** E'ChannelType

-- | Enum of 'A.Value' .
-- Каналы продвижения товаров:  * `PUSH` — пуш-уведомление из приложения Яндекс Маркет.  * `STRETCH_MAIN` — верхний баннер-растяжка на главной странице Яндекс Маркета.  * `MAIN_PAGE_CAROUSEL` — карусель акций на главной странице Яндекс Маркета.  * `PRODUCT_RETAIL_PAGE` — товар на странице ритейл-повода.  * `MAIN_PAGE_CAROUSEL_WEB` — карусель акций на главной странице веб версии Яндекс Маркета.  * `PRODUCT_SEPARATE_LANDING` — товар на лендинге акции.  * `SUPER_SHELF_CATEGORY` — полка в категориях.  * `CAROUSEL_RETAIL_PAGE` — карусель на лендинге ритейл-повода.  * `POPUP_APPLICATION` — всплывающее окно в приложении Яндекс Маркет.  * `POST_TELEGRAM` — пост в Телеграм-канале Яндекс Маркета.  * `CPA` — реклама в партнерской сети Яндекс Маркета.  * `WEB_PERFORMANCE_DIRECT` — реклама в Яндекс Директе.  * `APP_PERFORMANCE` — реклама в AppStore и Google Play.  * `BANNER_PICKUP_POINT` — баннер в ПВЗ Маркета.  * `BLOGGER_PERFORMANCE` — рекламная интеграция у блогеров.  * `DIGITAL_CHANNEL_BANNER` — баннер в digital-каналах и социальных сетях VK, Одноклассники.  * `YANDEX_ECOSYSTEM_CHANNELS` — реклама в других сервисах Яндекса: GO, Delivery, Еда.  * `PARTNERS_MAIN_BANNER` — баннер на главной странице mail.ru, auto.ru, ya.ru.  * `OTHER` — прочее. 
data E'ChannelType
  = E'ChannelType'PUSH -- ^ @"PUSH"@
  | E'ChannelType'STRETCH_MAIN -- ^ @"STRETCH_MAIN"@
  | E'ChannelType'MAIN_PAGE_CAROUSEL -- ^ @"MAIN_PAGE_CAROUSEL"@
  | E'ChannelType'PRODUCT_RETAIL_PAGE -- ^ @"PRODUCT_RETAIL_PAGE"@
  | E'ChannelType'MAIN_PAGE_CAROUSEL_WEB -- ^ @"MAIN_PAGE_CAROUSEL_WEB"@
  | E'ChannelType'PRODUCT_SEPARATE_LANDING -- ^ @"PRODUCT_SEPARATE_LANDING"@
  | E'ChannelType'SUPER_SHELF_CATEGORY -- ^ @"SUPER_SHELF_CATEGORY"@
  | E'ChannelType'CAROUSEL_RETAIL_PAGE -- ^ @"CAROUSEL_RETAIL_PAGE"@
  | E'ChannelType'POPUP_APPLICATION -- ^ @"POPUP_APPLICATION"@
  | E'ChannelType'POST_TELEGRAM -- ^ @"POST_TELEGRAM"@
  | E'ChannelType'CPA -- ^ @"CPA"@
  | E'ChannelType'WEB_PERFORMANCE_DIRECT -- ^ @"WEB_PERFORMANCE_DIRECT"@
  | E'ChannelType'APP_PERFORMANCE -- ^ @"APP_PERFORMANCE"@
  | E'ChannelType'BANNER_PICKUP_POINT -- ^ @"BANNER_PICKUP_POINT"@
  | E'ChannelType'BLOGGER_PERFORMANCE -- ^ @"BLOGGER_PERFORMANCE"@
  | E'ChannelType'DIGITAL_CHANNEL_BANNER -- ^ @"DIGITAL_CHANNEL_BANNER"@
  | E'ChannelType'YANDEX_ECOSYSTEM_CHANNELS -- ^ @"YANDEX_ECOSYSTEM_CHANNELS"@
  | E'ChannelType'PARTNERS_MAIN_BANNER -- ^ @"PARTNERS_MAIN_BANNER"@
  | E'ChannelType'OTHER -- ^ @"OTHER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ChannelType where toJSON = A.toJSON . fromE'ChannelType
instance A.FromJSON E'ChannelType where parseJSON o = P.either P.fail (pure . P.id) . toE'ChannelType =<< A.parseJSON o
instance WH.ToHttpApiData E'ChannelType where toQueryParam = WH.toQueryParam . fromE'ChannelType
instance WH.FromHttpApiData E'ChannelType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ChannelType
instance MimeRender MimeMultipartFormData E'ChannelType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ChannelType' enum
fromE'ChannelType :: E'ChannelType -> A.Value
fromE'ChannelType = \case
  E'ChannelType'PUSH -> "PUSH"
  E'ChannelType'STRETCH_MAIN -> "STRETCH_MAIN"
  E'ChannelType'MAIN_PAGE_CAROUSEL -> "MAIN_PAGE_CAROUSEL"
  E'ChannelType'PRODUCT_RETAIL_PAGE -> "PRODUCT_RETAIL_PAGE"
  E'ChannelType'MAIN_PAGE_CAROUSEL_WEB -> "MAIN_PAGE_CAROUSEL_WEB"
  E'ChannelType'PRODUCT_SEPARATE_LANDING -> "PRODUCT_SEPARATE_LANDING"
  E'ChannelType'SUPER_SHELF_CATEGORY -> "SUPER_SHELF_CATEGORY"
  E'ChannelType'CAROUSEL_RETAIL_PAGE -> "CAROUSEL_RETAIL_PAGE"
  E'ChannelType'POPUP_APPLICATION -> "POPUP_APPLICATION"
  E'ChannelType'POST_TELEGRAM -> "POST_TELEGRAM"
  E'ChannelType'CPA -> "CPA"
  E'ChannelType'WEB_PERFORMANCE_DIRECT -> "WEB_PERFORMANCE_DIRECT"
  E'ChannelType'APP_PERFORMANCE -> "APP_PERFORMANCE"
  E'ChannelType'BANNER_PICKUP_POINT -> "BANNER_PICKUP_POINT"
  E'ChannelType'BLOGGER_PERFORMANCE -> "BLOGGER_PERFORMANCE"
  E'ChannelType'DIGITAL_CHANNEL_BANNER -> "DIGITAL_CHANNEL_BANNER"
  E'ChannelType'YANDEX_ECOSYSTEM_CHANNELS -> "YANDEX_ECOSYSTEM_CHANNELS"
  E'ChannelType'PARTNERS_MAIN_BANNER -> "PARTNERS_MAIN_BANNER"
  E'ChannelType'OTHER -> "OTHER"

-- | parse 'E'ChannelType' enum
toE'ChannelType :: A.Value -> P.Either String E'ChannelType
toE'ChannelType = \case
  "PUSH" -> P.Right E'ChannelType'PUSH
  "STRETCH_MAIN" -> P.Right E'ChannelType'STRETCH_MAIN
  "MAIN_PAGE_CAROUSEL" -> P.Right E'ChannelType'MAIN_PAGE_CAROUSEL
  "PRODUCT_RETAIL_PAGE" -> P.Right E'ChannelType'PRODUCT_RETAIL_PAGE
  "MAIN_PAGE_CAROUSEL_WEB" -> P.Right E'ChannelType'MAIN_PAGE_CAROUSEL_WEB
  "PRODUCT_SEPARATE_LANDING" -> P.Right E'ChannelType'PRODUCT_SEPARATE_LANDING
  "SUPER_SHELF_CATEGORY" -> P.Right E'ChannelType'SUPER_SHELF_CATEGORY
  "CAROUSEL_RETAIL_PAGE" -> P.Right E'ChannelType'CAROUSEL_RETAIL_PAGE
  "POPUP_APPLICATION" -> P.Right E'ChannelType'POPUP_APPLICATION
  "POST_TELEGRAM" -> P.Right E'ChannelType'POST_TELEGRAM
  "CPA" -> P.Right E'ChannelType'CPA
  "WEB_PERFORMANCE_DIRECT" -> P.Right E'ChannelType'WEB_PERFORMANCE_DIRECT
  "APP_PERFORMANCE" -> P.Right E'ChannelType'APP_PERFORMANCE
  "BANNER_PICKUP_POINT" -> P.Right E'ChannelType'BANNER_PICKUP_POINT
  "BLOGGER_PERFORMANCE" -> P.Right E'ChannelType'BLOGGER_PERFORMANCE
  "DIGITAL_CHANNEL_BANNER" -> P.Right E'ChannelType'DIGITAL_CHANNEL_BANNER
  "YANDEX_ECOSYSTEM_CHANNELS" -> P.Right E'ChannelType'YANDEX_ECOSYSTEM_CHANNELS
  "PARTNERS_MAIN_BANNER" -> P.Right E'ChannelType'PARTNERS_MAIN_BANNER
  "OTHER" -> P.Right E'ChannelType'OTHER
  s -> P.Left $ "toE'ChannelType: enum parse failure: " P.++ P.show s


-- ** EacVerificationStatusType

-- | Enum of 'Text' .
-- Статус проверки кода подтверждения:  * `ACCEPTED` — код верный. * `REJECTED` — код неверный. * `NEED_UPDATE` — Маркет отправит новый код. Значение возвращается, если превышено количество попыток отправки кода. 
data EacVerificationStatusType
  = EacVerificationStatusType'ACCEPTED -- ^ @"ACCEPTED"@
  | EacVerificationStatusType'REJECTED -- ^ @"REJECTED"@
  | EacVerificationStatusType'NEED_UPDATE -- ^ @"NEED_UPDATE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON EacVerificationStatusType where toJSON = A.toJSON . fromEacVerificationStatusType
instance A.FromJSON EacVerificationStatusType where parseJSON o = P.either P.fail (pure . P.id) . toEacVerificationStatusType =<< A.parseJSON o
instance WH.ToHttpApiData EacVerificationStatusType where toQueryParam = WH.toQueryParam . fromEacVerificationStatusType
instance WH.FromHttpApiData EacVerificationStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toEacVerificationStatusType
instance MimeRender MimeMultipartFormData EacVerificationStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'EacVerificationStatusType' enum
fromEacVerificationStatusType :: EacVerificationStatusType -> Text
fromEacVerificationStatusType = \case
  EacVerificationStatusType'ACCEPTED -> "ACCEPTED"
  EacVerificationStatusType'REJECTED -> "REJECTED"
  EacVerificationStatusType'NEED_UPDATE -> "NEED_UPDATE"

-- | parse 'EacVerificationStatusType' enum
toEacVerificationStatusType :: Text -> P.Either String EacVerificationStatusType
toEacVerificationStatusType = \case
  "ACCEPTED" -> P.Right EacVerificationStatusType'ACCEPTED
  "REJECTED" -> P.Right EacVerificationStatusType'REJECTED
  "NEED_UPDATE" -> P.Right EacVerificationStatusType'NEED_UPDATE
  s -> P.Left $ "toEacVerificationStatusType: enum parse failure: " P.++ P.show s


-- ** FeedContentErrorType

-- | Enum of 'Text' .
-- Тип ошибки в содержимом прайс-листа.  Возможные значения:  * `PARSE_ERROR` — ошибка при проверке прайс-листа, не связанная с форматом YML. Например, прайс-лист пустой или его не удалось разархивировать. * `PARSE_XML_ERROR` — несоответствие техническим требованиям формата YML. Например, элементы и их значения описаны некорректно. * `TOO_MANY_REJECTED_OFFERS` — более чем в половине предложений из прайс-листа найдены ошибки. Все предложения из прайс-листа не будут опубликованы на Маркете. 
data FeedContentErrorType
  = FeedContentErrorType'PARSE_ERROR -- ^ @"PARSE_ERROR"@
  | FeedContentErrorType'PARSE_XML_ERROR -- ^ @"PARSE_XML_ERROR"@
  | FeedContentErrorType'TOO_MANY_REJECTED_OFFERS -- ^ @"TOO_MANY_REJECTED_OFFERS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedContentErrorType where toJSON = A.toJSON . fromFeedContentErrorType
instance A.FromJSON FeedContentErrorType where parseJSON o = P.either P.fail (pure . P.id) . toFeedContentErrorType =<< A.parseJSON o
instance WH.ToHttpApiData FeedContentErrorType where toQueryParam = WH.toQueryParam . fromFeedContentErrorType
instance WH.FromHttpApiData FeedContentErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedContentErrorType
instance MimeRender MimeMultipartFormData FeedContentErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedContentErrorType' enum
fromFeedContentErrorType :: FeedContentErrorType -> Text
fromFeedContentErrorType = \case
  FeedContentErrorType'PARSE_ERROR -> "PARSE_ERROR"
  FeedContentErrorType'PARSE_XML_ERROR -> "PARSE_XML_ERROR"
  FeedContentErrorType'TOO_MANY_REJECTED_OFFERS -> "TOO_MANY_REJECTED_OFFERS"

-- | parse 'FeedContentErrorType' enum
toFeedContentErrorType :: Text -> P.Either String FeedContentErrorType
toFeedContentErrorType = \case
  "PARSE_ERROR" -> P.Right FeedContentErrorType'PARSE_ERROR
  "PARSE_XML_ERROR" -> P.Right FeedContentErrorType'PARSE_XML_ERROR
  "TOO_MANY_REJECTED_OFFERS" -> P.Right FeedContentErrorType'TOO_MANY_REJECTED_OFFERS
  s -> P.Left $ "toFeedContentErrorType: enum parse failure: " P.++ P.show s


-- ** FeedDownloadErrorType

-- | Enum of 'Text' .
-- Тип ошибки загрузки прайс-листа.  Возможные значения:  * `DOWNLOAD_ERROR` — ошибка загрузки прайс-листа. Например, проблема с DNS-сервером или обрыв интернет-соединения.   Проблема описана в параметре `description`.  * `DOWNLOAD_HTTP_ERROR` — Яндекс Маркет передал запрос на получение прайс-листа и получил в ответ HTTP-код, отличный от 2xx.  HTTP-код выведен в параметре `httpStatusCode`. 
data FeedDownloadErrorType
  = FeedDownloadErrorType'ERROR -- ^ @"DOWNLOAD_ERROR"@
  | FeedDownloadErrorType'HTTP_ERROR -- ^ @"DOWNLOAD_HTTP_ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedDownloadErrorType where toJSON = A.toJSON . fromFeedDownloadErrorType
instance A.FromJSON FeedDownloadErrorType where parseJSON o = P.either P.fail (pure . P.id) . toFeedDownloadErrorType =<< A.parseJSON o
instance WH.ToHttpApiData FeedDownloadErrorType where toQueryParam = WH.toQueryParam . fromFeedDownloadErrorType
instance WH.FromHttpApiData FeedDownloadErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedDownloadErrorType
instance MimeRender MimeMultipartFormData FeedDownloadErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedDownloadErrorType' enum
fromFeedDownloadErrorType :: FeedDownloadErrorType -> Text
fromFeedDownloadErrorType = \case
  FeedDownloadErrorType'ERROR -> "DOWNLOAD_ERROR"
  FeedDownloadErrorType'HTTP_ERROR -> "DOWNLOAD_HTTP_ERROR"

-- | parse 'FeedDownloadErrorType' enum
toFeedDownloadErrorType :: Text -> P.Either String FeedDownloadErrorType
toFeedDownloadErrorType = \case
  "DOWNLOAD_ERROR" -> P.Right FeedDownloadErrorType'ERROR
  "DOWNLOAD_HTTP_ERROR" -> P.Right FeedDownloadErrorType'HTTP_ERROR
  s -> P.Left $ "toFeedDownloadErrorType: enum parse failure: " P.++ P.show s


-- ** FeedIndexLogsErrorType

-- | Enum of 'Text' .
-- Тип ошибки индексации прайс-листа.  Возможные значения:  * `DOWNLOAD_ERROR` — ошибка загрузки прайс-листа. Например, проблема с DNS-сервером или обрыв интернет-соединения.    Проблема описана в параметре `description`.  * `DOWNLOAD_HTTP_ERROR` — Маркет передал запрос на получение прайс-листа и получил в ответ HTTP-код, отличный от 2xx.    HTTP-код выведен в параметре `httpStatusCode`.  * `PARSE_ERROR` — ошибка при проверке прайс-листа, не связанная с форматом YML. Например, прайс-лист пустой или его не удалось разархивировать.  * `PARSE_XML_ERROR` — несоответствие техническим требованиям формата YML. Например, элементы и их значения описаны некорректно.  * `TOO_MANY_REJECTED_OFFERS` — более чем в половине предложений из прайс-листа найдены ошибки. Все предложения из прайс-листа не будут опубликованы на Маркете. 
data FeedIndexLogsErrorType
  = FeedIndexLogsErrorType'DOWNLOAD_ERROR -- ^ @"DOWNLOAD_ERROR"@
  | FeedIndexLogsErrorType'DOWNLOAD_HTTP_ERROR -- ^ @"DOWNLOAD_HTTP_ERROR"@
  | FeedIndexLogsErrorType'PARSE_ERROR -- ^ @"PARSE_ERROR"@
  | FeedIndexLogsErrorType'PARSE_XML_ERROR -- ^ @"PARSE_XML_ERROR"@
  | FeedIndexLogsErrorType'TOO_MANY_REJECTED_OFFERS -- ^ @"TOO_MANY_REJECTED_OFFERS"@
  | FeedIndexLogsErrorType'NOT_INDEXED -- ^ @"NOT_INDEXED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedIndexLogsErrorType where toJSON = A.toJSON . fromFeedIndexLogsErrorType
instance A.FromJSON FeedIndexLogsErrorType where parseJSON o = P.either P.fail (pure . P.id) . toFeedIndexLogsErrorType =<< A.parseJSON o
instance WH.ToHttpApiData FeedIndexLogsErrorType where toQueryParam = WH.toQueryParam . fromFeedIndexLogsErrorType
instance WH.FromHttpApiData FeedIndexLogsErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedIndexLogsErrorType
instance MimeRender MimeMultipartFormData FeedIndexLogsErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedIndexLogsErrorType' enum
fromFeedIndexLogsErrorType :: FeedIndexLogsErrorType -> Text
fromFeedIndexLogsErrorType = \case
  FeedIndexLogsErrorType'DOWNLOAD_ERROR -> "DOWNLOAD_ERROR"
  FeedIndexLogsErrorType'DOWNLOAD_HTTP_ERROR -> "DOWNLOAD_HTTP_ERROR"
  FeedIndexLogsErrorType'PARSE_ERROR -> "PARSE_ERROR"
  FeedIndexLogsErrorType'PARSE_XML_ERROR -> "PARSE_XML_ERROR"
  FeedIndexLogsErrorType'TOO_MANY_REJECTED_OFFERS -> "TOO_MANY_REJECTED_OFFERS"
  FeedIndexLogsErrorType'NOT_INDEXED -> "NOT_INDEXED"

-- | parse 'FeedIndexLogsErrorType' enum
toFeedIndexLogsErrorType :: Text -> P.Either String FeedIndexLogsErrorType
toFeedIndexLogsErrorType = \case
  "DOWNLOAD_ERROR" -> P.Right FeedIndexLogsErrorType'DOWNLOAD_ERROR
  "DOWNLOAD_HTTP_ERROR" -> P.Right FeedIndexLogsErrorType'DOWNLOAD_HTTP_ERROR
  "PARSE_ERROR" -> P.Right FeedIndexLogsErrorType'PARSE_ERROR
  "PARSE_XML_ERROR" -> P.Right FeedIndexLogsErrorType'PARSE_XML_ERROR
  "TOO_MANY_REJECTED_OFFERS" -> P.Right FeedIndexLogsErrorType'TOO_MANY_REJECTED_OFFERS
  "NOT_INDEXED" -> P.Right FeedIndexLogsErrorType'NOT_INDEXED
  s -> P.Left $ "toFeedIndexLogsErrorType: enum parse failure: " P.++ P.show s


-- ** FeedIndexLogsIndexType

-- | Enum of 'Text' .
-- Тип обновления.  Возможные значения:  * `DIFF` — частичное обновление данных на Яндекс Маркете (например, обновление цен ранее опубликованных предложений и публикация новых). * `FAST_PRICE` — только обновление цен ранее опубликованных предложений. * `FULL` — полное обновление данных на Яндекс Маркете. 
data FeedIndexLogsIndexType
  = FeedIndexLogsIndexType'DIFF -- ^ @"DIFF"@
  | FeedIndexLogsIndexType'FAST_PRICE -- ^ @"FAST_PRICE"@
  | FeedIndexLogsIndexType'FULL -- ^ @"FULL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedIndexLogsIndexType where toJSON = A.toJSON . fromFeedIndexLogsIndexType
instance A.FromJSON FeedIndexLogsIndexType where parseJSON o = P.either P.fail (pure . P.id) . toFeedIndexLogsIndexType =<< A.parseJSON o
instance WH.ToHttpApiData FeedIndexLogsIndexType where toQueryParam = WH.toQueryParam . fromFeedIndexLogsIndexType
instance WH.FromHttpApiData FeedIndexLogsIndexType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedIndexLogsIndexType
instance MimeRender MimeMultipartFormData FeedIndexLogsIndexType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedIndexLogsIndexType' enum
fromFeedIndexLogsIndexType :: FeedIndexLogsIndexType -> Text
fromFeedIndexLogsIndexType = \case
  FeedIndexLogsIndexType'DIFF -> "DIFF"
  FeedIndexLogsIndexType'FAST_PRICE -> "FAST_PRICE"
  FeedIndexLogsIndexType'FULL -> "FULL"

-- | parse 'FeedIndexLogsIndexType' enum
toFeedIndexLogsIndexType :: Text -> P.Either String FeedIndexLogsIndexType
toFeedIndexLogsIndexType = \case
  "DIFF" -> P.Right FeedIndexLogsIndexType'DIFF
  "FAST_PRICE" -> P.Right FeedIndexLogsIndexType'FAST_PRICE
  "FULL" -> P.Right FeedIndexLogsIndexType'FULL
  s -> P.Left $ "toFeedIndexLogsIndexType: enum parse failure: " P.++ P.show s


-- ** FeedIndexLogsStatusType

-- | Enum of 'Text' .
-- Статус индексации прайс-листа и проверки на соответствие техническим требованиям.  Возможные значения:  * `ERROR` — произошли ошибки. * `OK` — обработан без ошибок. * `WARNING` — наблюдались некритичные проблемы. 
data FeedIndexLogsStatusType
  = FeedIndexLogsStatusType'ERROR -- ^ @"ERROR"@
  | FeedIndexLogsStatusType'OK -- ^ @"OK"@
  | FeedIndexLogsStatusType'WARNING -- ^ @"WARNING"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedIndexLogsStatusType where toJSON = A.toJSON . fromFeedIndexLogsStatusType
instance A.FromJSON FeedIndexLogsStatusType where parseJSON o = P.either P.fail (pure . P.id) . toFeedIndexLogsStatusType =<< A.parseJSON o
instance WH.ToHttpApiData FeedIndexLogsStatusType where toQueryParam = WH.toQueryParam . fromFeedIndexLogsStatusType
instance WH.FromHttpApiData FeedIndexLogsStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedIndexLogsStatusType
instance MimeRender MimeMultipartFormData FeedIndexLogsStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedIndexLogsStatusType' enum
fromFeedIndexLogsStatusType :: FeedIndexLogsStatusType -> Text
fromFeedIndexLogsStatusType = \case
  FeedIndexLogsStatusType'ERROR -> "ERROR"
  FeedIndexLogsStatusType'OK -> "OK"
  FeedIndexLogsStatusType'WARNING -> "WARNING"

-- | parse 'FeedIndexLogsStatusType' enum
toFeedIndexLogsStatusType :: Text -> P.Either String FeedIndexLogsStatusType
toFeedIndexLogsStatusType = \case
  "ERROR" -> P.Right FeedIndexLogsStatusType'ERROR
  "OK" -> P.Right FeedIndexLogsStatusType'OK
  "WARNING" -> P.Right FeedIndexLogsStatusType'WARNING
  s -> P.Left $ "toFeedIndexLogsStatusType: enum parse failure: " P.++ P.show s


-- ** FeedStatusType

-- | Enum of 'Text' .
-- Статус прайс-листа.  Возможные значения:    * `ERROR` — найдены ошибки.   * `NA` — прайс-лист не загружался более семи дней или на этапе загрузки произошла ошибка.   * `OK` — ошибок не найдено. 
data FeedStatusType
  = FeedStatusType'ERROR -- ^ @"ERROR"@
  | FeedStatusType'NA -- ^ @"NA"@
  | FeedStatusType'OK -- ^ @"OK"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedStatusType where toJSON = A.toJSON . fromFeedStatusType
instance A.FromJSON FeedStatusType where parseJSON o = P.either P.fail (pure . P.id) . toFeedStatusType =<< A.parseJSON o
instance WH.ToHttpApiData FeedStatusType where toQueryParam = WH.toQueryParam . fromFeedStatusType
instance WH.FromHttpApiData FeedStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedStatusType
instance MimeRender MimeMultipartFormData FeedStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedStatusType' enum
fromFeedStatusType :: FeedStatusType -> Text
fromFeedStatusType = \case
  FeedStatusType'ERROR -> "ERROR"
  FeedStatusType'NA -> "NA"
  FeedStatusType'OK -> "OK"

-- | parse 'FeedStatusType' enum
toFeedStatusType :: Text -> P.Either String FeedStatusType
toFeedStatusType = \case
  "ERROR" -> P.Right FeedStatusType'ERROR
  "NA" -> P.Right FeedStatusType'NA
  "OK" -> P.Right FeedStatusType'OK
  s -> P.Left $ "toFeedStatusType: enum parse failure: " P.++ P.show s


-- ** FeedbackCommentAuthorType

-- | Enum of 'Text' .
-- Тип автора:  * `USER` — пользователь. * `SHOP` — магазин. 
data FeedbackCommentAuthorType
  = FeedbackCommentAuthorType'USER -- ^ @"USER"@
  | FeedbackCommentAuthorType'SHOP -- ^ @"SHOP"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedbackCommentAuthorType where toJSON = A.toJSON . fromFeedbackCommentAuthorType
instance A.FromJSON FeedbackCommentAuthorType where parseJSON o = P.either P.fail (pure . P.id) . toFeedbackCommentAuthorType =<< A.parseJSON o
instance WH.ToHttpApiData FeedbackCommentAuthorType where toQueryParam = WH.toQueryParam . fromFeedbackCommentAuthorType
instance WH.FromHttpApiData FeedbackCommentAuthorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedbackCommentAuthorType
instance MimeRender MimeMultipartFormData FeedbackCommentAuthorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedbackCommentAuthorType' enum
fromFeedbackCommentAuthorType :: FeedbackCommentAuthorType -> Text
fromFeedbackCommentAuthorType = \case
  FeedbackCommentAuthorType'USER -> "USER"
  FeedbackCommentAuthorType'SHOP -> "SHOP"

-- | parse 'FeedbackCommentAuthorType' enum
toFeedbackCommentAuthorType :: Text -> P.Either String FeedbackCommentAuthorType
toFeedbackCommentAuthorType = \case
  "USER" -> P.Right FeedbackCommentAuthorType'USER
  "SHOP" -> P.Right FeedbackCommentAuthorType'SHOP
  s -> P.Left $ "toFeedbackCommentAuthorType: enum parse failure: " P.++ P.show s


-- ** FeedbackDeliveryType

-- | Enum of 'Text' .
-- Способ покупки, указанный в отзыве:  * `DELIVERY` — доставка. * `PICKUP` — самовывоз. * `INSTORE` — в магазине. 
data FeedbackDeliveryType
  = FeedbackDeliveryType'DELIVERY -- ^ @"DELIVERY"@
  | FeedbackDeliveryType'PICKUP -- ^ @"PICKUP"@
  | FeedbackDeliveryType'INSTORE -- ^ @"INSTORE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedbackDeliveryType where toJSON = A.toJSON . fromFeedbackDeliveryType
instance A.FromJSON FeedbackDeliveryType where parseJSON o = P.either P.fail (pure . P.id) . toFeedbackDeliveryType =<< A.parseJSON o
instance WH.ToHttpApiData FeedbackDeliveryType where toQueryParam = WH.toQueryParam . fromFeedbackDeliveryType
instance WH.FromHttpApiData FeedbackDeliveryType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedbackDeliveryType
instance MimeRender MimeMultipartFormData FeedbackDeliveryType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedbackDeliveryType' enum
fromFeedbackDeliveryType :: FeedbackDeliveryType -> Text
fromFeedbackDeliveryType = \case
  FeedbackDeliveryType'DELIVERY -> "DELIVERY"
  FeedbackDeliveryType'PICKUP -> "PICKUP"
  FeedbackDeliveryType'INSTORE -> "INSTORE"

-- | parse 'FeedbackDeliveryType' enum
toFeedbackDeliveryType :: Text -> P.Either String FeedbackDeliveryType
toFeedbackDeliveryType = \case
  "DELIVERY" -> P.Right FeedbackDeliveryType'DELIVERY
  "PICKUP" -> P.Right FeedbackDeliveryType'PICKUP
  "INSTORE" -> P.Right FeedbackDeliveryType'INSTORE
  s -> P.Left $ "toFeedbackDeliveryType: enum parse failure: " P.++ P.show s


-- ** FeedbackReactionStatusType

-- | Enum of 'Text' .
-- Статус реакции на отзыв:  * `ALL` — все отзывы.  * `NEED_REACTION` — отзывы, на которые нужно ответить. 
data FeedbackReactionStatusType
  = FeedbackReactionStatusType'ALL -- ^ @"ALL"@
  | FeedbackReactionStatusType'NEED_REACTION -- ^ @"NEED_REACTION"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedbackReactionStatusType where toJSON = A.toJSON . fromFeedbackReactionStatusType
instance A.FromJSON FeedbackReactionStatusType where parseJSON o = P.either P.fail (pure . P.id) . toFeedbackReactionStatusType =<< A.parseJSON o
instance WH.ToHttpApiData FeedbackReactionStatusType where toQueryParam = WH.toQueryParam . fromFeedbackReactionStatusType
instance WH.FromHttpApiData FeedbackReactionStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedbackReactionStatusType
instance MimeRender MimeMultipartFormData FeedbackReactionStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedbackReactionStatusType' enum
fromFeedbackReactionStatusType :: FeedbackReactionStatusType -> Text
fromFeedbackReactionStatusType = \case
  FeedbackReactionStatusType'ALL -> "ALL"
  FeedbackReactionStatusType'NEED_REACTION -> "NEED_REACTION"

-- | parse 'FeedbackReactionStatusType' enum
toFeedbackReactionStatusType :: Text -> P.Either String FeedbackReactionStatusType
toFeedbackReactionStatusType = \case
  "ALL" -> P.Right FeedbackReactionStatusType'ALL
  "NEED_REACTION" -> P.Right FeedbackReactionStatusType'NEED_REACTION
  s -> P.Left $ "toFeedbackReactionStatusType: enum parse failure: " P.++ P.show s


-- ** FeedbackStateType

-- | Enum of 'Text' .
-- Статус отзыва:  * `LAST` — актуален. * `PREVIOUS` — устарел. * `DELETED` — удален. 
data FeedbackStateType
  = FeedbackStateType'LAST -- ^ @"LAST"@
  | FeedbackStateType'PREVIOUS -- ^ @"PREVIOUS"@
  | FeedbackStateType'DELETED -- ^ @"DELETED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeedbackStateType where toJSON = A.toJSON . fromFeedbackStateType
instance A.FromJSON FeedbackStateType where parseJSON o = P.either P.fail (pure . P.id) . toFeedbackStateType =<< A.parseJSON o
instance WH.ToHttpApiData FeedbackStateType where toQueryParam = WH.toQueryParam . fromFeedbackStateType
instance WH.FromHttpApiData FeedbackStateType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeedbackStateType
instance MimeRender MimeMultipartFormData FeedbackStateType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeedbackStateType' enum
fromFeedbackStateType :: FeedbackStateType -> Text
fromFeedbackStateType = \case
  FeedbackStateType'LAST -> "LAST"
  FeedbackStateType'PREVIOUS -> "PREVIOUS"
  FeedbackStateType'DELETED -> "DELETED"

-- | parse 'FeedbackStateType' enum
toFeedbackStateType :: Text -> P.Either String FeedbackStateType
toFeedbackStateType = \case
  "LAST" -> P.Right FeedbackStateType'LAST
  "PREVIOUS" -> P.Right FeedbackStateType'PREVIOUS
  "DELETED" -> P.Right FeedbackStateType'DELETED
  s -> P.Left $ "toFeedbackStateType: enum parse failure: " P.++ P.show s


-- ** FieldStateType

-- | Enum of 'Text' .
-- Фильтр по заполненности или незаполненности поля:  * `SPECIFIED` — вывести товары, у которых поле заполнено. * `EMPTY` — вывести товары, у которых поле не заполнено. 
data FieldStateType
  = FieldStateType'SPECIFIED -- ^ @"SPECIFIED"@
  | FieldStateType'EMPTY -- ^ @"EMPTY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FieldStateType where toJSON = A.toJSON . fromFieldStateType
instance A.FromJSON FieldStateType where parseJSON o = P.either P.fail (pure . P.id) . toFieldStateType =<< A.parseJSON o
instance WH.ToHttpApiData FieldStateType where toQueryParam = WH.toQueryParam . fromFieldStateType
instance WH.FromHttpApiData FieldStateType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFieldStateType
instance MimeRender MimeMultipartFormData FieldStateType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FieldStateType' enum
fromFieldStateType :: FieldStateType -> Text
fromFieldStateType = \case
  FieldStateType'SPECIFIED -> "SPECIFIED"
  FieldStateType'EMPTY -> "EMPTY"

-- | parse 'FieldStateType' enum
toFieldStateType :: Text -> P.Either String FieldStateType
toFieldStateType = \case
  "SPECIFIED" -> P.Right FieldStateType'SPECIFIED
  "EMPTY" -> P.Right FieldStateType'EMPTY
  s -> P.Left $ "toFieldStateType: enum parse failure: " P.++ P.show s


-- ** GoodsFeedbackCommentAuthorType

-- | Enum of 'Text' .
-- Тип автора:  * `USER` — пользователь. * `BUSINESS` — кабинет. 
data GoodsFeedbackCommentAuthorType
  = GoodsFeedbackCommentAuthorType'USER -- ^ @"USER"@
  | GoodsFeedbackCommentAuthorType'BUSINESS -- ^ @"BUSINESS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON GoodsFeedbackCommentAuthorType where toJSON = A.toJSON . fromGoodsFeedbackCommentAuthorType
instance A.FromJSON GoodsFeedbackCommentAuthorType where parseJSON o = P.either P.fail (pure . P.id) . toGoodsFeedbackCommentAuthorType =<< A.parseJSON o
instance WH.ToHttpApiData GoodsFeedbackCommentAuthorType where toQueryParam = WH.toQueryParam . fromGoodsFeedbackCommentAuthorType
instance WH.FromHttpApiData GoodsFeedbackCommentAuthorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toGoodsFeedbackCommentAuthorType
instance MimeRender MimeMultipartFormData GoodsFeedbackCommentAuthorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'GoodsFeedbackCommentAuthorType' enum
fromGoodsFeedbackCommentAuthorType :: GoodsFeedbackCommentAuthorType -> Text
fromGoodsFeedbackCommentAuthorType = \case
  GoodsFeedbackCommentAuthorType'USER -> "USER"
  GoodsFeedbackCommentAuthorType'BUSINESS -> "BUSINESS"

-- | parse 'GoodsFeedbackCommentAuthorType' enum
toGoodsFeedbackCommentAuthorType :: Text -> P.Either String GoodsFeedbackCommentAuthorType
toGoodsFeedbackCommentAuthorType = \case
  "USER" -> P.Right GoodsFeedbackCommentAuthorType'USER
  "BUSINESS" -> P.Right GoodsFeedbackCommentAuthorType'BUSINESS
  s -> P.Left $ "toGoodsFeedbackCommentAuthorType: enum parse failure: " P.++ P.show s


-- ** GoodsFeedbackCommentStatusType

-- | Enum of 'Text' .
-- Статус комментария:  * `PUBLISHED` — опубликован. * `UNMODERATED` — не проверен. * `BANNED` — заблокирован. * `DELETED` — удален. 
data GoodsFeedbackCommentStatusType
  = GoodsFeedbackCommentStatusType'PUBLISHED -- ^ @"PUBLISHED"@
  | GoodsFeedbackCommentStatusType'UNMODERATED -- ^ @"UNMODERATED"@
  | GoodsFeedbackCommentStatusType'BANNED -- ^ @"BANNED"@
  | GoodsFeedbackCommentStatusType'DELETED -- ^ @"DELETED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON GoodsFeedbackCommentStatusType where toJSON = A.toJSON . fromGoodsFeedbackCommentStatusType
instance A.FromJSON GoodsFeedbackCommentStatusType where parseJSON o = P.either P.fail (pure . P.id) . toGoodsFeedbackCommentStatusType =<< A.parseJSON o
instance WH.ToHttpApiData GoodsFeedbackCommentStatusType where toQueryParam = WH.toQueryParam . fromGoodsFeedbackCommentStatusType
instance WH.FromHttpApiData GoodsFeedbackCommentStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toGoodsFeedbackCommentStatusType
instance MimeRender MimeMultipartFormData GoodsFeedbackCommentStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'GoodsFeedbackCommentStatusType' enum
fromGoodsFeedbackCommentStatusType :: GoodsFeedbackCommentStatusType -> Text
fromGoodsFeedbackCommentStatusType = \case
  GoodsFeedbackCommentStatusType'PUBLISHED -> "PUBLISHED"
  GoodsFeedbackCommentStatusType'UNMODERATED -> "UNMODERATED"
  GoodsFeedbackCommentStatusType'BANNED -> "BANNED"
  GoodsFeedbackCommentStatusType'DELETED -> "DELETED"

-- | parse 'GoodsFeedbackCommentStatusType' enum
toGoodsFeedbackCommentStatusType :: Text -> P.Either String GoodsFeedbackCommentStatusType
toGoodsFeedbackCommentStatusType = \case
  "PUBLISHED" -> P.Right GoodsFeedbackCommentStatusType'PUBLISHED
  "UNMODERATED" -> P.Right GoodsFeedbackCommentStatusType'UNMODERATED
  "BANNED" -> P.Right GoodsFeedbackCommentStatusType'BANNED
  "DELETED" -> P.Right GoodsFeedbackCommentStatusType'DELETED
  s -> P.Left $ "toGoodsFeedbackCommentStatusType: enum parse failure: " P.++ P.show s


-- ** LanguageType

-- | Enum of 'Text' .
-- Язык:  * `RU` — русский.  * `EN` — английский. 
data LanguageType
  = LanguageType'RU -- ^ @"RU"@
  | LanguageType'EN -- ^ @"EN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LanguageType where toJSON = A.toJSON . fromLanguageType
instance A.FromJSON LanguageType where parseJSON o = P.either P.fail (pure . P.id) . toLanguageType =<< A.parseJSON o
instance WH.ToHttpApiData LanguageType where toQueryParam = WH.toQueryParam . fromLanguageType
instance WH.FromHttpApiData LanguageType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLanguageType
instance MimeRender MimeMultipartFormData LanguageType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LanguageType' enum
fromLanguageType :: LanguageType -> Text
fromLanguageType = \case
  LanguageType'RU -> "RU"
  LanguageType'EN -> "EN"

-- | parse 'LanguageType' enum
toLanguageType :: Text -> P.Either String LanguageType
toLanguageType = \case
  "RU" -> P.Right LanguageType'RU
  "EN" -> P.Right LanguageType'EN
  s -> P.Left $ "toLanguageType: enum parse failure: " P.++ P.show s


-- ** LicenseCheckStatusType

-- | Enum of 'Text' .
-- Статус проверки лицензии:  * `NEW` — лицензия проверяется. * `SUCCESS` — лицензия прошла проверку. * `FAIL` — лицензия не прошла проверку. 
data LicenseCheckStatusType
  = LicenseCheckStatusType'NEW -- ^ @"NEW"@
  | LicenseCheckStatusType'SUCCESS -- ^ @"SUCCESS"@
  | LicenseCheckStatusType'FAIL -- ^ @"FAIL"@
  | LicenseCheckStatusType'REVOKE -- ^ @"REVOKE"@
  | LicenseCheckStatusType'DONT_WANT -- ^ @"DONT_WANT"@
  | LicenseCheckStatusType'FAIL_MANUAL -- ^ @"FAIL_MANUAL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LicenseCheckStatusType where toJSON = A.toJSON . fromLicenseCheckStatusType
instance A.FromJSON LicenseCheckStatusType where parseJSON o = P.either P.fail (pure . P.id) . toLicenseCheckStatusType =<< A.parseJSON o
instance WH.ToHttpApiData LicenseCheckStatusType where toQueryParam = WH.toQueryParam . fromLicenseCheckStatusType
instance WH.FromHttpApiData LicenseCheckStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLicenseCheckStatusType
instance MimeRender MimeMultipartFormData LicenseCheckStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LicenseCheckStatusType' enum
fromLicenseCheckStatusType :: LicenseCheckStatusType -> Text
fromLicenseCheckStatusType = \case
  LicenseCheckStatusType'NEW -> "NEW"
  LicenseCheckStatusType'SUCCESS -> "SUCCESS"
  LicenseCheckStatusType'FAIL -> "FAIL"
  LicenseCheckStatusType'REVOKE -> "REVOKE"
  LicenseCheckStatusType'DONT_WANT -> "DONT_WANT"
  LicenseCheckStatusType'FAIL_MANUAL -> "FAIL_MANUAL"

-- | parse 'LicenseCheckStatusType' enum
toLicenseCheckStatusType :: Text -> P.Either String LicenseCheckStatusType
toLicenseCheckStatusType = \case
  "NEW" -> P.Right LicenseCheckStatusType'NEW
  "SUCCESS" -> P.Right LicenseCheckStatusType'SUCCESS
  "FAIL" -> P.Right LicenseCheckStatusType'FAIL
  "REVOKE" -> P.Right LicenseCheckStatusType'REVOKE
  "DONT_WANT" -> P.Right LicenseCheckStatusType'DONT_WANT
  "FAIL_MANUAL" -> P.Right LicenseCheckStatusType'FAIL_MANUAL
  s -> P.Left $ "toLicenseCheckStatusType: enum parse failure: " P.++ P.show s


-- ** LicenseType

-- | Enum of 'Text' .
-- Тип лицензии:  * `ALCOHOL` — лицензия на розничную продажу алкогольной продукции. 
data LicenseType
  = LicenseType'ALCOHOL -- ^ @"ALCOHOL"@
  | LicenseType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LicenseType where toJSON = A.toJSON . fromLicenseType
instance A.FromJSON LicenseType where parseJSON o = P.either P.fail (pure . P.id) . toLicenseType =<< A.parseJSON o
instance WH.ToHttpApiData LicenseType where toQueryParam = WH.toQueryParam . fromLicenseType
instance WH.FromHttpApiData LicenseType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLicenseType
instance MimeRender MimeMultipartFormData LicenseType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LicenseType' enum
fromLicenseType :: LicenseType -> Text
fromLicenseType = \case
  LicenseType'ALCOHOL -> "ALCOHOL"
  LicenseType'UNKNOWN -> "UNKNOWN"

-- | parse 'LicenseType' enum
toLicenseType :: Text -> P.Either String LicenseType
toLicenseType = \case
  "ALCOHOL" -> P.Right LicenseType'ALCOHOL
  "UNKNOWN" -> P.Right LicenseType'UNKNOWN
  s -> P.Left $ "toLicenseType: enum parse failure: " P.++ P.show s


-- ** LogisticPointType

-- | Enum of 'Text' .
-- Тип логистической точки:    * `WAREHOUSE` — склад.   * `PICKUP_POINT` — обычная точка выдачи заказов (ПВЗ).   * `PICKUP_TERMINAL` — постамат.   * `PICKUP_POST_OFFICE` — отделение почтовой связи (ОПС).   * `PICKUP_MIXED` — торговый зал и пункт выдачи заказов.   * `PICKUP_RETAIL` — торговый зал. 
data LogisticPointType
  = LogisticPointType'WAREHOUSE -- ^ @"WAREHOUSE"@
  | LogisticPointType'PICKUP_POINT -- ^ @"PICKUP_POINT"@
  | LogisticPointType'PICKUP_TERMINAL -- ^ @"PICKUP_TERMINAL"@
  | LogisticPointType'PICKUP_POST_OFFICE -- ^ @"PICKUP_POST_OFFICE"@
  | LogisticPointType'PICKUP_MIXED -- ^ @"PICKUP_MIXED"@
  | LogisticPointType'PICKUP_RETAIL -- ^ @"PICKUP_RETAIL"@
  | LogisticPointType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LogisticPointType where toJSON = A.toJSON . fromLogisticPointType
instance A.FromJSON LogisticPointType where parseJSON o = P.either P.fail (pure . P.id) . toLogisticPointType =<< A.parseJSON o
instance WH.ToHttpApiData LogisticPointType where toQueryParam = WH.toQueryParam . fromLogisticPointType
instance WH.FromHttpApiData LogisticPointType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLogisticPointType
instance MimeRender MimeMultipartFormData LogisticPointType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LogisticPointType' enum
fromLogisticPointType :: LogisticPointType -> Text
fromLogisticPointType = \case
  LogisticPointType'WAREHOUSE -> "WAREHOUSE"
  LogisticPointType'PICKUP_POINT -> "PICKUP_POINT"
  LogisticPointType'PICKUP_TERMINAL -> "PICKUP_TERMINAL"
  LogisticPointType'PICKUP_POST_OFFICE -> "PICKUP_POST_OFFICE"
  LogisticPointType'PICKUP_MIXED -> "PICKUP_MIXED"
  LogisticPointType'PICKUP_RETAIL -> "PICKUP_RETAIL"
  LogisticPointType'UNKNOWN -> "UNKNOWN"

-- | parse 'LogisticPointType' enum
toLogisticPointType :: Text -> P.Either String LogisticPointType
toLogisticPointType = \case
  "WAREHOUSE" -> P.Right LogisticPointType'WAREHOUSE
  "PICKUP_POINT" -> P.Right LogisticPointType'PICKUP_POINT
  "PICKUP_TERMINAL" -> P.Right LogisticPointType'PICKUP_TERMINAL
  "PICKUP_POST_OFFICE" -> P.Right LogisticPointType'PICKUP_POST_OFFICE
  "PICKUP_MIXED" -> P.Right LogisticPointType'PICKUP_MIXED
  "PICKUP_RETAIL" -> P.Right LogisticPointType'PICKUP_RETAIL
  "UNKNOWN" -> P.Right LogisticPointType'UNKNOWN
  s -> P.Left $ "toLogisticPointType: enum parse failure: " P.++ P.show s


-- ** MechanicsType

-- | Enum of 'Text' .
-- Тип акции:  * `DIRECT_DISCOUNT` — прямая скидка.  * `BLUE_FLASH` — флеш-акция.  * `MARKET_PROMOCODE` — скидка по промокоду. 
data MechanicsType
  = MechanicsType'DIRECT_DISCOUNT -- ^ @"DIRECT_DISCOUNT"@
  | MechanicsType'BLUE_FLASH -- ^ @"BLUE_FLASH"@
  | MechanicsType'MARKET_PROMOCODE -- ^ @"MARKET_PROMOCODE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON MechanicsType where toJSON = A.toJSON . fromMechanicsType
instance A.FromJSON MechanicsType where parseJSON o = P.either P.fail (pure . P.id) . toMechanicsType =<< A.parseJSON o
instance WH.ToHttpApiData MechanicsType where toQueryParam = WH.toQueryParam . fromMechanicsType
instance WH.FromHttpApiData MechanicsType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toMechanicsType
instance MimeRender MimeMultipartFormData MechanicsType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'MechanicsType' enum
fromMechanicsType :: MechanicsType -> Text
fromMechanicsType = \case
  MechanicsType'DIRECT_DISCOUNT -> "DIRECT_DISCOUNT"
  MechanicsType'BLUE_FLASH -> "BLUE_FLASH"
  MechanicsType'MARKET_PROMOCODE -> "MARKET_PROMOCODE"

-- | parse 'MechanicsType' enum
toMechanicsType :: Text -> P.Either String MechanicsType
toMechanicsType = \case
  "DIRECT_DISCOUNT" -> P.Right MechanicsType'DIRECT_DISCOUNT
  "BLUE_FLASH" -> P.Right MechanicsType'BLUE_FLASH
  "MARKET_PROMOCODE" -> P.Right MechanicsType'MARKET_PROMOCODE
  s -> P.Left $ "toMechanicsType: enum parse failure: " P.++ P.show s


-- ** OfferAvailabilityStatusType

-- | Enum of 'Text' .
-- Планы по поставкам:  * `ACTIVE` — поставки будут. * `INACTIVE` — поставок не будет: товар есть на складе, но вы больше не планируете его поставлять. Через 60 дней после того, как товар закончится на складе, этот статус изменится на `DELISTED`. * `DELISTED` — архив: товар закончился на складе, и его поставок больше не будет. Если товар вернется на склад (например, покупатель вернет заказ), этот статус изменится на `INACTIVE`. 
data OfferAvailabilityStatusType
  = OfferAvailabilityStatusType'ACTIVE -- ^ @"ACTIVE"@
  | OfferAvailabilityStatusType'INACTIVE -- ^ @"INACTIVE"@
  | OfferAvailabilityStatusType'DELISTED -- ^ @"DELISTED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferAvailabilityStatusType where toJSON = A.toJSON . fromOfferAvailabilityStatusType
instance A.FromJSON OfferAvailabilityStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOfferAvailabilityStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OfferAvailabilityStatusType where toQueryParam = WH.toQueryParam . fromOfferAvailabilityStatusType
instance WH.FromHttpApiData OfferAvailabilityStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferAvailabilityStatusType
instance MimeRender MimeMultipartFormData OfferAvailabilityStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferAvailabilityStatusType' enum
fromOfferAvailabilityStatusType :: OfferAvailabilityStatusType -> Text
fromOfferAvailabilityStatusType = \case
  OfferAvailabilityStatusType'ACTIVE -> "ACTIVE"
  OfferAvailabilityStatusType'INACTIVE -> "INACTIVE"
  OfferAvailabilityStatusType'DELISTED -> "DELISTED"

-- | parse 'OfferAvailabilityStatusType' enum
toOfferAvailabilityStatusType :: Text -> P.Either String OfferAvailabilityStatusType
toOfferAvailabilityStatusType = \case
  "ACTIVE" -> P.Right OfferAvailabilityStatusType'ACTIVE
  "INACTIVE" -> P.Right OfferAvailabilityStatusType'INACTIVE
  "DELISTED" -> P.Right OfferAvailabilityStatusType'DELISTED
  s -> P.Left $ "toOfferAvailabilityStatusType: enum parse failure: " P.++ P.show s


-- ** OfferCampaignStatusType

-- | Enum of 'Text' .
-- Статус товара:  * `PUBLISHED` — Готов к продаже. * `CHECKING` — На проверке. * `DISABLED_BY_PARTNER` — Скрыт вами. * `REJECTED_BY_MARKET` — Отклонен. * `DISABLED_AUTOMATICALLY` — Исправьте ошибки. * `CREATING_CARD` — Создается карточка. * `NO_CARD` — Нужна карточка. * `NO_STOCKS` — Нет на складе. * `ARCHIVED` — В архиве.  [Что обозначает каждый из статусов](https://yandex.ru/support/marketplace/assortment/add/statuses.html) 
data OfferCampaignStatusType
  = OfferCampaignStatusType'PUBLISHED -- ^ @"PUBLISHED"@
  | OfferCampaignStatusType'CHECKING -- ^ @"CHECKING"@
  | OfferCampaignStatusType'DISABLED_BY_PARTNER -- ^ @"DISABLED_BY_PARTNER"@
  | OfferCampaignStatusType'DISABLED_AUTOMATICALLY -- ^ @"DISABLED_AUTOMATICALLY"@
  | OfferCampaignStatusType'REJECTED_BY_MARKET -- ^ @"REJECTED_BY_MARKET"@
  | OfferCampaignStatusType'CREATING_CARD -- ^ @"CREATING_CARD"@
  | OfferCampaignStatusType'NO_CARD -- ^ @"NO_CARD"@
  | OfferCampaignStatusType'NO_STOCKS -- ^ @"NO_STOCKS"@
  | OfferCampaignStatusType'ARCHIVED -- ^ @"ARCHIVED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferCampaignStatusType where toJSON = A.toJSON . fromOfferCampaignStatusType
instance A.FromJSON OfferCampaignStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOfferCampaignStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OfferCampaignStatusType where toQueryParam = WH.toQueryParam . fromOfferCampaignStatusType
instance WH.FromHttpApiData OfferCampaignStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferCampaignStatusType
instance MimeRender MimeMultipartFormData OfferCampaignStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferCampaignStatusType' enum
fromOfferCampaignStatusType :: OfferCampaignStatusType -> Text
fromOfferCampaignStatusType = \case
  OfferCampaignStatusType'PUBLISHED -> "PUBLISHED"
  OfferCampaignStatusType'CHECKING -> "CHECKING"
  OfferCampaignStatusType'DISABLED_BY_PARTNER -> "DISABLED_BY_PARTNER"
  OfferCampaignStatusType'DISABLED_AUTOMATICALLY -> "DISABLED_AUTOMATICALLY"
  OfferCampaignStatusType'REJECTED_BY_MARKET -> "REJECTED_BY_MARKET"
  OfferCampaignStatusType'CREATING_CARD -> "CREATING_CARD"
  OfferCampaignStatusType'NO_CARD -> "NO_CARD"
  OfferCampaignStatusType'NO_STOCKS -> "NO_STOCKS"
  OfferCampaignStatusType'ARCHIVED -> "ARCHIVED"

-- | parse 'OfferCampaignStatusType' enum
toOfferCampaignStatusType :: Text -> P.Either String OfferCampaignStatusType
toOfferCampaignStatusType = \case
  "PUBLISHED" -> P.Right OfferCampaignStatusType'PUBLISHED
  "CHECKING" -> P.Right OfferCampaignStatusType'CHECKING
  "DISABLED_BY_PARTNER" -> P.Right OfferCampaignStatusType'DISABLED_BY_PARTNER
  "DISABLED_AUTOMATICALLY" -> P.Right OfferCampaignStatusType'DISABLED_AUTOMATICALLY
  "REJECTED_BY_MARKET" -> P.Right OfferCampaignStatusType'REJECTED_BY_MARKET
  "CREATING_CARD" -> P.Right OfferCampaignStatusType'CREATING_CARD
  "NO_CARD" -> P.Right OfferCampaignStatusType'NO_CARD
  "NO_STOCKS" -> P.Right OfferCampaignStatusType'NO_STOCKS
  "ARCHIVED" -> P.Right OfferCampaignStatusType'ARCHIVED
  s -> P.Left $ "toOfferCampaignStatusType: enum parse failure: " P.++ P.show s


-- ** OfferCardRecommendationType

-- | Enum of 'Text' .
-- Рекомендация по дополнению или замене контента. Не возвращается для карточек, которые заполнены Маркетом или содержат бывшие в употреблении товары.  Часть рекомендаций относятся к **основным параметрам**, которые есть у товаров любых категорий. Другие — к тем **характеристикам**, которые есть у товара потому, что он относится к определенной категории.  **1. Рекомендации, относящиеся к основным параметрам**  Каждая такая рекомендация относится к **единственному параметру**. Чтобы заполнить этот параметр, пользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  Рекомендации по заполнению параметров в `updateOfferMappings`:  * `RECOGNIZED_VENDOR` — напишите название производителя так, как его пишет сам производитель (параметр `vendor`). * `PICTURE_COUNT` — добавьте изображения (параметр `pictures`). * `FIRST_PICTURE_SIZE` — замените первое изображение более крупным (параметр `pictures`). * `TITLE_LENGTH` — измените название (параметр `name`). Составьте название по схеме: тип + бренд или производитель + модель + особенности, если есть (размер, вес, цвет). * `DESCRIPTION_LENGTH` — добавьте описание рекомендуемого размера (параметр `description`). * `AVERAGE_PICTURE_SIZE` — замените все изображения на изображения высокого качества (параметр `pictures`). * `FIRST_VIDEO_LENGTH` — добавьте первое видео рекомендуемой длины (параметр `videos`). * `AVERAGE_VIDEO_SIZE` — замените все видео на видео высокого качества (параметр `videos`). * `VIDEO_COUNT` — добавьте больше видео (параметр `videos`).  Рекомендуемые значения параметров описаны в [Справке Яндекс Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/add/).  **2. Рекомендации, относящиеся к характеристикам по категориям**  Каждая такая рекомендация предполагает заполнение **одной или нескольких характеристик**. Чтобы узнать, какие именно характеристики нужно заполнить, воспользуйтесь запросом [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md). Например, если вы получили рекомендацию `MAIN`, нужно заполнить характеристики, имеющие `MAIN` в массиве `recommendationTypes`.  Рекомендации:  * `MAIN` — заполните ключевые характеристики товара, которые используются в поиске и фильтрах. * `ADDITIONAL` — заполните дополнительные характеристики товара. * `DISTINCTIVE` — заполните характеристики, которыми отличаются друг от друга варианты товара.  **3. Устаревшие рекомендации**  * `HAS_VIDEO`. * `FILTERABLE`. * `HAS_DESCRIPTION`. * `HAS_BARCODE`. 
data OfferCardRecommendationType
  = OfferCardRecommendationType'HAS_VIDEO -- ^ @"HAS_VIDEO"@
  | OfferCardRecommendationType'RECOGNIZED_VENDOR -- ^ @"RECOGNIZED_VENDOR"@
  | OfferCardRecommendationType'MAIN -- ^ @"MAIN"@
  | OfferCardRecommendationType'ADDITIONAL -- ^ @"ADDITIONAL"@
  | OfferCardRecommendationType'DISTINCTIVE -- ^ @"DISTINCTIVE"@
  | OfferCardRecommendationType'FILTERABLE -- ^ @"FILTERABLE"@
  | OfferCardRecommendationType'PICTURE_COUNT -- ^ @"PICTURE_COUNT"@
  | OfferCardRecommendationType'HAS_DESCRIPTION -- ^ @"HAS_DESCRIPTION"@
  | OfferCardRecommendationType'HAS_BARCODE -- ^ @"HAS_BARCODE"@
  | OfferCardRecommendationType'FIRST_PICTURE_SIZE -- ^ @"FIRST_PICTURE_SIZE"@
  | OfferCardRecommendationType'TITLE_LENGTH -- ^ @"TITLE_LENGTH"@
  | OfferCardRecommendationType'DESCRIPTION_LENGTH -- ^ @"DESCRIPTION_LENGTH"@
  | OfferCardRecommendationType'AVERAGE_PICTURE_SIZE -- ^ @"AVERAGE_PICTURE_SIZE"@
  | OfferCardRecommendationType'FIRST_VIDEO_SIZE -- ^ @"FIRST_VIDEO_SIZE"@
  | OfferCardRecommendationType'FIRST_VIDEO_LENGTH -- ^ @"FIRST_VIDEO_LENGTH"@
  | OfferCardRecommendationType'AVERAGE_VIDEO_SIZE -- ^ @"AVERAGE_VIDEO_SIZE"@
  | OfferCardRecommendationType'VIDEO_COUNT -- ^ @"VIDEO_COUNT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferCardRecommendationType where toJSON = A.toJSON . fromOfferCardRecommendationType
instance A.FromJSON OfferCardRecommendationType where parseJSON o = P.either P.fail (pure . P.id) . toOfferCardRecommendationType =<< A.parseJSON o
instance WH.ToHttpApiData OfferCardRecommendationType where toQueryParam = WH.toQueryParam . fromOfferCardRecommendationType
instance WH.FromHttpApiData OfferCardRecommendationType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferCardRecommendationType
instance MimeRender MimeMultipartFormData OfferCardRecommendationType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferCardRecommendationType' enum
fromOfferCardRecommendationType :: OfferCardRecommendationType -> Text
fromOfferCardRecommendationType = \case
  OfferCardRecommendationType'HAS_VIDEO -> "HAS_VIDEO"
  OfferCardRecommendationType'RECOGNIZED_VENDOR -> "RECOGNIZED_VENDOR"
  OfferCardRecommendationType'MAIN -> "MAIN"
  OfferCardRecommendationType'ADDITIONAL -> "ADDITIONAL"
  OfferCardRecommendationType'DISTINCTIVE -> "DISTINCTIVE"
  OfferCardRecommendationType'FILTERABLE -> "FILTERABLE"
  OfferCardRecommendationType'PICTURE_COUNT -> "PICTURE_COUNT"
  OfferCardRecommendationType'HAS_DESCRIPTION -> "HAS_DESCRIPTION"
  OfferCardRecommendationType'HAS_BARCODE -> "HAS_BARCODE"
  OfferCardRecommendationType'FIRST_PICTURE_SIZE -> "FIRST_PICTURE_SIZE"
  OfferCardRecommendationType'TITLE_LENGTH -> "TITLE_LENGTH"
  OfferCardRecommendationType'DESCRIPTION_LENGTH -> "DESCRIPTION_LENGTH"
  OfferCardRecommendationType'AVERAGE_PICTURE_SIZE -> "AVERAGE_PICTURE_SIZE"
  OfferCardRecommendationType'FIRST_VIDEO_SIZE -> "FIRST_VIDEO_SIZE"
  OfferCardRecommendationType'FIRST_VIDEO_LENGTH -> "FIRST_VIDEO_LENGTH"
  OfferCardRecommendationType'AVERAGE_VIDEO_SIZE -> "AVERAGE_VIDEO_SIZE"
  OfferCardRecommendationType'VIDEO_COUNT -> "VIDEO_COUNT"

-- | parse 'OfferCardRecommendationType' enum
toOfferCardRecommendationType :: Text -> P.Either String OfferCardRecommendationType
toOfferCardRecommendationType = \case
  "HAS_VIDEO" -> P.Right OfferCardRecommendationType'HAS_VIDEO
  "RECOGNIZED_VENDOR" -> P.Right OfferCardRecommendationType'RECOGNIZED_VENDOR
  "MAIN" -> P.Right OfferCardRecommendationType'MAIN
  "ADDITIONAL" -> P.Right OfferCardRecommendationType'ADDITIONAL
  "DISTINCTIVE" -> P.Right OfferCardRecommendationType'DISTINCTIVE
  "FILTERABLE" -> P.Right OfferCardRecommendationType'FILTERABLE
  "PICTURE_COUNT" -> P.Right OfferCardRecommendationType'PICTURE_COUNT
  "HAS_DESCRIPTION" -> P.Right OfferCardRecommendationType'HAS_DESCRIPTION
  "HAS_BARCODE" -> P.Right OfferCardRecommendationType'HAS_BARCODE
  "FIRST_PICTURE_SIZE" -> P.Right OfferCardRecommendationType'FIRST_PICTURE_SIZE
  "TITLE_LENGTH" -> P.Right OfferCardRecommendationType'TITLE_LENGTH
  "DESCRIPTION_LENGTH" -> P.Right OfferCardRecommendationType'DESCRIPTION_LENGTH
  "AVERAGE_PICTURE_SIZE" -> P.Right OfferCardRecommendationType'AVERAGE_PICTURE_SIZE
  "FIRST_VIDEO_SIZE" -> P.Right OfferCardRecommendationType'FIRST_VIDEO_SIZE
  "FIRST_VIDEO_LENGTH" -> P.Right OfferCardRecommendationType'FIRST_VIDEO_LENGTH
  "AVERAGE_VIDEO_SIZE" -> P.Right OfferCardRecommendationType'AVERAGE_VIDEO_SIZE
  "VIDEO_COUNT" -> P.Right OfferCardRecommendationType'VIDEO_COUNT
  s -> P.Left $ "toOfferCardRecommendationType: enum parse failure: " P.++ P.show s


-- ** OfferCardStatusType

-- | Enum of 'Text' .
-- Статус карточки товара:  * `HAS_CARD_CAN_NOT_UPDATE` — Карточка Маркета. * `HAS_CARD_CAN_UPDATE` — Можно дополнить. * `HAS_CARD_CAN_UPDATE_ERRORS` — Изменения не приняты. * `HAS_CARD_CAN_UPDATE_PROCESSING` — Изменения на проверке. * `NO_CARD_NEED_CONTENT` — Создайте карточку. * `NO_CARD_MARKET_WILL_CREATE` — Создаст Маркет. * `NO_CARD_ERRORS` — Не создана из-за ошибки. * `NO_CARD_PROCESSING` — Проверяем данные. * `NO_CARD_ADD_TO_CAMPAIGN` — Разместите товар в магазине.  [Что обозначает каждый из статусов](https://yandex.ru/support/marketplace/assortment/content/statuses.html) 
data OfferCardStatusType
  = OfferCardStatusType'HAS_CARD_CAN_NOT_UPDATE -- ^ @"HAS_CARD_CAN_NOT_UPDATE"@
  | OfferCardStatusType'HAS_CARD_CAN_UPDATE -- ^ @"HAS_CARD_CAN_UPDATE"@
  | OfferCardStatusType'HAS_CARD_CAN_UPDATE_ERRORS -- ^ @"HAS_CARD_CAN_UPDATE_ERRORS"@
  | OfferCardStatusType'HAS_CARD_CAN_UPDATE_PROCESSING -- ^ @"HAS_CARD_CAN_UPDATE_PROCESSING"@
  | OfferCardStatusType'NO_CARD_NEED_CONTENT -- ^ @"NO_CARD_NEED_CONTENT"@
  | OfferCardStatusType'NO_CARD_MARKET_WILL_CREATE -- ^ @"NO_CARD_MARKET_WILL_CREATE"@
  | OfferCardStatusType'NO_CARD_ERRORS -- ^ @"NO_CARD_ERRORS"@
  | OfferCardStatusType'NO_CARD_PROCESSING -- ^ @"NO_CARD_PROCESSING"@
  | OfferCardStatusType'NO_CARD_ADD_TO_CAMPAIGN -- ^ @"NO_CARD_ADD_TO_CAMPAIGN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferCardStatusType where toJSON = A.toJSON . fromOfferCardStatusType
instance A.FromJSON OfferCardStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOfferCardStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OfferCardStatusType where toQueryParam = WH.toQueryParam . fromOfferCardStatusType
instance WH.FromHttpApiData OfferCardStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferCardStatusType
instance MimeRender MimeMultipartFormData OfferCardStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferCardStatusType' enum
fromOfferCardStatusType :: OfferCardStatusType -> Text
fromOfferCardStatusType = \case
  OfferCardStatusType'HAS_CARD_CAN_NOT_UPDATE -> "HAS_CARD_CAN_NOT_UPDATE"
  OfferCardStatusType'HAS_CARD_CAN_UPDATE -> "HAS_CARD_CAN_UPDATE"
  OfferCardStatusType'HAS_CARD_CAN_UPDATE_ERRORS -> "HAS_CARD_CAN_UPDATE_ERRORS"
  OfferCardStatusType'HAS_CARD_CAN_UPDATE_PROCESSING -> "HAS_CARD_CAN_UPDATE_PROCESSING"
  OfferCardStatusType'NO_CARD_NEED_CONTENT -> "NO_CARD_NEED_CONTENT"
  OfferCardStatusType'NO_CARD_MARKET_WILL_CREATE -> "NO_CARD_MARKET_WILL_CREATE"
  OfferCardStatusType'NO_CARD_ERRORS -> "NO_CARD_ERRORS"
  OfferCardStatusType'NO_CARD_PROCESSING -> "NO_CARD_PROCESSING"
  OfferCardStatusType'NO_CARD_ADD_TO_CAMPAIGN -> "NO_CARD_ADD_TO_CAMPAIGN"

-- | parse 'OfferCardStatusType' enum
toOfferCardStatusType :: Text -> P.Either String OfferCardStatusType
toOfferCardStatusType = \case
  "HAS_CARD_CAN_NOT_UPDATE" -> P.Right OfferCardStatusType'HAS_CARD_CAN_NOT_UPDATE
  "HAS_CARD_CAN_UPDATE" -> P.Right OfferCardStatusType'HAS_CARD_CAN_UPDATE
  "HAS_CARD_CAN_UPDATE_ERRORS" -> P.Right OfferCardStatusType'HAS_CARD_CAN_UPDATE_ERRORS
  "HAS_CARD_CAN_UPDATE_PROCESSING" -> P.Right OfferCardStatusType'HAS_CARD_CAN_UPDATE_PROCESSING
  "NO_CARD_NEED_CONTENT" -> P.Right OfferCardStatusType'NO_CARD_NEED_CONTENT
  "NO_CARD_MARKET_WILL_CREATE" -> P.Right OfferCardStatusType'NO_CARD_MARKET_WILL_CREATE
  "NO_CARD_ERRORS" -> P.Right OfferCardStatusType'NO_CARD_ERRORS
  "NO_CARD_PROCESSING" -> P.Right OfferCardStatusType'NO_CARD_PROCESSING
  "NO_CARD_ADD_TO_CAMPAIGN" -> P.Right OfferCardStatusType'NO_CARD_ADD_TO_CAMPAIGN
  s -> P.Left $ "toOfferCardStatusType: enum parse failure: " P.++ P.show s


-- ** OfferConditionQualityType

-- | Enum of 'Text' .
-- Внешний вид товара:  * `PERFECT` — идеальный. * `EXCELLENT` — отличный. * `GOOD` — хороший. * `NOT_SPECIFIED` — не выбран. 
data OfferConditionQualityType
  = OfferConditionQualityType'PERFECT -- ^ @"PERFECT"@
  | OfferConditionQualityType'EXCELLENT -- ^ @"EXCELLENT"@
  | OfferConditionQualityType'GOOD -- ^ @"GOOD"@
  | OfferConditionQualityType'NOT_SPECIFIED -- ^ @"NOT_SPECIFIED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferConditionQualityType where toJSON = A.toJSON . fromOfferConditionQualityType
instance A.FromJSON OfferConditionQualityType where parseJSON o = P.either P.fail (pure . P.id) . toOfferConditionQualityType =<< A.parseJSON o
instance WH.ToHttpApiData OfferConditionQualityType where toQueryParam = WH.toQueryParam . fromOfferConditionQualityType
instance WH.FromHttpApiData OfferConditionQualityType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferConditionQualityType
instance MimeRender MimeMultipartFormData OfferConditionQualityType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferConditionQualityType' enum
fromOfferConditionQualityType :: OfferConditionQualityType -> Text
fromOfferConditionQualityType = \case
  OfferConditionQualityType'PERFECT -> "PERFECT"
  OfferConditionQualityType'EXCELLENT -> "EXCELLENT"
  OfferConditionQualityType'GOOD -> "GOOD"
  OfferConditionQualityType'NOT_SPECIFIED -> "NOT_SPECIFIED"

-- | parse 'OfferConditionQualityType' enum
toOfferConditionQualityType :: Text -> P.Either String OfferConditionQualityType
toOfferConditionQualityType = \case
  "PERFECT" -> P.Right OfferConditionQualityType'PERFECT
  "EXCELLENT" -> P.Right OfferConditionQualityType'EXCELLENT
  "GOOD" -> P.Right OfferConditionQualityType'GOOD
  "NOT_SPECIFIED" -> P.Right OfferConditionQualityType'NOT_SPECIFIED
  s -> P.Left $ "toOfferConditionQualityType: enum parse failure: " P.++ P.show s


-- ** OfferConditionType

-- | Enum of 'Text' .
-- Тип уценки:  * `PREOWNED` —  бывший в употреблении товар, раньше принадлежал другому человеку. * `SHOWCASESAMPLE` — витринный образец. * `REFURBISHED` — повторная продажа товара. * `REDUCTION` — товар с дефектами. * `RENOVATED` — восстановленный товар. * `NOT_SPECIFIED` — не выбран.  `REFURBISHED` — специальное значение для одежды, обуви и аксессуаров. Используется только для уцененных товаров из этой категории. Другие значения для одежды, обуви и аксессуаров не используются. 
data OfferConditionType
  = OfferConditionType'PREOWNED -- ^ @"PREOWNED"@
  | OfferConditionType'SHOWCASESAMPLE -- ^ @"SHOWCASESAMPLE"@
  | OfferConditionType'REFURBISHED -- ^ @"REFURBISHED"@
  | OfferConditionType'REDUCTION -- ^ @"REDUCTION"@
  | OfferConditionType'RENOVATED -- ^ @"RENOVATED"@
  | OfferConditionType'NOT_SPECIFIED -- ^ @"NOT_SPECIFIED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferConditionType where toJSON = A.toJSON . fromOfferConditionType
instance A.FromJSON OfferConditionType where parseJSON o = P.either P.fail (pure . P.id) . toOfferConditionType =<< A.parseJSON o
instance WH.ToHttpApiData OfferConditionType where toQueryParam = WH.toQueryParam . fromOfferConditionType
instance WH.FromHttpApiData OfferConditionType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferConditionType
instance MimeRender MimeMultipartFormData OfferConditionType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferConditionType' enum
fromOfferConditionType :: OfferConditionType -> Text
fromOfferConditionType = \case
  OfferConditionType'PREOWNED -> "PREOWNED"
  OfferConditionType'SHOWCASESAMPLE -> "SHOWCASESAMPLE"
  OfferConditionType'REFURBISHED -> "REFURBISHED"
  OfferConditionType'REDUCTION -> "REDUCTION"
  OfferConditionType'RENOVATED -> "RENOVATED"
  OfferConditionType'NOT_SPECIFIED -> "NOT_SPECIFIED"

-- | parse 'OfferConditionType' enum
toOfferConditionType :: Text -> P.Either String OfferConditionType
toOfferConditionType = \case
  "PREOWNED" -> P.Right OfferConditionType'PREOWNED
  "SHOWCASESAMPLE" -> P.Right OfferConditionType'SHOWCASESAMPLE
  "REFURBISHED" -> P.Right OfferConditionType'REFURBISHED
  "REDUCTION" -> P.Right OfferConditionType'REDUCTION
  "RENOVATED" -> P.Right OfferConditionType'RENOVATED
  "NOT_SPECIFIED" -> P.Right OfferConditionType'NOT_SPECIFIED
  s -> P.Left $ "toOfferConditionType: enum parse failure: " P.++ P.show s


-- ** OfferContentErrorType

-- | Enum of 'Text' .
-- Типы ошибок:  * `OFFER_NOT_FOUND` — такого товара нет в каталоге. * `UNKNOWN_CATEGORY` — указана неизвестная категория. * `CATEGORY_MISMATCH` — указана категория, которая не совпадает с категорией товара. * `UNKNOWN_PARAMETER` — передана характеристика, которой нет среди характеристик категории. * `UNEXPECTED_BOOLEAN_VALUE` — вместо boolean-значения передано что-то другое. * `NUMBER_FORMAT` — передана строка, не обозначающая число, вместо числа. * `VALUE_BLANK` — передано пустое значение. * `INVALID_UNIT_ID` — передана единица измерения, недопустимая для характеристики. * `INVALID_GROUP_ID_LENGTH` — в названии превышено допустимое значение символов — 255. * `INVALID_GROUP_ID_CHARACTERS` — переданы [недопустимые символы](*ascii-code). 
data OfferContentErrorType
  = OfferContentErrorType'OFFER_NOT_FOUND -- ^ @"OFFER_NOT_FOUND"@
  | OfferContentErrorType'UNKNOWN_CATEGORY -- ^ @"UNKNOWN_CATEGORY"@
  | OfferContentErrorType'CATEGORY_MISMATCH -- ^ @"CATEGORY_MISMATCH"@
  | OfferContentErrorType'UNKNOWN_PARAMETER -- ^ @"UNKNOWN_PARAMETER"@
  | OfferContentErrorType'UNEXPECTED_BOOLEAN_VALUE -- ^ @"UNEXPECTED_BOOLEAN_VALUE"@
  | OfferContentErrorType'NUMBER_FORMAT -- ^ @"NUMBER_FORMAT"@
  | OfferContentErrorType'VALUE_BLANK -- ^ @"VALUE_BLANK"@
  | OfferContentErrorType'INVALID_UNIT_ID -- ^ @"INVALID_UNIT_ID"@
  | OfferContentErrorType'INVALID_GROUP_ID_LENGTH -- ^ @"INVALID_GROUP_ID_LENGTH"@
  | OfferContentErrorType'INVALID_GROUP_ID_CHARACTERS -- ^ @"INVALID_GROUP_ID_CHARACTERS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferContentErrorType where toJSON = A.toJSON . fromOfferContentErrorType
instance A.FromJSON OfferContentErrorType where parseJSON o = P.either P.fail (pure . P.id) . toOfferContentErrorType =<< A.parseJSON o
instance WH.ToHttpApiData OfferContentErrorType where toQueryParam = WH.toQueryParam . fromOfferContentErrorType
instance WH.FromHttpApiData OfferContentErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferContentErrorType
instance MimeRender MimeMultipartFormData OfferContentErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferContentErrorType' enum
fromOfferContentErrorType :: OfferContentErrorType -> Text
fromOfferContentErrorType = \case
  OfferContentErrorType'OFFER_NOT_FOUND -> "OFFER_NOT_FOUND"
  OfferContentErrorType'UNKNOWN_CATEGORY -> "UNKNOWN_CATEGORY"
  OfferContentErrorType'CATEGORY_MISMATCH -> "CATEGORY_MISMATCH"
  OfferContentErrorType'UNKNOWN_PARAMETER -> "UNKNOWN_PARAMETER"
  OfferContentErrorType'UNEXPECTED_BOOLEAN_VALUE -> "UNEXPECTED_BOOLEAN_VALUE"
  OfferContentErrorType'NUMBER_FORMAT -> "NUMBER_FORMAT"
  OfferContentErrorType'VALUE_BLANK -> "VALUE_BLANK"
  OfferContentErrorType'INVALID_UNIT_ID -> "INVALID_UNIT_ID"
  OfferContentErrorType'INVALID_GROUP_ID_LENGTH -> "INVALID_GROUP_ID_LENGTH"
  OfferContentErrorType'INVALID_GROUP_ID_CHARACTERS -> "INVALID_GROUP_ID_CHARACTERS"

-- | parse 'OfferContentErrorType' enum
toOfferContentErrorType :: Text -> P.Either String OfferContentErrorType
toOfferContentErrorType = \case
  "OFFER_NOT_FOUND" -> P.Right OfferContentErrorType'OFFER_NOT_FOUND
  "UNKNOWN_CATEGORY" -> P.Right OfferContentErrorType'UNKNOWN_CATEGORY
  "CATEGORY_MISMATCH" -> P.Right OfferContentErrorType'CATEGORY_MISMATCH
  "UNKNOWN_PARAMETER" -> P.Right OfferContentErrorType'UNKNOWN_PARAMETER
  "UNEXPECTED_BOOLEAN_VALUE" -> P.Right OfferContentErrorType'UNEXPECTED_BOOLEAN_VALUE
  "NUMBER_FORMAT" -> P.Right OfferContentErrorType'NUMBER_FORMAT
  "VALUE_BLANK" -> P.Right OfferContentErrorType'VALUE_BLANK
  "INVALID_UNIT_ID" -> P.Right OfferContentErrorType'INVALID_UNIT_ID
  "INVALID_GROUP_ID_LENGTH" -> P.Right OfferContentErrorType'INVALID_GROUP_ID_LENGTH
  "INVALID_GROUP_ID_CHARACTERS" -> P.Right OfferContentErrorType'INVALID_GROUP_ID_CHARACTERS
  s -> P.Left $ "toOfferContentErrorType: enum parse failure: " P.++ P.show s


-- ** OfferMappingErrorType

-- | Enum of 'Text' .
-- Типы ошибок:  * `UNKNOWN_CATEGORY` — указана неизвестная категория. * `CATEGORY_MISMATCH` — указана категория, которая не совпадает с категорией товара. * `EMPTY_MARKET_CATEGORY` — не указана категория Маркета при передаче характеристик категории. * `UNKNOWN_PARAMETER` — передана характеристика, которой нет среди характеристик категории. * `UNEXPECTED_BOOLEAN_VALUE` — вместо boolean-значения передано что-то другое. * `NUMBER_FORMAT` — передана строка, не обозначающая число, вместо числа. * `VALUE_BLANK` — передано пустое значение. * `INVALID_UNIT_ID` — передана единица измерения, недопустимая для характеристики. * `INVALID_GROUP_ID_LENGTH` — в названии превышено допустимое значение символов — 255. * `INVALID_GROUP_ID_CHARACTERS` — переданы [недопустимые символы](*ascii-code). * `INVALID_PICKER_URL` — передана ссылка на изображение для миниатюры, которой нет в переданных ссылках на изображение товара. 
data OfferMappingErrorType
  = OfferMappingErrorType'UNKNOWN_CATEGORY -- ^ @"UNKNOWN_CATEGORY"@
  | OfferMappingErrorType'CATEGORY_MISMATCH -- ^ @"CATEGORY_MISMATCH"@
  | OfferMappingErrorType'EMPTY_MARKET_CATEGORY -- ^ @"EMPTY_MARKET_CATEGORY"@
  | OfferMappingErrorType'UNKNOWN_PARAMETER -- ^ @"UNKNOWN_PARAMETER"@
  | OfferMappingErrorType'UNEXPECTED_BOOLEAN_VALUE -- ^ @"UNEXPECTED_BOOLEAN_VALUE"@
  | OfferMappingErrorType'NUMBER_FORMAT -- ^ @"NUMBER_FORMAT"@
  | OfferMappingErrorType'VALUE_BLANK -- ^ @"VALUE_BLANK"@
  | OfferMappingErrorType'INVALID_UNIT_ID -- ^ @"INVALID_UNIT_ID"@
  | OfferMappingErrorType'INVALID_GROUP_ID_LENGTH -- ^ @"INVALID_GROUP_ID_LENGTH"@
  | OfferMappingErrorType'INVALID_GROUP_ID_CHARACTERS -- ^ @"INVALID_GROUP_ID_CHARACTERS"@
  | OfferMappingErrorType'INVALID_PICKER_URL -- ^ @"INVALID_PICKER_URL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferMappingErrorType where toJSON = A.toJSON . fromOfferMappingErrorType
instance A.FromJSON OfferMappingErrorType where parseJSON o = P.either P.fail (pure . P.id) . toOfferMappingErrorType =<< A.parseJSON o
instance WH.ToHttpApiData OfferMappingErrorType where toQueryParam = WH.toQueryParam . fromOfferMappingErrorType
instance WH.FromHttpApiData OfferMappingErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferMappingErrorType
instance MimeRender MimeMultipartFormData OfferMappingErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferMappingErrorType' enum
fromOfferMappingErrorType :: OfferMappingErrorType -> Text
fromOfferMappingErrorType = \case
  OfferMappingErrorType'UNKNOWN_CATEGORY -> "UNKNOWN_CATEGORY"
  OfferMappingErrorType'CATEGORY_MISMATCH -> "CATEGORY_MISMATCH"
  OfferMappingErrorType'EMPTY_MARKET_CATEGORY -> "EMPTY_MARKET_CATEGORY"
  OfferMappingErrorType'UNKNOWN_PARAMETER -> "UNKNOWN_PARAMETER"
  OfferMappingErrorType'UNEXPECTED_BOOLEAN_VALUE -> "UNEXPECTED_BOOLEAN_VALUE"
  OfferMappingErrorType'NUMBER_FORMAT -> "NUMBER_FORMAT"
  OfferMappingErrorType'VALUE_BLANK -> "VALUE_BLANK"
  OfferMappingErrorType'INVALID_UNIT_ID -> "INVALID_UNIT_ID"
  OfferMappingErrorType'INVALID_GROUP_ID_LENGTH -> "INVALID_GROUP_ID_LENGTH"
  OfferMappingErrorType'INVALID_GROUP_ID_CHARACTERS -> "INVALID_GROUP_ID_CHARACTERS"
  OfferMappingErrorType'INVALID_PICKER_URL -> "INVALID_PICKER_URL"

-- | parse 'OfferMappingErrorType' enum
toOfferMappingErrorType :: Text -> P.Either String OfferMappingErrorType
toOfferMappingErrorType = \case
  "UNKNOWN_CATEGORY" -> P.Right OfferMappingErrorType'UNKNOWN_CATEGORY
  "CATEGORY_MISMATCH" -> P.Right OfferMappingErrorType'CATEGORY_MISMATCH
  "EMPTY_MARKET_CATEGORY" -> P.Right OfferMappingErrorType'EMPTY_MARKET_CATEGORY
  "UNKNOWN_PARAMETER" -> P.Right OfferMappingErrorType'UNKNOWN_PARAMETER
  "UNEXPECTED_BOOLEAN_VALUE" -> P.Right OfferMappingErrorType'UNEXPECTED_BOOLEAN_VALUE
  "NUMBER_FORMAT" -> P.Right OfferMappingErrorType'NUMBER_FORMAT
  "VALUE_BLANK" -> P.Right OfferMappingErrorType'VALUE_BLANK
  "INVALID_UNIT_ID" -> P.Right OfferMappingErrorType'INVALID_UNIT_ID
  "INVALID_GROUP_ID_LENGTH" -> P.Right OfferMappingErrorType'INVALID_GROUP_ID_LENGTH
  "INVALID_GROUP_ID_CHARACTERS" -> P.Right OfferMappingErrorType'INVALID_GROUP_ID_CHARACTERS
  "INVALID_PICKER_URL" -> P.Right OfferMappingErrorType'INVALID_PICKER_URL
  s -> P.Left $ "toOfferMappingErrorType: enum parse failure: " P.++ P.show s


-- ** OfferMappingKindType

-- | Enum of 'Text' .
-- Вид маппинга.
data OfferMappingKindType
  = OfferMappingKindType'ACTIVE -- ^ @"ACTIVE"@
  | OfferMappingKindType'ALL -- ^ @"ALL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferMappingKindType where toJSON = A.toJSON . fromOfferMappingKindType
instance A.FromJSON OfferMappingKindType where parseJSON o = P.either P.fail (pure . P.id) . toOfferMappingKindType =<< A.parseJSON o
instance WH.ToHttpApiData OfferMappingKindType where toQueryParam = WH.toQueryParam . fromOfferMappingKindType
instance WH.FromHttpApiData OfferMappingKindType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferMappingKindType
instance MimeRender MimeMultipartFormData OfferMappingKindType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferMappingKindType' enum
fromOfferMappingKindType :: OfferMappingKindType -> Text
fromOfferMappingKindType = \case
  OfferMappingKindType'ACTIVE -> "ACTIVE"
  OfferMappingKindType'ALL -> "ALL"

-- | parse 'OfferMappingKindType' enum
toOfferMappingKindType :: Text -> P.Either String OfferMappingKindType
toOfferMappingKindType = \case
  "ACTIVE" -> P.Right OfferMappingKindType'ACTIVE
  "ALL" -> P.Right OfferMappingKindType'ALL
  s -> P.Left $ "toOfferMappingKindType: enum parse failure: " P.++ P.show s


-- ** OfferProcessingNoteType

-- | Enum of 'Text' .
-- Тип причины, по которой товар не прошел модерацию:  * `ASSORTMENT` — товар производится в разных вариантах. Каждый из них нужно описать как отдельный товар (входной параметр `offer-mapping-entry` запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md) или строка в каталоге, если вы загружаете товары через кабинет продавца на Маркете). * `CANCELLED` — товар отозван с модерации по вашей инициативе. * `CONFLICTING_INFORMATION` _(ранее ошибочно `CONFLICTING`)_ — вы предоставили противоречивую информацию о товаре. Параметры, которые нужно исправить, указаны в параметре `payload`. * `DEPARTMENT_FROZEN` — правила размещения товаров в данной категории перерабатываются, поэтому товар пока не может пройти модерацию. * `INCORRECT_INFORMATION` — информация о товаре, которую вы предоставили, противоречит описанию от производителя. Параметры, которые нужно исправить, указаны в параметре `payload`. * `LEGAL_CONFLICT` — товар не прошел модерацию по юридическим причинам. Например, он официально не продается в России или у вас нет разрешения на его продажу. * `NEED_CLASSIFICATION_INFORMATION` — информации о товаре, которую вы предоставили, не хватает, чтобы отнести его к категории. Проверьте, что правильно указали название, категорию, производителя и страны производства товара, а также URL изображений или страниц с описанием, по которым можно идентифицировать товар. * `NEED_INFORMATION` — товар раньше не продавался в России и пока не размещается на Маркете. Для него можно создать карточку. Подробнее см. в разделе [Работа с карточкой товара](https://yandex.ru/support/marketplace/assortment/content/index.html) Справки Маркета для продавцов. * `NEED_PICTURES` — для идентификации товара нужны его изображения. Отправьте URL изображений товара в запросе [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md) или загрузите обновленный каталог через кабинет продавца на Маркете. * `NEED_VENDOR` — неверно указан производитель товара. * `NO_CATEGORY`, `NO_KNOWLEDGE` — товары из указанной категории пока не размещаются на Маркете. Если категория появится, товар будет снова отправлен на модерацию. * `NO_PARAMETERS_IN_SHOP_TITLE` — товар производится в разных вариантах, и из указанного названия непонятно, о каком идет речь. Параметры, которые нужно добавить в название товара, указаны в параметре `payload`. * `NO_SIZE_MEASURE` — для этого товара нужна размерная сетка. Отправьте ее в службу поддержки или вашему менеджеру. Требования к размерной сетке указаны в параметре `payload`. * `UNKNOWN` — товар не прошел модерацию по другой причине. Обратитесь в службу поддержки или к вашему менеджеру. 
data OfferProcessingNoteType
  = OfferProcessingNoteType'ASSORTMENT -- ^ @"ASSORTMENT"@
  | OfferProcessingNoteType'CANCELLED -- ^ @"CANCELLED"@
  | OfferProcessingNoteType'CONFLICTING_INFORMATION -- ^ @"CONFLICTING_INFORMATION"@
  | OfferProcessingNoteType'OTHER -- ^ @"OTHER"@
  | OfferProcessingNoteType'DEPARTMENT_FROZEN -- ^ @"DEPARTMENT_FROZEN"@
  | OfferProcessingNoteType'INCORRECT_INFORMATION -- ^ @"INCORRECT_INFORMATION"@
  | OfferProcessingNoteType'LEGAL_CONFLICT -- ^ @"LEGAL_CONFLICT"@
  | OfferProcessingNoteType'NEED_CLASSIFICATION_INFORMATION -- ^ @"NEED_CLASSIFICATION_INFORMATION"@
  | OfferProcessingNoteType'NEED_INFORMATION -- ^ @"NEED_INFORMATION"@
  | OfferProcessingNoteType'NEED_PICTURES -- ^ @"NEED_PICTURES"@
  | OfferProcessingNoteType'NEED_VENDOR -- ^ @"NEED_VENDOR"@
  | OfferProcessingNoteType'NO_CATEGORY -- ^ @"NO_CATEGORY"@
  | OfferProcessingNoteType'NO_KNOWLEDGE -- ^ @"NO_KNOWLEDGE"@
  | OfferProcessingNoteType'NO_PARAMETERS_IN_SHOP_TITLE -- ^ @"NO_PARAMETERS_IN_SHOP_TITLE"@
  | OfferProcessingNoteType'NO_SIZE_MEASURE -- ^ @"NO_SIZE_MEASURE"@
  | OfferProcessingNoteType'SAMPLE_LINE -- ^ @"SAMPLE_LINE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferProcessingNoteType where toJSON = A.toJSON . fromOfferProcessingNoteType
instance A.FromJSON OfferProcessingNoteType where parseJSON o = P.either P.fail (pure . P.id) . toOfferProcessingNoteType =<< A.parseJSON o
instance WH.ToHttpApiData OfferProcessingNoteType where toQueryParam = WH.toQueryParam . fromOfferProcessingNoteType
instance WH.FromHttpApiData OfferProcessingNoteType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferProcessingNoteType
instance MimeRender MimeMultipartFormData OfferProcessingNoteType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferProcessingNoteType' enum
fromOfferProcessingNoteType :: OfferProcessingNoteType -> Text
fromOfferProcessingNoteType = \case
  OfferProcessingNoteType'ASSORTMENT -> "ASSORTMENT"
  OfferProcessingNoteType'CANCELLED -> "CANCELLED"
  OfferProcessingNoteType'CONFLICTING_INFORMATION -> "CONFLICTING_INFORMATION"
  OfferProcessingNoteType'OTHER -> "OTHER"
  OfferProcessingNoteType'DEPARTMENT_FROZEN -> "DEPARTMENT_FROZEN"
  OfferProcessingNoteType'INCORRECT_INFORMATION -> "INCORRECT_INFORMATION"
  OfferProcessingNoteType'LEGAL_CONFLICT -> "LEGAL_CONFLICT"
  OfferProcessingNoteType'NEED_CLASSIFICATION_INFORMATION -> "NEED_CLASSIFICATION_INFORMATION"
  OfferProcessingNoteType'NEED_INFORMATION -> "NEED_INFORMATION"
  OfferProcessingNoteType'NEED_PICTURES -> "NEED_PICTURES"
  OfferProcessingNoteType'NEED_VENDOR -> "NEED_VENDOR"
  OfferProcessingNoteType'NO_CATEGORY -> "NO_CATEGORY"
  OfferProcessingNoteType'NO_KNOWLEDGE -> "NO_KNOWLEDGE"
  OfferProcessingNoteType'NO_PARAMETERS_IN_SHOP_TITLE -> "NO_PARAMETERS_IN_SHOP_TITLE"
  OfferProcessingNoteType'NO_SIZE_MEASURE -> "NO_SIZE_MEASURE"
  OfferProcessingNoteType'SAMPLE_LINE -> "SAMPLE_LINE"

-- | parse 'OfferProcessingNoteType' enum
toOfferProcessingNoteType :: Text -> P.Either String OfferProcessingNoteType
toOfferProcessingNoteType = \case
  "ASSORTMENT" -> P.Right OfferProcessingNoteType'ASSORTMENT
  "CANCELLED" -> P.Right OfferProcessingNoteType'CANCELLED
  "CONFLICTING_INFORMATION" -> P.Right OfferProcessingNoteType'CONFLICTING_INFORMATION
  "OTHER" -> P.Right OfferProcessingNoteType'OTHER
  "DEPARTMENT_FROZEN" -> P.Right OfferProcessingNoteType'DEPARTMENT_FROZEN
  "INCORRECT_INFORMATION" -> P.Right OfferProcessingNoteType'INCORRECT_INFORMATION
  "LEGAL_CONFLICT" -> P.Right OfferProcessingNoteType'LEGAL_CONFLICT
  "NEED_CLASSIFICATION_INFORMATION" -> P.Right OfferProcessingNoteType'NEED_CLASSIFICATION_INFORMATION
  "NEED_INFORMATION" -> P.Right OfferProcessingNoteType'NEED_INFORMATION
  "NEED_PICTURES" -> P.Right OfferProcessingNoteType'NEED_PICTURES
  "NEED_VENDOR" -> P.Right OfferProcessingNoteType'NEED_VENDOR
  "NO_CATEGORY" -> P.Right OfferProcessingNoteType'NO_CATEGORY
  "NO_KNOWLEDGE" -> P.Right OfferProcessingNoteType'NO_KNOWLEDGE
  "NO_PARAMETERS_IN_SHOP_TITLE" -> P.Right OfferProcessingNoteType'NO_PARAMETERS_IN_SHOP_TITLE
  "NO_SIZE_MEASURE" -> P.Right OfferProcessingNoteType'NO_SIZE_MEASURE
  "SAMPLE_LINE" -> P.Right OfferProcessingNoteType'SAMPLE_LINE
  s -> P.Left $ "toOfferProcessingNoteType: enum parse failure: " P.++ P.show s


-- ** OfferProcessingStatusType

-- | Enum of 'Text' .
-- Статус публикации товара:  * `READY` — товар прошел модерацию. Чтобы разместить его на Маркете, установите для него цену. * `IN_WORK` — товар проходит модерацию. Это занимает несколько дней. * `NEED_CONTENT` — для товара без SKU на Маркете `marketSku` нужно найти карточку самостоятельно (через API или кабинет продавца на Маркете) или создать ее, если товар еще не продается на Маркете. * `NEED_INFO` — товар не прошел модерацию из-за ошибок или недостающих сведений в описании товара. Информация о причинах отклонения возвращается в параметре `notes`. * `REJECTED` — товар не прошел модерацию, так как Маркет не планирует размещать подобные товары. * `SUSPENDED` — товар не прошел модерацию, так как Маркет пока не размещает подобные товары. 
data OfferProcessingStatusType
  = OfferProcessingStatusType'UNKNOWN -- ^ @"UNKNOWN"@
  | OfferProcessingStatusType'READY -- ^ @"READY"@
  | OfferProcessingStatusType'IN_WORK -- ^ @"IN_WORK"@
  | OfferProcessingStatusType'NEED_INFO -- ^ @"NEED_INFO"@
  | OfferProcessingStatusType'NEED_MAPPING -- ^ @"NEED_MAPPING"@
  | OfferProcessingStatusType'NEED_CONTENT -- ^ @"NEED_CONTENT"@
  | OfferProcessingStatusType'CONTENT_PROCESSING -- ^ @"CONTENT_PROCESSING"@
  | OfferProcessingStatusType'SUSPENDED -- ^ @"SUSPENDED"@
  | OfferProcessingStatusType'REJECTED -- ^ @"REJECTED"@
  | OfferProcessingStatusType'REVIEW -- ^ @"REVIEW"@
  | OfferProcessingStatusType'CREATE_ERROR -- ^ @"CREATE_ERROR"@
  | OfferProcessingStatusType'UPDATE_ERROR -- ^ @"UPDATE_ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferProcessingStatusType where toJSON = A.toJSON . fromOfferProcessingStatusType
instance A.FromJSON OfferProcessingStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOfferProcessingStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OfferProcessingStatusType where toQueryParam = WH.toQueryParam . fromOfferProcessingStatusType
instance WH.FromHttpApiData OfferProcessingStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferProcessingStatusType
instance MimeRender MimeMultipartFormData OfferProcessingStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferProcessingStatusType' enum
fromOfferProcessingStatusType :: OfferProcessingStatusType -> Text
fromOfferProcessingStatusType = \case
  OfferProcessingStatusType'UNKNOWN -> "UNKNOWN"
  OfferProcessingStatusType'READY -> "READY"
  OfferProcessingStatusType'IN_WORK -> "IN_WORK"
  OfferProcessingStatusType'NEED_INFO -> "NEED_INFO"
  OfferProcessingStatusType'NEED_MAPPING -> "NEED_MAPPING"
  OfferProcessingStatusType'NEED_CONTENT -> "NEED_CONTENT"
  OfferProcessingStatusType'CONTENT_PROCESSING -> "CONTENT_PROCESSING"
  OfferProcessingStatusType'SUSPENDED -> "SUSPENDED"
  OfferProcessingStatusType'REJECTED -> "REJECTED"
  OfferProcessingStatusType'REVIEW -> "REVIEW"
  OfferProcessingStatusType'CREATE_ERROR -> "CREATE_ERROR"
  OfferProcessingStatusType'UPDATE_ERROR -> "UPDATE_ERROR"

-- | parse 'OfferProcessingStatusType' enum
toOfferProcessingStatusType :: Text -> P.Either String OfferProcessingStatusType
toOfferProcessingStatusType = \case
  "UNKNOWN" -> P.Right OfferProcessingStatusType'UNKNOWN
  "READY" -> P.Right OfferProcessingStatusType'READY
  "IN_WORK" -> P.Right OfferProcessingStatusType'IN_WORK
  "NEED_INFO" -> P.Right OfferProcessingStatusType'NEED_INFO
  "NEED_MAPPING" -> P.Right OfferProcessingStatusType'NEED_MAPPING
  "NEED_CONTENT" -> P.Right OfferProcessingStatusType'NEED_CONTENT
  "CONTENT_PROCESSING" -> P.Right OfferProcessingStatusType'CONTENT_PROCESSING
  "SUSPENDED" -> P.Right OfferProcessingStatusType'SUSPENDED
  "REJECTED" -> P.Right OfferProcessingStatusType'REJECTED
  "REVIEW" -> P.Right OfferProcessingStatusType'REVIEW
  "CREATE_ERROR" -> P.Right OfferProcessingStatusType'CREATE_ERROR
  "UPDATE_ERROR" -> P.Right OfferProcessingStatusType'UPDATE_ERROR
  s -> P.Left $ "toOfferProcessingStatusType: enum parse failure: " P.++ P.show s


-- ** OfferSellingProgramStatusType

-- | Enum of 'Text' .
-- Информация о доступности или недоступности.  * `FINE` — доступно. * `REJECT` — недоступно. 
data OfferSellingProgramStatusType
  = OfferSellingProgramStatusType'FINE -- ^ @"FINE"@
  | OfferSellingProgramStatusType'REJECT -- ^ @"REJECT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferSellingProgramStatusType where toJSON = A.toJSON . fromOfferSellingProgramStatusType
instance A.FromJSON OfferSellingProgramStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOfferSellingProgramStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OfferSellingProgramStatusType where toQueryParam = WH.toQueryParam . fromOfferSellingProgramStatusType
instance WH.FromHttpApiData OfferSellingProgramStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferSellingProgramStatusType
instance MimeRender MimeMultipartFormData OfferSellingProgramStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferSellingProgramStatusType' enum
fromOfferSellingProgramStatusType :: OfferSellingProgramStatusType -> Text
fromOfferSellingProgramStatusType = \case
  OfferSellingProgramStatusType'FINE -> "FINE"
  OfferSellingProgramStatusType'REJECT -> "REJECT"

-- | parse 'OfferSellingProgramStatusType' enum
toOfferSellingProgramStatusType :: Text -> P.Either String OfferSellingProgramStatusType
toOfferSellingProgramStatusType = \case
  "FINE" -> P.Right OfferSellingProgramStatusType'FINE
  "REJECT" -> P.Right OfferSellingProgramStatusType'REJECT
  s -> P.Left $ "toOfferSellingProgramStatusType: enum parse failure: " P.++ P.show s


-- ** OfferType

-- | Enum of 'Text' .
-- Особый тип товара:  * `MEDICINE` — лекарства. * `BOOK` — бумажные и электронные книги. * `AUDIOBOOK` — аудиокниги. * `ARTIST_TITLE` — музыкальная и видеопродукция. * `ON_DEMAND` — товары на заказ.  {% note info \"Если ваш товар — книга\" %}  Укажите год издания в характеристиках товара. [Подробнее о параметре](../../reference/business-assortment/updateOfferMappings.md#offerparamdto)  {% endnote %} 
data OfferType
  = OfferType'DEFAULT -- ^ @"DEFAULT"@
  | OfferType'MEDICINE -- ^ @"MEDICINE"@
  | OfferType'BOOK -- ^ @"BOOK"@
  | OfferType'AUDIOBOOK -- ^ @"AUDIOBOOK"@
  | OfferType'ARTIST_TITLE -- ^ @"ARTIST_TITLE"@
  | OfferType'ON_DEMAND -- ^ @"ON_DEMAND"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OfferType where toJSON = A.toJSON . fromOfferType
instance A.FromJSON OfferType where parseJSON o = P.either P.fail (pure . P.id) . toOfferType =<< A.parseJSON o
instance WH.ToHttpApiData OfferType where toQueryParam = WH.toQueryParam . fromOfferType
instance WH.FromHttpApiData OfferType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOfferType
instance MimeRender MimeMultipartFormData OfferType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OfferType' enum
fromOfferType :: OfferType -> Text
fromOfferType = \case
  OfferType'DEFAULT -> "DEFAULT"
  OfferType'MEDICINE -> "MEDICINE"
  OfferType'BOOK -> "BOOK"
  OfferType'AUDIOBOOK -> "AUDIOBOOK"
  OfferType'ARTIST_TITLE -> "ARTIST_TITLE"
  OfferType'ON_DEMAND -> "ON_DEMAND"

-- | parse 'OfferType' enum
toOfferType :: Text -> P.Either String OfferType
toOfferType = \case
  "DEFAULT" -> P.Right OfferType'DEFAULT
  "MEDICINE" -> P.Right OfferType'MEDICINE
  "BOOK" -> P.Right OfferType'BOOK
  "AUDIOBOOK" -> P.Right OfferType'AUDIOBOOK
  "ARTIST_TITLE" -> P.Right OfferType'ARTIST_TITLE
  "ON_DEMAND" -> P.Right OfferType'ON_DEMAND
  s -> P.Left $ "toOfferType: enum parse failure: " P.++ P.show s


-- ** OrderBuyerType

-- | Enum of 'Text' .
-- Тип покупателя:  * `PERSON` — физическое лицо.  * `BUSINESS` — организация. 
data OrderBuyerType
  = OrderBuyerType'PERSON -- ^ @"PERSON"@
  | OrderBuyerType'BUSINESS -- ^ @"BUSINESS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderBuyerType where toJSON = A.toJSON . fromOrderBuyerType
instance A.FromJSON OrderBuyerType where parseJSON o = P.either P.fail (pure . P.id) . toOrderBuyerType =<< A.parseJSON o
instance WH.ToHttpApiData OrderBuyerType where toQueryParam = WH.toQueryParam . fromOrderBuyerType
instance WH.FromHttpApiData OrderBuyerType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderBuyerType
instance MimeRender MimeMultipartFormData OrderBuyerType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderBuyerType' enum
fromOrderBuyerType :: OrderBuyerType -> Text
fromOrderBuyerType = \case
  OrderBuyerType'PERSON -> "PERSON"
  OrderBuyerType'BUSINESS -> "BUSINESS"

-- | parse 'OrderBuyerType' enum
toOrderBuyerType :: Text -> P.Either String OrderBuyerType
toOrderBuyerType = \case
  "PERSON" -> P.Right OrderBuyerType'PERSON
  "BUSINESS" -> P.Right OrderBuyerType'BUSINESS
  s -> P.Left $ "toOrderBuyerType: enum parse failure: " P.++ P.show s


-- ** OrderCancellationReasonType

-- | Enum of 'Text' .
-- Варианты причин, по которым заказ не может быть отменен.  * `ORDER_DELIVERED` — заказ уже доставлен. * `ORDER_IN_DELIVERY` — заказ уже у курьера. 
data OrderCancellationReasonType
  = OrderCancellationReasonType'DELIVERED -- ^ @"ORDER_DELIVERED"@
  | OrderCancellationReasonType'IN_DELIVERY -- ^ @"ORDER_IN_DELIVERY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderCancellationReasonType where toJSON = A.toJSON . fromOrderCancellationReasonType
instance A.FromJSON OrderCancellationReasonType where parseJSON o = P.either P.fail (pure . P.id) . toOrderCancellationReasonType =<< A.parseJSON o
instance WH.ToHttpApiData OrderCancellationReasonType where toQueryParam = WH.toQueryParam . fromOrderCancellationReasonType
instance WH.FromHttpApiData OrderCancellationReasonType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderCancellationReasonType
instance MimeRender MimeMultipartFormData OrderCancellationReasonType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderCancellationReasonType' enum
fromOrderCancellationReasonType :: OrderCancellationReasonType -> Text
fromOrderCancellationReasonType = \case
  OrderCancellationReasonType'DELIVERED -> "ORDER_DELIVERED"
  OrderCancellationReasonType'IN_DELIVERY -> "ORDER_IN_DELIVERY"

-- | parse 'OrderCancellationReasonType' enum
toOrderCancellationReasonType :: Text -> P.Either String OrderCancellationReasonType
toOrderCancellationReasonType = \case
  "ORDER_DELIVERED" -> P.Right OrderCancellationReasonType'DELIVERED
  "ORDER_IN_DELIVERY" -> P.Right OrderCancellationReasonType'IN_DELIVERY
  s -> P.Left $ "toOrderCancellationReasonType: enum parse failure: " P.++ P.show s


-- ** OrderDeliveryDateReasonType

-- | Enum of 'Text' .
-- Причина переноса доставки заказа. Возможные причины изменения даты:   - ```USER_MOVED_DELIVERY_DATES``` — покупатель попросил изменить дату или вы договорились привезти ему заказ раньше изначальной даты. Кроме этого указывается для подтверждения даты доставки товаров на заказ с долгой (31-60 дней) доставкой.   - ```PARTNER_MOVED_DELIVERY_DATES``` — магазин не может доставить заказ в срок. 
data OrderDeliveryDateReasonType
  = OrderDeliveryDateReasonType'USER_MOVED_DELIVERY_DATES -- ^ @"USER_MOVED_DELIVERY_DATES"@
  | OrderDeliveryDateReasonType'PARTNER_MOVED_DELIVERY_DATES -- ^ @"PARTNER_MOVED_DELIVERY_DATES"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderDeliveryDateReasonType where toJSON = A.toJSON . fromOrderDeliveryDateReasonType
instance A.FromJSON OrderDeliveryDateReasonType where parseJSON o = P.either P.fail (pure . P.id) . toOrderDeliveryDateReasonType =<< A.parseJSON o
instance WH.ToHttpApiData OrderDeliveryDateReasonType where toQueryParam = WH.toQueryParam . fromOrderDeliveryDateReasonType
instance WH.FromHttpApiData OrderDeliveryDateReasonType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderDeliveryDateReasonType
instance MimeRender MimeMultipartFormData OrderDeliveryDateReasonType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderDeliveryDateReasonType' enum
fromOrderDeliveryDateReasonType :: OrderDeliveryDateReasonType -> Text
fromOrderDeliveryDateReasonType = \case
  OrderDeliveryDateReasonType'USER_MOVED_DELIVERY_DATES -> "USER_MOVED_DELIVERY_DATES"
  OrderDeliveryDateReasonType'PARTNER_MOVED_DELIVERY_DATES -> "PARTNER_MOVED_DELIVERY_DATES"

-- | parse 'OrderDeliveryDateReasonType' enum
toOrderDeliveryDateReasonType :: Text -> P.Either String OrderDeliveryDateReasonType
toOrderDeliveryDateReasonType = \case
  "USER_MOVED_DELIVERY_DATES" -> P.Right OrderDeliveryDateReasonType'USER_MOVED_DELIVERY_DATES
  "PARTNER_MOVED_DELIVERY_DATES" -> P.Right OrderDeliveryDateReasonType'PARTNER_MOVED_DELIVERY_DATES
  s -> P.Left $ "toOrderDeliveryDateReasonType: enum parse failure: " P.++ P.show s


-- ** OrderDeliveryDispatchType

-- | Enum of 'Text' .
-- Способ отгрузки:  * `BUYER` — доставка покупателю.  * `MARKET_PARTNER_OUTLET` — доставка в пункт выдачи партнера.  * `MARKET_BRANDED_OUTLET` — доставка в пункт выдачи заказов Маркета.  * `SHOP_OUTLET` — доставка в пункт выдачи заказов магазина.  * `DROPOFF` — доставка в пункт выдачи, который принимает заказы от продавцов и передает их курьерам.  * `UNKNOWN` — неизвестный тип. 
data OrderDeliveryDispatchType
  = OrderDeliveryDispatchType'UNKNOWN -- ^ @"UNKNOWN"@
  | OrderDeliveryDispatchType'BUYER -- ^ @"BUYER"@
  | OrderDeliveryDispatchType'MARKET_PARTNER_OUTLET -- ^ @"MARKET_PARTNER_OUTLET"@
  | OrderDeliveryDispatchType'MARKET_BRANDED_OUTLET -- ^ @"MARKET_BRANDED_OUTLET"@
  | OrderDeliveryDispatchType'SHOP_OUTLET -- ^ @"SHOP_OUTLET"@
  | OrderDeliveryDispatchType'DROPOFF -- ^ @"DROPOFF"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderDeliveryDispatchType where toJSON = A.toJSON . fromOrderDeliveryDispatchType
instance A.FromJSON OrderDeliveryDispatchType where parseJSON o = P.either P.fail (pure . P.id) . toOrderDeliveryDispatchType =<< A.parseJSON o
instance WH.ToHttpApiData OrderDeliveryDispatchType where toQueryParam = WH.toQueryParam . fromOrderDeliveryDispatchType
instance WH.FromHttpApiData OrderDeliveryDispatchType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderDeliveryDispatchType
instance MimeRender MimeMultipartFormData OrderDeliveryDispatchType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderDeliveryDispatchType' enum
fromOrderDeliveryDispatchType :: OrderDeliveryDispatchType -> Text
fromOrderDeliveryDispatchType = \case
  OrderDeliveryDispatchType'UNKNOWN -> "UNKNOWN"
  OrderDeliveryDispatchType'BUYER -> "BUYER"
  OrderDeliveryDispatchType'MARKET_PARTNER_OUTLET -> "MARKET_PARTNER_OUTLET"
  OrderDeliveryDispatchType'MARKET_BRANDED_OUTLET -> "MARKET_BRANDED_OUTLET"
  OrderDeliveryDispatchType'SHOP_OUTLET -> "SHOP_OUTLET"
  OrderDeliveryDispatchType'DROPOFF -> "DROPOFF"

-- | parse 'OrderDeliveryDispatchType' enum
toOrderDeliveryDispatchType :: Text -> P.Either String OrderDeliveryDispatchType
toOrderDeliveryDispatchType = \case
  "UNKNOWN" -> P.Right OrderDeliveryDispatchType'UNKNOWN
  "BUYER" -> P.Right OrderDeliveryDispatchType'BUYER
  "MARKET_PARTNER_OUTLET" -> P.Right OrderDeliveryDispatchType'MARKET_PARTNER_OUTLET
  "MARKET_BRANDED_OUTLET" -> P.Right OrderDeliveryDispatchType'MARKET_BRANDED_OUTLET
  "SHOP_OUTLET" -> P.Right OrderDeliveryDispatchType'SHOP_OUTLET
  "DROPOFF" -> P.Right OrderDeliveryDispatchType'DROPOFF
  s -> P.Left $ "toOrderDeliveryDispatchType: enum parse failure: " P.++ P.show s


-- ** OrderDeliveryEacType

-- | Enum of 'Text' .
-- Тип кода подтверждения ЭАПП:  * `MERCHANT_TO_COURIER` — продавец передает код курьеру.  * `COURIER_TO_MERCHANT` — курьер передает код продавцу.  * `CHECKING_BY_MERCHANT` — продавец проверяет код на своей стороне. 
data OrderDeliveryEacType
  = OrderDeliveryEacType'MERCHANT_TO_COURIER -- ^ @"MERCHANT_TO_COURIER"@
  | OrderDeliveryEacType'COURIER_TO_MERCHANT -- ^ @"COURIER_TO_MERCHANT"@
  | OrderDeliveryEacType'CHECKING_BY_MERCHANT -- ^ @"CHECKING_BY_MERCHANT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderDeliveryEacType where toJSON = A.toJSON . fromOrderDeliveryEacType
instance A.FromJSON OrderDeliveryEacType where parseJSON o = P.either P.fail (pure . P.id) . toOrderDeliveryEacType =<< A.parseJSON o
instance WH.ToHttpApiData OrderDeliveryEacType where toQueryParam = WH.toQueryParam . fromOrderDeliveryEacType
instance WH.FromHttpApiData OrderDeliveryEacType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderDeliveryEacType
instance MimeRender MimeMultipartFormData OrderDeliveryEacType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderDeliveryEacType' enum
fromOrderDeliveryEacType :: OrderDeliveryEacType -> Text
fromOrderDeliveryEacType = \case
  OrderDeliveryEacType'MERCHANT_TO_COURIER -> "MERCHANT_TO_COURIER"
  OrderDeliveryEacType'COURIER_TO_MERCHANT -> "COURIER_TO_MERCHANT"
  OrderDeliveryEacType'CHECKING_BY_MERCHANT -> "CHECKING_BY_MERCHANT"

-- | parse 'OrderDeliveryEacType' enum
toOrderDeliveryEacType :: Text -> P.Either String OrderDeliveryEacType
toOrderDeliveryEacType = \case
  "MERCHANT_TO_COURIER" -> P.Right OrderDeliveryEacType'MERCHANT_TO_COURIER
  "COURIER_TO_MERCHANT" -> P.Right OrderDeliveryEacType'COURIER_TO_MERCHANT
  "CHECKING_BY_MERCHANT" -> P.Right OrderDeliveryEacType'CHECKING_BY_MERCHANT
  s -> P.Left $ "toOrderDeliveryEacType: enum parse failure: " P.++ P.show s


-- ** OrderDeliveryPartnerType

-- | Enum of 'Text' .
-- Тип сотрудничества со службой доставки в рамках конкретного заказа:  * `SHOP` — магазин работает со службой доставки напрямую или доставляет заказы самостоятельно.  * `YANDEX_MARKET` — магазин работает со службой доставки через Маркет.  * `UNKNOWN` — неизвестный тип. 
data OrderDeliveryPartnerType
  = OrderDeliveryPartnerType'SHOP -- ^ @"SHOP"@
  | OrderDeliveryPartnerType'YANDEX_MARKET -- ^ @"YANDEX_MARKET"@
  | OrderDeliveryPartnerType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderDeliveryPartnerType where toJSON = A.toJSON . fromOrderDeliveryPartnerType
instance A.FromJSON OrderDeliveryPartnerType where parseJSON o = P.either P.fail (pure . P.id) . toOrderDeliveryPartnerType =<< A.parseJSON o
instance WH.ToHttpApiData OrderDeliveryPartnerType where toQueryParam = WH.toQueryParam . fromOrderDeliveryPartnerType
instance WH.FromHttpApiData OrderDeliveryPartnerType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderDeliveryPartnerType
instance MimeRender MimeMultipartFormData OrderDeliveryPartnerType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderDeliveryPartnerType' enum
fromOrderDeliveryPartnerType :: OrderDeliveryPartnerType -> Text
fromOrderDeliveryPartnerType = \case
  OrderDeliveryPartnerType'SHOP -> "SHOP"
  OrderDeliveryPartnerType'YANDEX_MARKET -> "YANDEX_MARKET"
  OrderDeliveryPartnerType'UNKNOWN -> "UNKNOWN"

-- | parse 'OrderDeliveryPartnerType' enum
toOrderDeliveryPartnerType :: Text -> P.Either String OrderDeliveryPartnerType
toOrderDeliveryPartnerType = \case
  "SHOP" -> P.Right OrderDeliveryPartnerType'SHOP
  "YANDEX_MARKET" -> P.Right OrderDeliveryPartnerType'YANDEX_MARKET
  "UNKNOWN" -> P.Right OrderDeliveryPartnerType'UNKNOWN
  s -> P.Left $ "toOrderDeliveryPartnerType: enum parse failure: " P.++ P.show s


-- ** OrderDeliveryType

-- | Enum of 'Text' .
-- Способ доставки заказа:  * `DELIVERY` — курьерская доставка.  * `PICKUP` — самовывоз.  * `POST` — почта.  * `DIGITAL` — для цифровых товаров.  * `UNKNOWN` — неизвестный тип. 
data OrderDeliveryType
  = OrderDeliveryType'DELIVERY -- ^ @"DELIVERY"@
  | OrderDeliveryType'PICKUP -- ^ @"PICKUP"@
  | OrderDeliveryType'POST -- ^ @"POST"@
  | OrderDeliveryType'DIGITAL -- ^ @"DIGITAL"@
  | OrderDeliveryType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderDeliveryType where toJSON = A.toJSON . fromOrderDeliveryType
instance A.FromJSON OrderDeliveryType where parseJSON o = P.either P.fail (pure . P.id) . toOrderDeliveryType =<< A.parseJSON o
instance WH.ToHttpApiData OrderDeliveryType where toQueryParam = WH.toQueryParam . fromOrderDeliveryType
instance WH.FromHttpApiData OrderDeliveryType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderDeliveryType
instance MimeRender MimeMultipartFormData OrderDeliveryType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderDeliveryType' enum
fromOrderDeliveryType :: OrderDeliveryType -> Text
fromOrderDeliveryType = \case
  OrderDeliveryType'DELIVERY -> "DELIVERY"
  OrderDeliveryType'PICKUP -> "PICKUP"
  OrderDeliveryType'POST -> "POST"
  OrderDeliveryType'DIGITAL -> "DIGITAL"
  OrderDeliveryType'UNKNOWN -> "UNKNOWN"

-- | parse 'OrderDeliveryType' enum
toOrderDeliveryType :: Text -> P.Either String OrderDeliveryType
toOrderDeliveryType = \case
  "DELIVERY" -> P.Right OrderDeliveryType'DELIVERY
  "PICKUP" -> P.Right OrderDeliveryType'PICKUP
  "POST" -> P.Right OrderDeliveryType'POST
  "DIGITAL" -> P.Right OrderDeliveryType'DIGITAL
  "UNKNOWN" -> P.Right OrderDeliveryType'UNKNOWN
  s -> P.Left $ "toOrderDeliveryType: enum parse failure: " P.++ P.show s


-- ** OrderDocumentStatusType

-- | Enum of 'Text' .
-- Статус документа:  * `READY` — готов. * `NOT_READY` — не готов. 
data OrderDocumentStatusType
  = OrderDocumentStatusType'READY -- ^ @"READY"@
  | OrderDocumentStatusType'NOT_READY -- ^ @"NOT_READY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderDocumentStatusType where toJSON = A.toJSON . fromOrderDocumentStatusType
instance A.FromJSON OrderDocumentStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOrderDocumentStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OrderDocumentStatusType where toQueryParam = WH.toQueryParam . fromOrderDocumentStatusType
instance WH.FromHttpApiData OrderDocumentStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderDocumentStatusType
instance MimeRender MimeMultipartFormData OrderDocumentStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderDocumentStatusType' enum
fromOrderDocumentStatusType :: OrderDocumentStatusType -> Text
fromOrderDocumentStatusType = \case
  OrderDocumentStatusType'READY -> "READY"
  OrderDocumentStatusType'NOT_READY -> "NOT_READY"

-- | parse 'OrderDocumentStatusType' enum
toOrderDocumentStatusType :: Text -> P.Either String OrderDocumentStatusType
toOrderDocumentStatusType = \case
  "READY" -> P.Right OrderDocumentStatusType'READY
  "NOT_READY" -> P.Right OrderDocumentStatusType'NOT_READY
  s -> P.Left $ "toOrderDocumentStatusType: enum parse failure: " P.++ P.show s


-- ** OrderItemInstanceType

-- | Enum of 'Text' .
-- Вид маркировки товара:  * `CIS` — КИЗ, идентификатор единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).  * `UIN` — УИН, уникальный идентификационный номер.  * `RNPT` — РНПТ, регистрационный номер партии товара.  * `GTD` — номер ГТД, грузовой таможенной декларации. 
data OrderItemInstanceType
  = OrderItemInstanceType'CIS -- ^ @"CIS"@
  | OrderItemInstanceType'UIN -- ^ @"UIN"@
  | OrderItemInstanceType'RNPT -- ^ @"RNPT"@
  | OrderItemInstanceType'GTD -- ^ @"GTD"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderItemInstanceType where toJSON = A.toJSON . fromOrderItemInstanceType
instance A.FromJSON OrderItemInstanceType where parseJSON o = P.either P.fail (pure . P.id) . toOrderItemInstanceType =<< A.parseJSON o
instance WH.ToHttpApiData OrderItemInstanceType where toQueryParam = WH.toQueryParam . fromOrderItemInstanceType
instance WH.FromHttpApiData OrderItemInstanceType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderItemInstanceType
instance MimeRender MimeMultipartFormData OrderItemInstanceType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderItemInstanceType' enum
fromOrderItemInstanceType :: OrderItemInstanceType -> Text
fromOrderItemInstanceType = \case
  OrderItemInstanceType'CIS -> "CIS"
  OrderItemInstanceType'UIN -> "UIN"
  OrderItemInstanceType'RNPT -> "RNPT"
  OrderItemInstanceType'GTD -> "GTD"

-- | parse 'OrderItemInstanceType' enum
toOrderItemInstanceType :: Text -> P.Either String OrderItemInstanceType
toOrderItemInstanceType = \case
  "CIS" -> P.Right OrderItemInstanceType'CIS
  "UIN" -> P.Right OrderItemInstanceType'UIN
  "RNPT" -> P.Right OrderItemInstanceType'RNPT
  "GTD" -> P.Right OrderItemInstanceType'GTD
  s -> P.Left $ "toOrderItemInstanceType: enum parse failure: " P.++ P.show s


-- ** OrderItemStatusType

-- | Enum of 'Text' .
-- Возвращенный или невыкупленный товар:  * `REJECTED` — невыкупленный.  * `RETURNED` — возвращенный. 
data OrderItemStatusType
  = OrderItemStatusType'REJECTED -- ^ @"REJECTED"@
  | OrderItemStatusType'RETURNED -- ^ @"RETURNED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderItemStatusType where toJSON = A.toJSON . fromOrderItemStatusType
instance A.FromJSON OrderItemStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOrderItemStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OrderItemStatusType where toQueryParam = WH.toQueryParam . fromOrderItemStatusType
instance WH.FromHttpApiData OrderItemStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderItemStatusType
instance MimeRender MimeMultipartFormData OrderItemStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderItemStatusType' enum
fromOrderItemStatusType :: OrderItemStatusType -> Text
fromOrderItemStatusType = \case
  OrderItemStatusType'REJECTED -> "REJECTED"
  OrderItemStatusType'RETURNED -> "RETURNED"

-- | parse 'OrderItemStatusType' enum
toOrderItemStatusType :: Text -> P.Either String OrderItemStatusType
toOrderItemStatusType = \case
  "REJECTED" -> P.Right OrderItemStatusType'REJECTED
  "RETURNED" -> P.Right OrderItemStatusType'RETURNED
  s -> P.Left $ "toOrderItemStatusType: enum parse failure: " P.++ P.show s


-- ** OrderItemSubsidyType

-- | Enum of 'Text' .
-- Тип субсидии:  * `YANDEX_CASHBACK` — скидка по подписке Яндекс Плюс.  * `SUBSIDY` — скидка Маркета (по акциям, промокодам, купонам и т. д.). 
data OrderItemSubsidyType
  = OrderItemSubsidyType'YANDEX_CASHBACK -- ^ @"YANDEX_CASHBACK"@
  | OrderItemSubsidyType'SUBSIDY -- ^ @"SUBSIDY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderItemSubsidyType where toJSON = A.toJSON . fromOrderItemSubsidyType
instance A.FromJSON OrderItemSubsidyType where parseJSON o = P.either P.fail (pure . P.id) . toOrderItemSubsidyType =<< A.parseJSON o
instance WH.ToHttpApiData OrderItemSubsidyType where toQueryParam = WH.toQueryParam . fromOrderItemSubsidyType
instance WH.FromHttpApiData OrderItemSubsidyType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderItemSubsidyType
instance MimeRender MimeMultipartFormData OrderItemSubsidyType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderItemSubsidyType' enum
fromOrderItemSubsidyType :: OrderItemSubsidyType -> Text
fromOrderItemSubsidyType = \case
  OrderItemSubsidyType'YANDEX_CASHBACK -> "YANDEX_CASHBACK"
  OrderItemSubsidyType'SUBSIDY -> "SUBSIDY"

-- | parse 'OrderItemSubsidyType' enum
toOrderItemSubsidyType :: Text -> P.Either String OrderItemSubsidyType
toOrderItemSubsidyType = \case
  "YANDEX_CASHBACK" -> P.Right OrderItemSubsidyType'YANDEX_CASHBACK
  "SUBSIDY" -> P.Right OrderItemSubsidyType'SUBSIDY
  s -> P.Left $ "toOrderItemSubsidyType: enum parse failure: " P.++ P.show s


-- ** OrderItemsModificationRequestReasonType

-- | Enum of 'Text' .
-- Причина обновления состава заказа.
data OrderItemsModificationRequestReasonType
  = OrderItemsModificationRequestReasonType'PARTNER_REQUESTED_REMOVE -- ^ @"PARTNER_REQUESTED_REMOVE"@
  | OrderItemsModificationRequestReasonType'USER_REQUESTED_REMOVE -- ^ @"USER_REQUESTED_REMOVE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderItemsModificationRequestReasonType where toJSON = A.toJSON . fromOrderItemsModificationRequestReasonType
instance A.FromJSON OrderItemsModificationRequestReasonType where parseJSON o = P.either P.fail (pure . P.id) . toOrderItemsModificationRequestReasonType =<< A.parseJSON o
instance WH.ToHttpApiData OrderItemsModificationRequestReasonType where toQueryParam = WH.toQueryParam . fromOrderItemsModificationRequestReasonType
instance WH.FromHttpApiData OrderItemsModificationRequestReasonType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderItemsModificationRequestReasonType
instance MimeRender MimeMultipartFormData OrderItemsModificationRequestReasonType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderItemsModificationRequestReasonType' enum
fromOrderItemsModificationRequestReasonType :: OrderItemsModificationRequestReasonType -> Text
fromOrderItemsModificationRequestReasonType = \case
  OrderItemsModificationRequestReasonType'PARTNER_REQUESTED_REMOVE -> "PARTNER_REQUESTED_REMOVE"
  OrderItemsModificationRequestReasonType'USER_REQUESTED_REMOVE -> "USER_REQUESTED_REMOVE"

-- | parse 'OrderItemsModificationRequestReasonType' enum
toOrderItemsModificationRequestReasonType :: Text -> P.Either String OrderItemsModificationRequestReasonType
toOrderItemsModificationRequestReasonType = \case
  "PARTNER_REQUESTED_REMOVE" -> P.Right OrderItemsModificationRequestReasonType'PARTNER_REQUESTED_REMOVE
  "USER_REQUESTED_REMOVE" -> P.Right OrderItemsModificationRequestReasonType'USER_REQUESTED_REMOVE
  s -> P.Left $ "toOrderItemsModificationRequestReasonType: enum parse failure: " P.++ P.show s


-- ** OrderLiftType

-- | Enum of 'Text' .
-- Тип подъема заказа на этаж:  * `NOT_NEEDED` — не требуется.  * `MANUAL` — ручной.  * `ELEVATOR` — лифт.  * `CARGO_ELEVATOR` — грузовой лифт.  * `FREE` — любой из перечисленных выше, если включена опция бесплатного подъема.  * `UNKNOWN` — неизвестный тип. 
data OrderLiftType
  = OrderLiftType'NOT_NEEDED -- ^ @"NOT_NEEDED"@
  | OrderLiftType'MANUAL -- ^ @"MANUAL"@
  | OrderLiftType'ELEVATOR -- ^ @"ELEVATOR"@
  | OrderLiftType'CARGO_ELEVATOR -- ^ @"CARGO_ELEVATOR"@
  | OrderLiftType'FREE -- ^ @"FREE"@
  | OrderLiftType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderLiftType where toJSON = A.toJSON . fromOrderLiftType
instance A.FromJSON OrderLiftType where parseJSON o = P.either P.fail (pure . P.id) . toOrderLiftType =<< A.parseJSON o
instance WH.ToHttpApiData OrderLiftType where toQueryParam = WH.toQueryParam . fromOrderLiftType
instance WH.FromHttpApiData OrderLiftType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderLiftType
instance MimeRender MimeMultipartFormData OrderLiftType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderLiftType' enum
fromOrderLiftType :: OrderLiftType -> Text
fromOrderLiftType = \case
  OrderLiftType'NOT_NEEDED -> "NOT_NEEDED"
  OrderLiftType'MANUAL -> "MANUAL"
  OrderLiftType'ELEVATOR -> "ELEVATOR"
  OrderLiftType'CARGO_ELEVATOR -> "CARGO_ELEVATOR"
  OrderLiftType'FREE -> "FREE"
  OrderLiftType'UNKNOWN -> "UNKNOWN"

-- | parse 'OrderLiftType' enum
toOrderLiftType :: Text -> P.Either String OrderLiftType
toOrderLiftType = \case
  "NOT_NEEDED" -> P.Right OrderLiftType'NOT_NEEDED
  "MANUAL" -> P.Right OrderLiftType'MANUAL
  "ELEVATOR" -> P.Right OrderLiftType'ELEVATOR
  "CARGO_ELEVATOR" -> P.Right OrderLiftType'CARGO_ELEVATOR
  "FREE" -> P.Right OrderLiftType'FREE
  "UNKNOWN" -> P.Right OrderLiftType'UNKNOWN
  s -> P.Left $ "toOrderLiftType: enum parse failure: " P.++ P.show s


-- ** OrderPaymentMethodType

-- | Enum of 'Text' .
-- Способ оплаты заказа:  * Значения, если выбрана оплата при оформлении заказа (`\"paymentType\": \"PREPAID\"`):    * `YANDEX` — банковской картой.    * `APPLE_PAY` — Apple Pay.    * `GOOGLE_PAY` — Google Pay.    * `CREDIT` — в кредит.    * `TINKOFF_CREDIT` — в кредит в Тинькофф Банке.    * `TINKOFF_INSTALLMENTS` — рассрочка в Тинькофф Банке.    * `EXTERNAL_CERTIFICATE` — подарочным сертификатом (например, из приложения «Сбербанк Онлайн»).    * `SBP` — через систему быстрых платежей.    * `B2B_ACCOUNT_PREPAYMENT` — заказ оплачивает организация.   * Значения, если выбрана оплата при получении заказа (`\"paymentType\": \"POSTPAID\"`):    * `CARD_ON_DELIVERY` — банковской картой.    * `BOUND_CARD_ON_DELIVERY` — привязанной картой при получении.    * `CASH_ON_DELIVERY` — наличными.    * `B2B_ACCOUNT_POSTPAYMENT` — заказ оплачивает организация после доставки.  * `UNKNOWN` — неизвестный тип.  Значение по умолчанию: `CASH_ON_DELIVERY`. 
data OrderPaymentMethodType
  = OrderPaymentMethodType'CASH_ON_DELIVERY -- ^ @"CASH_ON_DELIVERY"@
  | OrderPaymentMethodType'CARD_ON_DELIVERY -- ^ @"CARD_ON_DELIVERY"@
  | OrderPaymentMethodType'BOUND_CARD_ON_DELIVERY -- ^ @"BOUND_CARD_ON_DELIVERY"@
  | OrderPaymentMethodType'YANDEX -- ^ @"YANDEX"@
  | OrderPaymentMethodType'APPLE_PAY -- ^ @"APPLE_PAY"@
  | OrderPaymentMethodType'EXTERNAL_CERTIFICATE -- ^ @"EXTERNAL_CERTIFICATE"@
  | OrderPaymentMethodType'CREDIT -- ^ @"CREDIT"@
  | OrderPaymentMethodType'GOOGLE_PAY -- ^ @"GOOGLE_PAY"@
  | OrderPaymentMethodType'TINKOFF_CREDIT -- ^ @"TINKOFF_CREDIT"@
  | OrderPaymentMethodType'SBP -- ^ @"SBP"@
  | OrderPaymentMethodType'TINKOFF_INSTALLMENTS -- ^ @"TINKOFF_INSTALLMENTS"@
  | OrderPaymentMethodType'B2B_ACCOUNT_PREPAYMENT -- ^ @"B2B_ACCOUNT_PREPAYMENT"@
  | OrderPaymentMethodType'B2B_ACCOUNT_POSTPAYMENT -- ^ @"B2B_ACCOUNT_POSTPAYMENT"@
  | OrderPaymentMethodType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderPaymentMethodType where toJSON = A.toJSON . fromOrderPaymentMethodType
instance A.FromJSON OrderPaymentMethodType where parseJSON o = P.either P.fail (pure . P.id) . toOrderPaymentMethodType =<< A.parseJSON o
instance WH.ToHttpApiData OrderPaymentMethodType where toQueryParam = WH.toQueryParam . fromOrderPaymentMethodType
instance WH.FromHttpApiData OrderPaymentMethodType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderPaymentMethodType
instance MimeRender MimeMultipartFormData OrderPaymentMethodType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderPaymentMethodType' enum
fromOrderPaymentMethodType :: OrderPaymentMethodType -> Text
fromOrderPaymentMethodType = \case
  OrderPaymentMethodType'CASH_ON_DELIVERY -> "CASH_ON_DELIVERY"
  OrderPaymentMethodType'CARD_ON_DELIVERY -> "CARD_ON_DELIVERY"
  OrderPaymentMethodType'BOUND_CARD_ON_DELIVERY -> "BOUND_CARD_ON_DELIVERY"
  OrderPaymentMethodType'YANDEX -> "YANDEX"
  OrderPaymentMethodType'APPLE_PAY -> "APPLE_PAY"
  OrderPaymentMethodType'EXTERNAL_CERTIFICATE -> "EXTERNAL_CERTIFICATE"
  OrderPaymentMethodType'CREDIT -> "CREDIT"
  OrderPaymentMethodType'GOOGLE_PAY -> "GOOGLE_PAY"
  OrderPaymentMethodType'TINKOFF_CREDIT -> "TINKOFF_CREDIT"
  OrderPaymentMethodType'SBP -> "SBP"
  OrderPaymentMethodType'TINKOFF_INSTALLMENTS -> "TINKOFF_INSTALLMENTS"
  OrderPaymentMethodType'B2B_ACCOUNT_PREPAYMENT -> "B2B_ACCOUNT_PREPAYMENT"
  OrderPaymentMethodType'B2B_ACCOUNT_POSTPAYMENT -> "B2B_ACCOUNT_POSTPAYMENT"
  OrderPaymentMethodType'UNKNOWN -> "UNKNOWN"

-- | parse 'OrderPaymentMethodType' enum
toOrderPaymentMethodType :: Text -> P.Either String OrderPaymentMethodType
toOrderPaymentMethodType = \case
  "CASH_ON_DELIVERY" -> P.Right OrderPaymentMethodType'CASH_ON_DELIVERY
  "CARD_ON_DELIVERY" -> P.Right OrderPaymentMethodType'CARD_ON_DELIVERY
  "BOUND_CARD_ON_DELIVERY" -> P.Right OrderPaymentMethodType'BOUND_CARD_ON_DELIVERY
  "YANDEX" -> P.Right OrderPaymentMethodType'YANDEX
  "APPLE_PAY" -> P.Right OrderPaymentMethodType'APPLE_PAY
  "EXTERNAL_CERTIFICATE" -> P.Right OrderPaymentMethodType'EXTERNAL_CERTIFICATE
  "CREDIT" -> P.Right OrderPaymentMethodType'CREDIT
  "GOOGLE_PAY" -> P.Right OrderPaymentMethodType'GOOGLE_PAY
  "TINKOFF_CREDIT" -> P.Right OrderPaymentMethodType'TINKOFF_CREDIT
  "SBP" -> P.Right OrderPaymentMethodType'SBP
  "TINKOFF_INSTALLMENTS" -> P.Right OrderPaymentMethodType'TINKOFF_INSTALLMENTS
  "B2B_ACCOUNT_PREPAYMENT" -> P.Right OrderPaymentMethodType'B2B_ACCOUNT_PREPAYMENT
  "B2B_ACCOUNT_POSTPAYMENT" -> P.Right OrderPaymentMethodType'B2B_ACCOUNT_POSTPAYMENT
  "UNKNOWN" -> P.Right OrderPaymentMethodType'UNKNOWN
  s -> P.Left $ "toOrderPaymentMethodType: enum parse failure: " P.++ P.show s


-- ** OrderPaymentType

-- | Enum of 'Text' .
-- Тип оплаты заказа:  * `PREPAID` — оплата при оформлении заказа.  * `POSTPAID` — оплата при получении заказа.  * `UNKNOWN` — неизвестный тип.  Если параметр отсутствует, заказ будет оплачен при получении. 
data OrderPaymentType
  = OrderPaymentType'PREPAID -- ^ @"PREPAID"@
  | OrderPaymentType'POSTPAID -- ^ @"POSTPAID"@
  | OrderPaymentType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderPaymentType where toJSON = A.toJSON . fromOrderPaymentType
instance A.FromJSON OrderPaymentType where parseJSON o = P.either P.fail (pure . P.id) . toOrderPaymentType =<< A.parseJSON o
instance WH.ToHttpApiData OrderPaymentType where toQueryParam = WH.toQueryParam . fromOrderPaymentType
instance WH.FromHttpApiData OrderPaymentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderPaymentType
instance MimeRender MimeMultipartFormData OrderPaymentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderPaymentType' enum
fromOrderPaymentType :: OrderPaymentType -> Text
fromOrderPaymentType = \case
  OrderPaymentType'PREPAID -> "PREPAID"
  OrderPaymentType'POSTPAID -> "POSTPAID"
  OrderPaymentType'UNKNOWN -> "UNKNOWN"

-- | parse 'OrderPaymentType' enum
toOrderPaymentType :: Text -> P.Either String OrderPaymentType
toOrderPaymentType = \case
  "PREPAID" -> P.Right OrderPaymentType'PREPAID
  "POSTPAID" -> P.Right OrderPaymentType'POSTPAID
  "UNKNOWN" -> P.Right OrderPaymentType'UNKNOWN
  s -> P.Left $ "toOrderPaymentType: enum parse failure: " P.++ P.show s


-- ** OrderPromoType

-- | Enum of 'Text' .
-- Тип скидки:  * `DIRECT_DISCOUNT` — прямая скидка, которую устанавливает продавец или Маркет.  * `BLUE_SET` — комплекты.  * `BLUE_FLASH` — флеш-акция.  * `MARKET_COUPON` — скидка по промокоду Маркета.  * `MARKET_PROMOCODE` — скидка по промокоду магазина.  * `MARKET_BLUE` — скидка на Маркете.  * `YANDEX_PLUS` — бесплатная доставка с подпиской Яндекс Плюс.  * `YANDEX_EMPLOYEE` — бесплатная доставка по определенным адресам.  * `LIMITED_FREE_DELIVERY_PROMO` — бесплатная доставка по ограниченному предложению.  * `FREE_DELIVERY_THRESHOLD` — бесплатная доставка при достижении определенной суммы заказа.  * `MULTICART_DISCOUNT` — скидка за то, что оформлена мультикорзина.  * `FREE_DELIVERY_FOR_LDI` — бесплатная доставка за то, что один из товаров крупногабаритный.  * `FREE_DELIVERY_FOR_LSC` — бесплатная доставка за то, что одна из корзин в мультикорзине крупногабаритная.  * `FREE_PICKUP` — бесплатная доставка в пункт выдачи заказов.  * `CHEAPEST_AS_GIFT` — самый дешевый товар в подарок.  * `CASHBACK` — кешбэк.  * `SUPPLIER_MULTICART_DISCOUNT` — скидка за доставку.  * `SPREAD_DISCOUNT_COUNT` — скидка за количество одинаковых товаров.  * `SPREAD_DISCOUNT_RECEIPT` — скидка от суммы чека.  * `ANNOUNCEMENT_PROMO` — информационная акция, скидка не применяется к товарам.  * `DISCOUNT_BY_PAYMENT_TYPE` — прямая скидка при оплате картой Плюса.  * `PERCENT_DISCOUNT` — прямая скидка в процентах.  * `DCO_EXTRA_DISCOUNT` — дополнительная скидка, необходимая для расчета субсидии от Маркета.  * `EMPTY_PROMO` — скрытые промокоды.  * `BLOCKING_PROMO` — блокирующее промо.  * `UNKNOWN` — неизвестный тип.  Устаревшие типы:  * `GENERIC_BUNDLE`.  * `MARKET_DEAL`.  * `MARKET_PRIME`.  * `MARKET_COIN`.  * `BERU_PLUS`.  * `PRICE_DROP_AS_YOU_SHOP`.  * `SECRET_SALE`. 
data OrderPromoType
  = OrderPromoType'DIRECT_DISCOUNT -- ^ @"DIRECT_DISCOUNT"@
  | OrderPromoType'BLUE_SET -- ^ @"BLUE_SET"@
  | OrderPromoType'BLUE_FLASH -- ^ @"BLUE_FLASH"@
  | OrderPromoType'GENERIC_BUNDLE -- ^ @"GENERIC_BUNDLE"@
  | OrderPromoType'MARKET_COUPON -- ^ @"MARKET_COUPON"@
  | OrderPromoType'MARKET_PROMOCODE -- ^ @"MARKET_PROMOCODE"@
  | OrderPromoType'MARKET_DEAL -- ^ @"MARKET_DEAL"@
  | OrderPromoType'MARKET_BLUE -- ^ @"MARKET_BLUE"@
  | OrderPromoType'MARKET_PRIME -- ^ @"MARKET_PRIME"@
  | OrderPromoType'YANDEX_PLUS -- ^ @"YANDEX_PLUS"@
  | OrderPromoType'BERU_PLUS -- ^ @"BERU_PLUS"@
  | OrderPromoType'MARKET_COIN -- ^ @"MARKET_COIN"@
  | OrderPromoType'YANDEX_EMPLOYEE -- ^ @"YANDEX_EMPLOYEE"@
  | OrderPromoType'LIMITED_FREE_DELIVERY_PROMO -- ^ @"LIMITED_FREE_DELIVERY_PROMO"@
  | OrderPromoType'FREE_DELIVERY_THRESHOLD -- ^ @"FREE_DELIVERY_THRESHOLD"@
  | OrderPromoType'MULTICART_DISCOUNT -- ^ @"MULTICART_DISCOUNT"@
  | OrderPromoType'PRICE_DROP_AS_YOU_SHOP -- ^ @"PRICE_DROP_AS_YOU_SHOP"@
  | OrderPromoType'FREE_DELIVERY_FOR_LDI -- ^ @"FREE_DELIVERY_FOR_LDI"@
  | OrderPromoType'FREE_DELIVERY_FOR_LSC -- ^ @"FREE_DELIVERY_FOR_LSC"@
  | OrderPromoType'SECRET_SALE -- ^ @"SECRET_SALE"@
  | OrderPromoType'FREE_PICKUP -- ^ @"FREE_PICKUP"@
  | OrderPromoType'CHEAPEST_AS_GIFT -- ^ @"CHEAPEST_AS_GIFT"@
  | OrderPromoType'CASHBACK -- ^ @"CASHBACK"@
  | OrderPromoType'SUPPLIER_MULTICART_DISCOUNT -- ^ @"SUPPLIER_MULTICART_DISCOUNT"@
  | OrderPromoType'SPREAD_DISCOUNT_COUNT -- ^ @"SPREAD_DISCOUNT_COUNT"@
  | OrderPromoType'SPREAD_DISCOUNT_RECEIPT -- ^ @"SPREAD_DISCOUNT_RECEIPT"@
  | OrderPromoType'ANNOUNCEMENT_PROMO -- ^ @"ANNOUNCEMENT_PROMO"@
  | OrderPromoType'DISCOUNT_BY_PAYMENT_TYPE -- ^ @"DISCOUNT_BY_PAYMENT_TYPE"@
  | OrderPromoType'PERCENT_DISCOUNT -- ^ @"PERCENT_DISCOUNT"@
  | OrderPromoType'DCO_EXTRA_DISCOUNT -- ^ @"DCO_EXTRA_DISCOUNT"@
  | OrderPromoType'EMPTY_PROMO -- ^ @"EMPTY_PROMO"@
  | OrderPromoType'BLOCKING_PROMO -- ^ @"BLOCKING_PROMO"@
  | OrderPromoType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderPromoType where toJSON = A.toJSON . fromOrderPromoType
instance A.FromJSON OrderPromoType where parseJSON o = P.either P.fail (pure . P.id) . toOrderPromoType =<< A.parseJSON o
instance WH.ToHttpApiData OrderPromoType where toQueryParam = WH.toQueryParam . fromOrderPromoType
instance WH.FromHttpApiData OrderPromoType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderPromoType
instance MimeRender MimeMultipartFormData OrderPromoType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderPromoType' enum
fromOrderPromoType :: OrderPromoType -> Text
fromOrderPromoType = \case
  OrderPromoType'DIRECT_DISCOUNT -> "DIRECT_DISCOUNT"
  OrderPromoType'BLUE_SET -> "BLUE_SET"
  OrderPromoType'BLUE_FLASH -> "BLUE_FLASH"
  OrderPromoType'GENERIC_BUNDLE -> "GENERIC_BUNDLE"
  OrderPromoType'MARKET_COUPON -> "MARKET_COUPON"
  OrderPromoType'MARKET_PROMOCODE -> "MARKET_PROMOCODE"
  OrderPromoType'MARKET_DEAL -> "MARKET_DEAL"
  OrderPromoType'MARKET_BLUE -> "MARKET_BLUE"
  OrderPromoType'MARKET_PRIME -> "MARKET_PRIME"
  OrderPromoType'YANDEX_PLUS -> "YANDEX_PLUS"
  OrderPromoType'BERU_PLUS -> "BERU_PLUS"
  OrderPromoType'MARKET_COIN -> "MARKET_COIN"
  OrderPromoType'YANDEX_EMPLOYEE -> "YANDEX_EMPLOYEE"
  OrderPromoType'LIMITED_FREE_DELIVERY_PROMO -> "LIMITED_FREE_DELIVERY_PROMO"
  OrderPromoType'FREE_DELIVERY_THRESHOLD -> "FREE_DELIVERY_THRESHOLD"
  OrderPromoType'MULTICART_DISCOUNT -> "MULTICART_DISCOUNT"
  OrderPromoType'PRICE_DROP_AS_YOU_SHOP -> "PRICE_DROP_AS_YOU_SHOP"
  OrderPromoType'FREE_DELIVERY_FOR_LDI -> "FREE_DELIVERY_FOR_LDI"
  OrderPromoType'FREE_DELIVERY_FOR_LSC -> "FREE_DELIVERY_FOR_LSC"
  OrderPromoType'SECRET_SALE -> "SECRET_SALE"
  OrderPromoType'FREE_PICKUP -> "FREE_PICKUP"
  OrderPromoType'CHEAPEST_AS_GIFT -> "CHEAPEST_AS_GIFT"
  OrderPromoType'CASHBACK -> "CASHBACK"
  OrderPromoType'SUPPLIER_MULTICART_DISCOUNT -> "SUPPLIER_MULTICART_DISCOUNT"
  OrderPromoType'SPREAD_DISCOUNT_COUNT -> "SPREAD_DISCOUNT_COUNT"
  OrderPromoType'SPREAD_DISCOUNT_RECEIPT -> "SPREAD_DISCOUNT_RECEIPT"
  OrderPromoType'ANNOUNCEMENT_PROMO -> "ANNOUNCEMENT_PROMO"
  OrderPromoType'DISCOUNT_BY_PAYMENT_TYPE -> "DISCOUNT_BY_PAYMENT_TYPE"
  OrderPromoType'PERCENT_DISCOUNT -> "PERCENT_DISCOUNT"
  OrderPromoType'DCO_EXTRA_DISCOUNT -> "DCO_EXTRA_DISCOUNT"
  OrderPromoType'EMPTY_PROMO -> "EMPTY_PROMO"
  OrderPromoType'BLOCKING_PROMO -> "BLOCKING_PROMO"
  OrderPromoType'UNKNOWN -> "UNKNOWN"

-- | parse 'OrderPromoType' enum
toOrderPromoType :: Text -> P.Either String OrderPromoType
toOrderPromoType = \case
  "DIRECT_DISCOUNT" -> P.Right OrderPromoType'DIRECT_DISCOUNT
  "BLUE_SET" -> P.Right OrderPromoType'BLUE_SET
  "BLUE_FLASH" -> P.Right OrderPromoType'BLUE_FLASH
  "GENERIC_BUNDLE" -> P.Right OrderPromoType'GENERIC_BUNDLE
  "MARKET_COUPON" -> P.Right OrderPromoType'MARKET_COUPON
  "MARKET_PROMOCODE" -> P.Right OrderPromoType'MARKET_PROMOCODE
  "MARKET_DEAL" -> P.Right OrderPromoType'MARKET_DEAL
  "MARKET_BLUE" -> P.Right OrderPromoType'MARKET_BLUE
  "MARKET_PRIME" -> P.Right OrderPromoType'MARKET_PRIME
  "YANDEX_PLUS" -> P.Right OrderPromoType'YANDEX_PLUS
  "BERU_PLUS" -> P.Right OrderPromoType'BERU_PLUS
  "MARKET_COIN" -> P.Right OrderPromoType'MARKET_COIN
  "YANDEX_EMPLOYEE" -> P.Right OrderPromoType'YANDEX_EMPLOYEE
  "LIMITED_FREE_DELIVERY_PROMO" -> P.Right OrderPromoType'LIMITED_FREE_DELIVERY_PROMO
  "FREE_DELIVERY_THRESHOLD" -> P.Right OrderPromoType'FREE_DELIVERY_THRESHOLD
  "MULTICART_DISCOUNT" -> P.Right OrderPromoType'MULTICART_DISCOUNT
  "PRICE_DROP_AS_YOU_SHOP" -> P.Right OrderPromoType'PRICE_DROP_AS_YOU_SHOP
  "FREE_DELIVERY_FOR_LDI" -> P.Right OrderPromoType'FREE_DELIVERY_FOR_LDI
  "FREE_DELIVERY_FOR_LSC" -> P.Right OrderPromoType'FREE_DELIVERY_FOR_LSC
  "SECRET_SALE" -> P.Right OrderPromoType'SECRET_SALE
  "FREE_PICKUP" -> P.Right OrderPromoType'FREE_PICKUP
  "CHEAPEST_AS_GIFT" -> P.Right OrderPromoType'CHEAPEST_AS_GIFT
  "CASHBACK" -> P.Right OrderPromoType'CASHBACK
  "SUPPLIER_MULTICART_DISCOUNT" -> P.Right OrderPromoType'SUPPLIER_MULTICART_DISCOUNT
  "SPREAD_DISCOUNT_COUNT" -> P.Right OrderPromoType'SPREAD_DISCOUNT_COUNT
  "SPREAD_DISCOUNT_RECEIPT" -> P.Right OrderPromoType'SPREAD_DISCOUNT_RECEIPT
  "ANNOUNCEMENT_PROMO" -> P.Right OrderPromoType'ANNOUNCEMENT_PROMO
  "DISCOUNT_BY_PAYMENT_TYPE" -> P.Right OrderPromoType'DISCOUNT_BY_PAYMENT_TYPE
  "PERCENT_DISCOUNT" -> P.Right OrderPromoType'PERCENT_DISCOUNT
  "DCO_EXTRA_DISCOUNT" -> P.Right OrderPromoType'DCO_EXTRA_DISCOUNT
  "EMPTY_PROMO" -> P.Right OrderPromoType'EMPTY_PROMO
  "BLOCKING_PROMO" -> P.Right OrderPromoType'BLOCKING_PROMO
  "UNKNOWN" -> P.Right OrderPromoType'UNKNOWN
  s -> P.Left $ "toOrderPromoType: enum parse failure: " P.++ P.show s


-- ** OrderStatsStatusType

-- | Enum of 'Text' .
-- Текущий статус заказа:  * `CANCELLED_BEFORE_PROCESSING` — заказ отменен до начала его обработки.  * `CANCELLED_IN_DELIVERY` — заказ отменен во время его доставки.  * `CANCELLED_IN_PROCESSING` — заказ отменен во время его обработки.  * `DELIVERY` — заказ передан службе доставки.  * `DELIVERED` — заказ доставлен.  * `PARTIALLY_DELIVERED` — заказ частично доставлен.  * `PARTIALLY_RETURNED` — заказ частично возвращен покупателем.  * `PENDING` — заказ ожидает подтверждения.  * `PICKUP` — заказ доставлен в пункт выдачи.  * `PROCESSING` — заказ в обработке.  * `RESERVED` — товар зарезервирован на складе.  * `RETURNED` — заказ полностью возвращен покупателем.  * `UNKNOWN` — неизвестный статус заказа.  * `UNPAID` — заказ от юридического лица ожидает оплаты.  * `LOST` — заказ утерян. 
data OrderStatsStatusType
  = OrderStatsStatusType'CANCELLED_BEFORE_PROCESSING -- ^ @"CANCELLED_BEFORE_PROCESSING"@
  | OrderStatsStatusType'CANCELLED_IN_DELIVERY -- ^ @"CANCELLED_IN_DELIVERY"@
  | OrderStatsStatusType'CANCELLED_IN_PROCESSING -- ^ @"CANCELLED_IN_PROCESSING"@
  | OrderStatsStatusType'DELIVERY -- ^ @"DELIVERY"@
  | OrderStatsStatusType'DELIVERED -- ^ @"DELIVERED"@
  | OrderStatsStatusType'PARTIALLY_DELIVERED -- ^ @"PARTIALLY_DELIVERED"@
  | OrderStatsStatusType'PARTIALLY_RETURNED -- ^ @"PARTIALLY_RETURNED"@
  | OrderStatsStatusType'PENDING -- ^ @"PENDING"@
  | OrderStatsStatusType'PICKUP -- ^ @"PICKUP"@
  | OrderStatsStatusType'PROCESSING -- ^ @"PROCESSING"@
  | OrderStatsStatusType'RESERVED -- ^ @"RESERVED"@
  | OrderStatsStatusType'RETURNED -- ^ @"RETURNED"@
  | OrderStatsStatusType'UNKNOWN -- ^ @"UNKNOWN"@
  | OrderStatsStatusType'UNPAID -- ^ @"UNPAID"@
  | OrderStatsStatusType'LOST -- ^ @"LOST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderStatsStatusType where toJSON = A.toJSON . fromOrderStatsStatusType
instance A.FromJSON OrderStatsStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOrderStatsStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OrderStatsStatusType where toQueryParam = WH.toQueryParam . fromOrderStatsStatusType
instance WH.FromHttpApiData OrderStatsStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderStatsStatusType
instance MimeRender MimeMultipartFormData OrderStatsStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderStatsStatusType' enum
fromOrderStatsStatusType :: OrderStatsStatusType -> Text
fromOrderStatsStatusType = \case
  OrderStatsStatusType'CANCELLED_BEFORE_PROCESSING -> "CANCELLED_BEFORE_PROCESSING"
  OrderStatsStatusType'CANCELLED_IN_DELIVERY -> "CANCELLED_IN_DELIVERY"
  OrderStatsStatusType'CANCELLED_IN_PROCESSING -> "CANCELLED_IN_PROCESSING"
  OrderStatsStatusType'DELIVERY -> "DELIVERY"
  OrderStatsStatusType'DELIVERED -> "DELIVERED"
  OrderStatsStatusType'PARTIALLY_DELIVERED -> "PARTIALLY_DELIVERED"
  OrderStatsStatusType'PARTIALLY_RETURNED -> "PARTIALLY_RETURNED"
  OrderStatsStatusType'PENDING -> "PENDING"
  OrderStatsStatusType'PICKUP -> "PICKUP"
  OrderStatsStatusType'PROCESSING -> "PROCESSING"
  OrderStatsStatusType'RESERVED -> "RESERVED"
  OrderStatsStatusType'RETURNED -> "RETURNED"
  OrderStatsStatusType'UNKNOWN -> "UNKNOWN"
  OrderStatsStatusType'UNPAID -> "UNPAID"
  OrderStatsStatusType'LOST -> "LOST"

-- | parse 'OrderStatsStatusType' enum
toOrderStatsStatusType :: Text -> P.Either String OrderStatsStatusType
toOrderStatsStatusType = \case
  "CANCELLED_BEFORE_PROCESSING" -> P.Right OrderStatsStatusType'CANCELLED_BEFORE_PROCESSING
  "CANCELLED_IN_DELIVERY" -> P.Right OrderStatsStatusType'CANCELLED_IN_DELIVERY
  "CANCELLED_IN_PROCESSING" -> P.Right OrderStatsStatusType'CANCELLED_IN_PROCESSING
  "DELIVERY" -> P.Right OrderStatsStatusType'DELIVERY
  "DELIVERED" -> P.Right OrderStatsStatusType'DELIVERED
  "PARTIALLY_DELIVERED" -> P.Right OrderStatsStatusType'PARTIALLY_DELIVERED
  "PARTIALLY_RETURNED" -> P.Right OrderStatsStatusType'PARTIALLY_RETURNED
  "PENDING" -> P.Right OrderStatsStatusType'PENDING
  "PICKUP" -> P.Right OrderStatsStatusType'PICKUP
  "PROCESSING" -> P.Right OrderStatsStatusType'PROCESSING
  "RESERVED" -> P.Right OrderStatsStatusType'RESERVED
  "RETURNED" -> P.Right OrderStatsStatusType'RETURNED
  "UNKNOWN" -> P.Right OrderStatsStatusType'UNKNOWN
  "UNPAID" -> P.Right OrderStatsStatusType'UNPAID
  "LOST" -> P.Right OrderStatsStatusType'LOST
  s -> P.Left $ "toOrderStatsStatusType: enum parse failure: " P.++ P.show s


-- ** OrderStatusType

-- | Enum of 'Text' .
-- Статус заказа:  * `CANCELLED` — отменен.  * `DELIVERED` — получен покупателем.  * `DELIVERY` — передан в службу доставки.  * `PICKUP` — доставлен в пункт самовывоза.  * `PROCESSING` — находится в обработке.  * `PENDING` — ожидает обработки со стороны продавца.  * `UNPAID` — оформлен, но еще не оплачен (если выбрана оплата при оформлении).  * `PLACING` — оформляется, подготовка к резервированию.  * `RESERVED` — зарезервирован, но недооформлен.  * `PARTIALLY_RETURNED` — возвращен частично.  * `RETURNED` — возвращен полностью.  * `UNKNOWN` — неизвестный статус.  Также могут возвращаться другие значения. Обрабатывать их не требуется. 
data OrderStatusType
  = OrderStatusType'PLACING -- ^ @"PLACING"@
  | OrderStatusType'RESERVED -- ^ @"RESERVED"@
  | OrderStatusType'UNPAID -- ^ @"UNPAID"@
  | OrderStatusType'PROCESSING -- ^ @"PROCESSING"@
  | OrderStatusType'DELIVERY -- ^ @"DELIVERY"@
  | OrderStatusType'PICKUP -- ^ @"PICKUP"@
  | OrderStatusType'DELIVERED -- ^ @"DELIVERED"@
  | OrderStatusType'CANCELLED -- ^ @"CANCELLED"@
  | OrderStatusType'PENDING -- ^ @"PENDING"@
  | OrderStatusType'PARTIALLY_RETURNED -- ^ @"PARTIALLY_RETURNED"@
  | OrderStatusType'RETURNED -- ^ @"RETURNED"@
  | OrderStatusType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderStatusType where toJSON = A.toJSON . fromOrderStatusType
instance A.FromJSON OrderStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOrderStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OrderStatusType where toQueryParam = WH.toQueryParam . fromOrderStatusType
instance WH.FromHttpApiData OrderStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderStatusType
instance MimeRender MimeMultipartFormData OrderStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderStatusType' enum
fromOrderStatusType :: OrderStatusType -> Text
fromOrderStatusType = \case
  OrderStatusType'PLACING -> "PLACING"
  OrderStatusType'RESERVED -> "RESERVED"
  OrderStatusType'UNPAID -> "UNPAID"
  OrderStatusType'PROCESSING -> "PROCESSING"
  OrderStatusType'DELIVERY -> "DELIVERY"
  OrderStatusType'PICKUP -> "PICKUP"
  OrderStatusType'DELIVERED -> "DELIVERED"
  OrderStatusType'CANCELLED -> "CANCELLED"
  OrderStatusType'PENDING -> "PENDING"
  OrderStatusType'PARTIALLY_RETURNED -> "PARTIALLY_RETURNED"
  OrderStatusType'RETURNED -> "RETURNED"
  OrderStatusType'UNKNOWN -> "UNKNOWN"

-- | parse 'OrderStatusType' enum
toOrderStatusType :: Text -> P.Either String OrderStatusType
toOrderStatusType = \case
  "PLACING" -> P.Right OrderStatusType'PLACING
  "RESERVED" -> P.Right OrderStatusType'RESERVED
  "UNPAID" -> P.Right OrderStatusType'UNPAID
  "PROCESSING" -> P.Right OrderStatusType'PROCESSING
  "DELIVERY" -> P.Right OrderStatusType'DELIVERY
  "PICKUP" -> P.Right OrderStatusType'PICKUP
  "DELIVERED" -> P.Right OrderStatusType'DELIVERED
  "CANCELLED" -> P.Right OrderStatusType'CANCELLED
  "PENDING" -> P.Right OrderStatusType'PENDING
  "PARTIALLY_RETURNED" -> P.Right OrderStatusType'PARTIALLY_RETURNED
  "RETURNED" -> P.Right OrderStatusType'RETURNED
  "UNKNOWN" -> P.Right OrderStatusType'UNKNOWN
  s -> P.Left $ "toOrderStatusType: enum parse failure: " P.++ P.show s


-- ** OrderSubsidyType

-- | Enum of 'Text' .
-- Тип субсидии:  * `YANDEX_CASHBACK` — скидка по подписке Яндекс Плюс.  * `SUBSIDY` — скидка Маркета (по акциям, промокодам, купонам и т. д.)  * `DELIVERY` — скидка за доставку (DBS). 
data OrderSubsidyType
  = OrderSubsidyType'YANDEX_CASHBACK -- ^ @"YANDEX_CASHBACK"@
  | OrderSubsidyType'SUBSIDY -- ^ @"SUBSIDY"@
  | OrderSubsidyType'DELIVERY -- ^ @"DELIVERY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderSubsidyType where toJSON = A.toJSON . fromOrderSubsidyType
instance A.FromJSON OrderSubsidyType where parseJSON o = P.either P.fail (pure . P.id) . toOrderSubsidyType =<< A.parseJSON o
instance WH.ToHttpApiData OrderSubsidyType where toQueryParam = WH.toQueryParam . fromOrderSubsidyType
instance WH.FromHttpApiData OrderSubsidyType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderSubsidyType
instance MimeRender MimeMultipartFormData OrderSubsidyType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderSubsidyType' enum
fromOrderSubsidyType :: OrderSubsidyType -> Text
fromOrderSubsidyType = \case
  OrderSubsidyType'YANDEX_CASHBACK -> "YANDEX_CASHBACK"
  OrderSubsidyType'SUBSIDY -> "SUBSIDY"
  OrderSubsidyType'DELIVERY -> "DELIVERY"

-- | parse 'OrderSubsidyType' enum
toOrderSubsidyType :: Text -> P.Either String OrderSubsidyType
toOrderSubsidyType = \case
  "YANDEX_CASHBACK" -> P.Right OrderSubsidyType'YANDEX_CASHBACK
  "SUBSIDY" -> P.Right OrderSubsidyType'SUBSIDY
  "DELIVERY" -> P.Right OrderSubsidyType'DELIVERY
  s -> P.Left $ "toOrderSubsidyType: enum parse failure: " P.++ P.show s


-- ** OrderSubstatusType

-- | Enum of 'Text' .
-- Этап обработки заказа (если он имеет статус `PROCESSING`) или причина отмены заказа (если он имеет статус `CANCELLED`).  * Значения для заказа в статусе `PROCESSING`:      * `STARTED` — заказ подтвержден, его можно начать обрабатывать.      * `READY_TO_SHIP` — заказ собран и готов к отправке.  * Значения для заказа в статусе `CANCELLED`:      * `PROCESSING_EXPIRED` — значение более не используется.      * `REPLACING_ORDER` — покупатель решил заменить товар другим по собственной инициативе.      * `RESERVATION_EXPIRED` — покупатель не завершил оформление зарезервированного заказа в течение 10 минут.      * `SHOP_FAILED` — магазин не может выполнить заказ.      * `USER_CHANGED_MIND` — покупатель отменил заказ по личным причинам.      * `USER_NOT_PAID` — покупатель не оплатил заказ (для типа оплаты `PREPAID`) в течение 30 минут.      * `USER_REFUSED_DELIVERY` — покупателя не устроили условия доставки.      * `USER_REFUSED_PRODUCT` — покупателю не подошел товар.      * `USER_REFUSED_QUALITY` — покупателя не устроило качество товара.      * `USER_UNREACHABLE` — не удалось связаться с покупателем. Для отмены с этой причиной необходимо выполнить условия:        * не менее 3 звонков с 8 до 21 в часовом поясе покупателя;       * перерыв между первым и третьим звонком не менее 90 минут;       * соединение не короче 5 секунд.        Если хотя бы одно из этих условий не выполнено (кроме случая, когда номер недоступен), отменить заказ не получится. Вернется ответ с кодом ошибки 400.  * `TECHNICAL_ERROR` — техническая ошибка на стороне Маркета. Обратитесь в поддержку.  Также могут возвращаться другие значения. Обрабатывать их не требуется. 
data OrderSubstatusType
  = OrderSubstatusType'RESERVATION_EXPIRED -- ^ @"RESERVATION_EXPIRED"@
  | OrderSubstatusType'USER_NOT_PAID -- ^ @"USER_NOT_PAID"@
  | OrderSubstatusType'USER_UNREACHABLE -- ^ @"USER_UNREACHABLE"@
  | OrderSubstatusType'USER_CHANGED_MIND -- ^ @"USER_CHANGED_MIND"@
  | OrderSubstatusType'USER_REFUSED_DELIVERY -- ^ @"USER_REFUSED_DELIVERY"@
  | OrderSubstatusType'USER_REFUSED_PRODUCT -- ^ @"USER_REFUSED_PRODUCT"@
  | OrderSubstatusType'SHOP_FAILED -- ^ @"SHOP_FAILED"@
  | OrderSubstatusType'USER_REFUSED_QUALITY -- ^ @"USER_REFUSED_QUALITY"@
  | OrderSubstatusType'REPLACING_ORDER -- ^ @"REPLACING_ORDER"@
  | OrderSubstatusType'PROCESSING_EXPIRED -- ^ @"PROCESSING_EXPIRED"@
  | OrderSubstatusType'PENDING_EXPIRED -- ^ @"PENDING_EXPIRED"@
  | OrderSubstatusType'SHOP_PENDING_CANCELLED -- ^ @"SHOP_PENDING_CANCELLED"@
  | OrderSubstatusType'PENDING_CANCELLED -- ^ @"PENDING_CANCELLED"@
  | OrderSubstatusType'USER_FRAUD -- ^ @"USER_FRAUD"@
  | OrderSubstatusType'RESERVATION_FAILED -- ^ @"RESERVATION_FAILED"@
  | OrderSubstatusType'USER_PLACED_OTHER_ORDER -- ^ @"USER_PLACED_OTHER_ORDER"@
  | OrderSubstatusType'USER_BOUGHT_CHEAPER -- ^ @"USER_BOUGHT_CHEAPER"@
  | OrderSubstatusType'MISSING_ITEM -- ^ @"MISSING_ITEM"@
  | OrderSubstatusType'BROKEN_ITEM -- ^ @"BROKEN_ITEM"@
  | OrderSubstatusType'WRONG_ITEM -- ^ @"WRONG_ITEM"@
  | OrderSubstatusType'PICKUP_EXPIRED -- ^ @"PICKUP_EXPIRED"@
  | OrderSubstatusType'DELIVERY_PROBLEMS -- ^ @"DELIVERY_PROBLEMS"@
  | OrderSubstatusType'LATE_CONTACT -- ^ @"LATE_CONTACT"@
  | OrderSubstatusType'CUSTOM -- ^ @"CUSTOM"@
  | OrderSubstatusType'DELIVERY_SERVICE_FAILED -- ^ @"DELIVERY_SERVICE_FAILED"@
  | OrderSubstatusType'WAREHOUSE_FAILED_TO_SHIP -- ^ @"WAREHOUSE_FAILED_TO_SHIP"@
  | OrderSubstatusType'DELIVERY_SERIVCE_UNDELIVERED -- ^ @"DELIVERY_SERIVCE_UNDELIVERED"@
  | OrderSubstatusType'DELIVERY_SERVICE_UNDELIVERED -- ^ @"DELIVERY_SERVICE_UNDELIVERED"@
  | OrderSubstatusType'PREORDER -- ^ @"PREORDER"@
  | OrderSubstatusType'AWAIT_CONFIRMATION -- ^ @"AWAIT_CONFIRMATION"@
  | OrderSubstatusType'STARTED -- ^ @"STARTED"@
  | OrderSubstatusType'PACKAGING -- ^ @"PACKAGING"@
  | OrderSubstatusType'READY_TO_SHIP -- ^ @"READY_TO_SHIP"@
  | OrderSubstatusType'SHIPPED -- ^ @"SHIPPED"@
  | OrderSubstatusType'ASYNC_PROCESSING -- ^ @"ASYNC_PROCESSING"@
  | OrderSubstatusType'USER_REFUSED_TO_PROVIDE_PERSONAL_DATA -- ^ @"USER_REFUSED_TO_PROVIDE_PERSONAL_DATA"@
  | OrderSubstatusType'WAITING_USER_INPUT -- ^ @"WAITING_USER_INPUT"@
  | OrderSubstatusType'WAITING_BANK_DECISION -- ^ @"WAITING_BANK_DECISION"@
  | OrderSubstatusType'BANK_REJECT_CREDIT_OFFER -- ^ @"BANK_REJECT_CREDIT_OFFER"@
  | OrderSubstatusType'CUSTOMER_REJECT_CREDIT_OFFER -- ^ @"CUSTOMER_REJECT_CREDIT_OFFER"@
  | OrderSubstatusType'CREDIT_OFFER_FAILED -- ^ @"CREDIT_OFFER_FAILED"@
  | OrderSubstatusType'AWAIT_DELIVERY_DATES_CONFIRMATION -- ^ @"AWAIT_DELIVERY_DATES_CONFIRMATION"@
  | OrderSubstatusType'SERVICE_FAULT -- ^ @"SERVICE_FAULT"@
  | OrderSubstatusType'DELIVERY_SERVICE_RECEIVED -- ^ @"DELIVERY_SERVICE_RECEIVED"@
  | OrderSubstatusType'USER_RECEIVED -- ^ @"USER_RECEIVED"@
  | OrderSubstatusType'WAITING_FOR_STOCKS -- ^ @"WAITING_FOR_STOCKS"@
  | OrderSubstatusType'AS_PART_OF_MULTI_ORDER -- ^ @"AS_PART_OF_MULTI_ORDER"@
  | OrderSubstatusType'READY_FOR_LAST_MILE -- ^ @"READY_FOR_LAST_MILE"@
  | OrderSubstatusType'LAST_MILE_STARTED -- ^ @"LAST_MILE_STARTED"@
  | OrderSubstatusType'ANTIFRAUD -- ^ @"ANTIFRAUD"@
  | OrderSubstatusType'DELIVERY_USER_NOT_RECEIVED -- ^ @"DELIVERY_USER_NOT_RECEIVED"@
  | OrderSubstatusType'DELIVERY_SERVICE_DELIVERED -- ^ @"DELIVERY_SERVICE_DELIVERED"@
  | OrderSubstatusType'DELIVERED_USER_NOT_RECEIVED -- ^ @"DELIVERED_USER_NOT_RECEIVED"@
  | OrderSubstatusType'USER_WANTED_ANOTHER_PAYMENT_METHOD -- ^ @"USER_WANTED_ANOTHER_PAYMENT_METHOD"@
  | OrderSubstatusType'USER_RECEIVED_TECHNICAL_ERROR -- ^ @"USER_RECEIVED_TECHNICAL_ERROR"@
  | OrderSubstatusType'USER_FORGOT_TO_USE_BONUS -- ^ @"USER_FORGOT_TO_USE_BONUS"@
  | OrderSubstatusType'RECEIVED_ON_DISTRIBUTION_CENTER -- ^ @"RECEIVED_ON_DISTRIBUTION_CENTER"@
  | OrderSubstatusType'DELIVERY_SERVICE_NOT_RECEIVED -- ^ @"DELIVERY_SERVICE_NOT_RECEIVED"@
  | OrderSubstatusType'DELIVERY_SERVICE_LOST -- ^ @"DELIVERY_SERVICE_LOST"@
  | OrderSubstatusType'SHIPPED_TO_WRONG_DELIVERY_SERVICE -- ^ @"SHIPPED_TO_WRONG_DELIVERY_SERVICE"@
  | OrderSubstatusType'DELIVERED_USER_RECEIVED -- ^ @"DELIVERED_USER_RECEIVED"@
  | OrderSubstatusType'WAITING_TINKOFF_DECISION -- ^ @"WAITING_TINKOFF_DECISION"@
  | OrderSubstatusType'COURIER_SEARCH -- ^ @"COURIER_SEARCH"@
  | OrderSubstatusType'COURIER_FOUND -- ^ @"COURIER_FOUND"@
  | OrderSubstatusType'COURIER_IN_TRANSIT_TO_SENDER -- ^ @"COURIER_IN_TRANSIT_TO_SENDER"@
  | OrderSubstatusType'COURIER_ARRIVED_TO_SENDER -- ^ @"COURIER_ARRIVED_TO_SENDER"@
  | OrderSubstatusType'COURIER_RECEIVED -- ^ @"COURIER_RECEIVED"@
  | OrderSubstatusType'COURIER_NOT_FOUND -- ^ @"COURIER_NOT_FOUND"@
  | OrderSubstatusType'COURIER_NOT_DELIVER_ORDER -- ^ @"COURIER_NOT_DELIVER_ORDER"@
  | OrderSubstatusType'COURIER_RETURNS_ORDER -- ^ @"COURIER_RETURNS_ORDER"@
  | OrderSubstatusType'COURIER_RETURNED_ORDER -- ^ @"COURIER_RETURNED_ORDER"@
  | OrderSubstatusType'WAITING_USER_DELIVERY_INPUT -- ^ @"WAITING_USER_DELIVERY_INPUT"@
  | OrderSubstatusType'PICKUP_SERVICE_RECEIVED -- ^ @"PICKUP_SERVICE_RECEIVED"@
  | OrderSubstatusType'PICKUP_USER_RECEIVED -- ^ @"PICKUP_USER_RECEIVED"@
  | OrderSubstatusType'CANCELLED_COURIER_NOT_FOUND -- ^ @"CANCELLED_COURIER_NOT_FOUND"@
  | OrderSubstatusType'COURIER_NOT_COME_FOR_ORDER -- ^ @"COURIER_NOT_COME_FOR_ORDER"@
  | OrderSubstatusType'DELIVERY_NOT_MANAGED_REGION -- ^ @"DELIVERY_NOT_MANAGED_REGION"@
  | OrderSubstatusType'INCOMPLETE_CONTACT_INFORMATION -- ^ @"INCOMPLETE_CONTACT_INFORMATION"@
  | OrderSubstatusType'INCOMPLETE_MULTI_ORDER -- ^ @"INCOMPLETE_MULTI_ORDER"@
  | OrderSubstatusType'INAPPROPRIATE_WEIGHT_SIZE -- ^ @"INAPPROPRIATE_WEIGHT_SIZE"@
  | OrderSubstatusType'TECHNICAL_ERROR -- ^ @"TECHNICAL_ERROR"@
  | OrderSubstatusType'SORTING_CENTER_LOST -- ^ @"SORTING_CENTER_LOST"@
  | OrderSubstatusType'COURIER_SEARCH_NOT_STARTED -- ^ @"COURIER_SEARCH_NOT_STARTED"@
  | OrderSubstatusType'LOST -- ^ @"LOST"@
  | OrderSubstatusType'AWAIT_PAYMENT -- ^ @"AWAIT_PAYMENT"@
  | OrderSubstatusType'AWAIT_LAVKA_RESERVATION -- ^ @"AWAIT_LAVKA_RESERVATION"@
  | OrderSubstatusType'USER_WANTS_TO_CHANGE_ADDRESS -- ^ @"USER_WANTS_TO_CHANGE_ADDRESS"@
  | OrderSubstatusType'FULL_NOT_RANSOM -- ^ @"FULL_NOT_RANSOM"@
  | OrderSubstatusType'PRESCRIPTION_MISMATCH -- ^ @"PRESCRIPTION_MISMATCH"@
  | OrderSubstatusType'DROPOFF_LOST -- ^ @"DROPOFF_LOST"@
  | OrderSubstatusType'DROPOFF_CLOSED -- ^ @"DROPOFF_CLOSED"@
  | OrderSubstatusType'DELIVERY_TO_STORE_STARTED -- ^ @"DELIVERY_TO_STORE_STARTED"@
  | OrderSubstatusType'USER_WANTS_TO_CHANGE_DELIVERY_DATE -- ^ @"USER_WANTS_TO_CHANGE_DELIVERY_DATE"@
  | OrderSubstatusType'WRONG_ITEM_DELIVERED -- ^ @"WRONG_ITEM_DELIVERED"@
  | OrderSubstatusType'DAMAGED_BOX -- ^ @"DAMAGED_BOX"@
  | OrderSubstatusType'AWAIT_DELIVERY_DATES -- ^ @"AWAIT_DELIVERY_DATES"@
  | OrderSubstatusType'LAST_MILE_COURIER_SEARCH -- ^ @"LAST_MILE_COURIER_SEARCH"@
  | OrderSubstatusType'PICKUP_POINT_CLOSED -- ^ @"PICKUP_POINT_CLOSED"@
  | OrderSubstatusType'LEGAL_INFO_CHANGED -- ^ @"LEGAL_INFO_CHANGED"@
  | OrderSubstatusType'USER_HAS_NO_TIME_TO_PICKUP_ORDER -- ^ @"USER_HAS_NO_TIME_TO_PICKUP_ORDER"@
  | OrderSubstatusType'DELIVERY_CUSTOMS_ARRIVED -- ^ @"DELIVERY_CUSTOMS_ARRIVED"@
  | OrderSubstatusType'DELIVERY_CUSTOMS_CLEARED -- ^ @"DELIVERY_CUSTOMS_CLEARED"@
  | OrderSubstatusType'FIRST_MILE_DELIVERY_SERVICE_RECEIVED -- ^ @"FIRST_MILE_DELIVERY_SERVICE_RECEIVED"@
  | OrderSubstatusType'AWAIT_AUTO_DELIVERY_DATES -- ^ @"AWAIT_AUTO_DELIVERY_DATES"@
  | OrderSubstatusType'AWAIT_USER_PERSONAL_DATA -- ^ @"AWAIT_USER_PERSONAL_DATA"@
  | OrderSubstatusType'NO_PERSONAL_DATA_EXPIRED -- ^ @"NO_PERSONAL_DATA_EXPIRED"@
  | OrderSubstatusType'CUSTOMS_PROBLEMS -- ^ @"CUSTOMS_PROBLEMS"@
  | OrderSubstatusType'AWAIT_CASHIER -- ^ @"AWAIT_CASHIER"@
  | OrderSubstatusType'WAITING_POSTPAID_BUDGET_RESERVATION -- ^ @"WAITING_POSTPAID_BUDGET_RESERVATION"@
  | OrderSubstatusType'AWAIT_SERVICEABLE_CONFIRMATION -- ^ @"AWAIT_SERVICEABLE_CONFIRMATION"@
  | OrderSubstatusType'POSTPAID_BUDGET_RESERVATION_FAILED -- ^ @"POSTPAID_BUDGET_RESERVATION_FAILED"@
  | OrderSubstatusType'AWAIT_CUSTOM_PRICE_CONFIRMATION -- ^ @"AWAIT_CUSTOM_PRICE_CONFIRMATION"@
  | OrderSubstatusType'READY_FOR_PICKUP -- ^ @"READY_FOR_PICKUP"@
  | OrderSubstatusType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderSubstatusType where toJSON = A.toJSON . fromOrderSubstatusType
instance A.FromJSON OrderSubstatusType where parseJSON o = P.either P.fail (pure . P.id) . toOrderSubstatusType =<< A.parseJSON o
instance WH.ToHttpApiData OrderSubstatusType where toQueryParam = WH.toQueryParam . fromOrderSubstatusType
instance WH.FromHttpApiData OrderSubstatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderSubstatusType
instance MimeRender MimeMultipartFormData OrderSubstatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderSubstatusType' enum
fromOrderSubstatusType :: OrderSubstatusType -> Text
fromOrderSubstatusType = \case
  OrderSubstatusType'RESERVATION_EXPIRED -> "RESERVATION_EXPIRED"
  OrderSubstatusType'USER_NOT_PAID -> "USER_NOT_PAID"
  OrderSubstatusType'USER_UNREACHABLE -> "USER_UNREACHABLE"
  OrderSubstatusType'USER_CHANGED_MIND -> "USER_CHANGED_MIND"
  OrderSubstatusType'USER_REFUSED_DELIVERY -> "USER_REFUSED_DELIVERY"
  OrderSubstatusType'USER_REFUSED_PRODUCT -> "USER_REFUSED_PRODUCT"
  OrderSubstatusType'SHOP_FAILED -> "SHOP_FAILED"
  OrderSubstatusType'USER_REFUSED_QUALITY -> "USER_REFUSED_QUALITY"
  OrderSubstatusType'REPLACING_ORDER -> "REPLACING_ORDER"
  OrderSubstatusType'PROCESSING_EXPIRED -> "PROCESSING_EXPIRED"
  OrderSubstatusType'PENDING_EXPIRED -> "PENDING_EXPIRED"
  OrderSubstatusType'SHOP_PENDING_CANCELLED -> "SHOP_PENDING_CANCELLED"
  OrderSubstatusType'PENDING_CANCELLED -> "PENDING_CANCELLED"
  OrderSubstatusType'USER_FRAUD -> "USER_FRAUD"
  OrderSubstatusType'RESERVATION_FAILED -> "RESERVATION_FAILED"
  OrderSubstatusType'USER_PLACED_OTHER_ORDER -> "USER_PLACED_OTHER_ORDER"
  OrderSubstatusType'USER_BOUGHT_CHEAPER -> "USER_BOUGHT_CHEAPER"
  OrderSubstatusType'MISSING_ITEM -> "MISSING_ITEM"
  OrderSubstatusType'BROKEN_ITEM -> "BROKEN_ITEM"
  OrderSubstatusType'WRONG_ITEM -> "WRONG_ITEM"
  OrderSubstatusType'PICKUP_EXPIRED -> "PICKUP_EXPIRED"
  OrderSubstatusType'DELIVERY_PROBLEMS -> "DELIVERY_PROBLEMS"
  OrderSubstatusType'LATE_CONTACT -> "LATE_CONTACT"
  OrderSubstatusType'CUSTOM -> "CUSTOM"
  OrderSubstatusType'DELIVERY_SERVICE_FAILED -> "DELIVERY_SERVICE_FAILED"
  OrderSubstatusType'WAREHOUSE_FAILED_TO_SHIP -> "WAREHOUSE_FAILED_TO_SHIP"
  OrderSubstatusType'DELIVERY_SERIVCE_UNDELIVERED -> "DELIVERY_SERIVCE_UNDELIVERED"
  OrderSubstatusType'DELIVERY_SERVICE_UNDELIVERED -> "DELIVERY_SERVICE_UNDELIVERED"
  OrderSubstatusType'PREORDER -> "PREORDER"
  OrderSubstatusType'AWAIT_CONFIRMATION -> "AWAIT_CONFIRMATION"
  OrderSubstatusType'STARTED -> "STARTED"
  OrderSubstatusType'PACKAGING -> "PACKAGING"
  OrderSubstatusType'READY_TO_SHIP -> "READY_TO_SHIP"
  OrderSubstatusType'SHIPPED -> "SHIPPED"
  OrderSubstatusType'ASYNC_PROCESSING -> "ASYNC_PROCESSING"
  OrderSubstatusType'USER_REFUSED_TO_PROVIDE_PERSONAL_DATA -> "USER_REFUSED_TO_PROVIDE_PERSONAL_DATA"
  OrderSubstatusType'WAITING_USER_INPUT -> "WAITING_USER_INPUT"
  OrderSubstatusType'WAITING_BANK_DECISION -> "WAITING_BANK_DECISION"
  OrderSubstatusType'BANK_REJECT_CREDIT_OFFER -> "BANK_REJECT_CREDIT_OFFER"
  OrderSubstatusType'CUSTOMER_REJECT_CREDIT_OFFER -> "CUSTOMER_REJECT_CREDIT_OFFER"
  OrderSubstatusType'CREDIT_OFFER_FAILED -> "CREDIT_OFFER_FAILED"
  OrderSubstatusType'AWAIT_DELIVERY_DATES_CONFIRMATION -> "AWAIT_DELIVERY_DATES_CONFIRMATION"
  OrderSubstatusType'SERVICE_FAULT -> "SERVICE_FAULT"
  OrderSubstatusType'DELIVERY_SERVICE_RECEIVED -> "DELIVERY_SERVICE_RECEIVED"
  OrderSubstatusType'USER_RECEIVED -> "USER_RECEIVED"
  OrderSubstatusType'WAITING_FOR_STOCKS -> "WAITING_FOR_STOCKS"
  OrderSubstatusType'AS_PART_OF_MULTI_ORDER -> "AS_PART_OF_MULTI_ORDER"
  OrderSubstatusType'READY_FOR_LAST_MILE -> "READY_FOR_LAST_MILE"
  OrderSubstatusType'LAST_MILE_STARTED -> "LAST_MILE_STARTED"
  OrderSubstatusType'ANTIFRAUD -> "ANTIFRAUD"
  OrderSubstatusType'DELIVERY_USER_NOT_RECEIVED -> "DELIVERY_USER_NOT_RECEIVED"
  OrderSubstatusType'DELIVERY_SERVICE_DELIVERED -> "DELIVERY_SERVICE_DELIVERED"
  OrderSubstatusType'DELIVERED_USER_NOT_RECEIVED -> "DELIVERED_USER_NOT_RECEIVED"
  OrderSubstatusType'USER_WANTED_ANOTHER_PAYMENT_METHOD -> "USER_WANTED_ANOTHER_PAYMENT_METHOD"
  OrderSubstatusType'USER_RECEIVED_TECHNICAL_ERROR -> "USER_RECEIVED_TECHNICAL_ERROR"
  OrderSubstatusType'USER_FORGOT_TO_USE_BONUS -> "USER_FORGOT_TO_USE_BONUS"
  OrderSubstatusType'RECEIVED_ON_DISTRIBUTION_CENTER -> "RECEIVED_ON_DISTRIBUTION_CENTER"
  OrderSubstatusType'DELIVERY_SERVICE_NOT_RECEIVED -> "DELIVERY_SERVICE_NOT_RECEIVED"
  OrderSubstatusType'DELIVERY_SERVICE_LOST -> "DELIVERY_SERVICE_LOST"
  OrderSubstatusType'SHIPPED_TO_WRONG_DELIVERY_SERVICE -> "SHIPPED_TO_WRONG_DELIVERY_SERVICE"
  OrderSubstatusType'DELIVERED_USER_RECEIVED -> "DELIVERED_USER_RECEIVED"
  OrderSubstatusType'WAITING_TINKOFF_DECISION -> "WAITING_TINKOFF_DECISION"
  OrderSubstatusType'COURIER_SEARCH -> "COURIER_SEARCH"
  OrderSubstatusType'COURIER_FOUND -> "COURIER_FOUND"
  OrderSubstatusType'COURIER_IN_TRANSIT_TO_SENDER -> "COURIER_IN_TRANSIT_TO_SENDER"
  OrderSubstatusType'COURIER_ARRIVED_TO_SENDER -> "COURIER_ARRIVED_TO_SENDER"
  OrderSubstatusType'COURIER_RECEIVED -> "COURIER_RECEIVED"
  OrderSubstatusType'COURIER_NOT_FOUND -> "COURIER_NOT_FOUND"
  OrderSubstatusType'COURIER_NOT_DELIVER_ORDER -> "COURIER_NOT_DELIVER_ORDER"
  OrderSubstatusType'COURIER_RETURNS_ORDER -> "COURIER_RETURNS_ORDER"
  OrderSubstatusType'COURIER_RETURNED_ORDER -> "COURIER_RETURNED_ORDER"
  OrderSubstatusType'WAITING_USER_DELIVERY_INPUT -> "WAITING_USER_DELIVERY_INPUT"
  OrderSubstatusType'PICKUP_SERVICE_RECEIVED -> "PICKUP_SERVICE_RECEIVED"
  OrderSubstatusType'PICKUP_USER_RECEIVED -> "PICKUP_USER_RECEIVED"
  OrderSubstatusType'CANCELLED_COURIER_NOT_FOUND -> "CANCELLED_COURIER_NOT_FOUND"
  OrderSubstatusType'COURIER_NOT_COME_FOR_ORDER -> "COURIER_NOT_COME_FOR_ORDER"
  OrderSubstatusType'DELIVERY_NOT_MANAGED_REGION -> "DELIVERY_NOT_MANAGED_REGION"
  OrderSubstatusType'INCOMPLETE_CONTACT_INFORMATION -> "INCOMPLETE_CONTACT_INFORMATION"
  OrderSubstatusType'INCOMPLETE_MULTI_ORDER -> "INCOMPLETE_MULTI_ORDER"
  OrderSubstatusType'INAPPROPRIATE_WEIGHT_SIZE -> "INAPPROPRIATE_WEIGHT_SIZE"
  OrderSubstatusType'TECHNICAL_ERROR -> "TECHNICAL_ERROR"
  OrderSubstatusType'SORTING_CENTER_LOST -> "SORTING_CENTER_LOST"
  OrderSubstatusType'COURIER_SEARCH_NOT_STARTED -> "COURIER_SEARCH_NOT_STARTED"
  OrderSubstatusType'LOST -> "LOST"
  OrderSubstatusType'AWAIT_PAYMENT -> "AWAIT_PAYMENT"
  OrderSubstatusType'AWAIT_LAVKA_RESERVATION -> "AWAIT_LAVKA_RESERVATION"
  OrderSubstatusType'USER_WANTS_TO_CHANGE_ADDRESS -> "USER_WANTS_TO_CHANGE_ADDRESS"
  OrderSubstatusType'FULL_NOT_RANSOM -> "FULL_NOT_RANSOM"
  OrderSubstatusType'PRESCRIPTION_MISMATCH -> "PRESCRIPTION_MISMATCH"
  OrderSubstatusType'DROPOFF_LOST -> "DROPOFF_LOST"
  OrderSubstatusType'DROPOFF_CLOSED -> "DROPOFF_CLOSED"
  OrderSubstatusType'DELIVERY_TO_STORE_STARTED -> "DELIVERY_TO_STORE_STARTED"
  OrderSubstatusType'USER_WANTS_TO_CHANGE_DELIVERY_DATE -> "USER_WANTS_TO_CHANGE_DELIVERY_DATE"
  OrderSubstatusType'WRONG_ITEM_DELIVERED -> "WRONG_ITEM_DELIVERED"
  OrderSubstatusType'DAMAGED_BOX -> "DAMAGED_BOX"
  OrderSubstatusType'AWAIT_DELIVERY_DATES -> "AWAIT_DELIVERY_DATES"
  OrderSubstatusType'LAST_MILE_COURIER_SEARCH -> "LAST_MILE_COURIER_SEARCH"
  OrderSubstatusType'PICKUP_POINT_CLOSED -> "PICKUP_POINT_CLOSED"
  OrderSubstatusType'LEGAL_INFO_CHANGED -> "LEGAL_INFO_CHANGED"
  OrderSubstatusType'USER_HAS_NO_TIME_TO_PICKUP_ORDER -> "USER_HAS_NO_TIME_TO_PICKUP_ORDER"
  OrderSubstatusType'DELIVERY_CUSTOMS_ARRIVED -> "DELIVERY_CUSTOMS_ARRIVED"
  OrderSubstatusType'DELIVERY_CUSTOMS_CLEARED -> "DELIVERY_CUSTOMS_CLEARED"
  OrderSubstatusType'FIRST_MILE_DELIVERY_SERVICE_RECEIVED -> "FIRST_MILE_DELIVERY_SERVICE_RECEIVED"
  OrderSubstatusType'AWAIT_AUTO_DELIVERY_DATES -> "AWAIT_AUTO_DELIVERY_DATES"
  OrderSubstatusType'AWAIT_USER_PERSONAL_DATA -> "AWAIT_USER_PERSONAL_DATA"
  OrderSubstatusType'NO_PERSONAL_DATA_EXPIRED -> "NO_PERSONAL_DATA_EXPIRED"
  OrderSubstatusType'CUSTOMS_PROBLEMS -> "CUSTOMS_PROBLEMS"
  OrderSubstatusType'AWAIT_CASHIER -> "AWAIT_CASHIER"
  OrderSubstatusType'WAITING_POSTPAID_BUDGET_RESERVATION -> "WAITING_POSTPAID_BUDGET_RESERVATION"
  OrderSubstatusType'AWAIT_SERVICEABLE_CONFIRMATION -> "AWAIT_SERVICEABLE_CONFIRMATION"
  OrderSubstatusType'POSTPAID_BUDGET_RESERVATION_FAILED -> "POSTPAID_BUDGET_RESERVATION_FAILED"
  OrderSubstatusType'AWAIT_CUSTOM_PRICE_CONFIRMATION -> "AWAIT_CUSTOM_PRICE_CONFIRMATION"
  OrderSubstatusType'READY_FOR_PICKUP -> "READY_FOR_PICKUP"
  OrderSubstatusType'UNKNOWN -> "UNKNOWN"

-- | parse 'OrderSubstatusType' enum
toOrderSubstatusType :: Text -> P.Either String OrderSubstatusType
toOrderSubstatusType = \case
  "RESERVATION_EXPIRED" -> P.Right OrderSubstatusType'RESERVATION_EXPIRED
  "USER_NOT_PAID" -> P.Right OrderSubstatusType'USER_NOT_PAID
  "USER_UNREACHABLE" -> P.Right OrderSubstatusType'USER_UNREACHABLE
  "USER_CHANGED_MIND" -> P.Right OrderSubstatusType'USER_CHANGED_MIND
  "USER_REFUSED_DELIVERY" -> P.Right OrderSubstatusType'USER_REFUSED_DELIVERY
  "USER_REFUSED_PRODUCT" -> P.Right OrderSubstatusType'USER_REFUSED_PRODUCT
  "SHOP_FAILED" -> P.Right OrderSubstatusType'SHOP_FAILED
  "USER_REFUSED_QUALITY" -> P.Right OrderSubstatusType'USER_REFUSED_QUALITY
  "REPLACING_ORDER" -> P.Right OrderSubstatusType'REPLACING_ORDER
  "PROCESSING_EXPIRED" -> P.Right OrderSubstatusType'PROCESSING_EXPIRED
  "PENDING_EXPIRED" -> P.Right OrderSubstatusType'PENDING_EXPIRED
  "SHOP_PENDING_CANCELLED" -> P.Right OrderSubstatusType'SHOP_PENDING_CANCELLED
  "PENDING_CANCELLED" -> P.Right OrderSubstatusType'PENDING_CANCELLED
  "USER_FRAUD" -> P.Right OrderSubstatusType'USER_FRAUD
  "RESERVATION_FAILED" -> P.Right OrderSubstatusType'RESERVATION_FAILED
  "USER_PLACED_OTHER_ORDER" -> P.Right OrderSubstatusType'USER_PLACED_OTHER_ORDER
  "USER_BOUGHT_CHEAPER" -> P.Right OrderSubstatusType'USER_BOUGHT_CHEAPER
  "MISSING_ITEM" -> P.Right OrderSubstatusType'MISSING_ITEM
  "BROKEN_ITEM" -> P.Right OrderSubstatusType'BROKEN_ITEM
  "WRONG_ITEM" -> P.Right OrderSubstatusType'WRONG_ITEM
  "PICKUP_EXPIRED" -> P.Right OrderSubstatusType'PICKUP_EXPIRED
  "DELIVERY_PROBLEMS" -> P.Right OrderSubstatusType'DELIVERY_PROBLEMS
  "LATE_CONTACT" -> P.Right OrderSubstatusType'LATE_CONTACT
  "CUSTOM" -> P.Right OrderSubstatusType'CUSTOM
  "DELIVERY_SERVICE_FAILED" -> P.Right OrderSubstatusType'DELIVERY_SERVICE_FAILED
  "WAREHOUSE_FAILED_TO_SHIP" -> P.Right OrderSubstatusType'WAREHOUSE_FAILED_TO_SHIP
  "DELIVERY_SERIVCE_UNDELIVERED" -> P.Right OrderSubstatusType'DELIVERY_SERIVCE_UNDELIVERED
  "DELIVERY_SERVICE_UNDELIVERED" -> P.Right OrderSubstatusType'DELIVERY_SERVICE_UNDELIVERED
  "PREORDER" -> P.Right OrderSubstatusType'PREORDER
  "AWAIT_CONFIRMATION" -> P.Right OrderSubstatusType'AWAIT_CONFIRMATION
  "STARTED" -> P.Right OrderSubstatusType'STARTED
  "PACKAGING" -> P.Right OrderSubstatusType'PACKAGING
  "READY_TO_SHIP" -> P.Right OrderSubstatusType'READY_TO_SHIP
  "SHIPPED" -> P.Right OrderSubstatusType'SHIPPED
  "ASYNC_PROCESSING" -> P.Right OrderSubstatusType'ASYNC_PROCESSING
  "USER_REFUSED_TO_PROVIDE_PERSONAL_DATA" -> P.Right OrderSubstatusType'USER_REFUSED_TO_PROVIDE_PERSONAL_DATA
  "WAITING_USER_INPUT" -> P.Right OrderSubstatusType'WAITING_USER_INPUT
  "WAITING_BANK_DECISION" -> P.Right OrderSubstatusType'WAITING_BANK_DECISION
  "BANK_REJECT_CREDIT_OFFER" -> P.Right OrderSubstatusType'BANK_REJECT_CREDIT_OFFER
  "CUSTOMER_REJECT_CREDIT_OFFER" -> P.Right OrderSubstatusType'CUSTOMER_REJECT_CREDIT_OFFER
  "CREDIT_OFFER_FAILED" -> P.Right OrderSubstatusType'CREDIT_OFFER_FAILED
  "AWAIT_DELIVERY_DATES_CONFIRMATION" -> P.Right OrderSubstatusType'AWAIT_DELIVERY_DATES_CONFIRMATION
  "SERVICE_FAULT" -> P.Right OrderSubstatusType'SERVICE_FAULT
  "DELIVERY_SERVICE_RECEIVED" -> P.Right OrderSubstatusType'DELIVERY_SERVICE_RECEIVED
  "USER_RECEIVED" -> P.Right OrderSubstatusType'USER_RECEIVED
  "WAITING_FOR_STOCKS" -> P.Right OrderSubstatusType'WAITING_FOR_STOCKS
  "AS_PART_OF_MULTI_ORDER" -> P.Right OrderSubstatusType'AS_PART_OF_MULTI_ORDER
  "READY_FOR_LAST_MILE" -> P.Right OrderSubstatusType'READY_FOR_LAST_MILE
  "LAST_MILE_STARTED" -> P.Right OrderSubstatusType'LAST_MILE_STARTED
  "ANTIFRAUD" -> P.Right OrderSubstatusType'ANTIFRAUD
  "DELIVERY_USER_NOT_RECEIVED" -> P.Right OrderSubstatusType'DELIVERY_USER_NOT_RECEIVED
  "DELIVERY_SERVICE_DELIVERED" -> P.Right OrderSubstatusType'DELIVERY_SERVICE_DELIVERED
  "DELIVERED_USER_NOT_RECEIVED" -> P.Right OrderSubstatusType'DELIVERED_USER_NOT_RECEIVED
  "USER_WANTED_ANOTHER_PAYMENT_METHOD" -> P.Right OrderSubstatusType'USER_WANTED_ANOTHER_PAYMENT_METHOD
  "USER_RECEIVED_TECHNICAL_ERROR" -> P.Right OrderSubstatusType'USER_RECEIVED_TECHNICAL_ERROR
  "USER_FORGOT_TO_USE_BONUS" -> P.Right OrderSubstatusType'USER_FORGOT_TO_USE_BONUS
  "RECEIVED_ON_DISTRIBUTION_CENTER" -> P.Right OrderSubstatusType'RECEIVED_ON_DISTRIBUTION_CENTER
  "DELIVERY_SERVICE_NOT_RECEIVED" -> P.Right OrderSubstatusType'DELIVERY_SERVICE_NOT_RECEIVED
  "DELIVERY_SERVICE_LOST" -> P.Right OrderSubstatusType'DELIVERY_SERVICE_LOST
  "SHIPPED_TO_WRONG_DELIVERY_SERVICE" -> P.Right OrderSubstatusType'SHIPPED_TO_WRONG_DELIVERY_SERVICE
  "DELIVERED_USER_RECEIVED" -> P.Right OrderSubstatusType'DELIVERED_USER_RECEIVED
  "WAITING_TINKOFF_DECISION" -> P.Right OrderSubstatusType'WAITING_TINKOFF_DECISION
  "COURIER_SEARCH" -> P.Right OrderSubstatusType'COURIER_SEARCH
  "COURIER_FOUND" -> P.Right OrderSubstatusType'COURIER_FOUND
  "COURIER_IN_TRANSIT_TO_SENDER" -> P.Right OrderSubstatusType'COURIER_IN_TRANSIT_TO_SENDER
  "COURIER_ARRIVED_TO_SENDER" -> P.Right OrderSubstatusType'COURIER_ARRIVED_TO_SENDER
  "COURIER_RECEIVED" -> P.Right OrderSubstatusType'COURIER_RECEIVED
  "COURIER_NOT_FOUND" -> P.Right OrderSubstatusType'COURIER_NOT_FOUND
  "COURIER_NOT_DELIVER_ORDER" -> P.Right OrderSubstatusType'COURIER_NOT_DELIVER_ORDER
  "COURIER_RETURNS_ORDER" -> P.Right OrderSubstatusType'COURIER_RETURNS_ORDER
  "COURIER_RETURNED_ORDER" -> P.Right OrderSubstatusType'COURIER_RETURNED_ORDER
  "WAITING_USER_DELIVERY_INPUT" -> P.Right OrderSubstatusType'WAITING_USER_DELIVERY_INPUT
  "PICKUP_SERVICE_RECEIVED" -> P.Right OrderSubstatusType'PICKUP_SERVICE_RECEIVED
  "PICKUP_USER_RECEIVED" -> P.Right OrderSubstatusType'PICKUP_USER_RECEIVED
  "CANCELLED_COURIER_NOT_FOUND" -> P.Right OrderSubstatusType'CANCELLED_COURIER_NOT_FOUND
  "COURIER_NOT_COME_FOR_ORDER" -> P.Right OrderSubstatusType'COURIER_NOT_COME_FOR_ORDER
  "DELIVERY_NOT_MANAGED_REGION" -> P.Right OrderSubstatusType'DELIVERY_NOT_MANAGED_REGION
  "INCOMPLETE_CONTACT_INFORMATION" -> P.Right OrderSubstatusType'INCOMPLETE_CONTACT_INFORMATION
  "INCOMPLETE_MULTI_ORDER" -> P.Right OrderSubstatusType'INCOMPLETE_MULTI_ORDER
  "INAPPROPRIATE_WEIGHT_SIZE" -> P.Right OrderSubstatusType'INAPPROPRIATE_WEIGHT_SIZE
  "TECHNICAL_ERROR" -> P.Right OrderSubstatusType'TECHNICAL_ERROR
  "SORTING_CENTER_LOST" -> P.Right OrderSubstatusType'SORTING_CENTER_LOST
  "COURIER_SEARCH_NOT_STARTED" -> P.Right OrderSubstatusType'COURIER_SEARCH_NOT_STARTED
  "LOST" -> P.Right OrderSubstatusType'LOST
  "AWAIT_PAYMENT" -> P.Right OrderSubstatusType'AWAIT_PAYMENT
  "AWAIT_LAVKA_RESERVATION" -> P.Right OrderSubstatusType'AWAIT_LAVKA_RESERVATION
  "USER_WANTS_TO_CHANGE_ADDRESS" -> P.Right OrderSubstatusType'USER_WANTS_TO_CHANGE_ADDRESS
  "FULL_NOT_RANSOM" -> P.Right OrderSubstatusType'FULL_NOT_RANSOM
  "PRESCRIPTION_MISMATCH" -> P.Right OrderSubstatusType'PRESCRIPTION_MISMATCH
  "DROPOFF_LOST" -> P.Right OrderSubstatusType'DROPOFF_LOST
  "DROPOFF_CLOSED" -> P.Right OrderSubstatusType'DROPOFF_CLOSED
  "DELIVERY_TO_STORE_STARTED" -> P.Right OrderSubstatusType'DELIVERY_TO_STORE_STARTED
  "USER_WANTS_TO_CHANGE_DELIVERY_DATE" -> P.Right OrderSubstatusType'USER_WANTS_TO_CHANGE_DELIVERY_DATE
  "WRONG_ITEM_DELIVERED" -> P.Right OrderSubstatusType'WRONG_ITEM_DELIVERED
  "DAMAGED_BOX" -> P.Right OrderSubstatusType'DAMAGED_BOX
  "AWAIT_DELIVERY_DATES" -> P.Right OrderSubstatusType'AWAIT_DELIVERY_DATES
  "LAST_MILE_COURIER_SEARCH" -> P.Right OrderSubstatusType'LAST_MILE_COURIER_SEARCH
  "PICKUP_POINT_CLOSED" -> P.Right OrderSubstatusType'PICKUP_POINT_CLOSED
  "LEGAL_INFO_CHANGED" -> P.Right OrderSubstatusType'LEGAL_INFO_CHANGED
  "USER_HAS_NO_TIME_TO_PICKUP_ORDER" -> P.Right OrderSubstatusType'USER_HAS_NO_TIME_TO_PICKUP_ORDER
  "DELIVERY_CUSTOMS_ARRIVED" -> P.Right OrderSubstatusType'DELIVERY_CUSTOMS_ARRIVED
  "DELIVERY_CUSTOMS_CLEARED" -> P.Right OrderSubstatusType'DELIVERY_CUSTOMS_CLEARED
  "FIRST_MILE_DELIVERY_SERVICE_RECEIVED" -> P.Right OrderSubstatusType'FIRST_MILE_DELIVERY_SERVICE_RECEIVED
  "AWAIT_AUTO_DELIVERY_DATES" -> P.Right OrderSubstatusType'AWAIT_AUTO_DELIVERY_DATES
  "AWAIT_USER_PERSONAL_DATA" -> P.Right OrderSubstatusType'AWAIT_USER_PERSONAL_DATA
  "NO_PERSONAL_DATA_EXPIRED" -> P.Right OrderSubstatusType'NO_PERSONAL_DATA_EXPIRED
  "CUSTOMS_PROBLEMS" -> P.Right OrderSubstatusType'CUSTOMS_PROBLEMS
  "AWAIT_CASHIER" -> P.Right OrderSubstatusType'AWAIT_CASHIER
  "WAITING_POSTPAID_BUDGET_RESERVATION" -> P.Right OrderSubstatusType'WAITING_POSTPAID_BUDGET_RESERVATION
  "AWAIT_SERVICEABLE_CONFIRMATION" -> P.Right OrderSubstatusType'AWAIT_SERVICEABLE_CONFIRMATION
  "POSTPAID_BUDGET_RESERVATION_FAILED" -> P.Right OrderSubstatusType'POSTPAID_BUDGET_RESERVATION_FAILED
  "AWAIT_CUSTOM_PRICE_CONFIRMATION" -> P.Right OrderSubstatusType'AWAIT_CUSTOM_PRICE_CONFIRMATION
  "READY_FOR_PICKUP" -> P.Right OrderSubstatusType'READY_FOR_PICKUP
  "UNKNOWN" -> P.Right OrderSubstatusType'UNKNOWN
  s -> P.Left $ "toOrderSubstatusType: enum parse failure: " P.++ P.show s


-- ** OrderTaxSystemType

-- | Enum of 'Text' .
-- Система налогообложения (СНО) магазина на момент оформления заказа:  * `ECHN` — единый сельскохозяйственный налог (ЕСХН).  * `ENVD` — единый налог на вмененный доход (ЕНВД).  * `OSN` — общая система налогообложения (ОСН).  * `PSN` — патентная система налогообложения (ПСН).  * `USN` — упрощенная система налогообложения (УСН).  * `USN_MINUS_COST` — упрощенная система налогообложения, доходы, уменьшенные на величину расходов (УСН «Доходы минус расходы»).  * `NPD` — налог на профессиональный доход (НПД).  * `UNKNOWN_VALUE` — неизвестное значение. Используется только совместно с параметром `payment-method=YANDEX`. 
data OrderTaxSystemType
  = OrderTaxSystemType'OSN -- ^ @"OSN"@
  | OrderTaxSystemType'USN -- ^ @"USN"@
  | OrderTaxSystemType'USN_MINUS_COST -- ^ @"USN_MINUS_COST"@
  | OrderTaxSystemType'ENVD -- ^ @"ENVD"@
  | OrderTaxSystemType'ECHN -- ^ @"ECHN"@
  | OrderTaxSystemType'PSN -- ^ @"PSN"@
  | OrderTaxSystemType'NPD -- ^ @"NPD"@
  | OrderTaxSystemType'UNKNOWN_VALUE -- ^ @"UNKNOWN_VALUE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderTaxSystemType where toJSON = A.toJSON . fromOrderTaxSystemType
instance A.FromJSON OrderTaxSystemType where parseJSON o = P.either P.fail (pure . P.id) . toOrderTaxSystemType =<< A.parseJSON o
instance WH.ToHttpApiData OrderTaxSystemType where toQueryParam = WH.toQueryParam . fromOrderTaxSystemType
instance WH.FromHttpApiData OrderTaxSystemType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderTaxSystemType
instance MimeRender MimeMultipartFormData OrderTaxSystemType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderTaxSystemType' enum
fromOrderTaxSystemType :: OrderTaxSystemType -> Text
fromOrderTaxSystemType = \case
  OrderTaxSystemType'OSN -> "OSN"
  OrderTaxSystemType'USN -> "USN"
  OrderTaxSystemType'USN_MINUS_COST -> "USN_MINUS_COST"
  OrderTaxSystemType'ENVD -> "ENVD"
  OrderTaxSystemType'ECHN -> "ECHN"
  OrderTaxSystemType'PSN -> "PSN"
  OrderTaxSystemType'NPD -> "NPD"
  OrderTaxSystemType'UNKNOWN_VALUE -> "UNKNOWN_VALUE"

-- | parse 'OrderTaxSystemType' enum
toOrderTaxSystemType :: Text -> P.Either String OrderTaxSystemType
toOrderTaxSystemType = \case
  "OSN" -> P.Right OrderTaxSystemType'OSN
  "USN" -> P.Right OrderTaxSystemType'USN
  "USN_MINUS_COST" -> P.Right OrderTaxSystemType'USN_MINUS_COST
  "ENVD" -> P.Right OrderTaxSystemType'ENVD
  "ECHN" -> P.Right OrderTaxSystemType'ECHN
  "PSN" -> P.Right OrderTaxSystemType'PSN
  "NPD" -> P.Right OrderTaxSystemType'NPD
  "UNKNOWN_VALUE" -> P.Right OrderTaxSystemType'UNKNOWN_VALUE
  s -> P.Left $ "toOrderTaxSystemType: enum parse failure: " P.++ P.show s


-- ** OrderUpdateStatusType

-- | Enum of 'Text' .
-- Изменился ли статус заказа:  * `OK` — статус изменен.  * `ERROR` — статус не изменен. В этом случае появится сообщение об ошибке в параметре `errorDetails`. 
data OrderUpdateStatusType
  = OrderUpdateStatusType'OK -- ^ @"OK"@
  | OrderUpdateStatusType'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderUpdateStatusType where toJSON = A.toJSON . fromOrderUpdateStatusType
instance A.FromJSON OrderUpdateStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOrderUpdateStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OrderUpdateStatusType where toQueryParam = WH.toQueryParam . fromOrderUpdateStatusType
instance WH.FromHttpApiData OrderUpdateStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderUpdateStatusType
instance MimeRender MimeMultipartFormData OrderUpdateStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderUpdateStatusType' enum
fromOrderUpdateStatusType :: OrderUpdateStatusType -> Text
fromOrderUpdateStatusType = \case
  OrderUpdateStatusType'OK -> "OK"
  OrderUpdateStatusType'ERROR -> "ERROR"

-- | parse 'OrderUpdateStatusType' enum
toOrderUpdateStatusType :: Text -> P.Either String OrderUpdateStatusType
toOrderUpdateStatusType = \case
  "OK" -> P.Right OrderUpdateStatusType'OK
  "ERROR" -> P.Right OrderUpdateStatusType'ERROR
  s -> P.Left $ "toOrderUpdateStatusType: enum parse failure: " P.++ P.show s


-- ** OrderVatType

-- | Enum of 'Text' .
-- Ставка налога на добавленную стоимость (НДС) на товар:  * `NO_VAT` — НДС не облагается, используется только для отдельных видов услуг.  * `VAT_0` — НДС 0%. Например, используется при продаже товаров, вывезенных в таможенной процедуре экспорта, или при оказании услуг по международной перевозке товаров.  * `VAT_10` — НДС 10%. Например, используется при реализации отдельных продовольственных и медицинских товаров.  * `VAT_10_110` — НДС 10/110. Расчетная ставка НДС 10%, применяется только при предоплате.  * `VAT_20` — НДС 20%. Основная ставка с 2019 года.  * `VAT_20_120` — НДС 20/120. Расчетная ставка НДС 20%, применяется только при предоплате.  * `VAT_18` — НДС 18%. Основная ставка до 2019 года.  * `VAT_18_118` — НДС 18/118. Ставка использовалась до 1 января 2019 года при предоплате.  * `UNKNOWN_VALUE` — неизвестный тип.  Используется только совместно с параметром `payment-method=YANDEX`. 
data OrderVatType
  = OrderVatType'NO_VAT -- ^ @"NO_VAT"@
  | OrderVatType'VAT_0 -- ^ @"VAT_0"@
  | OrderVatType'VAT_10 -- ^ @"VAT_10"@
  | OrderVatType'VAT_10_110 -- ^ @"VAT_10_110"@
  | OrderVatType'VAT_20 -- ^ @"VAT_20"@
  | OrderVatType'VAT_20_120 -- ^ @"VAT_20_120"@
  | OrderVatType'VAT_18 -- ^ @"VAT_18"@
  | OrderVatType'VAT_18_118 -- ^ @"VAT_18_118"@
  | OrderVatType'UNKNOWN_VALUE -- ^ @"UNKNOWN_VALUE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderVatType where toJSON = A.toJSON . fromOrderVatType
instance A.FromJSON OrderVatType where parseJSON o = P.either P.fail (pure . P.id) . toOrderVatType =<< A.parseJSON o
instance WH.ToHttpApiData OrderVatType where toQueryParam = WH.toQueryParam . fromOrderVatType
instance WH.FromHttpApiData OrderVatType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderVatType
instance MimeRender MimeMultipartFormData OrderVatType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderVatType' enum
fromOrderVatType :: OrderVatType -> Text
fromOrderVatType = \case
  OrderVatType'NO_VAT -> "NO_VAT"
  OrderVatType'VAT_0 -> "VAT_0"
  OrderVatType'VAT_10 -> "VAT_10"
  OrderVatType'VAT_10_110 -> "VAT_10_110"
  OrderVatType'VAT_20 -> "VAT_20"
  OrderVatType'VAT_20_120 -> "VAT_20_120"
  OrderVatType'VAT_18 -> "VAT_18"
  OrderVatType'VAT_18_118 -> "VAT_18_118"
  OrderVatType'UNKNOWN_VALUE -> "UNKNOWN_VALUE"

-- | parse 'OrderVatType' enum
toOrderVatType :: Text -> P.Either String OrderVatType
toOrderVatType = \case
  "NO_VAT" -> P.Right OrderVatType'NO_VAT
  "VAT_0" -> P.Right OrderVatType'VAT_0
  "VAT_10" -> P.Right OrderVatType'VAT_10
  "VAT_10_110" -> P.Right OrderVatType'VAT_10_110
  "VAT_20" -> P.Right OrderVatType'VAT_20
  "VAT_20_120" -> P.Right OrderVatType'VAT_20_120
  "VAT_18" -> P.Right OrderVatType'VAT_18
  "VAT_18_118" -> P.Right OrderVatType'VAT_18_118
  "UNKNOWN_VALUE" -> P.Right OrderVatType'UNKNOWN_VALUE
  s -> P.Left $ "toOrderVatType: enum parse failure: " P.++ P.show s


-- ** OrdersStatsCommissionType

-- | Enum of 'Text' .
-- Услуга:  * `FEE` — размещение товара на Маркете. * `FULFILLMENT` — складская обработка. Не возвращается с 1 января 2024 года. * `LOYALTY_PARTICIPATION_FEE` — участие в программе лояльности и отзывы за баллы. * `AUCTION_PROMOTION` — буст продаж с оплатой за продажи. * `INSTALLMENT` — рассрочка. Не возвращается с 24 февраля 2022 года. * `DELIVERY_TO_CUSTOMER` — доставка покупателю (FBY, FBS). Для DBS и Экспресс — если заказ возвращается через логистику Маркета. * `EXPRESS_DELIVERY_TO_CUSTOMER` — экспресс-доставка покупателю (Экспресс). * `AGENCY` — прием платежа покупателя. * `PAYMENT_TRANSFER` — перевод платежа покупателя. * `RETURNED_ORDERS_STORAGE` — хранение невыкупов и возвратов (FBS). Для DBS и Экспресс — если заказ возвращается через логистику Маркета. * `SORTING` — обработка заказа (FBS). * `INTAKE_SORTING` — организация забора заказов со склада продавца (FBS). * `RETURN_PROCESSING` — обработка заказов на складе (FBS). Для DBS и Экспресс — если заказ возвращается через логистику Маркета. * `ILLIQUID_GOODS_SALE` — вознаграждение за продажу невывезенных товаров. 
data OrdersStatsCommissionType
  = OrdersStatsCommissionType'FEE -- ^ @"FEE"@
  | OrdersStatsCommissionType'FULFILLMENT -- ^ @"FULFILLMENT"@
  | OrdersStatsCommissionType'LOYALTY_PARTICIPATION_FEE -- ^ @"LOYALTY_PARTICIPATION_FEE"@
  | OrdersStatsCommissionType'AUCTION_PROMOTION -- ^ @"AUCTION_PROMOTION"@
  | OrdersStatsCommissionType'INSTALLMENT -- ^ @"INSTALLMENT"@
  | OrdersStatsCommissionType'DELIVERY_TO_CUSTOMER -- ^ @"DELIVERY_TO_CUSTOMER"@
  | OrdersStatsCommissionType'EXPRESS_DELIVERY_TO_CUSTOMER -- ^ @"EXPRESS_DELIVERY_TO_CUSTOMER"@
  | OrdersStatsCommissionType'AGENCY -- ^ @"AGENCY"@
  | OrdersStatsCommissionType'PAYMENT_TRANSFER -- ^ @"PAYMENT_TRANSFER"@
  | OrdersStatsCommissionType'RETURNED_ORDERS_STORAGE -- ^ @"RETURNED_ORDERS_STORAGE"@
  | OrdersStatsCommissionType'SORTING -- ^ @"SORTING"@
  | OrdersStatsCommissionType'INTAKE_SORTING -- ^ @"INTAKE_SORTING"@
  | OrdersStatsCommissionType'RETURN_PROCESSING -- ^ @"RETURN_PROCESSING"@
  | OrdersStatsCommissionType'ILLIQUID_GOODS_SALE -- ^ @"ILLIQUID_GOODS_SALE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdersStatsCommissionType where toJSON = A.toJSON . fromOrdersStatsCommissionType
instance A.FromJSON OrdersStatsCommissionType where parseJSON o = P.either P.fail (pure . P.id) . toOrdersStatsCommissionType =<< A.parseJSON o
instance WH.ToHttpApiData OrdersStatsCommissionType where toQueryParam = WH.toQueryParam . fromOrdersStatsCommissionType
instance WH.FromHttpApiData OrdersStatsCommissionType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdersStatsCommissionType
instance MimeRender MimeMultipartFormData OrdersStatsCommissionType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdersStatsCommissionType' enum
fromOrdersStatsCommissionType :: OrdersStatsCommissionType -> Text
fromOrdersStatsCommissionType = \case
  OrdersStatsCommissionType'FEE -> "FEE"
  OrdersStatsCommissionType'FULFILLMENT -> "FULFILLMENT"
  OrdersStatsCommissionType'LOYALTY_PARTICIPATION_FEE -> "LOYALTY_PARTICIPATION_FEE"
  OrdersStatsCommissionType'AUCTION_PROMOTION -> "AUCTION_PROMOTION"
  OrdersStatsCommissionType'INSTALLMENT -> "INSTALLMENT"
  OrdersStatsCommissionType'DELIVERY_TO_CUSTOMER -> "DELIVERY_TO_CUSTOMER"
  OrdersStatsCommissionType'EXPRESS_DELIVERY_TO_CUSTOMER -> "EXPRESS_DELIVERY_TO_CUSTOMER"
  OrdersStatsCommissionType'AGENCY -> "AGENCY"
  OrdersStatsCommissionType'PAYMENT_TRANSFER -> "PAYMENT_TRANSFER"
  OrdersStatsCommissionType'RETURNED_ORDERS_STORAGE -> "RETURNED_ORDERS_STORAGE"
  OrdersStatsCommissionType'SORTING -> "SORTING"
  OrdersStatsCommissionType'INTAKE_SORTING -> "INTAKE_SORTING"
  OrdersStatsCommissionType'RETURN_PROCESSING -> "RETURN_PROCESSING"
  OrdersStatsCommissionType'ILLIQUID_GOODS_SALE -> "ILLIQUID_GOODS_SALE"

-- | parse 'OrdersStatsCommissionType' enum
toOrdersStatsCommissionType :: Text -> P.Either String OrdersStatsCommissionType
toOrdersStatsCommissionType = \case
  "FEE" -> P.Right OrdersStatsCommissionType'FEE
  "FULFILLMENT" -> P.Right OrdersStatsCommissionType'FULFILLMENT
  "LOYALTY_PARTICIPATION_FEE" -> P.Right OrdersStatsCommissionType'LOYALTY_PARTICIPATION_FEE
  "AUCTION_PROMOTION" -> P.Right OrdersStatsCommissionType'AUCTION_PROMOTION
  "INSTALLMENT" -> P.Right OrdersStatsCommissionType'INSTALLMENT
  "DELIVERY_TO_CUSTOMER" -> P.Right OrdersStatsCommissionType'DELIVERY_TO_CUSTOMER
  "EXPRESS_DELIVERY_TO_CUSTOMER" -> P.Right OrdersStatsCommissionType'EXPRESS_DELIVERY_TO_CUSTOMER
  "AGENCY" -> P.Right OrdersStatsCommissionType'AGENCY
  "PAYMENT_TRANSFER" -> P.Right OrdersStatsCommissionType'PAYMENT_TRANSFER
  "RETURNED_ORDERS_STORAGE" -> P.Right OrdersStatsCommissionType'RETURNED_ORDERS_STORAGE
  "SORTING" -> P.Right OrdersStatsCommissionType'SORTING
  "INTAKE_SORTING" -> P.Right OrdersStatsCommissionType'INTAKE_SORTING
  "RETURN_PROCESSING" -> P.Right OrdersStatsCommissionType'RETURN_PROCESSING
  "ILLIQUID_GOODS_SALE" -> P.Right OrdersStatsCommissionType'ILLIQUID_GOODS_SALE
  s -> P.Left $ "toOrdersStatsCommissionType: enum parse failure: " P.++ P.show s


-- ** OrdersStatsItemStatusType

-- | Enum of 'Text' .
-- Статус товара:  * `REJECTED` — товар был добавлен в созданный заказ, но не был оплачен. * `RETURNED` — товар вернули. 
data OrdersStatsItemStatusType
  = OrdersStatsItemStatusType'REJECTED -- ^ @"REJECTED"@
  | OrdersStatsItemStatusType'RETURNED -- ^ @"RETURNED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdersStatsItemStatusType where toJSON = A.toJSON . fromOrdersStatsItemStatusType
instance A.FromJSON OrdersStatsItemStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOrdersStatsItemStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OrdersStatsItemStatusType where toQueryParam = WH.toQueryParam . fromOrdersStatsItemStatusType
instance WH.FromHttpApiData OrdersStatsItemStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdersStatsItemStatusType
instance MimeRender MimeMultipartFormData OrdersStatsItemStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdersStatsItemStatusType' enum
fromOrdersStatsItemStatusType :: OrdersStatsItemStatusType -> Text
fromOrdersStatsItemStatusType = \case
  OrdersStatsItemStatusType'REJECTED -> "REJECTED"
  OrdersStatsItemStatusType'RETURNED -> "RETURNED"

-- | parse 'OrdersStatsItemStatusType' enum
toOrdersStatsItemStatusType :: Text -> P.Either String OrdersStatsItemStatusType
toOrdersStatsItemStatusType = \case
  "REJECTED" -> P.Right OrdersStatsItemStatusType'REJECTED
  "RETURNED" -> P.Right OrdersStatsItemStatusType'RETURNED
  s -> P.Left $ "toOrdersStatsItemStatusType: enum parse failure: " P.++ P.show s


-- ** OrdersStatsOrderPaymentType

-- | Enum of 'Text' .
-- Тип оплаты заказа: - `CREDIT` — заказ оформлен в кредит. - `POSTPAID` — заказ оплачен после того, как был получен. - `PREPAID` — заказ оплачен до того, как был получен. 
data OrdersStatsOrderPaymentType
  = OrdersStatsOrderPaymentType'CREDIT -- ^ @"CREDIT"@
  | OrdersStatsOrderPaymentType'POSTPAID -- ^ @"POSTPAID"@
  | OrdersStatsOrderPaymentType'PREPAID -- ^ @"PREPAID"@
  | OrdersStatsOrderPaymentType'TINKOFF_CREDIT -- ^ @"TINKOFF_CREDIT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdersStatsOrderPaymentType where toJSON = A.toJSON . fromOrdersStatsOrderPaymentType
instance A.FromJSON OrdersStatsOrderPaymentType where parseJSON o = P.either P.fail (pure . P.id) . toOrdersStatsOrderPaymentType =<< A.parseJSON o
instance WH.ToHttpApiData OrdersStatsOrderPaymentType where toQueryParam = WH.toQueryParam . fromOrdersStatsOrderPaymentType
instance WH.FromHttpApiData OrdersStatsOrderPaymentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdersStatsOrderPaymentType
instance MimeRender MimeMultipartFormData OrdersStatsOrderPaymentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdersStatsOrderPaymentType' enum
fromOrdersStatsOrderPaymentType :: OrdersStatsOrderPaymentType -> Text
fromOrdersStatsOrderPaymentType = \case
  OrdersStatsOrderPaymentType'CREDIT -> "CREDIT"
  OrdersStatsOrderPaymentType'POSTPAID -> "POSTPAID"
  OrdersStatsOrderPaymentType'PREPAID -> "PREPAID"
  OrdersStatsOrderPaymentType'TINKOFF_CREDIT -> "TINKOFF_CREDIT"

-- | parse 'OrdersStatsOrderPaymentType' enum
toOrdersStatsOrderPaymentType :: Text -> P.Either String OrdersStatsOrderPaymentType
toOrdersStatsOrderPaymentType = \case
  "CREDIT" -> P.Right OrdersStatsOrderPaymentType'CREDIT
  "POSTPAID" -> P.Right OrdersStatsOrderPaymentType'POSTPAID
  "PREPAID" -> P.Right OrdersStatsOrderPaymentType'PREPAID
  "TINKOFF_CREDIT" -> P.Right OrdersStatsOrderPaymentType'TINKOFF_CREDIT
  s -> P.Left $ "toOrdersStatsOrderPaymentType: enum parse failure: " P.++ P.show s


-- ** OrdersStatsPaymentSourceType

-- | Enum of 'Text' .
-- Способ денежного перевода: - `BUYER` — оплата или возврат деньгами. - `CASHBACK` — оплата или возврат баллами Плюса. - `MARKETPLACE` — оплата или возврат купонами. - `SPLIT` — оплата картой по частям (Сплит). 
data OrdersStatsPaymentSourceType
  = OrdersStatsPaymentSourceType'BUYER -- ^ @"BUYER"@
  | OrdersStatsPaymentSourceType'CASHBACK -- ^ @"CASHBACK"@
  | OrdersStatsPaymentSourceType'MARKETPLACE -- ^ @"MARKETPLACE"@
  | OrdersStatsPaymentSourceType'SPLIT -- ^ @"SPLIT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdersStatsPaymentSourceType where toJSON = A.toJSON . fromOrdersStatsPaymentSourceType
instance A.FromJSON OrdersStatsPaymentSourceType where parseJSON o = P.either P.fail (pure . P.id) . toOrdersStatsPaymentSourceType =<< A.parseJSON o
instance WH.ToHttpApiData OrdersStatsPaymentSourceType where toQueryParam = WH.toQueryParam . fromOrdersStatsPaymentSourceType
instance WH.FromHttpApiData OrdersStatsPaymentSourceType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdersStatsPaymentSourceType
instance MimeRender MimeMultipartFormData OrdersStatsPaymentSourceType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdersStatsPaymentSourceType' enum
fromOrdersStatsPaymentSourceType :: OrdersStatsPaymentSourceType -> Text
fromOrdersStatsPaymentSourceType = \case
  OrdersStatsPaymentSourceType'BUYER -> "BUYER"
  OrdersStatsPaymentSourceType'CASHBACK -> "CASHBACK"
  OrdersStatsPaymentSourceType'MARKETPLACE -> "MARKETPLACE"
  OrdersStatsPaymentSourceType'SPLIT -> "SPLIT"

-- | parse 'OrdersStatsPaymentSourceType' enum
toOrdersStatsPaymentSourceType :: Text -> P.Either String OrdersStatsPaymentSourceType
toOrdersStatsPaymentSourceType = \case
  "BUYER" -> P.Right OrdersStatsPaymentSourceType'BUYER
  "CASHBACK" -> P.Right OrdersStatsPaymentSourceType'CASHBACK
  "MARKETPLACE" -> P.Right OrdersStatsPaymentSourceType'MARKETPLACE
  "SPLIT" -> P.Right OrdersStatsPaymentSourceType'SPLIT
  s -> P.Left $ "toOrdersStatsPaymentSourceType: enum parse failure: " P.++ P.show s


-- ** OrdersStatsPaymentType

-- | Enum of 'Text' .
-- Тип денежного перевода: - `PAYMENT` — оплата. - `REFUND` — возврат. 
data OrdersStatsPaymentType
  = OrdersStatsPaymentType'PAYMENT -- ^ @"PAYMENT"@
  | OrdersStatsPaymentType'REFUND -- ^ @"REFUND"@
  | OrdersStatsPaymentType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdersStatsPaymentType where toJSON = A.toJSON . fromOrdersStatsPaymentType
instance A.FromJSON OrdersStatsPaymentType where parseJSON o = P.either P.fail (pure . P.id) . toOrdersStatsPaymentType =<< A.parseJSON o
instance WH.ToHttpApiData OrdersStatsPaymentType where toQueryParam = WH.toQueryParam . fromOrdersStatsPaymentType
instance WH.FromHttpApiData OrdersStatsPaymentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdersStatsPaymentType
instance MimeRender MimeMultipartFormData OrdersStatsPaymentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdersStatsPaymentType' enum
fromOrdersStatsPaymentType :: OrdersStatsPaymentType -> Text
fromOrdersStatsPaymentType = \case
  OrdersStatsPaymentType'PAYMENT -> "PAYMENT"
  OrdersStatsPaymentType'REFUND -> "REFUND"
  OrdersStatsPaymentType'UNKNOWN -> "UNKNOWN"

-- | parse 'OrdersStatsPaymentType' enum
toOrdersStatsPaymentType :: Text -> P.Either String OrdersStatsPaymentType
toOrdersStatsPaymentType = \case
  "PAYMENT" -> P.Right OrdersStatsPaymentType'PAYMENT
  "REFUND" -> P.Right OrdersStatsPaymentType'REFUND
  "UNKNOWN" -> P.Right OrdersStatsPaymentType'UNKNOWN
  s -> P.Left $ "toOrdersStatsPaymentType: enum parse failure: " P.++ P.show s


-- ** OrdersStatsPriceType

-- | Enum of 'Text' .
-- Тип скидки или цена на товар: - `BUYER` — цена на товар с учетом скидок, в том числе купонов. - `CASHBACK` — баллы Плюса. - `MARKETPLACE` — купоны. 
data OrdersStatsPriceType
  = OrdersStatsPriceType'BUYER -- ^ @"BUYER"@
  | OrdersStatsPriceType'CASHBACK -- ^ @"CASHBACK"@
  | OrdersStatsPriceType'MARKETPLACE -- ^ @"MARKETPLACE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdersStatsPriceType where toJSON = A.toJSON . fromOrdersStatsPriceType
instance A.FromJSON OrdersStatsPriceType where parseJSON o = P.either P.fail (pure . P.id) . toOrdersStatsPriceType =<< A.parseJSON o
instance WH.ToHttpApiData OrdersStatsPriceType where toQueryParam = WH.toQueryParam . fromOrdersStatsPriceType
instance WH.FromHttpApiData OrdersStatsPriceType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdersStatsPriceType
instance MimeRender MimeMultipartFormData OrdersStatsPriceType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdersStatsPriceType' enum
fromOrdersStatsPriceType :: OrdersStatsPriceType -> Text
fromOrdersStatsPriceType = \case
  OrdersStatsPriceType'BUYER -> "BUYER"
  OrdersStatsPriceType'CASHBACK -> "CASHBACK"
  OrdersStatsPriceType'MARKETPLACE -> "MARKETPLACE"

-- | parse 'OrdersStatsPriceType' enum
toOrdersStatsPriceType :: Text -> P.Either String OrdersStatsPriceType
toOrdersStatsPriceType = \case
  "BUYER" -> P.Right OrdersStatsPriceType'BUYER
  "CASHBACK" -> P.Right OrdersStatsPriceType'CASHBACK
  "MARKETPLACE" -> P.Right OrdersStatsPriceType'MARKETPLACE
  s -> P.Left $ "toOrdersStatsPriceType: enum parse failure: " P.++ P.show s


-- ** OrdersStatsStockType

-- | Enum of 'Text' .
-- Тип товара:  * `DEFECT` — товар бракованный.  * `FIT` — товар надлежащего качества. 
data OrdersStatsStockType
  = OrdersStatsStockType'FIT -- ^ @"FIT"@
  | OrdersStatsStockType'FREEZE -- ^ @"FREEZE"@
  | OrdersStatsStockType'AVAILABLE -- ^ @"AVAILABLE"@
  | OrdersStatsStockType'QUARANTINE -- ^ @"QUARANTINE"@
  | OrdersStatsStockType'UTILIZATION -- ^ @"UTILIZATION"@
  | OrdersStatsStockType'DEFECT -- ^ @"DEFECT"@
  | OrdersStatsStockType'EXPIRED -- ^ @"EXPIRED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdersStatsStockType where toJSON = A.toJSON . fromOrdersStatsStockType
instance A.FromJSON OrdersStatsStockType where parseJSON o = P.either P.fail (pure . P.id) . toOrdersStatsStockType =<< A.parseJSON o
instance WH.ToHttpApiData OrdersStatsStockType where toQueryParam = WH.toQueryParam . fromOrdersStatsStockType
instance WH.FromHttpApiData OrdersStatsStockType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdersStatsStockType
instance MimeRender MimeMultipartFormData OrdersStatsStockType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdersStatsStockType' enum
fromOrdersStatsStockType :: OrdersStatsStockType -> Text
fromOrdersStatsStockType = \case
  OrdersStatsStockType'FIT -> "FIT"
  OrdersStatsStockType'FREEZE -> "FREEZE"
  OrdersStatsStockType'AVAILABLE -> "AVAILABLE"
  OrdersStatsStockType'QUARANTINE -> "QUARANTINE"
  OrdersStatsStockType'UTILIZATION -> "UTILIZATION"
  OrdersStatsStockType'DEFECT -> "DEFECT"
  OrdersStatsStockType'EXPIRED -> "EXPIRED"

-- | parse 'OrdersStatsStockType' enum
toOrdersStatsStockType :: Text -> P.Either String OrdersStatsStockType
toOrdersStatsStockType = \case
  "FIT" -> P.Right OrdersStatsStockType'FIT
  "FREEZE" -> P.Right OrdersStatsStockType'FREEZE
  "AVAILABLE" -> P.Right OrdersStatsStockType'AVAILABLE
  "QUARANTINE" -> P.Right OrdersStatsStockType'QUARANTINE
  "UTILIZATION" -> P.Right OrdersStatsStockType'UTILIZATION
  "DEFECT" -> P.Right OrdersStatsStockType'DEFECT
  "EXPIRED" -> P.Right OrdersStatsStockType'EXPIRED
  s -> P.Left $ "toOrdersStatsStockType: enum parse failure: " P.++ P.show s


-- ** OutletStatusType

-- | Enum of 'Text' .
-- Статус точки продаж.  Возможные значения:  * `AT_MODERATION` — проверяется. * `FAILED` — не прошла проверку и отклонена модератором. * `MODERATED` — проверена и одобрена. * `NONMODERATED` — новая точка, нуждается в проверке. 
data OutletStatusType
  = OutletStatusType'AT_MODERATION -- ^ @"AT_MODERATION"@
  | OutletStatusType'FAILED -- ^ @"FAILED"@
  | OutletStatusType'MODERATED -- ^ @"MODERATED"@
  | OutletStatusType'NONMODERATED -- ^ @"NONMODERATED"@
  | OutletStatusType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OutletStatusType where toJSON = A.toJSON . fromOutletStatusType
instance A.FromJSON OutletStatusType where parseJSON o = P.either P.fail (pure . P.id) . toOutletStatusType =<< A.parseJSON o
instance WH.ToHttpApiData OutletStatusType where toQueryParam = WH.toQueryParam . fromOutletStatusType
instance WH.FromHttpApiData OutletStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOutletStatusType
instance MimeRender MimeMultipartFormData OutletStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OutletStatusType' enum
fromOutletStatusType :: OutletStatusType -> Text
fromOutletStatusType = \case
  OutletStatusType'AT_MODERATION -> "AT_MODERATION"
  OutletStatusType'FAILED -> "FAILED"
  OutletStatusType'MODERATED -> "MODERATED"
  OutletStatusType'NONMODERATED -> "NONMODERATED"
  OutletStatusType'UNKNOWN -> "UNKNOWN"

-- | parse 'OutletStatusType' enum
toOutletStatusType :: Text -> P.Either String OutletStatusType
toOutletStatusType = \case
  "AT_MODERATION" -> P.Right OutletStatusType'AT_MODERATION
  "FAILED" -> P.Right OutletStatusType'FAILED
  "MODERATED" -> P.Right OutletStatusType'MODERATED
  "NONMODERATED" -> P.Right OutletStatusType'NONMODERATED
  "UNKNOWN" -> P.Right OutletStatusType'UNKNOWN
  s -> P.Left $ "toOutletStatusType: enum parse failure: " P.++ P.show s


-- ** OutletType

-- | Enum of 'Text' .
-- Тип точки продаж.  Возможные значения:  * `DEPOT` — пункт выдачи заказов. * `MIXED` — смешанный тип точки продаж (торговый зал и пункт выдачи заказов). * `RETAIL` — розничная точка продаж (торговый зал). 
data OutletType
  = OutletType'DEPOT -- ^ @"DEPOT"@
  | OutletType'MIXED -- ^ @"MIXED"@
  | OutletType'RETAIL -- ^ @"RETAIL"@
  | OutletType'NOT_DEFINED -- ^ @"NOT_DEFINED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OutletType where toJSON = A.toJSON . fromOutletType
instance A.FromJSON OutletType where parseJSON o = P.either P.fail (pure . P.id) . toOutletType =<< A.parseJSON o
instance WH.ToHttpApiData OutletType where toQueryParam = WH.toQueryParam . fromOutletType
instance WH.FromHttpApiData OutletType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOutletType
instance MimeRender MimeMultipartFormData OutletType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OutletType' enum
fromOutletType :: OutletType -> Text
fromOutletType = \case
  OutletType'DEPOT -> "DEPOT"
  OutletType'MIXED -> "MIXED"
  OutletType'RETAIL -> "RETAIL"
  OutletType'NOT_DEFINED -> "NOT_DEFINED"

-- | parse 'OutletType' enum
toOutletType :: Text -> P.Either String OutletType
toOutletType = \case
  "DEPOT" -> P.Right OutletType'DEPOT
  "MIXED" -> P.Right OutletType'MIXED
  "RETAIL" -> P.Right OutletType'RETAIL
  "NOT_DEFINED" -> P.Right OutletType'NOT_DEFINED
  s -> P.Left $ "toOutletType: enum parse failure: " P.++ P.show s


-- ** OutletVisibilityType

-- | Enum of 'Text' .
-- Состояние точки продаж.  Возможные значения:  * `HIDDEN` — точка продаж выключена. * `VISIBLE` — точка продаж включена. 
data OutletVisibilityType
  = OutletVisibilityType'HIDDEN -- ^ @"HIDDEN"@
  | OutletVisibilityType'VISIBLE -- ^ @"VISIBLE"@
  | OutletVisibilityType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OutletVisibilityType where toJSON = A.toJSON . fromOutletVisibilityType
instance A.FromJSON OutletVisibilityType where parseJSON o = P.either P.fail (pure . P.id) . toOutletVisibilityType =<< A.parseJSON o
instance WH.ToHttpApiData OutletVisibilityType where toQueryParam = WH.toQueryParam . fromOutletVisibilityType
instance WH.FromHttpApiData OutletVisibilityType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOutletVisibilityType
instance MimeRender MimeMultipartFormData OutletVisibilityType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OutletVisibilityType' enum
fromOutletVisibilityType :: OutletVisibilityType -> Text
fromOutletVisibilityType = \case
  OutletVisibilityType'HIDDEN -> "HIDDEN"
  OutletVisibilityType'VISIBLE -> "VISIBLE"
  OutletVisibilityType'UNKNOWN -> "UNKNOWN"

-- | parse 'OutletVisibilityType' enum
toOutletVisibilityType :: Text -> P.Either String OutletVisibilityType
toOutletVisibilityType = \case
  "HIDDEN" -> P.Right OutletVisibilityType'HIDDEN
  "VISIBLE" -> P.Right OutletVisibilityType'VISIBLE
  "UNKNOWN" -> P.Right OutletVisibilityType'UNKNOWN
  s -> P.Left $ "toOutletVisibilityType: enum parse failure: " P.++ P.show s


-- ** PageFormatType

-- | Enum of 'Text' .
-- Размещение ярлыков на странице: * `A7` — в PDF-файле будут страницы формата близкому к A7. На каждой странице размещается ярлык размером 75 × 120 мм (80,4 × 125,6 мм с учетом полей). * `A4` — в PDF-файле будут страницы формата A4. На каждой странице размещаются восемь ярлыков размером 70,6 × 99,1 мм без полей. 
data PageFormatType
  = PageFormatType'A7 -- ^ @"A7"@
  | PageFormatType'A4 -- ^ @"A4"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PageFormatType where toJSON = A.toJSON . fromPageFormatType
instance A.FromJSON PageFormatType where parseJSON o = P.either P.fail (pure . P.id) . toPageFormatType =<< A.parseJSON o
instance WH.ToHttpApiData PageFormatType where toQueryParam = WH.toQueryParam . fromPageFormatType
instance WH.FromHttpApiData PageFormatType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPageFormatType
instance MimeRender MimeMultipartFormData PageFormatType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PageFormatType' enum
fromPageFormatType :: PageFormatType -> Text
fromPageFormatType = \case
  PageFormatType'A7 -> "A7"
  PageFormatType'A4 -> "A4"

-- | parse 'PageFormatType' enum
toPageFormatType :: Text -> P.Either String PageFormatType
toPageFormatType = \case
  "A7" -> P.Right PageFormatType'A7
  "A4" -> P.Right PageFormatType'A4
  s -> P.Left $ "toPageFormatType: enum parse failure: " P.++ P.show s


-- ** ParameterType

-- | Enum of 'Text' .
-- Тип данных:  * `TEXT` — текст. * `ENUM` — список возможных значений. * `BOOLEAN` — `true` или `false`. * `NUMERIC` — число. 
data ParameterType
  = ParameterType'TEXT -- ^ @"TEXT"@
  | ParameterType'ENUM -- ^ @"ENUM"@
  | ParameterType'BOOLEAN -- ^ @"BOOLEAN"@
  | ParameterType'NUMERIC -- ^ @"NUMERIC"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ParameterType where toJSON = A.toJSON . fromParameterType
instance A.FromJSON ParameterType where parseJSON o = P.either P.fail (pure . P.id) . toParameterType =<< A.parseJSON o
instance WH.ToHttpApiData ParameterType where toQueryParam = WH.toQueryParam . fromParameterType
instance WH.FromHttpApiData ParameterType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toParameterType
instance MimeRender MimeMultipartFormData ParameterType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ParameterType' enum
fromParameterType :: ParameterType -> Text
fromParameterType = \case
  ParameterType'TEXT -> "TEXT"
  ParameterType'ENUM -> "ENUM"
  ParameterType'BOOLEAN -> "BOOLEAN"
  ParameterType'NUMERIC -> "NUMERIC"

-- | parse 'ParameterType' enum
toParameterType :: Text -> P.Either String ParameterType
toParameterType = \case
  "TEXT" -> P.Right ParameterType'TEXT
  "ENUM" -> P.Right ParameterType'ENUM
  "BOOLEAN" -> P.Right ParameterType'BOOLEAN
  "NUMERIC" -> P.Right ParameterType'NUMERIC
  s -> P.Left $ "toParameterType: enum parse failure: " P.++ P.show s


-- ** PaymentFrequencyType

-- | Enum of 'Text' .
-- Частота выплат:  * `DAILY` — ежедневно. * `WEEKLY` — раз в неделю. * `BIWEEKLY` — раз в две недели. * `MONTHLY` — раз в месяц.  Подробнее о графике выплат читайте [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/introduction/rates/acquiring.html). 
data PaymentFrequencyType
  = PaymentFrequencyType'DAILY -- ^ @"DAILY"@
  | PaymentFrequencyType'WEEKLY -- ^ @"WEEKLY"@
  | PaymentFrequencyType'BIWEEKLY -- ^ @"BIWEEKLY"@
  | PaymentFrequencyType'MONTHLY -- ^ @"MONTHLY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PaymentFrequencyType where toJSON = A.toJSON . fromPaymentFrequencyType
instance A.FromJSON PaymentFrequencyType where parseJSON o = P.either P.fail (pure . P.id) . toPaymentFrequencyType =<< A.parseJSON o
instance WH.ToHttpApiData PaymentFrequencyType where toQueryParam = WH.toQueryParam . fromPaymentFrequencyType
instance WH.FromHttpApiData PaymentFrequencyType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPaymentFrequencyType
instance MimeRender MimeMultipartFormData PaymentFrequencyType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PaymentFrequencyType' enum
fromPaymentFrequencyType :: PaymentFrequencyType -> Text
fromPaymentFrequencyType = \case
  PaymentFrequencyType'DAILY -> "DAILY"
  PaymentFrequencyType'WEEKLY -> "WEEKLY"
  PaymentFrequencyType'BIWEEKLY -> "BIWEEKLY"
  PaymentFrequencyType'MONTHLY -> "MONTHLY"

-- | parse 'PaymentFrequencyType' enum
toPaymentFrequencyType :: Text -> P.Either String PaymentFrequencyType
toPaymentFrequencyType = \case
  "DAILY" -> P.Right PaymentFrequencyType'DAILY
  "WEEKLY" -> P.Right PaymentFrequencyType'WEEKLY
  "BIWEEKLY" -> P.Right PaymentFrequencyType'BIWEEKLY
  "MONTHLY" -> P.Right PaymentFrequencyType'MONTHLY
  s -> P.Left $ "toPaymentFrequencyType: enum parse failure: " P.++ P.show s


-- ** PlacementType

-- | Enum of 'Text' .
-- Модель, по которой работает магазин:  * `FBS` — FBS или Экспресс. * `FBY` — FBY. * `DBS` — DBS. 
data PlacementType
  = PlacementType'FBS -- ^ @"FBS"@
  | PlacementType'FBY -- ^ @"FBY"@
  | PlacementType'DBS -- ^ @"DBS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PlacementType where toJSON = A.toJSON . fromPlacementType
instance A.FromJSON PlacementType where parseJSON o = P.either P.fail (pure . P.id) . toPlacementType =<< A.parseJSON o
instance WH.ToHttpApiData PlacementType where toQueryParam = WH.toQueryParam . fromPlacementType
instance WH.FromHttpApiData PlacementType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPlacementType
instance MimeRender MimeMultipartFormData PlacementType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PlacementType' enum
fromPlacementType :: PlacementType -> Text
fromPlacementType = \case
  PlacementType'FBS -> "FBS"
  PlacementType'FBY -> "FBY"
  PlacementType'DBS -> "DBS"

-- | parse 'PlacementType' enum
toPlacementType :: Text -> P.Either String PlacementType
toPlacementType = \case
  "FBS" -> P.Right PlacementType'FBS
  "FBY" -> P.Right PlacementType'FBY
  "DBS" -> P.Right PlacementType'DBS
  s -> P.Left $ "toPlacementType: enum parse failure: " P.++ P.show s


-- ** PriceCompetitivenessType

-- | Enum of 'Text' .
-- Привлекательность цены:  * `OPTIMAL` — привлекательная. * `AVERAGE` — умеренная. * `LOW` — непривлекательная. 
data PriceCompetitivenessType
  = PriceCompetitivenessType'OPTIMAL -- ^ @"OPTIMAL"@
  | PriceCompetitivenessType'AVERAGE -- ^ @"AVERAGE"@
  | PriceCompetitivenessType'LOW -- ^ @"LOW"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PriceCompetitivenessType where toJSON = A.toJSON . fromPriceCompetitivenessType
instance A.FromJSON PriceCompetitivenessType where parseJSON o = P.either P.fail (pure . P.id) . toPriceCompetitivenessType =<< A.parseJSON o
instance WH.ToHttpApiData PriceCompetitivenessType where toQueryParam = WH.toQueryParam . fromPriceCompetitivenessType
instance WH.FromHttpApiData PriceCompetitivenessType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPriceCompetitivenessType
instance MimeRender MimeMultipartFormData PriceCompetitivenessType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PriceCompetitivenessType' enum
fromPriceCompetitivenessType :: PriceCompetitivenessType -> Text
fromPriceCompetitivenessType = \case
  PriceCompetitivenessType'OPTIMAL -> "OPTIMAL"
  PriceCompetitivenessType'AVERAGE -> "AVERAGE"
  PriceCompetitivenessType'LOW -> "LOW"

-- | parse 'PriceCompetitivenessType' enum
toPriceCompetitivenessType :: Text -> P.Either String PriceCompetitivenessType
toPriceCompetitivenessType = \case
  "OPTIMAL" -> P.Right PriceCompetitivenessType'OPTIMAL
  "AVERAGE" -> P.Right PriceCompetitivenessType'AVERAGE
  "LOW" -> P.Right PriceCompetitivenessType'LOW
  s -> P.Left $ "toPriceCompetitivenessType: enum parse failure: " P.++ P.show s


-- ** PriceQuarantineVerdictParamNameType

-- | Enum of 'Text' .
-- Имя параметра причины скрытия товара по цене.  * `CURRENT_PRICE` — цена, из-за которой товар попал в карантин. * `LAST_VALID_PRICE` — последняя цена до попадания в карантин (только для карантина типа `PRICE_CHANGE`). * `MIN_PRICE` — порог попадания в карантин (только для карантина типов `LOW_PRICE` и `LOW_PRICE_PROMO`). * `CURRENCY` — валюта. 
data PriceQuarantineVerdictParamNameType
  = PriceQuarantineVerdictParamNameType'CURRENT_PRICE -- ^ @"CURRENT_PRICE"@
  | PriceQuarantineVerdictParamNameType'LAST_VALID_PRICE -- ^ @"LAST_VALID_PRICE"@
  | PriceQuarantineVerdictParamNameType'MIN_PRICE -- ^ @"MIN_PRICE"@
  | PriceQuarantineVerdictParamNameType'CURRENCY -- ^ @"CURRENCY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PriceQuarantineVerdictParamNameType where toJSON = A.toJSON . fromPriceQuarantineVerdictParamNameType
instance A.FromJSON PriceQuarantineVerdictParamNameType where parseJSON o = P.either P.fail (pure . P.id) . toPriceQuarantineVerdictParamNameType =<< A.parseJSON o
instance WH.ToHttpApiData PriceQuarantineVerdictParamNameType where toQueryParam = WH.toQueryParam . fromPriceQuarantineVerdictParamNameType
instance WH.FromHttpApiData PriceQuarantineVerdictParamNameType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPriceQuarantineVerdictParamNameType
instance MimeRender MimeMultipartFormData PriceQuarantineVerdictParamNameType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PriceQuarantineVerdictParamNameType' enum
fromPriceQuarantineVerdictParamNameType :: PriceQuarantineVerdictParamNameType -> Text
fromPriceQuarantineVerdictParamNameType = \case
  PriceQuarantineVerdictParamNameType'CURRENT_PRICE -> "CURRENT_PRICE"
  PriceQuarantineVerdictParamNameType'LAST_VALID_PRICE -> "LAST_VALID_PRICE"
  PriceQuarantineVerdictParamNameType'MIN_PRICE -> "MIN_PRICE"
  PriceQuarantineVerdictParamNameType'CURRENCY -> "CURRENCY"

-- | parse 'PriceQuarantineVerdictParamNameType' enum
toPriceQuarantineVerdictParamNameType :: Text -> P.Either String PriceQuarantineVerdictParamNameType
toPriceQuarantineVerdictParamNameType = \case
  "CURRENT_PRICE" -> P.Right PriceQuarantineVerdictParamNameType'CURRENT_PRICE
  "LAST_VALID_PRICE" -> P.Right PriceQuarantineVerdictParamNameType'LAST_VALID_PRICE
  "MIN_PRICE" -> P.Right PriceQuarantineVerdictParamNameType'MIN_PRICE
  "CURRENCY" -> P.Right PriceQuarantineVerdictParamNameType'CURRENCY
  s -> P.Left $ "toPriceQuarantineVerdictParamNameType: enum parse failure: " P.++ P.show s


-- ** PriceQuarantineVerdictType

-- | Enum of 'Text' .
-- Типы карантина:  * `PRICE_CHANGE` — новая цена слишком сильно отличается от прежней. В поле `params` будет  новая цена `CURRENT_PRICE` и последняя цена до попадания в карантин `LAST_VALID_PRICE`. * `LOW_PRICE` — установленная цена слишком сильно отличается от рыночной. В поле `params` будет установленная вами цена `CURRENT_PRICE` и порог попадания в карантин `MIN_PRICE`. * `LOW_PRICE_PROMO` — цена после применения акций слишком сильно отличается от рыночной. В поле `params` будет цена после применения акций `CURRENT_PRICE` и порог попадания в карантин `MIN_PRICE`. 
data PriceQuarantineVerdictType
  = PriceQuarantineVerdictType'PRICE_CHANGE -- ^ @"PRICE_CHANGE"@
  | PriceQuarantineVerdictType'LOW_PRICE -- ^ @"LOW_PRICE"@
  | PriceQuarantineVerdictType'LOW_PRICE_PROMO -- ^ @"LOW_PRICE_PROMO"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PriceQuarantineVerdictType where toJSON = A.toJSON . fromPriceQuarantineVerdictType
instance A.FromJSON PriceQuarantineVerdictType where parseJSON o = P.either P.fail (pure . P.id) . toPriceQuarantineVerdictType =<< A.parseJSON o
instance WH.ToHttpApiData PriceQuarantineVerdictType where toQueryParam = WH.toQueryParam . fromPriceQuarantineVerdictType
instance WH.FromHttpApiData PriceQuarantineVerdictType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPriceQuarantineVerdictType
instance MimeRender MimeMultipartFormData PriceQuarantineVerdictType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PriceQuarantineVerdictType' enum
fromPriceQuarantineVerdictType :: PriceQuarantineVerdictType -> Text
fromPriceQuarantineVerdictType = \case
  PriceQuarantineVerdictType'PRICE_CHANGE -> "PRICE_CHANGE"
  PriceQuarantineVerdictType'LOW_PRICE -> "LOW_PRICE"
  PriceQuarantineVerdictType'LOW_PRICE_PROMO -> "LOW_PRICE_PROMO"

-- | parse 'PriceQuarantineVerdictType' enum
toPriceQuarantineVerdictType :: Text -> P.Either String PriceQuarantineVerdictType
toPriceQuarantineVerdictType = \case
  "PRICE_CHANGE" -> P.Right PriceQuarantineVerdictType'PRICE_CHANGE
  "LOW_PRICE" -> P.Right PriceQuarantineVerdictType'LOW_PRICE
  "LOW_PRICE_PROMO" -> P.Right PriceQuarantineVerdictType'LOW_PRICE_PROMO
  s -> P.Left $ "toPriceQuarantineVerdictType: enum parse failure: " P.++ P.show s


-- ** PriceSuggestType

-- | Enum of 'Text' .
-- Тип цены:  * `BUYBOX` — самая низкая цена на товар, по которой он продается сейчас. Эта цена обновляется в режиме реального времени. Если вы установите цену ниже, начнет показываться ваше предложение. Если для этого значения в параметре `price` указана цена, которая совпадает с вашей, значит, ваш товар уже показывается на витрине. Если кроме вас этот товар продают другие продавцы по такой же цене, их предложения также будут отображаться вместе с вашими по очереди. * `DEFAULT_OFFER` — рекомендованная Маркетом цена, которая привлекает покупателей. Рассчитывается только для популярных на сервисе товаров и обновляется раз в четыре часа. * `MIN_PRICE_MARKET` — минимальная цена на Маркете. Самая низкая цена среди всех предложений товара на Маркете во всех регионах, включая те, которые не видны на витрине. Эта цена обновляется в режиме реального времени и обеспечивает большее количество показов на Маркете, чем самая низкая или рекомендованная цена. 
data PriceSuggestType
  = PriceSuggestType'BUYBOX -- ^ @"BUYBOX"@
  | PriceSuggestType'DEFAULT_OFFER -- ^ @"DEFAULT_OFFER"@
  | PriceSuggestType'MIN_PRICE_MARKET -- ^ @"MIN_PRICE_MARKET"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PriceSuggestType where toJSON = A.toJSON . fromPriceSuggestType
instance A.FromJSON PriceSuggestType where parseJSON o = P.either P.fail (pure . P.id) . toPriceSuggestType =<< A.parseJSON o
instance WH.ToHttpApiData PriceSuggestType where toQueryParam = WH.toQueryParam . fromPriceSuggestType
instance WH.FromHttpApiData PriceSuggestType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPriceSuggestType
instance MimeRender MimeMultipartFormData PriceSuggestType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PriceSuggestType' enum
fromPriceSuggestType :: PriceSuggestType -> Text
fromPriceSuggestType = \case
  PriceSuggestType'BUYBOX -> "BUYBOX"
  PriceSuggestType'DEFAULT_OFFER -> "DEFAULT_OFFER"
  PriceSuggestType'MIN_PRICE_MARKET -> "MIN_PRICE_MARKET"

-- | parse 'PriceSuggestType' enum
toPriceSuggestType :: Text -> P.Either String PriceSuggestType
toPriceSuggestType = \case
  "BUYBOX" -> P.Right PriceSuggestType'BUYBOX
  "DEFAULT_OFFER" -> P.Right PriceSuggestType'DEFAULT_OFFER
  "MIN_PRICE_MARKET" -> P.Right PriceSuggestType'MIN_PRICE_MARKET
  s -> P.Left $ "toPriceSuggestType: enum parse failure: " P.++ P.show s


-- ** PromoOfferParticipationStatusFilterType

-- | Enum of 'Text' .
-- Фильтр для товаров, которые добавлены в акцию вручную:  * `MANUALLY_ADDED` — товары, которые добавлены вручную.  * `NOT_MANUALLY_ADDED`— товары, которые не участвуют в акции и те, которые добавлены автоматически.  Если не передать параметр `statusType`, вернутся все товары.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
data PromoOfferParticipationStatusFilterType
  = PromoOfferParticipationStatusFilterType'MANUALLY_ADDED -- ^ @"MANUALLY_ADDED"@
  | PromoOfferParticipationStatusFilterType'NOT_MANUALLY_ADDED -- ^ @"NOT_MANUALLY_ADDED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PromoOfferParticipationStatusFilterType where toJSON = A.toJSON . fromPromoOfferParticipationStatusFilterType
instance A.FromJSON PromoOfferParticipationStatusFilterType where parseJSON o = P.either P.fail (pure . P.id) . toPromoOfferParticipationStatusFilterType =<< A.parseJSON o
instance WH.ToHttpApiData PromoOfferParticipationStatusFilterType where toQueryParam = WH.toQueryParam . fromPromoOfferParticipationStatusFilterType
instance WH.FromHttpApiData PromoOfferParticipationStatusFilterType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPromoOfferParticipationStatusFilterType
instance MimeRender MimeMultipartFormData PromoOfferParticipationStatusFilterType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PromoOfferParticipationStatusFilterType' enum
fromPromoOfferParticipationStatusFilterType :: PromoOfferParticipationStatusFilterType -> Text
fromPromoOfferParticipationStatusFilterType = \case
  PromoOfferParticipationStatusFilterType'MANUALLY_ADDED -> "MANUALLY_ADDED"
  PromoOfferParticipationStatusFilterType'NOT_MANUALLY_ADDED -> "NOT_MANUALLY_ADDED"

-- | parse 'PromoOfferParticipationStatusFilterType' enum
toPromoOfferParticipationStatusFilterType :: Text -> P.Either String PromoOfferParticipationStatusFilterType
toPromoOfferParticipationStatusFilterType = \case
  "MANUALLY_ADDED" -> P.Right PromoOfferParticipationStatusFilterType'MANUALLY_ADDED
  "NOT_MANUALLY_ADDED" -> P.Right PromoOfferParticipationStatusFilterType'NOT_MANUALLY_ADDED
  s -> P.Left $ "toPromoOfferParticipationStatusFilterType: enum parse failure: " P.++ P.show s


-- ** PromoOfferParticipationStatusType

-- | Enum of 'Text' .
-- Статус товара в акции:  * `AUTO` — добавлен автоматически во всех магазинах кабинета, в которых товар доступен для покупки.  * `PARTIALLY_AUTO` — добавлен автоматически у части магазинов.  * `MANUAL` — добавлен вручную.  * `NOT_PARTICIPATING` — не участвует в акции.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
data PromoOfferParticipationStatusType
  = PromoOfferParticipationStatusType'AUTO -- ^ @"AUTO"@
  | PromoOfferParticipationStatusType'PARTIALLY_AUTO -- ^ @"PARTIALLY_AUTO"@
  | PromoOfferParticipationStatusType'MANUAL -- ^ @"MANUAL"@
  | PromoOfferParticipationStatusType'NOT_PARTICIPATING -- ^ @"NOT_PARTICIPATING"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PromoOfferParticipationStatusType where toJSON = A.toJSON . fromPromoOfferParticipationStatusType
instance A.FromJSON PromoOfferParticipationStatusType where parseJSON o = P.either P.fail (pure . P.id) . toPromoOfferParticipationStatusType =<< A.parseJSON o
instance WH.ToHttpApiData PromoOfferParticipationStatusType where toQueryParam = WH.toQueryParam . fromPromoOfferParticipationStatusType
instance WH.FromHttpApiData PromoOfferParticipationStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPromoOfferParticipationStatusType
instance MimeRender MimeMultipartFormData PromoOfferParticipationStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PromoOfferParticipationStatusType' enum
fromPromoOfferParticipationStatusType :: PromoOfferParticipationStatusType -> Text
fromPromoOfferParticipationStatusType = \case
  PromoOfferParticipationStatusType'AUTO -> "AUTO"
  PromoOfferParticipationStatusType'PARTIALLY_AUTO -> "PARTIALLY_AUTO"
  PromoOfferParticipationStatusType'MANUAL -> "MANUAL"
  PromoOfferParticipationStatusType'NOT_PARTICIPATING -> "NOT_PARTICIPATING"

-- | parse 'PromoOfferParticipationStatusType' enum
toPromoOfferParticipationStatusType :: Text -> P.Either String PromoOfferParticipationStatusType
toPromoOfferParticipationStatusType = \case
  "AUTO" -> P.Right PromoOfferParticipationStatusType'AUTO
  "PARTIALLY_AUTO" -> P.Right PromoOfferParticipationStatusType'PARTIALLY_AUTO
  "MANUAL" -> P.Right PromoOfferParticipationStatusType'MANUAL
  "NOT_PARTICIPATING" -> P.Right PromoOfferParticipationStatusType'NOT_PARTICIPATING
  s -> P.Left $ "toPromoOfferParticipationStatusType: enum parse failure: " P.++ P.show s


-- ** PromoOfferUpdateWarningCodeType

-- | Enum of 'Text' .
-- Предупреждение, которое появилось при добавлении товара:  * `DEEP_DISCOUNT_OFFER` — большая разница с ценой в каталоге. Проверьте, нет ли ошибки.  * `CATALOG_PRICE_IS_LOWER_THAN_PROMO` — [базовая цена](*basic-price) в кабинете ниже цены по акции. У товара в акции будет отображаться базовая цена.  * `SHOP_PRICES_ARE_LOWER_THAN_PROMO` — цена в отдельном магазине ниже цены по акции. У товара в акции будет отображаться цена в магазине. Для остальных магазинов будет действовать цена по акции.  * `PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE` — в отдельном магазине цена с учетом промокода выше максимально возможной цены. Товар не будет участвовать в акции.  * `SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO` — товар в отдельном магазине не подходит под условия акции. 
data PromoOfferUpdateWarningCodeType
  = PromoOfferUpdateWarningCodeType'DEEP_DISCOUNT_OFFER -- ^ @"DEEP_DISCOUNT_OFFER"@
  | PromoOfferUpdateWarningCodeType'CATALOG_PRICE_IS_LOWER_THAN_PROMO -- ^ @"CATALOG_PRICE_IS_LOWER_THAN_PROMO"@
  | PromoOfferUpdateWarningCodeType'SHOP_PRICES_ARE_LOWER_THAN_PROMO -- ^ @"SHOP_PRICES_ARE_LOWER_THAN_PROMO"@
  | PromoOfferUpdateWarningCodeType'PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE -- ^ @"PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE"@
  | PromoOfferUpdateWarningCodeType'SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO -- ^ @"SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PromoOfferUpdateWarningCodeType where toJSON = A.toJSON . fromPromoOfferUpdateWarningCodeType
instance A.FromJSON PromoOfferUpdateWarningCodeType where parseJSON o = P.either P.fail (pure . P.id) . toPromoOfferUpdateWarningCodeType =<< A.parseJSON o
instance WH.ToHttpApiData PromoOfferUpdateWarningCodeType where toQueryParam = WH.toQueryParam . fromPromoOfferUpdateWarningCodeType
instance WH.FromHttpApiData PromoOfferUpdateWarningCodeType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPromoOfferUpdateWarningCodeType
instance MimeRender MimeMultipartFormData PromoOfferUpdateWarningCodeType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PromoOfferUpdateWarningCodeType' enum
fromPromoOfferUpdateWarningCodeType :: PromoOfferUpdateWarningCodeType -> Text
fromPromoOfferUpdateWarningCodeType = \case
  PromoOfferUpdateWarningCodeType'DEEP_DISCOUNT_OFFER -> "DEEP_DISCOUNT_OFFER"
  PromoOfferUpdateWarningCodeType'CATALOG_PRICE_IS_LOWER_THAN_PROMO -> "CATALOG_PRICE_IS_LOWER_THAN_PROMO"
  PromoOfferUpdateWarningCodeType'SHOP_PRICES_ARE_LOWER_THAN_PROMO -> "SHOP_PRICES_ARE_LOWER_THAN_PROMO"
  PromoOfferUpdateWarningCodeType'PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE -> "PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE"
  PromoOfferUpdateWarningCodeType'SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO -> "SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO"

-- | parse 'PromoOfferUpdateWarningCodeType' enum
toPromoOfferUpdateWarningCodeType :: Text -> P.Either String PromoOfferUpdateWarningCodeType
toPromoOfferUpdateWarningCodeType = \case
  "DEEP_DISCOUNT_OFFER" -> P.Right PromoOfferUpdateWarningCodeType'DEEP_DISCOUNT_OFFER
  "CATALOG_PRICE_IS_LOWER_THAN_PROMO" -> P.Right PromoOfferUpdateWarningCodeType'CATALOG_PRICE_IS_LOWER_THAN_PROMO
  "SHOP_PRICES_ARE_LOWER_THAN_PROMO" -> P.Right PromoOfferUpdateWarningCodeType'SHOP_PRICES_ARE_LOWER_THAN_PROMO
  "PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE" -> P.Right PromoOfferUpdateWarningCodeType'PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE
  "SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO" -> P.Right PromoOfferUpdateWarningCodeType'SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO
  s -> P.Left $ "toPromoOfferUpdateWarningCodeType: enum parse failure: " P.++ P.show s


-- ** PromoParticipationType

-- | Enum of 'Text' .
-- Какие акции вернутся:  * `PARTICIPATING_NOW` — текущие и будущие акции продавца.  * `PARTICIPATED` — завершенные акции продавца за последний год. Если за год их было меньше 15, в ответе придут 15 последних акций за все время. 
data PromoParticipationType
  = PromoParticipationType'PARTICIPATING_NOW -- ^ @"PARTICIPATING_NOW"@
  | PromoParticipationType'PARTICIPATED -- ^ @"PARTICIPATED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PromoParticipationType where toJSON = A.toJSON . fromPromoParticipationType
instance A.FromJSON PromoParticipationType where parseJSON o = P.either P.fail (pure . P.id) . toPromoParticipationType =<< A.parseJSON o
instance WH.ToHttpApiData PromoParticipationType where toQueryParam = WH.toQueryParam . fromPromoParticipationType
instance WH.FromHttpApiData PromoParticipationType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPromoParticipationType
instance MimeRender MimeMultipartFormData PromoParticipationType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PromoParticipationType' enum
fromPromoParticipationType :: PromoParticipationType -> Text
fromPromoParticipationType = \case
  PromoParticipationType'PARTICIPATING_NOW -> "PARTICIPATING_NOW"
  PromoParticipationType'PARTICIPATED -> "PARTICIPATED"

-- | parse 'PromoParticipationType' enum
toPromoParticipationType :: Text -> P.Either String PromoParticipationType
toPromoParticipationType = \case
  "PARTICIPATING_NOW" -> P.Right PromoParticipationType'PARTICIPATING_NOW
  "PARTICIPATED" -> P.Right PromoParticipationType'PARTICIPATED
  s -> P.Left $ "toPromoParticipationType: enum parse failure: " P.++ P.show s


-- ** QualityRatingComponentType

-- | Enum of 'Text' .
-- Составляющие индекса качества.  **Для модели DBS:** * `DBS_CANCELLATION_RATE` — доля отмененных товаров. * `DBS_LATE_DELIVERY_RATE` — доля заказов, доставленных после плановой даты.  **Для моделей FBS и Экспресс:** * `FBS_CANCELLATION_RATE` — доля отмененных товаров. * `FBS_LATE_SHIP_RATE` — доля не вовремя отгруженных заказов.  **Для модели FBY:** * `FBY_LATE_DELIVERY_RATE` — доля товаров, которые приехали на склад с опозданием. * `FBY_CANCELLATION_RATE` — доля отмененных или недоставленных товаров. * `FBY_DELIVERY_DIFF_RATE` — доля товаров, которые не прибыли вместе с поставкой или которые не приняли. * `FBY_LATE_EDITING_RATE` — доля товаров, которые поздно убрали из заявки. 
data QualityRatingComponentType
  = QualityRatingComponentType'DBS_CANCELLATION_RATE -- ^ @"DBS_CANCELLATION_RATE"@
  | QualityRatingComponentType'DBS_LATE_DELIVERY_RATE -- ^ @"DBS_LATE_DELIVERY_RATE"@
  | QualityRatingComponentType'FBS_CANCELLATION_RATE -- ^ @"FBS_CANCELLATION_RATE"@
  | QualityRatingComponentType'FBS_LATE_SHIP_RATE -- ^ @"FBS_LATE_SHIP_RATE"@
  | QualityRatingComponentType'FBY_LATE_DELIVERY_RATE -- ^ @"FBY_LATE_DELIVERY_RATE"@
  | QualityRatingComponentType'FBY_CANCELLATION_RATE -- ^ @"FBY_CANCELLATION_RATE"@
  | QualityRatingComponentType'FBY_DELIVERY_DIFF_RATE -- ^ @"FBY_DELIVERY_DIFF_RATE"@
  | QualityRatingComponentType'FBY_LATE_EDITING_RATE -- ^ @"FBY_LATE_EDITING_RATE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON QualityRatingComponentType where toJSON = A.toJSON . fromQualityRatingComponentType
instance A.FromJSON QualityRatingComponentType where parseJSON o = P.either P.fail (pure . P.id) . toQualityRatingComponentType =<< A.parseJSON o
instance WH.ToHttpApiData QualityRatingComponentType where toQueryParam = WH.toQueryParam . fromQualityRatingComponentType
instance WH.FromHttpApiData QualityRatingComponentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toQualityRatingComponentType
instance MimeRender MimeMultipartFormData QualityRatingComponentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'QualityRatingComponentType' enum
fromQualityRatingComponentType :: QualityRatingComponentType -> Text
fromQualityRatingComponentType = \case
  QualityRatingComponentType'DBS_CANCELLATION_RATE -> "DBS_CANCELLATION_RATE"
  QualityRatingComponentType'DBS_LATE_DELIVERY_RATE -> "DBS_LATE_DELIVERY_RATE"
  QualityRatingComponentType'FBS_CANCELLATION_RATE -> "FBS_CANCELLATION_RATE"
  QualityRatingComponentType'FBS_LATE_SHIP_RATE -> "FBS_LATE_SHIP_RATE"
  QualityRatingComponentType'FBY_LATE_DELIVERY_RATE -> "FBY_LATE_DELIVERY_RATE"
  QualityRatingComponentType'FBY_CANCELLATION_RATE -> "FBY_CANCELLATION_RATE"
  QualityRatingComponentType'FBY_DELIVERY_DIFF_RATE -> "FBY_DELIVERY_DIFF_RATE"
  QualityRatingComponentType'FBY_LATE_EDITING_RATE -> "FBY_LATE_EDITING_RATE"

-- | parse 'QualityRatingComponentType' enum
toQualityRatingComponentType :: Text -> P.Either String QualityRatingComponentType
toQualityRatingComponentType = \case
  "DBS_CANCELLATION_RATE" -> P.Right QualityRatingComponentType'DBS_CANCELLATION_RATE
  "DBS_LATE_DELIVERY_RATE" -> P.Right QualityRatingComponentType'DBS_LATE_DELIVERY_RATE
  "FBS_CANCELLATION_RATE" -> P.Right QualityRatingComponentType'FBS_CANCELLATION_RATE
  "FBS_LATE_SHIP_RATE" -> P.Right QualityRatingComponentType'FBS_LATE_SHIP_RATE
  "FBY_LATE_DELIVERY_RATE" -> P.Right QualityRatingComponentType'FBY_LATE_DELIVERY_RATE
  "FBY_CANCELLATION_RATE" -> P.Right QualityRatingComponentType'FBY_CANCELLATION_RATE
  "FBY_DELIVERY_DIFF_RATE" -> P.Right QualityRatingComponentType'FBY_DELIVERY_DIFF_RATE
  "FBY_LATE_EDITING_RATE" -> P.Right QualityRatingComponentType'FBY_LATE_EDITING_RATE
  s -> P.Left $ "toQualityRatingComponentType: enum parse failure: " P.++ P.show s


-- ** RecipientType

-- | Enum of 'Text' .
-- Способ возврата товара покупателем:  * `SHOP` — в точку возврата магазина.  * `DELIVERY_SERVICE` — отправить курьером.  * `POST` — почта. 
data RecipientType
  = RecipientType'SHOP -- ^ @"SHOP"@
  | RecipientType'DELIVERY_SERVICE -- ^ @"DELIVERY_SERVICE"@
  | RecipientType'POST -- ^ @"POST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RecipientType where toJSON = A.toJSON . fromRecipientType
instance A.FromJSON RecipientType where parseJSON o = P.either P.fail (pure . P.id) . toRecipientType =<< A.parseJSON o
instance WH.ToHttpApiData RecipientType where toQueryParam = WH.toQueryParam . fromRecipientType
instance WH.FromHttpApiData RecipientType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRecipientType
instance MimeRender MimeMultipartFormData RecipientType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RecipientType' enum
fromRecipientType :: RecipientType -> Text
fromRecipientType = \case
  RecipientType'SHOP -> "SHOP"
  RecipientType'DELIVERY_SERVICE -> "DELIVERY_SERVICE"
  RecipientType'POST -> "POST"

-- | parse 'RecipientType' enum
toRecipientType :: Text -> P.Either String RecipientType
toRecipientType = \case
  "SHOP" -> P.Right RecipientType'SHOP
  "DELIVERY_SERVICE" -> P.Right RecipientType'DELIVERY_SERVICE
  "POST" -> P.Right RecipientType'POST
  s -> P.Left $ "toRecipientType: enum parse failure: " P.++ P.show s


-- ** RefundStatusType

-- | Enum of 'Text' .
-- Cтатус возврата денег:  * `STARTED_BY_USER` — создан клиентом из личного кабинета.  * `REFUND_IN_PROGRESS` — ждет решение о возврате денег.  * `REFUNDED` — по возврату проведены все возвратные денежные транзакции.  * `FAILED` — невозможно провести возврат покупателю.  * `WAITING_FOR_DECISION` — ожидает решения.  * `DECISION_MADE` — по возврату принято решение.  * `REFUNDED_WITH_BONUSES` — возврат осуществлен баллами Плюса или промокодом.  * `REFUNDED_BY_SHOP` — магазин сделал самостоятельно возврат денег.  * `COMPLETE_WITHOUT_REFUND` — возврат денег не требуется.  * `CANCELLED` — возврат отменен. 
data RefundStatusType
  = RefundStatusType'STARTED_BY_USER -- ^ @"STARTED_BY_USER"@
  | RefundStatusType'REFUND_IN_PROGRESS -- ^ @"REFUND_IN_PROGRESS"@
  | RefundStatusType'REFUNDED -- ^ @"REFUNDED"@
  | RefundStatusType'FAILED -- ^ @"FAILED"@
  | RefundStatusType'WAITING_FOR_DECISION -- ^ @"WAITING_FOR_DECISION"@
  | RefundStatusType'DECISION_MADE -- ^ @"DECISION_MADE"@
  | RefundStatusType'REFUNDED_WITH_BONUSES -- ^ @"REFUNDED_WITH_BONUSES"@
  | RefundStatusType'REFUNDED_BY_SHOP -- ^ @"REFUNDED_BY_SHOP"@
  | RefundStatusType'CANCELLED -- ^ @"CANCELLED"@
  | RefundStatusType'COMPLETE_WITHOUT_REFUND -- ^ @"COMPLETE_WITHOUT_REFUND"@
  | RefundStatusType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RefundStatusType where toJSON = A.toJSON . fromRefundStatusType
instance A.FromJSON RefundStatusType where parseJSON o = P.either P.fail (pure . P.id) . toRefundStatusType =<< A.parseJSON o
instance WH.ToHttpApiData RefundStatusType where toQueryParam = WH.toQueryParam . fromRefundStatusType
instance WH.FromHttpApiData RefundStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRefundStatusType
instance MimeRender MimeMultipartFormData RefundStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RefundStatusType' enum
fromRefundStatusType :: RefundStatusType -> Text
fromRefundStatusType = \case
  RefundStatusType'STARTED_BY_USER -> "STARTED_BY_USER"
  RefundStatusType'REFUND_IN_PROGRESS -> "REFUND_IN_PROGRESS"
  RefundStatusType'REFUNDED -> "REFUNDED"
  RefundStatusType'FAILED -> "FAILED"
  RefundStatusType'WAITING_FOR_DECISION -> "WAITING_FOR_DECISION"
  RefundStatusType'DECISION_MADE -> "DECISION_MADE"
  RefundStatusType'REFUNDED_WITH_BONUSES -> "REFUNDED_WITH_BONUSES"
  RefundStatusType'REFUNDED_BY_SHOP -> "REFUNDED_BY_SHOP"
  RefundStatusType'CANCELLED -> "CANCELLED"
  RefundStatusType'COMPLETE_WITHOUT_REFUND -> "COMPLETE_WITHOUT_REFUND"
  RefundStatusType'UNKNOWN -> "UNKNOWN"

-- | parse 'RefundStatusType' enum
toRefundStatusType :: Text -> P.Either String RefundStatusType
toRefundStatusType = \case
  "STARTED_BY_USER" -> P.Right RefundStatusType'STARTED_BY_USER
  "REFUND_IN_PROGRESS" -> P.Right RefundStatusType'REFUND_IN_PROGRESS
  "REFUNDED" -> P.Right RefundStatusType'REFUNDED
  "FAILED" -> P.Right RefundStatusType'FAILED
  "WAITING_FOR_DECISION" -> P.Right RefundStatusType'WAITING_FOR_DECISION
  "DECISION_MADE" -> P.Right RefundStatusType'DECISION_MADE
  "REFUNDED_WITH_BONUSES" -> P.Right RefundStatusType'REFUNDED_WITH_BONUSES
  "REFUNDED_BY_SHOP" -> P.Right RefundStatusType'REFUNDED_BY_SHOP
  "CANCELLED" -> P.Right RefundStatusType'CANCELLED
  "COMPLETE_WITHOUT_REFUND" -> P.Right RefundStatusType'COMPLETE_WITHOUT_REFUND
  "UNKNOWN" -> P.Right RefundStatusType'UNKNOWN
  s -> P.Left $ "toRefundStatusType: enum parse failure: " P.++ P.show s


-- ** RegionType

-- | Enum of 'Text' .
-- Тип региона.  Возможные значения:  * `CITY_DISTRICT` — район города.  * `CITY` — крупный город.  * `CONTINENT` — континент.  * `COUNTRY_DISTRICT` — область.  * `COUNTRY` — страна.  * `REGION` — регион.  * `REPUBLIC_AREA` — район субъекта федерации.  * `REPUBLIC` — субъект федерации.  * `SUBWAY_STATION` — станция метро.  * `VILLAGE` — город.  * `OTHER` — неизвестный регион. 
data RegionType
  = RegionType'OTHER -- ^ @"OTHER"@
  | RegionType'CONTINENT -- ^ @"CONTINENT"@
  | RegionType'REGION -- ^ @"REGION"@
  | RegionType'COUNTRY -- ^ @"COUNTRY"@
  | RegionType'COUNTRY_DISTRICT -- ^ @"COUNTRY_DISTRICT"@
  | RegionType'REPUBLIC -- ^ @"REPUBLIC"@
  | RegionType'CITY -- ^ @"CITY"@
  | RegionType'VILLAGE -- ^ @"VILLAGE"@
  | RegionType'CITY_DISTRICT -- ^ @"CITY_DISTRICT"@
  | RegionType'SUBWAY_STATION -- ^ @"SUBWAY_STATION"@
  | RegionType'REPUBLIC_AREA -- ^ @"REPUBLIC_AREA"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RegionType where toJSON = A.toJSON . fromRegionType
instance A.FromJSON RegionType where parseJSON o = P.either P.fail (pure . P.id) . toRegionType =<< A.parseJSON o
instance WH.ToHttpApiData RegionType where toQueryParam = WH.toQueryParam . fromRegionType
instance WH.FromHttpApiData RegionType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRegionType
instance MimeRender MimeMultipartFormData RegionType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RegionType' enum
fromRegionType :: RegionType -> Text
fromRegionType = \case
  RegionType'OTHER -> "OTHER"
  RegionType'CONTINENT -> "CONTINENT"
  RegionType'REGION -> "REGION"
  RegionType'COUNTRY -> "COUNTRY"
  RegionType'COUNTRY_DISTRICT -> "COUNTRY_DISTRICT"
  RegionType'REPUBLIC -> "REPUBLIC"
  RegionType'CITY -> "CITY"
  RegionType'VILLAGE -> "VILLAGE"
  RegionType'CITY_DISTRICT -> "CITY_DISTRICT"
  RegionType'SUBWAY_STATION -> "SUBWAY_STATION"
  RegionType'REPUBLIC_AREA -> "REPUBLIC_AREA"

-- | parse 'RegionType' enum
toRegionType :: Text -> P.Either String RegionType
toRegionType = \case
  "OTHER" -> P.Right RegionType'OTHER
  "CONTINENT" -> P.Right RegionType'CONTINENT
  "REGION" -> P.Right RegionType'REGION
  "COUNTRY" -> P.Right RegionType'COUNTRY
  "COUNTRY_DISTRICT" -> P.Right RegionType'COUNTRY_DISTRICT
  "REPUBLIC" -> P.Right RegionType'REPUBLIC
  "CITY" -> P.Right RegionType'CITY
  "VILLAGE" -> P.Right RegionType'VILLAGE
  "CITY_DISTRICT" -> P.Right RegionType'CITY_DISTRICT
  "SUBWAY_STATION" -> P.Right RegionType'SUBWAY_STATION
  "REPUBLIC_AREA" -> P.Right RegionType'REPUBLIC_AREA
  s -> P.Left $ "toRegionType: enum parse failure: " P.++ P.show s


-- ** RejectedPromoOfferDeleteReasonType

-- | Enum of 'Text' .
-- Описание ошибки:  * `OFFER_DOES_NOT_EXIST` — в кабинете нет товара с таким SKU. 
data RejectedPromoOfferDeleteReasonType
  = RejectedPromoOfferDeleteReasonType'OFFER_DOES_NOT_EXIST -- ^ @"OFFER_DOES_NOT_EXIST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RejectedPromoOfferDeleteReasonType where toJSON = A.toJSON . fromRejectedPromoOfferDeleteReasonType
instance A.FromJSON RejectedPromoOfferDeleteReasonType where parseJSON o = P.either P.fail (pure . P.id) . toRejectedPromoOfferDeleteReasonType =<< A.parseJSON o
instance WH.ToHttpApiData RejectedPromoOfferDeleteReasonType where toQueryParam = WH.toQueryParam . fromRejectedPromoOfferDeleteReasonType
instance WH.FromHttpApiData RejectedPromoOfferDeleteReasonType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRejectedPromoOfferDeleteReasonType
instance MimeRender MimeMultipartFormData RejectedPromoOfferDeleteReasonType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RejectedPromoOfferDeleteReasonType' enum
fromRejectedPromoOfferDeleteReasonType :: RejectedPromoOfferDeleteReasonType -> Text
fromRejectedPromoOfferDeleteReasonType = \case
  RejectedPromoOfferDeleteReasonType'OFFER_DOES_NOT_EXIST -> "OFFER_DOES_NOT_EXIST"

-- | parse 'RejectedPromoOfferDeleteReasonType' enum
toRejectedPromoOfferDeleteReasonType :: Text -> P.Either String RejectedPromoOfferDeleteReasonType
toRejectedPromoOfferDeleteReasonType = \case
  "OFFER_DOES_NOT_EXIST" -> P.Right RejectedPromoOfferDeleteReasonType'OFFER_DOES_NOT_EXIST
  s -> P.Left $ "toRejectedPromoOfferDeleteReasonType: enum parse failure: " P.++ P.show s


-- ** RejectedPromoOfferUpdateReasonType

-- | Enum of 'Text' .
-- Причина отклонения изменения:  * `OFFER_DOES_NOT_EXIST` — в кабинете нет товара с таким SKU.  * `OFFER_DUPLICATION` — один и тот же товар передан несколько раз.  * `OFFER_NOT_ELIGIBLE_FOR_PROMO` — товар не подходит под условия акции.  * `OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED` — товар не добавлен в акцию по техническим причинам.  * `DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED` — истек срок добавления товаров в акцию.  * `EMPTY_OLD_PRICE` — не указана зачеркнутая цена.  * `EMPTY_PROMO_PRICE` — не указана цена по акции.  * `MAX_PROMO_PRICE_EXCEEDED` — цена по акции превышает максимально возможную цену для участия в акции.  * `PROMO_PRICE_BIGGER_THAN_MAX` — цена по акции больше 95% от зачеркнутой цены.  * `PROMO_PRICE_SMALLER_THAN_MIN` — цена по акции меньше 1% от зачеркнутой цены. 
data RejectedPromoOfferUpdateReasonType
  = RejectedPromoOfferUpdateReasonType'OFFER_DOES_NOT_EXIST -- ^ @"OFFER_DOES_NOT_EXIST"@
  | RejectedPromoOfferUpdateReasonType'OFFER_DUPLICATION -- ^ @"OFFER_DUPLICATION"@
  | RejectedPromoOfferUpdateReasonType'OFFER_NOT_ELIGIBLE_FOR_PROMO -- ^ @"OFFER_NOT_ELIGIBLE_FOR_PROMO"@
  | RejectedPromoOfferUpdateReasonType'OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED -- ^ @"OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED"@
  | RejectedPromoOfferUpdateReasonType'DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED -- ^ @"DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED"@
  | RejectedPromoOfferUpdateReasonType'EMPTY_OLD_PRICE -- ^ @"EMPTY_OLD_PRICE"@
  | RejectedPromoOfferUpdateReasonType'EMPTY_PROMO_PRICE -- ^ @"EMPTY_PROMO_PRICE"@
  | RejectedPromoOfferUpdateReasonType'MAX_PROMO_PRICE_EXCEEDED -- ^ @"MAX_PROMO_PRICE_EXCEEDED"@
  | RejectedPromoOfferUpdateReasonType'PROMO_PRICE_BIGGER_THAN_MAX -- ^ @"PROMO_PRICE_BIGGER_THAN_MAX"@
  | RejectedPromoOfferUpdateReasonType'PROMO_PRICE_SMALLER_THAN_MIN -- ^ @"PROMO_PRICE_SMALLER_THAN_MIN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RejectedPromoOfferUpdateReasonType where toJSON = A.toJSON . fromRejectedPromoOfferUpdateReasonType
instance A.FromJSON RejectedPromoOfferUpdateReasonType where parseJSON o = P.either P.fail (pure . P.id) . toRejectedPromoOfferUpdateReasonType =<< A.parseJSON o
instance WH.ToHttpApiData RejectedPromoOfferUpdateReasonType where toQueryParam = WH.toQueryParam . fromRejectedPromoOfferUpdateReasonType
instance WH.FromHttpApiData RejectedPromoOfferUpdateReasonType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRejectedPromoOfferUpdateReasonType
instance MimeRender MimeMultipartFormData RejectedPromoOfferUpdateReasonType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RejectedPromoOfferUpdateReasonType' enum
fromRejectedPromoOfferUpdateReasonType :: RejectedPromoOfferUpdateReasonType -> Text
fromRejectedPromoOfferUpdateReasonType = \case
  RejectedPromoOfferUpdateReasonType'OFFER_DOES_NOT_EXIST -> "OFFER_DOES_NOT_EXIST"
  RejectedPromoOfferUpdateReasonType'OFFER_DUPLICATION -> "OFFER_DUPLICATION"
  RejectedPromoOfferUpdateReasonType'OFFER_NOT_ELIGIBLE_FOR_PROMO -> "OFFER_NOT_ELIGIBLE_FOR_PROMO"
  RejectedPromoOfferUpdateReasonType'OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED -> "OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED"
  RejectedPromoOfferUpdateReasonType'DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED -> "DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED"
  RejectedPromoOfferUpdateReasonType'EMPTY_OLD_PRICE -> "EMPTY_OLD_PRICE"
  RejectedPromoOfferUpdateReasonType'EMPTY_PROMO_PRICE -> "EMPTY_PROMO_PRICE"
  RejectedPromoOfferUpdateReasonType'MAX_PROMO_PRICE_EXCEEDED -> "MAX_PROMO_PRICE_EXCEEDED"
  RejectedPromoOfferUpdateReasonType'PROMO_PRICE_BIGGER_THAN_MAX -> "PROMO_PRICE_BIGGER_THAN_MAX"
  RejectedPromoOfferUpdateReasonType'PROMO_PRICE_SMALLER_THAN_MIN -> "PROMO_PRICE_SMALLER_THAN_MIN"

-- | parse 'RejectedPromoOfferUpdateReasonType' enum
toRejectedPromoOfferUpdateReasonType :: Text -> P.Either String RejectedPromoOfferUpdateReasonType
toRejectedPromoOfferUpdateReasonType = \case
  "OFFER_DOES_NOT_EXIST" -> P.Right RejectedPromoOfferUpdateReasonType'OFFER_DOES_NOT_EXIST
  "OFFER_DUPLICATION" -> P.Right RejectedPromoOfferUpdateReasonType'OFFER_DUPLICATION
  "OFFER_NOT_ELIGIBLE_FOR_PROMO" -> P.Right RejectedPromoOfferUpdateReasonType'OFFER_NOT_ELIGIBLE_FOR_PROMO
  "OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED" -> P.Right RejectedPromoOfferUpdateReasonType'OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED
  "DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED" -> P.Right RejectedPromoOfferUpdateReasonType'DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED
  "EMPTY_OLD_PRICE" -> P.Right RejectedPromoOfferUpdateReasonType'EMPTY_OLD_PRICE
  "EMPTY_PROMO_PRICE" -> P.Right RejectedPromoOfferUpdateReasonType'EMPTY_PROMO_PRICE
  "MAX_PROMO_PRICE_EXCEEDED" -> P.Right RejectedPromoOfferUpdateReasonType'MAX_PROMO_PRICE_EXCEEDED
  "PROMO_PRICE_BIGGER_THAN_MAX" -> P.Right RejectedPromoOfferUpdateReasonType'PROMO_PRICE_BIGGER_THAN_MAX
  "PROMO_PRICE_SMALLER_THAN_MIN" -> P.Right RejectedPromoOfferUpdateReasonType'PROMO_PRICE_SMALLER_THAN_MIN
  s -> P.Left $ "toRejectedPromoOfferUpdateReasonType: enum parse failure: " P.++ P.show s


-- ** ReportFormatType

-- | Enum of 'Text' .
-- Формат отчета:  * `FILE` — файл с электронной таблицей. * `CSV` — ZIP-архив с CSV-файлами на каждый лист отчета. 
data ReportFormatType
  = ReportFormatType'FILE -- ^ @"FILE"@
  | ReportFormatType'CSV -- ^ @"CSV"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReportFormatType where toJSON = A.toJSON . fromReportFormatType
instance A.FromJSON ReportFormatType where parseJSON o = P.either P.fail (pure . P.id) . toReportFormatType =<< A.parseJSON o
instance WH.ToHttpApiData ReportFormatType where toQueryParam = WH.toQueryParam . fromReportFormatType
instance WH.FromHttpApiData ReportFormatType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReportFormatType
instance MimeRender MimeMultipartFormData ReportFormatType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReportFormatType' enum
fromReportFormatType :: ReportFormatType -> Text
fromReportFormatType = \case
  ReportFormatType'FILE -> "FILE"
  ReportFormatType'CSV -> "CSV"

-- | parse 'ReportFormatType' enum
toReportFormatType :: Text -> P.Either String ReportFormatType
toReportFormatType = \case
  "FILE" -> P.Right ReportFormatType'FILE
  "CSV" -> P.Right ReportFormatType'CSV
  s -> P.Left $ "toReportFormatType: enum parse failure: " P.++ P.show s


-- ** ReportStatusType

-- | Enum of 'Text' .
-- Статус генерации отчета:  * `PENDING` — отчет ожидает генерации. * `PROCESSING` — отчет генерируется. * `FAILED` — во время генерации произошла ошибка. * `DONE` — отчет готов. 
data ReportStatusType
  = ReportStatusType'PENDING -- ^ @"PENDING"@
  | ReportStatusType'PROCESSING -- ^ @"PROCESSING"@
  | ReportStatusType'FAILED -- ^ @"FAILED"@
  | ReportStatusType'DONE -- ^ @"DONE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReportStatusType where toJSON = A.toJSON . fromReportStatusType
instance A.FromJSON ReportStatusType where parseJSON o = P.either P.fail (pure . P.id) . toReportStatusType =<< A.parseJSON o
instance WH.ToHttpApiData ReportStatusType where toQueryParam = WH.toQueryParam . fromReportStatusType
instance WH.FromHttpApiData ReportStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReportStatusType
instance MimeRender MimeMultipartFormData ReportStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReportStatusType' enum
fromReportStatusType :: ReportStatusType -> Text
fromReportStatusType = \case
  ReportStatusType'PENDING -> "PENDING"
  ReportStatusType'PROCESSING -> "PROCESSING"
  ReportStatusType'FAILED -> "FAILED"
  ReportStatusType'DONE -> "DONE"

-- | parse 'ReportStatusType' enum
toReportStatusType :: Text -> P.Either String ReportStatusType
toReportStatusType = \case
  "PENDING" -> P.Right ReportStatusType'PENDING
  "PROCESSING" -> P.Right ReportStatusType'PROCESSING
  "FAILED" -> P.Right ReportStatusType'FAILED
  "DONE" -> P.Right ReportStatusType'DONE
  s -> P.Left $ "toReportStatusType: enum parse failure: " P.++ P.show s


-- ** ReportSubStatusType

-- | Enum of 'Text' .
-- Подстатус генерации отчета: * `NO_DATA` — для такого отчета нет данных. * `TOO_LARGE` — отчет превысил допустимый размер — укажите меньший период времени или уточните условия запроса. * `RESOURCE_NOT_FOUND` — для такого отчета не удалось найти часть сущностей. 
data ReportSubStatusType
  = ReportSubStatusType'NO_DATA -- ^ @"NO_DATA"@
  | ReportSubStatusType'TOO_LARGE -- ^ @"TOO_LARGE"@
  | ReportSubStatusType'RESOURCE_NOT_FOUND -- ^ @"RESOURCE_NOT_FOUND"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReportSubStatusType where toJSON = A.toJSON . fromReportSubStatusType
instance A.FromJSON ReportSubStatusType where parseJSON o = P.either P.fail (pure . P.id) . toReportSubStatusType =<< A.parseJSON o
instance WH.ToHttpApiData ReportSubStatusType where toQueryParam = WH.toQueryParam . fromReportSubStatusType
instance WH.FromHttpApiData ReportSubStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReportSubStatusType
instance MimeRender MimeMultipartFormData ReportSubStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReportSubStatusType' enum
fromReportSubStatusType :: ReportSubStatusType -> Text
fromReportSubStatusType = \case
  ReportSubStatusType'NO_DATA -> "NO_DATA"
  ReportSubStatusType'TOO_LARGE -> "TOO_LARGE"
  ReportSubStatusType'RESOURCE_NOT_FOUND -> "RESOURCE_NOT_FOUND"

-- | parse 'ReportSubStatusType' enum
toReportSubStatusType :: Text -> P.Either String ReportSubStatusType
toReportSubStatusType = \case
  "NO_DATA" -> P.Right ReportSubStatusType'NO_DATA
  "TOO_LARGE" -> P.Right ReportSubStatusType'TOO_LARGE
  "RESOURCE_NOT_FOUND" -> P.Right ReportSubStatusType'RESOURCE_NOT_FOUND
  s -> P.Left $ "toReportSubStatusType: enum parse failure: " P.++ P.show s


-- ** ReturnDecisionReasonType

-- | Enum of 'Text' .
-- Причины возврата:  * `BAD_QUALITY` — бракованный товар (есть недостатки).  * `DO_NOT_FIT` — товар не подошел.  * `WRONG_ITEM` — привезли не тот товар.  * `DAMAGE_DELIVERY` — товар поврежден при доставке.  * `LOYALTY_FAIL` — невозможно установить виновного в браке/пересорте.  * `CONTENT_FAIL` — ошибочное описание товара по вине Маркета.  * `UNKNOWN` — причина не известна. 
data ReturnDecisionReasonType
  = ReturnDecisionReasonType'BAD_QUALITY -- ^ @"BAD_QUALITY"@
  | ReturnDecisionReasonType'DOES_NOT_FIT -- ^ @"DOES_NOT_FIT"@
  | ReturnDecisionReasonType'WRONG_ITEM -- ^ @"WRONG_ITEM"@
  | ReturnDecisionReasonType'DAMAGE_DELIVERY -- ^ @"DAMAGE_DELIVERY"@
  | ReturnDecisionReasonType'LOYALTY_FAIL -- ^ @"LOYALTY_FAIL"@
  | ReturnDecisionReasonType'CONTENT_FAIL -- ^ @"CONTENT_FAIL"@
  | ReturnDecisionReasonType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReturnDecisionReasonType where toJSON = A.toJSON . fromReturnDecisionReasonType
instance A.FromJSON ReturnDecisionReasonType where parseJSON o = P.either P.fail (pure . P.id) . toReturnDecisionReasonType =<< A.parseJSON o
instance WH.ToHttpApiData ReturnDecisionReasonType where toQueryParam = WH.toQueryParam . fromReturnDecisionReasonType
instance WH.FromHttpApiData ReturnDecisionReasonType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReturnDecisionReasonType
instance MimeRender MimeMultipartFormData ReturnDecisionReasonType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReturnDecisionReasonType' enum
fromReturnDecisionReasonType :: ReturnDecisionReasonType -> Text
fromReturnDecisionReasonType = \case
  ReturnDecisionReasonType'BAD_QUALITY -> "BAD_QUALITY"
  ReturnDecisionReasonType'DOES_NOT_FIT -> "DOES_NOT_FIT"
  ReturnDecisionReasonType'WRONG_ITEM -> "WRONG_ITEM"
  ReturnDecisionReasonType'DAMAGE_DELIVERY -> "DAMAGE_DELIVERY"
  ReturnDecisionReasonType'LOYALTY_FAIL -> "LOYALTY_FAIL"
  ReturnDecisionReasonType'CONTENT_FAIL -> "CONTENT_FAIL"
  ReturnDecisionReasonType'UNKNOWN -> "UNKNOWN"

-- | parse 'ReturnDecisionReasonType' enum
toReturnDecisionReasonType :: Text -> P.Either String ReturnDecisionReasonType
toReturnDecisionReasonType = \case
  "BAD_QUALITY" -> P.Right ReturnDecisionReasonType'BAD_QUALITY
  "DOES_NOT_FIT" -> P.Right ReturnDecisionReasonType'DOES_NOT_FIT
  "WRONG_ITEM" -> P.Right ReturnDecisionReasonType'WRONG_ITEM
  "DAMAGE_DELIVERY" -> P.Right ReturnDecisionReasonType'DAMAGE_DELIVERY
  "LOYALTY_FAIL" -> P.Right ReturnDecisionReasonType'LOYALTY_FAIL
  "CONTENT_FAIL" -> P.Right ReturnDecisionReasonType'CONTENT_FAIL
  "UNKNOWN" -> P.Right ReturnDecisionReasonType'UNKNOWN
  s -> P.Left $ "toReturnDecisionReasonType: enum parse failure: " P.++ P.show s


-- ** ReturnDecisionSubreasonType

-- | Enum of 'Text' .
-- Детали причин возврата:   * `DO_NOT_FIT`:     * `USER_DID_NOT_LIKE` — товар не понравился.     * `USER_CHANGED_MIND` — передумал покупать.     * `DELIVERED_TOO_LONG` — длительный срок доставки, поэтому передумал.    * `BAD_QUALITY`:     * `BAD_PACKAGE` — упаковка товара была нарушена.     * `DAMAGED` — царапины, сколы.     * `NOT_WORKING` — не включается / не работает.     * `INCOMPLETENESS` — некомплект (не хватает детали в наборе, к товару).    * `WRONG_ITEM`:     * `WRONG_ITEM` — не тот товар.     * `WRONG_COLOR` — не соответствует по цвету.     * `DID_NOT_MATCH_DESCRIPTION` — не соответствует заявленным характеристикам/описанию. 
data ReturnDecisionSubreasonType
  = ReturnDecisionSubreasonType'USER_DID_NOT_LIKE -- ^ @"USER_DID_NOT_LIKE"@
  | ReturnDecisionSubreasonType'USER_CHANGED_MIND -- ^ @"USER_CHANGED_MIND"@
  | ReturnDecisionSubreasonType'DELIVERED_TOO_LONG -- ^ @"DELIVERED_TOO_LONG"@
  | ReturnDecisionSubreasonType'BAD_PACKAGE -- ^ @"BAD_PACKAGE"@
  | ReturnDecisionSubreasonType'DAMAGED -- ^ @"DAMAGED"@
  | ReturnDecisionSubreasonType'NOT_WORKING -- ^ @"NOT_WORKING"@
  | ReturnDecisionSubreasonType'INCOMPLETENESS -- ^ @"INCOMPLETENESS"@
  | ReturnDecisionSubreasonType'WRONG_ITEM -- ^ @"WRONG_ITEM"@
  | ReturnDecisionSubreasonType'WRONG_COLOR -- ^ @"WRONG_COLOR"@
  | ReturnDecisionSubreasonType'DID_NOT_MATCH_DESCRIPTION -- ^ @"DID_NOT_MATCH_DESCRIPTION"@
  | ReturnDecisionSubreasonType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReturnDecisionSubreasonType where toJSON = A.toJSON . fromReturnDecisionSubreasonType
instance A.FromJSON ReturnDecisionSubreasonType where parseJSON o = P.either P.fail (pure . P.id) . toReturnDecisionSubreasonType =<< A.parseJSON o
instance WH.ToHttpApiData ReturnDecisionSubreasonType where toQueryParam = WH.toQueryParam . fromReturnDecisionSubreasonType
instance WH.FromHttpApiData ReturnDecisionSubreasonType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReturnDecisionSubreasonType
instance MimeRender MimeMultipartFormData ReturnDecisionSubreasonType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReturnDecisionSubreasonType' enum
fromReturnDecisionSubreasonType :: ReturnDecisionSubreasonType -> Text
fromReturnDecisionSubreasonType = \case
  ReturnDecisionSubreasonType'USER_DID_NOT_LIKE -> "USER_DID_NOT_LIKE"
  ReturnDecisionSubreasonType'USER_CHANGED_MIND -> "USER_CHANGED_MIND"
  ReturnDecisionSubreasonType'DELIVERED_TOO_LONG -> "DELIVERED_TOO_LONG"
  ReturnDecisionSubreasonType'BAD_PACKAGE -> "BAD_PACKAGE"
  ReturnDecisionSubreasonType'DAMAGED -> "DAMAGED"
  ReturnDecisionSubreasonType'NOT_WORKING -> "NOT_WORKING"
  ReturnDecisionSubreasonType'INCOMPLETENESS -> "INCOMPLETENESS"
  ReturnDecisionSubreasonType'WRONG_ITEM -> "WRONG_ITEM"
  ReturnDecisionSubreasonType'WRONG_COLOR -> "WRONG_COLOR"
  ReturnDecisionSubreasonType'DID_NOT_MATCH_DESCRIPTION -> "DID_NOT_MATCH_DESCRIPTION"
  ReturnDecisionSubreasonType'UNKNOWN -> "UNKNOWN"

-- | parse 'ReturnDecisionSubreasonType' enum
toReturnDecisionSubreasonType :: Text -> P.Either String ReturnDecisionSubreasonType
toReturnDecisionSubreasonType = \case
  "USER_DID_NOT_LIKE" -> P.Right ReturnDecisionSubreasonType'USER_DID_NOT_LIKE
  "USER_CHANGED_MIND" -> P.Right ReturnDecisionSubreasonType'USER_CHANGED_MIND
  "DELIVERED_TOO_LONG" -> P.Right ReturnDecisionSubreasonType'DELIVERED_TOO_LONG
  "BAD_PACKAGE" -> P.Right ReturnDecisionSubreasonType'BAD_PACKAGE
  "DAMAGED" -> P.Right ReturnDecisionSubreasonType'DAMAGED
  "NOT_WORKING" -> P.Right ReturnDecisionSubreasonType'NOT_WORKING
  "INCOMPLETENESS" -> P.Right ReturnDecisionSubreasonType'INCOMPLETENESS
  "WRONG_ITEM" -> P.Right ReturnDecisionSubreasonType'WRONG_ITEM
  "WRONG_COLOR" -> P.Right ReturnDecisionSubreasonType'WRONG_COLOR
  "DID_NOT_MATCH_DESCRIPTION" -> P.Right ReturnDecisionSubreasonType'DID_NOT_MATCH_DESCRIPTION
  "UNKNOWN" -> P.Right ReturnDecisionSubreasonType'UNKNOWN
  s -> P.Left $ "toReturnDecisionSubreasonType: enum parse failure: " P.++ P.show s


-- ** ReturnDecisionType

-- | Enum of 'Text' .
-- Решение по возврату:  * `REFUND_MONEY` — вернуть деньги покупателю.  * `REFUND_MONEY_INCLUDING_SHIPMENT` — вернуть деньги за товар и пересылку.  * `REPAIR` — отремонтировать товар.  * `REPLACE` — заменить товар.  * `SEND_TO_EXAMINATION` — взять товар на экспертизу.  * `DECLINE_REFUND` — отказать в возврате.  * `OTHER_DECISION` — другое решение. 
data ReturnDecisionType
  = ReturnDecisionType'REFUND_MONEY -- ^ @"REFUND_MONEY"@
  | ReturnDecisionType'REFUND_MONEY_INCLUDING_SHIPMENT -- ^ @"REFUND_MONEY_INCLUDING_SHIPMENT"@
  | ReturnDecisionType'REPAIR -- ^ @"REPAIR"@
  | ReturnDecisionType'REPLACE -- ^ @"REPLACE"@
  | ReturnDecisionType'SEND_TO_EXAMINATION -- ^ @"SEND_TO_EXAMINATION"@
  | ReturnDecisionType'DECLINE_REFUND -- ^ @"DECLINE_REFUND"@
  | ReturnDecisionType'OTHER_DECISION -- ^ @"OTHER_DECISION"@
  | ReturnDecisionType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReturnDecisionType where toJSON = A.toJSON . fromReturnDecisionType
instance A.FromJSON ReturnDecisionType where parseJSON o = P.either P.fail (pure . P.id) . toReturnDecisionType =<< A.parseJSON o
instance WH.ToHttpApiData ReturnDecisionType where toQueryParam = WH.toQueryParam . fromReturnDecisionType
instance WH.FromHttpApiData ReturnDecisionType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReturnDecisionType
instance MimeRender MimeMultipartFormData ReturnDecisionType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReturnDecisionType' enum
fromReturnDecisionType :: ReturnDecisionType -> Text
fromReturnDecisionType = \case
  ReturnDecisionType'REFUND_MONEY -> "REFUND_MONEY"
  ReturnDecisionType'REFUND_MONEY_INCLUDING_SHIPMENT -> "REFUND_MONEY_INCLUDING_SHIPMENT"
  ReturnDecisionType'REPAIR -> "REPAIR"
  ReturnDecisionType'REPLACE -> "REPLACE"
  ReturnDecisionType'SEND_TO_EXAMINATION -> "SEND_TO_EXAMINATION"
  ReturnDecisionType'DECLINE_REFUND -> "DECLINE_REFUND"
  ReturnDecisionType'OTHER_DECISION -> "OTHER_DECISION"
  ReturnDecisionType'UNKNOWN -> "UNKNOWN"

-- | parse 'ReturnDecisionType' enum
toReturnDecisionType :: Text -> P.Either String ReturnDecisionType
toReturnDecisionType = \case
  "REFUND_MONEY" -> P.Right ReturnDecisionType'REFUND_MONEY
  "REFUND_MONEY_INCLUDING_SHIPMENT" -> P.Right ReturnDecisionType'REFUND_MONEY_INCLUDING_SHIPMENT
  "REPAIR" -> P.Right ReturnDecisionType'REPAIR
  "REPLACE" -> P.Right ReturnDecisionType'REPLACE
  "SEND_TO_EXAMINATION" -> P.Right ReturnDecisionType'SEND_TO_EXAMINATION
  "DECLINE_REFUND" -> P.Right ReturnDecisionType'DECLINE_REFUND
  "OTHER_DECISION" -> P.Right ReturnDecisionType'OTHER_DECISION
  "UNKNOWN" -> P.Right ReturnDecisionType'UNKNOWN
  s -> P.Left $ "toReturnDecisionType: enum parse failure: " P.++ P.show s


-- ** ReturnInstanceStatusType

-- | Enum of 'Text' .
-- Логистический статус конкретного товара.
data ReturnInstanceStatusType
  = ReturnInstanceStatusType'CREATED -- ^ @"CREATED"@
  | ReturnInstanceStatusType'RECEIVED -- ^ @"RECEIVED"@
  | ReturnInstanceStatusType'IN_TRANSIT -- ^ @"IN_TRANSIT"@
  | ReturnInstanceStatusType'READY_FOR_PICKUP -- ^ @"READY_FOR_PICKUP"@
  | ReturnInstanceStatusType'PICKED -- ^ @"PICKED"@
  | ReturnInstanceStatusType'RECEIVED_ON_FULFILLMENT -- ^ @"RECEIVED_ON_FULFILLMENT"@
  | ReturnInstanceStatusType'CANCELLED -- ^ @"CANCELLED"@
  | ReturnInstanceStatusType'LOST -- ^ @"LOST"@
  | ReturnInstanceStatusType'UTILIZED -- ^ @"UTILIZED"@
  | ReturnInstanceStatusType'PREPARED_FOR_UTILIZATION -- ^ @"PREPARED_FOR_UTILIZATION"@
  | ReturnInstanceStatusType'EXPROPRIATED -- ^ @"EXPROPRIATED"@
  | ReturnInstanceStatusType'NOT_IN_DEMAND -- ^ @"NOT_IN_DEMAND"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReturnInstanceStatusType where toJSON = A.toJSON . fromReturnInstanceStatusType
instance A.FromJSON ReturnInstanceStatusType where parseJSON o = P.either P.fail (pure . P.id) . toReturnInstanceStatusType =<< A.parseJSON o
instance WH.ToHttpApiData ReturnInstanceStatusType where toQueryParam = WH.toQueryParam . fromReturnInstanceStatusType
instance WH.FromHttpApiData ReturnInstanceStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReturnInstanceStatusType
instance MimeRender MimeMultipartFormData ReturnInstanceStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReturnInstanceStatusType' enum
fromReturnInstanceStatusType :: ReturnInstanceStatusType -> Text
fromReturnInstanceStatusType = \case
  ReturnInstanceStatusType'CREATED -> "CREATED"
  ReturnInstanceStatusType'RECEIVED -> "RECEIVED"
  ReturnInstanceStatusType'IN_TRANSIT -> "IN_TRANSIT"
  ReturnInstanceStatusType'READY_FOR_PICKUP -> "READY_FOR_PICKUP"
  ReturnInstanceStatusType'PICKED -> "PICKED"
  ReturnInstanceStatusType'RECEIVED_ON_FULFILLMENT -> "RECEIVED_ON_FULFILLMENT"
  ReturnInstanceStatusType'CANCELLED -> "CANCELLED"
  ReturnInstanceStatusType'LOST -> "LOST"
  ReturnInstanceStatusType'UTILIZED -> "UTILIZED"
  ReturnInstanceStatusType'PREPARED_FOR_UTILIZATION -> "PREPARED_FOR_UTILIZATION"
  ReturnInstanceStatusType'EXPROPRIATED -> "EXPROPRIATED"
  ReturnInstanceStatusType'NOT_IN_DEMAND -> "NOT_IN_DEMAND"

-- | parse 'ReturnInstanceStatusType' enum
toReturnInstanceStatusType :: Text -> P.Either String ReturnInstanceStatusType
toReturnInstanceStatusType = \case
  "CREATED" -> P.Right ReturnInstanceStatusType'CREATED
  "RECEIVED" -> P.Right ReturnInstanceStatusType'RECEIVED
  "IN_TRANSIT" -> P.Right ReturnInstanceStatusType'IN_TRANSIT
  "READY_FOR_PICKUP" -> P.Right ReturnInstanceStatusType'READY_FOR_PICKUP
  "PICKED" -> P.Right ReturnInstanceStatusType'PICKED
  "RECEIVED_ON_FULFILLMENT" -> P.Right ReturnInstanceStatusType'RECEIVED_ON_FULFILLMENT
  "CANCELLED" -> P.Right ReturnInstanceStatusType'CANCELLED
  "LOST" -> P.Right ReturnInstanceStatusType'LOST
  "UTILIZED" -> P.Right ReturnInstanceStatusType'UTILIZED
  "PREPARED_FOR_UTILIZATION" -> P.Right ReturnInstanceStatusType'PREPARED_FOR_UTILIZATION
  "EXPROPRIATED" -> P.Right ReturnInstanceStatusType'EXPROPRIATED
  "NOT_IN_DEMAND" -> P.Right ReturnInstanceStatusType'NOT_IN_DEMAND
  s -> P.Left $ "toReturnInstanceStatusType: enum parse failure: " P.++ P.show s


-- ** ReturnInstanceStockType

-- | Enum of 'Text' .
-- Тип остатка на складе.
data ReturnInstanceStockType
  = ReturnInstanceStockType'FIT -- ^ @"FIT"@
  | ReturnInstanceStockType'DEFECT -- ^ @"DEFECT"@
  | ReturnInstanceStockType'ANOMALY -- ^ @"ANOMALY"@
  | ReturnInstanceStockType'SURPLUS -- ^ @"SURPLUS"@
  | ReturnInstanceStockType'EXPIRED -- ^ @"EXPIRED"@
  | ReturnInstanceStockType'MISGRADING -- ^ @"MISGRADING"@
  | ReturnInstanceStockType'UNDEFINED -- ^ @"UNDEFINED"@
  | ReturnInstanceStockType'INCORRECT_IMEI -- ^ @"INCORRECT_IMEI"@
  | ReturnInstanceStockType'INCORRECT_SERIAL_NUMBER -- ^ @"INCORRECT_SERIAL_NUMBER"@
  | ReturnInstanceStockType'INCORRECT_CIS -- ^ @"INCORRECT_CIS"@
  | ReturnInstanceStockType'PART_MISSING -- ^ @"PART_MISSING"@
  | ReturnInstanceStockType'NON_COMPLIENT -- ^ @"NON_COMPLIENT"@
  | ReturnInstanceStockType'NOT_ACCEPTABLE -- ^ @"NOT_ACCEPTABLE"@
  | ReturnInstanceStockType'SERVICE -- ^ @"SERVICE"@
  | ReturnInstanceStockType'MARKDOWN -- ^ @"MARKDOWN"@
  | ReturnInstanceStockType'DEMO -- ^ @"DEMO"@
  | ReturnInstanceStockType'REPAIR -- ^ @"REPAIR"@
  | ReturnInstanceStockType'FIRMWARE -- ^ @"FIRMWARE"@
  | ReturnInstanceStockType'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReturnInstanceStockType where toJSON = A.toJSON . fromReturnInstanceStockType
instance A.FromJSON ReturnInstanceStockType where parseJSON o = P.either P.fail (pure . P.id) . toReturnInstanceStockType =<< A.parseJSON o
instance WH.ToHttpApiData ReturnInstanceStockType where toQueryParam = WH.toQueryParam . fromReturnInstanceStockType
instance WH.FromHttpApiData ReturnInstanceStockType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReturnInstanceStockType
instance MimeRender MimeMultipartFormData ReturnInstanceStockType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReturnInstanceStockType' enum
fromReturnInstanceStockType :: ReturnInstanceStockType -> Text
fromReturnInstanceStockType = \case
  ReturnInstanceStockType'FIT -> "FIT"
  ReturnInstanceStockType'DEFECT -> "DEFECT"
  ReturnInstanceStockType'ANOMALY -> "ANOMALY"
  ReturnInstanceStockType'SURPLUS -> "SURPLUS"
  ReturnInstanceStockType'EXPIRED -> "EXPIRED"
  ReturnInstanceStockType'MISGRADING -> "MISGRADING"
  ReturnInstanceStockType'UNDEFINED -> "UNDEFINED"
  ReturnInstanceStockType'INCORRECT_IMEI -> "INCORRECT_IMEI"
  ReturnInstanceStockType'INCORRECT_SERIAL_NUMBER -> "INCORRECT_SERIAL_NUMBER"
  ReturnInstanceStockType'INCORRECT_CIS -> "INCORRECT_CIS"
  ReturnInstanceStockType'PART_MISSING -> "PART_MISSING"
  ReturnInstanceStockType'NON_COMPLIENT -> "NON_COMPLIENT"
  ReturnInstanceStockType'NOT_ACCEPTABLE -> "NOT_ACCEPTABLE"
  ReturnInstanceStockType'SERVICE -> "SERVICE"
  ReturnInstanceStockType'MARKDOWN -> "MARKDOWN"
  ReturnInstanceStockType'DEMO -> "DEMO"
  ReturnInstanceStockType'REPAIR -> "REPAIR"
  ReturnInstanceStockType'FIRMWARE -> "FIRMWARE"
  ReturnInstanceStockType'UNKNOWN -> "UNKNOWN"

-- | parse 'ReturnInstanceStockType' enum
toReturnInstanceStockType :: Text -> P.Either String ReturnInstanceStockType
toReturnInstanceStockType = \case
  "FIT" -> P.Right ReturnInstanceStockType'FIT
  "DEFECT" -> P.Right ReturnInstanceStockType'DEFECT
  "ANOMALY" -> P.Right ReturnInstanceStockType'ANOMALY
  "SURPLUS" -> P.Right ReturnInstanceStockType'SURPLUS
  "EXPIRED" -> P.Right ReturnInstanceStockType'EXPIRED
  "MISGRADING" -> P.Right ReturnInstanceStockType'MISGRADING
  "UNDEFINED" -> P.Right ReturnInstanceStockType'UNDEFINED
  "INCORRECT_IMEI" -> P.Right ReturnInstanceStockType'INCORRECT_IMEI
  "INCORRECT_SERIAL_NUMBER" -> P.Right ReturnInstanceStockType'INCORRECT_SERIAL_NUMBER
  "INCORRECT_CIS" -> P.Right ReturnInstanceStockType'INCORRECT_CIS
  "PART_MISSING" -> P.Right ReturnInstanceStockType'PART_MISSING
  "NON_COMPLIENT" -> P.Right ReturnInstanceStockType'NON_COMPLIENT
  "NOT_ACCEPTABLE" -> P.Right ReturnInstanceStockType'NOT_ACCEPTABLE
  "SERVICE" -> P.Right ReturnInstanceStockType'SERVICE
  "MARKDOWN" -> P.Right ReturnInstanceStockType'MARKDOWN
  "DEMO" -> P.Right ReturnInstanceStockType'DEMO
  "REPAIR" -> P.Right ReturnInstanceStockType'REPAIR
  "FIRMWARE" -> P.Right ReturnInstanceStockType'FIRMWARE
  "UNKNOWN" -> P.Right ReturnInstanceStockType'UNKNOWN
  s -> P.Left $ "toReturnInstanceStockType: enum parse failure: " P.++ P.show s


-- ** ReturnRequestDecisionType

-- | Enum of 'Text' .
-- Решение по возврату.
data ReturnRequestDecisionType
  = ReturnRequestDecisionType'REFUND_MONEY -- ^ @"REFUND_MONEY"@
  | ReturnRequestDecisionType'REFUND_MONEY_INCLUDING_SHIPMENT -- ^ @"REFUND_MONEY_INCLUDING_SHIPMENT"@
  | ReturnRequestDecisionType'REPAIR -- ^ @"REPAIR"@
  | ReturnRequestDecisionType'REPLACE -- ^ @"REPLACE"@
  | ReturnRequestDecisionType'SEND_TO_EXAMINATION -- ^ @"SEND_TO_EXAMINATION"@
  | ReturnRequestDecisionType'DECLINE_REFUND -- ^ @"DECLINE_REFUND"@
  | ReturnRequestDecisionType'OTHER_DECISION -- ^ @"OTHER_DECISION"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReturnRequestDecisionType where toJSON = A.toJSON . fromReturnRequestDecisionType
instance A.FromJSON ReturnRequestDecisionType where parseJSON o = P.either P.fail (pure . P.id) . toReturnRequestDecisionType =<< A.parseJSON o
instance WH.ToHttpApiData ReturnRequestDecisionType where toQueryParam = WH.toQueryParam . fromReturnRequestDecisionType
instance WH.FromHttpApiData ReturnRequestDecisionType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReturnRequestDecisionType
instance MimeRender MimeMultipartFormData ReturnRequestDecisionType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReturnRequestDecisionType' enum
fromReturnRequestDecisionType :: ReturnRequestDecisionType -> Text
fromReturnRequestDecisionType = \case
  ReturnRequestDecisionType'REFUND_MONEY -> "REFUND_MONEY"
  ReturnRequestDecisionType'REFUND_MONEY_INCLUDING_SHIPMENT -> "REFUND_MONEY_INCLUDING_SHIPMENT"
  ReturnRequestDecisionType'REPAIR -> "REPAIR"
  ReturnRequestDecisionType'REPLACE -> "REPLACE"
  ReturnRequestDecisionType'SEND_TO_EXAMINATION -> "SEND_TO_EXAMINATION"
  ReturnRequestDecisionType'DECLINE_REFUND -> "DECLINE_REFUND"
  ReturnRequestDecisionType'OTHER_DECISION -> "OTHER_DECISION"

-- | parse 'ReturnRequestDecisionType' enum
toReturnRequestDecisionType :: Text -> P.Either String ReturnRequestDecisionType
toReturnRequestDecisionType = \case
  "REFUND_MONEY" -> P.Right ReturnRequestDecisionType'REFUND_MONEY
  "REFUND_MONEY_INCLUDING_SHIPMENT" -> P.Right ReturnRequestDecisionType'REFUND_MONEY_INCLUDING_SHIPMENT
  "REPAIR" -> P.Right ReturnRequestDecisionType'REPAIR
  "REPLACE" -> P.Right ReturnRequestDecisionType'REPLACE
  "SEND_TO_EXAMINATION" -> P.Right ReturnRequestDecisionType'SEND_TO_EXAMINATION
  "DECLINE_REFUND" -> P.Right ReturnRequestDecisionType'DECLINE_REFUND
  "OTHER_DECISION" -> P.Right ReturnRequestDecisionType'OTHER_DECISION
  s -> P.Left $ "toReturnRequestDecisionType: enum parse failure: " P.++ P.show s


-- ** ReturnShipmentStatusType

-- | Enum of 'Text' .
-- Статус передачи возврата:  * `CREATED` — возврат создан.  * `RECEIVED` — принят у покупателя.  * `IN_TRANSIT` — возврат в пути.  * `READY_FOR_PICKUP` — возврат готов к выдаче магазину.  * `PICKED` — возврат выдан магазину.  * `LOST` — возврат утерян при транспортировке.  * `CANCELLED` — возврат отменен.  * `FULFILMENT_RECEIVED` — возврат принят на складе Маркета.  * `PREPARED_FOR_UTILIZATION` — возврат передан в утилизацию.  * `UTILIZED` — возврат утилизирован. 
data ReturnShipmentStatusType
  = ReturnShipmentStatusType'CREATED -- ^ @"CREATED"@
  | ReturnShipmentStatusType'RECEIVED -- ^ @"RECEIVED"@
  | ReturnShipmentStatusType'IN_TRANSIT -- ^ @"IN_TRANSIT"@
  | ReturnShipmentStatusType'READY_FOR_PICKUP -- ^ @"READY_FOR_PICKUP"@
  | ReturnShipmentStatusType'PICKED -- ^ @"PICKED"@
  | ReturnShipmentStatusType'LOST -- ^ @"LOST"@
  | ReturnShipmentStatusType'EXPIRED -- ^ @"EXPIRED"@
  | ReturnShipmentStatusType'CANCELLED -- ^ @"CANCELLED"@
  | ReturnShipmentStatusType'FULFILMENT_RECEIVED -- ^ @"FULFILMENT_RECEIVED"@
  | ReturnShipmentStatusType'PREPARED_FOR_UTILIZATION -- ^ @"PREPARED_FOR_UTILIZATION"@
  | ReturnShipmentStatusType'NOT_IN_DEMAND -- ^ @"NOT_IN_DEMAND"@
  | ReturnShipmentStatusType'UTILIZED -- ^ @"UTILIZED"@
  | ReturnShipmentStatusType'READY_FOR_EXPROPRIATION -- ^ @"READY_FOR_EXPROPRIATION"@
  | ReturnShipmentStatusType'RECEIVED_FOR_EXPROPRIATION -- ^ @"RECEIVED_FOR_EXPROPRIATION"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReturnShipmentStatusType where toJSON = A.toJSON . fromReturnShipmentStatusType
instance A.FromJSON ReturnShipmentStatusType where parseJSON o = P.either P.fail (pure . P.id) . toReturnShipmentStatusType =<< A.parseJSON o
instance WH.ToHttpApiData ReturnShipmentStatusType where toQueryParam = WH.toQueryParam . fromReturnShipmentStatusType
instance WH.FromHttpApiData ReturnShipmentStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReturnShipmentStatusType
instance MimeRender MimeMultipartFormData ReturnShipmentStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReturnShipmentStatusType' enum
fromReturnShipmentStatusType :: ReturnShipmentStatusType -> Text
fromReturnShipmentStatusType = \case
  ReturnShipmentStatusType'CREATED -> "CREATED"
  ReturnShipmentStatusType'RECEIVED -> "RECEIVED"
  ReturnShipmentStatusType'IN_TRANSIT -> "IN_TRANSIT"
  ReturnShipmentStatusType'READY_FOR_PICKUP -> "READY_FOR_PICKUP"
  ReturnShipmentStatusType'PICKED -> "PICKED"
  ReturnShipmentStatusType'LOST -> "LOST"
  ReturnShipmentStatusType'EXPIRED -> "EXPIRED"
  ReturnShipmentStatusType'CANCELLED -> "CANCELLED"
  ReturnShipmentStatusType'FULFILMENT_RECEIVED -> "FULFILMENT_RECEIVED"
  ReturnShipmentStatusType'PREPARED_FOR_UTILIZATION -> "PREPARED_FOR_UTILIZATION"
  ReturnShipmentStatusType'NOT_IN_DEMAND -> "NOT_IN_DEMAND"
  ReturnShipmentStatusType'UTILIZED -> "UTILIZED"
  ReturnShipmentStatusType'READY_FOR_EXPROPRIATION -> "READY_FOR_EXPROPRIATION"
  ReturnShipmentStatusType'RECEIVED_FOR_EXPROPRIATION -> "RECEIVED_FOR_EXPROPRIATION"

-- | parse 'ReturnShipmentStatusType' enum
toReturnShipmentStatusType :: Text -> P.Either String ReturnShipmentStatusType
toReturnShipmentStatusType = \case
  "CREATED" -> P.Right ReturnShipmentStatusType'CREATED
  "RECEIVED" -> P.Right ReturnShipmentStatusType'RECEIVED
  "IN_TRANSIT" -> P.Right ReturnShipmentStatusType'IN_TRANSIT
  "READY_FOR_PICKUP" -> P.Right ReturnShipmentStatusType'READY_FOR_PICKUP
  "PICKED" -> P.Right ReturnShipmentStatusType'PICKED
  "LOST" -> P.Right ReturnShipmentStatusType'LOST
  "EXPIRED" -> P.Right ReturnShipmentStatusType'EXPIRED
  "CANCELLED" -> P.Right ReturnShipmentStatusType'CANCELLED
  "FULFILMENT_RECEIVED" -> P.Right ReturnShipmentStatusType'FULFILMENT_RECEIVED
  "PREPARED_FOR_UTILIZATION" -> P.Right ReturnShipmentStatusType'PREPARED_FOR_UTILIZATION
  "NOT_IN_DEMAND" -> P.Right ReturnShipmentStatusType'NOT_IN_DEMAND
  "UTILIZED" -> P.Right ReturnShipmentStatusType'UTILIZED
  "READY_FOR_EXPROPRIATION" -> P.Right ReturnShipmentStatusType'READY_FOR_EXPROPRIATION
  "RECEIVED_FOR_EXPROPRIATION" -> P.Right ReturnShipmentStatusType'RECEIVED_FOR_EXPROPRIATION
  s -> P.Left $ "toReturnShipmentStatusType: enum parse failure: " P.++ P.show s


-- ** ReturnType

-- | Enum of 'Text' .
-- Тип заказа для фильтрации:  * `RETURN` — возврат.  * `UNREDEEMED` — невыкуп.  Если не указывать, в ответе будут и возвраты, и невыкупы. 
data ReturnType
  = ReturnType'UNREDEEMED -- ^ @"UNREDEEMED"@
  | ReturnType'RETURN -- ^ @"RETURN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ReturnType where toJSON = A.toJSON . fromReturnType
instance A.FromJSON ReturnType where parseJSON o = P.either P.fail (pure . P.id) . toReturnType =<< A.parseJSON o
instance WH.ToHttpApiData ReturnType where toQueryParam = WH.toQueryParam . fromReturnType
instance WH.FromHttpApiData ReturnType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReturnType
instance MimeRender MimeMultipartFormData ReturnType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ReturnType' enum
fromReturnType :: ReturnType -> Text
fromReturnType = \case
  ReturnType'UNREDEEMED -> "UNREDEEMED"
  ReturnType'RETURN -> "RETURN"

-- | parse 'ReturnType' enum
toReturnType :: Text -> P.Either String ReturnType
toReturnType = \case
  "UNREDEEMED" -> P.Right ReturnType'UNREDEEMED
  "RETURN" -> P.Right ReturnType'RETURN
  s -> P.Left $ "toReturnType: enum parse failure: " P.++ P.show s


-- ** SellingProgramType

-- | Enum of 'Text' .
-- Модель размещения:  * `FBY` — FBY. * `FBS` — FBS. * `DBS` — DBS. * `EXPRESS` — Экспресс. 
data SellingProgramType
  = SellingProgramType'FBY -- ^ @"FBY"@
  | SellingProgramType'FBS -- ^ @"FBS"@
  | SellingProgramType'DBS -- ^ @"DBS"@
  | SellingProgramType'EXPRESS -- ^ @"EXPRESS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SellingProgramType where toJSON = A.toJSON . fromSellingProgramType
instance A.FromJSON SellingProgramType where parseJSON o = P.either P.fail (pure . P.id) . toSellingProgramType =<< A.parseJSON o
instance WH.ToHttpApiData SellingProgramType where toQueryParam = WH.toQueryParam . fromSellingProgramType
instance WH.FromHttpApiData SellingProgramType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSellingProgramType
instance MimeRender MimeMultipartFormData SellingProgramType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SellingProgramType' enum
fromSellingProgramType :: SellingProgramType -> Text
fromSellingProgramType = \case
  SellingProgramType'FBY -> "FBY"
  SellingProgramType'FBS -> "FBS"
  SellingProgramType'DBS -> "DBS"
  SellingProgramType'EXPRESS -> "EXPRESS"

-- | parse 'SellingProgramType' enum
toSellingProgramType :: Text -> P.Either String SellingProgramType
toSellingProgramType = \case
  "FBY" -> P.Right SellingProgramType'FBY
  "FBS" -> P.Right SellingProgramType'FBS
  "DBS" -> P.Right SellingProgramType'DBS
  "EXPRESS" -> P.Right SellingProgramType'EXPRESS
  s -> P.Left $ "toSellingProgramType: enum parse failure: " P.++ P.show s


-- ** ShelfsStatisticsAttributionType

-- | Enum of 'Text' .
-- Тип атрибуции:   * `CLICKS` — по кликам.   * `SHOWS` — по показам. <br><br>  О том, какие данные в отчете зависят и не зависят от типа атрибуции, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf#stats). 
data ShelfsStatisticsAttributionType
  = ShelfsStatisticsAttributionType'CLICKS -- ^ @"CLICKS"@
  | ShelfsStatisticsAttributionType'SHOWS -- ^ @"SHOWS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ShelfsStatisticsAttributionType where toJSON = A.toJSON . fromShelfsStatisticsAttributionType
instance A.FromJSON ShelfsStatisticsAttributionType where parseJSON o = P.either P.fail (pure . P.id) . toShelfsStatisticsAttributionType =<< A.parseJSON o
instance WH.ToHttpApiData ShelfsStatisticsAttributionType where toQueryParam = WH.toQueryParam . fromShelfsStatisticsAttributionType
instance WH.FromHttpApiData ShelfsStatisticsAttributionType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toShelfsStatisticsAttributionType
instance MimeRender MimeMultipartFormData ShelfsStatisticsAttributionType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ShelfsStatisticsAttributionType' enum
fromShelfsStatisticsAttributionType :: ShelfsStatisticsAttributionType -> Text
fromShelfsStatisticsAttributionType = \case
  ShelfsStatisticsAttributionType'CLICKS -> "CLICKS"
  ShelfsStatisticsAttributionType'SHOWS -> "SHOWS"

-- | parse 'ShelfsStatisticsAttributionType' enum
toShelfsStatisticsAttributionType :: Text -> P.Either String ShelfsStatisticsAttributionType
toShelfsStatisticsAttributionType = \case
  "CLICKS" -> P.Right ShelfsStatisticsAttributionType'CLICKS
  "SHOWS" -> P.Right ShelfsStatisticsAttributionType'SHOWS
  s -> P.Left $ "toShelfsStatisticsAttributionType: enum parse failure: " P.++ P.show s


-- ** ShipmentActionType

-- | Enum of 'Text' .
-- Действия с отгрузкой:  * `CONFIRM` — подтвердить отгрузку. * `DOWNLOAD_ACT` — скачать акт приема-передачи отгрузки. * `DOWNLOAD_INBOUND_ACT` — скачать список принятых заказов. * `DOWNLOAD_DISCREPANCY_ACT` — скачать акт расхождений. * `CHANGE_PALLETS_COUNT` — указать количество палет. 
data ShipmentActionType
  = ShipmentActionType'CONFIRM -- ^ @"CONFIRM"@
  | ShipmentActionType'DOWNLOAD_ACT -- ^ @"DOWNLOAD_ACT"@
  | ShipmentActionType'DOWNLOAD_INBOUND_ACT -- ^ @"DOWNLOAD_INBOUND_ACT"@
  | ShipmentActionType'DOWNLOAD_DISCREPANCY_ACT -- ^ @"DOWNLOAD_DISCREPANCY_ACT"@
  | ShipmentActionType'CHANGE_PALLETS_COUNT -- ^ @"CHANGE_PALLETS_COUNT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ShipmentActionType where toJSON = A.toJSON . fromShipmentActionType
instance A.FromJSON ShipmentActionType where parseJSON o = P.either P.fail (pure . P.id) . toShipmentActionType =<< A.parseJSON o
instance WH.ToHttpApiData ShipmentActionType where toQueryParam = WH.toQueryParam . fromShipmentActionType
instance WH.FromHttpApiData ShipmentActionType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toShipmentActionType
instance MimeRender MimeMultipartFormData ShipmentActionType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ShipmentActionType' enum
fromShipmentActionType :: ShipmentActionType -> Text
fromShipmentActionType = \case
  ShipmentActionType'CONFIRM -> "CONFIRM"
  ShipmentActionType'DOWNLOAD_ACT -> "DOWNLOAD_ACT"
  ShipmentActionType'DOWNLOAD_INBOUND_ACT -> "DOWNLOAD_INBOUND_ACT"
  ShipmentActionType'DOWNLOAD_DISCREPANCY_ACT -> "DOWNLOAD_DISCREPANCY_ACT"
  ShipmentActionType'CHANGE_PALLETS_COUNT -> "CHANGE_PALLETS_COUNT"

-- | parse 'ShipmentActionType' enum
toShipmentActionType :: Text -> P.Either String ShipmentActionType
toShipmentActionType = \case
  "CONFIRM" -> P.Right ShipmentActionType'CONFIRM
  "DOWNLOAD_ACT" -> P.Right ShipmentActionType'DOWNLOAD_ACT
  "DOWNLOAD_INBOUND_ACT" -> P.Right ShipmentActionType'DOWNLOAD_INBOUND_ACT
  "DOWNLOAD_DISCREPANCY_ACT" -> P.Right ShipmentActionType'DOWNLOAD_DISCREPANCY_ACT
  "CHANGE_PALLETS_COUNT" -> P.Right ShipmentActionType'CHANGE_PALLETS_COUNT
  s -> P.Left $ "toShipmentActionType: enum parse failure: " P.++ P.show s


-- ** ShipmentPalletLabelPageFormatType

-- | Enum of 'Text' .
-- Формат страницы: * `A4` — формат страницы A4. * `A8` — формат страницы A8. 
data ShipmentPalletLabelPageFormatType
  = ShipmentPalletLabelPageFormatType'A4 -- ^ @"A4"@
  | ShipmentPalletLabelPageFormatType'A8 -- ^ @"A8"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ShipmentPalletLabelPageFormatType where toJSON = A.toJSON . fromShipmentPalletLabelPageFormatType
instance A.FromJSON ShipmentPalletLabelPageFormatType where parseJSON o = P.either P.fail (pure . P.id) . toShipmentPalletLabelPageFormatType =<< A.parseJSON o
instance WH.ToHttpApiData ShipmentPalletLabelPageFormatType where toQueryParam = WH.toQueryParam . fromShipmentPalletLabelPageFormatType
instance WH.FromHttpApiData ShipmentPalletLabelPageFormatType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toShipmentPalletLabelPageFormatType
instance MimeRender MimeMultipartFormData ShipmentPalletLabelPageFormatType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ShipmentPalletLabelPageFormatType' enum
fromShipmentPalletLabelPageFormatType :: ShipmentPalletLabelPageFormatType -> Text
fromShipmentPalletLabelPageFormatType = \case
  ShipmentPalletLabelPageFormatType'A4 -> "A4"
  ShipmentPalletLabelPageFormatType'A8 -> "A8"

-- | parse 'ShipmentPalletLabelPageFormatType' enum
toShipmentPalletLabelPageFormatType :: Text -> P.Either String ShipmentPalletLabelPageFormatType
toShipmentPalletLabelPageFormatType = \case
  "A4" -> P.Right ShipmentPalletLabelPageFormatType'A4
  "A8" -> P.Right ShipmentPalletLabelPageFormatType'A8
  s -> P.Left $ "toShipmentPalletLabelPageFormatType: enum parse failure: " P.++ P.show s


-- ** ShipmentStatusType

-- | Enum of 'Text' .
-- Статус отгрузки:  * `OUTBOUND_CREATED` — формируется. * `OUTBOUND_READY_FOR_CONFIRMATION` — можно обрабатывать. * `OUTBOUND_CONFIRMED` — подтверждена и готова к отправке. * `OUTBOUND_SIGNED` — по ней подписан электронный акт приема-передачи. * `ACCEPTED` — принята в сортировочном центре или пункте приема. * `ACCEPTED_WITH_DISCREPANCIES` — принята с расхождениями. * `FINISHED` — завершена. * `ERROR` — отменена из-за ошибки. 
data ShipmentStatusType
  = ShipmentStatusType'OUTBOUND_CREATED -- ^ @"OUTBOUND_CREATED"@
  | ShipmentStatusType'OUTBOUND_READY_FOR_CONFIRMATION -- ^ @"OUTBOUND_READY_FOR_CONFIRMATION"@
  | ShipmentStatusType'OUTBOUND_CONFIRMED -- ^ @"OUTBOUND_CONFIRMED"@
  | ShipmentStatusType'OUTBOUND_SIGNED -- ^ @"OUTBOUND_SIGNED"@
  | ShipmentStatusType'FINISHED -- ^ @"FINISHED"@
  | ShipmentStatusType'ACCEPTED -- ^ @"ACCEPTED"@
  | ShipmentStatusType'ACCEPTED_WITH_DISCREPANCIES -- ^ @"ACCEPTED_WITH_DISCREPANCIES"@
  | ShipmentStatusType'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ShipmentStatusType where toJSON = A.toJSON . fromShipmentStatusType
instance A.FromJSON ShipmentStatusType where parseJSON o = P.either P.fail (pure . P.id) . toShipmentStatusType =<< A.parseJSON o
instance WH.ToHttpApiData ShipmentStatusType where toQueryParam = WH.toQueryParam . fromShipmentStatusType
instance WH.FromHttpApiData ShipmentStatusType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toShipmentStatusType
instance MimeRender MimeMultipartFormData ShipmentStatusType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ShipmentStatusType' enum
fromShipmentStatusType :: ShipmentStatusType -> Text
fromShipmentStatusType = \case
  ShipmentStatusType'OUTBOUND_CREATED -> "OUTBOUND_CREATED"
  ShipmentStatusType'OUTBOUND_READY_FOR_CONFIRMATION -> "OUTBOUND_READY_FOR_CONFIRMATION"
  ShipmentStatusType'OUTBOUND_CONFIRMED -> "OUTBOUND_CONFIRMED"
  ShipmentStatusType'OUTBOUND_SIGNED -> "OUTBOUND_SIGNED"
  ShipmentStatusType'FINISHED -> "FINISHED"
  ShipmentStatusType'ACCEPTED -> "ACCEPTED"
  ShipmentStatusType'ACCEPTED_WITH_DISCREPANCIES -> "ACCEPTED_WITH_DISCREPANCIES"
  ShipmentStatusType'ERROR -> "ERROR"

-- | parse 'ShipmentStatusType' enum
toShipmentStatusType :: Text -> P.Either String ShipmentStatusType
toShipmentStatusType = \case
  "OUTBOUND_CREATED" -> P.Right ShipmentStatusType'OUTBOUND_CREATED
  "OUTBOUND_READY_FOR_CONFIRMATION" -> P.Right ShipmentStatusType'OUTBOUND_READY_FOR_CONFIRMATION
  "OUTBOUND_CONFIRMED" -> P.Right ShipmentStatusType'OUTBOUND_CONFIRMED
  "OUTBOUND_SIGNED" -> P.Right ShipmentStatusType'OUTBOUND_SIGNED
  "FINISHED" -> P.Right ShipmentStatusType'FINISHED
  "ACCEPTED" -> P.Right ShipmentStatusType'ACCEPTED
  "ACCEPTED_WITH_DISCREPANCIES" -> P.Right ShipmentStatusType'ACCEPTED_WITH_DISCREPANCIES
  "ERROR" -> P.Right ShipmentStatusType'ERROR
  s -> P.Left $ "toShipmentStatusType: enum parse failure: " P.++ P.show s


-- ** ShipmentType

-- | Enum of 'Text' .
-- Способ отгрузки заказов:  * `IMPORT` — вы самостоятельно привозите заказы в выбранный сортировочный центр или пункт приема заказов. * `WITHDRAW` — вы отгружаете заказы со своего склада курьерам Яндекс Маркета. 
data ShipmentType
  = ShipmentType'IMPORT -- ^ @"IMPORT"@
  | ShipmentType'WITHDRAW -- ^ @"WITHDRAW"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ShipmentType where toJSON = A.toJSON . fromShipmentType
instance A.FromJSON ShipmentType where parseJSON o = P.either P.fail (pure . P.id) . toShipmentType =<< A.parseJSON o
instance WH.ToHttpApiData ShipmentType where toQueryParam = WH.toQueryParam . fromShipmentType
instance WH.FromHttpApiData ShipmentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toShipmentType
instance MimeRender MimeMultipartFormData ShipmentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ShipmentType' enum
fromShipmentType :: ShipmentType -> Text
fromShipmentType = \case
  ShipmentType'IMPORT -> "IMPORT"
  ShipmentType'WITHDRAW -> "WITHDRAW"

-- | parse 'ShipmentType' enum
toShipmentType :: Text -> P.Either String ShipmentType
toShipmentType = \case
  "IMPORT" -> P.Right ShipmentType'IMPORT
  "WITHDRAW" -> P.Right ShipmentType'WITHDRAW
  s -> P.Left $ "toShipmentType: enum parse failure: " P.++ P.show s


-- ** ShowsSalesGroupingType

-- | Enum of 'Text' .
-- Группировка данных отчета. Возможные значения: * `CATEGORIES` — группировка по категориям. * `OFFERS` — группировка по товарам. 
data ShowsSalesGroupingType
  = ShowsSalesGroupingType'CATEGORIES -- ^ @"CATEGORIES"@
  | ShowsSalesGroupingType'OFFERS -- ^ @"OFFERS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ShowsSalesGroupingType where toJSON = A.toJSON . fromShowsSalesGroupingType
instance A.FromJSON ShowsSalesGroupingType where parseJSON o = P.either P.fail (pure . P.id) . toShowsSalesGroupingType =<< A.parseJSON o
instance WH.ToHttpApiData ShowsSalesGroupingType where toQueryParam = WH.toQueryParam . fromShowsSalesGroupingType
instance WH.FromHttpApiData ShowsSalesGroupingType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toShowsSalesGroupingType
instance MimeRender MimeMultipartFormData ShowsSalesGroupingType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ShowsSalesGroupingType' enum
fromShowsSalesGroupingType :: ShowsSalesGroupingType -> Text
fromShowsSalesGroupingType = \case
  ShowsSalesGroupingType'CATEGORIES -> "CATEGORIES"
  ShowsSalesGroupingType'OFFERS -> "OFFERS"

-- | parse 'ShowsSalesGroupingType' enum
toShowsSalesGroupingType :: Text -> P.Either String ShowsSalesGroupingType
toShowsSalesGroupingType = \case
  "CATEGORIES" -> P.Right ShowsSalesGroupingType'CATEGORIES
  "OFFERS" -> P.Right ShowsSalesGroupingType'OFFERS
  s -> P.Left $ "toShowsSalesGroupingType: enum parse failure: " P.++ P.show s


-- ** SortOrderType

-- | Enum of 'Text' .
-- Направление сортировки.  Возможные значения: - `ASC` — сортировка по возрастанию. - `DESC` — сортировка по убыванию. 
data SortOrderType
  = SortOrderType'ASC -- ^ @"ASC"@
  | SortOrderType'DESC -- ^ @"DESC"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SortOrderType where toJSON = A.toJSON . fromSortOrderType
instance A.FromJSON SortOrderType where parseJSON o = P.either P.fail (pure . P.id) . toSortOrderType =<< A.parseJSON o
instance WH.ToHttpApiData SortOrderType where toQueryParam = WH.toQueryParam . fromSortOrderType
instance WH.FromHttpApiData SortOrderType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSortOrderType
instance MimeRender MimeMultipartFormData SortOrderType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SortOrderType' enum
fromSortOrderType :: SortOrderType -> Text
fromSortOrderType = \case
  SortOrderType'ASC -> "ASC"
  SortOrderType'DESC -> "DESC"

-- | parse 'SortOrderType' enum
toSortOrderType :: Text -> P.Either String SortOrderType
toSortOrderType = \case
  "ASC" -> P.Right SortOrderType'ASC
  "DESC" -> P.Right SortOrderType'DESC
  s -> P.Left $ "toSortOrderType: enum parse failure: " P.++ P.show s


-- ** TariffType

-- | Enum of 'Text' .
-- Услуга Маркета или дополнительный тариф к услуге размещения:  * `AGENCY_COMMISSION` — прием платежа покупателя.  * `PAYMENT_TRANSFER` — перевод платежа покупателя.  * `STORAGE` — хранение товара на складе Маркета в течение суток.  * `SURPLUS` — хранение излишков на складе Маркета.  * `WITHDRAW` — вывоз товара со склада Маркета.  * `FEE` — размещение товара на Маркете.  * `DELIVERY_TO_CUSTOMER` — доставка покупателю.  * `CROSSREGIONAL_DELIVERY` — доставка в федеральный округ, город или населенный пункт.  * `CROSSREGIONAL_DELIVERY_RETURN` — доставка невыкупов и возвратов.  * `DISPOSAL` — утилизация.  * `SORTING_CENTER_STORAGE` — хранение невыкупов и возвратов.  * `EXPRESS_DELIVERY` — экспресс-доставка покупателю.  * `FF_XDOC_SUPPLY_BOX` — поставка товара через транзитный склад (за короб).  * `FF_XDOC_SUPPLY_PALLET` — поставка товара через транзитный склад (за палету).  * `SORTING` — обработка заказа.  * `MIDDLE_MILE` — средняя миля.  * `RETURN_PROCESSING` — обработка невыкупов и возвратов.  * `EXPRESS_CANCELLED_BY_PARTNER` — отмена заказа с экспресс-доставкой.  * `DELIVERY_TO_CUSTOMER_RETURN` — возврат доставляемого товара на склад.  * `CROSSBORDER_DELIVERY` — доставка из-за рубежа.  * `INTAKE_SORTING_BULKY_CARGO` — сортировка заказов с крупногабаритными товарами, которые Маркет забрал со склада продавца.  * `INTAKE_SORTING_SMALL_GOODS` — сортировка заказов с малогабаритными товарами, которые Маркет забрал со склада продавца.  * `INTAKE_SORTING_DAILY` — организация забора заказов со склада продавца.  * `FF_STORAGE_BILLING` — хранения товаров на складе.  * `CANCELLED_ORDER_FEE_QI` — отмена заказа по вине продавца.  * `LATE_ORDER_EXECUTION_FEE_QI` — несвоевременная отгрузка или доставка.  Подробнее об услугах Маркета читайте [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/introduction/rates/index.html). 
data TariffType
  = TariffType'AGENCY_COMMISSION -- ^ @"AGENCY_COMMISSION"@
  | TariffType'PAYMENT_TRANSFER -- ^ @"PAYMENT_TRANSFER"@
  | TariffType'STORAGE -- ^ @"STORAGE"@
  | TariffType'WITHDRAW -- ^ @"WITHDRAW"@
  | TariffType'SURPLUS -- ^ @"SURPLUS"@
  | TariffType'FEE -- ^ @"FEE"@
  | TariffType'DELIVERY_TO_CUSTOMER -- ^ @"DELIVERY_TO_CUSTOMER"@
  | TariffType'CROSSREGIONAL_DELIVERY -- ^ @"CROSSREGIONAL_DELIVERY"@
  | TariffType'CROSSREGIONAL_DELIVERY_RETURN -- ^ @"CROSSREGIONAL_DELIVERY_RETURN"@
  | TariffType'DISPOSAL -- ^ @"DISPOSAL"@
  | TariffType'SORTING_CENTER_STORAGE -- ^ @"SORTING_CENTER_STORAGE"@
  | TariffType'EXPRESS_DELIVERY -- ^ @"EXPRESS_DELIVERY"@
  | TariffType'FF_XDOC_SUPPLY_BOX -- ^ @"FF_XDOC_SUPPLY_BOX"@
  | TariffType'FF_XDOC_SUPPLY_PALLET -- ^ @"FF_XDOC_SUPPLY_PALLET"@
  | TariffType'SORTING -- ^ @"SORTING"@
  | TariffType'MIDDLE_MILE -- ^ @"MIDDLE_MILE"@
  | TariffType'RETURN_PROCESSING -- ^ @"RETURN_PROCESSING"@
  | TariffType'EXPRESS_CANCELLED_BY_PARTNER -- ^ @"EXPRESS_CANCELLED_BY_PARTNER"@
  | TariffType'DELIVERY_TO_CUSTOMER_RETURN -- ^ @"DELIVERY_TO_CUSTOMER_RETURN"@
  | TariffType'CROSSBORDER_DELIVERY -- ^ @"CROSSBORDER_DELIVERY"@
  | TariffType'INTAKE_SORTING_BULKY_CARGO -- ^ @"INTAKE_SORTING_BULKY_CARGO"@
  | TariffType'INTAKE_SORTING_SMALL_GOODS -- ^ @"INTAKE_SORTING_SMALL_GOODS"@
  | TariffType'INTAKE_SORTING_DAILY -- ^ @"INTAKE_SORTING_DAILY"@
  | TariffType'FF_STORAGE_BILLING -- ^ @"FF_STORAGE_BILLING"@
  | TariffType'CANCELLED_ORDER_FEE_QI -- ^ @"CANCELLED_ORDER_FEE_QI"@
  | TariffType'LATE_ORDER_EXECUTION_FEE_QI -- ^ @"LATE_ORDER_EXECUTION_FEE_QI"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TariffType where toJSON = A.toJSON . fromTariffType
instance A.FromJSON TariffType where parseJSON o = P.either P.fail (pure . P.id) . toTariffType =<< A.parseJSON o
instance WH.ToHttpApiData TariffType where toQueryParam = WH.toQueryParam . fromTariffType
instance WH.FromHttpApiData TariffType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTariffType
instance MimeRender MimeMultipartFormData TariffType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TariffType' enum
fromTariffType :: TariffType -> Text
fromTariffType = \case
  TariffType'AGENCY_COMMISSION -> "AGENCY_COMMISSION"
  TariffType'PAYMENT_TRANSFER -> "PAYMENT_TRANSFER"
  TariffType'STORAGE -> "STORAGE"
  TariffType'WITHDRAW -> "WITHDRAW"
  TariffType'SURPLUS -> "SURPLUS"
  TariffType'FEE -> "FEE"
  TariffType'DELIVERY_TO_CUSTOMER -> "DELIVERY_TO_CUSTOMER"
  TariffType'CROSSREGIONAL_DELIVERY -> "CROSSREGIONAL_DELIVERY"
  TariffType'CROSSREGIONAL_DELIVERY_RETURN -> "CROSSREGIONAL_DELIVERY_RETURN"
  TariffType'DISPOSAL -> "DISPOSAL"
  TariffType'SORTING_CENTER_STORAGE -> "SORTING_CENTER_STORAGE"
  TariffType'EXPRESS_DELIVERY -> "EXPRESS_DELIVERY"
  TariffType'FF_XDOC_SUPPLY_BOX -> "FF_XDOC_SUPPLY_BOX"
  TariffType'FF_XDOC_SUPPLY_PALLET -> "FF_XDOC_SUPPLY_PALLET"
  TariffType'SORTING -> "SORTING"
  TariffType'MIDDLE_MILE -> "MIDDLE_MILE"
  TariffType'RETURN_PROCESSING -> "RETURN_PROCESSING"
  TariffType'EXPRESS_CANCELLED_BY_PARTNER -> "EXPRESS_CANCELLED_BY_PARTNER"
  TariffType'DELIVERY_TO_CUSTOMER_RETURN -> "DELIVERY_TO_CUSTOMER_RETURN"
  TariffType'CROSSBORDER_DELIVERY -> "CROSSBORDER_DELIVERY"
  TariffType'INTAKE_SORTING_BULKY_CARGO -> "INTAKE_SORTING_BULKY_CARGO"
  TariffType'INTAKE_SORTING_SMALL_GOODS -> "INTAKE_SORTING_SMALL_GOODS"
  TariffType'INTAKE_SORTING_DAILY -> "INTAKE_SORTING_DAILY"
  TariffType'FF_STORAGE_BILLING -> "FF_STORAGE_BILLING"
  TariffType'CANCELLED_ORDER_FEE_QI -> "CANCELLED_ORDER_FEE_QI"
  TariffType'LATE_ORDER_EXECUTION_FEE_QI -> "LATE_ORDER_EXECUTION_FEE_QI"

-- | parse 'TariffType' enum
toTariffType :: Text -> P.Either String TariffType
toTariffType = \case
  "AGENCY_COMMISSION" -> P.Right TariffType'AGENCY_COMMISSION
  "PAYMENT_TRANSFER" -> P.Right TariffType'PAYMENT_TRANSFER
  "STORAGE" -> P.Right TariffType'STORAGE
  "WITHDRAW" -> P.Right TariffType'WITHDRAW
  "SURPLUS" -> P.Right TariffType'SURPLUS
  "FEE" -> P.Right TariffType'FEE
  "DELIVERY_TO_CUSTOMER" -> P.Right TariffType'DELIVERY_TO_CUSTOMER
  "CROSSREGIONAL_DELIVERY" -> P.Right TariffType'CROSSREGIONAL_DELIVERY
  "CROSSREGIONAL_DELIVERY_RETURN" -> P.Right TariffType'CROSSREGIONAL_DELIVERY_RETURN
  "DISPOSAL" -> P.Right TariffType'DISPOSAL
  "SORTING_CENTER_STORAGE" -> P.Right TariffType'SORTING_CENTER_STORAGE
  "EXPRESS_DELIVERY" -> P.Right TariffType'EXPRESS_DELIVERY
  "FF_XDOC_SUPPLY_BOX" -> P.Right TariffType'FF_XDOC_SUPPLY_BOX
  "FF_XDOC_SUPPLY_PALLET" -> P.Right TariffType'FF_XDOC_SUPPLY_PALLET
  "SORTING" -> P.Right TariffType'SORTING
  "MIDDLE_MILE" -> P.Right TariffType'MIDDLE_MILE
  "RETURN_PROCESSING" -> P.Right TariffType'RETURN_PROCESSING
  "EXPRESS_CANCELLED_BY_PARTNER" -> P.Right TariffType'EXPRESS_CANCELLED_BY_PARTNER
  "DELIVERY_TO_CUSTOMER_RETURN" -> P.Right TariffType'DELIVERY_TO_CUSTOMER_RETURN
  "CROSSBORDER_DELIVERY" -> P.Right TariffType'CROSSBORDER_DELIVERY
  "INTAKE_SORTING_BULKY_CARGO" -> P.Right TariffType'INTAKE_SORTING_BULKY_CARGO
  "INTAKE_SORTING_SMALL_GOODS" -> P.Right TariffType'INTAKE_SORTING_SMALL_GOODS
  "INTAKE_SORTING_DAILY" -> P.Right TariffType'INTAKE_SORTING_DAILY
  "FF_STORAGE_BILLING" -> P.Right TariffType'FF_STORAGE_BILLING
  "CANCELLED_ORDER_FEE_QI" -> P.Right TariffType'CANCELLED_ORDER_FEE_QI
  "LATE_ORDER_EXECUTION_FEE_QI" -> P.Right TariffType'LATE_ORDER_EXECUTION_FEE_QI
  s -> P.Left $ "toTariffType: enum parse failure: " P.++ P.show s


-- ** TimeUnitType

-- | Enum of 'Text' .
-- Единица измерения времени:  * `HOUR` — час. * `DAY` — сутки. * `WEEK` — неделя. * `MONTH` — месяц. * `YEAR` — год. 
data TimeUnitType
  = TimeUnitType'HOUR -- ^ @"HOUR"@
  | TimeUnitType'DAY -- ^ @"DAY"@
  | TimeUnitType'WEEK -- ^ @"WEEK"@
  | TimeUnitType'MONTH -- ^ @"MONTH"@
  | TimeUnitType'YEAR -- ^ @"YEAR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TimeUnitType where toJSON = A.toJSON . fromTimeUnitType
instance A.FromJSON TimeUnitType where parseJSON o = P.either P.fail (pure . P.id) . toTimeUnitType =<< A.parseJSON o
instance WH.ToHttpApiData TimeUnitType where toQueryParam = WH.toQueryParam . fromTimeUnitType
instance WH.FromHttpApiData TimeUnitType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTimeUnitType
instance MimeRender MimeMultipartFormData TimeUnitType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TimeUnitType' enum
fromTimeUnitType :: TimeUnitType -> Text
fromTimeUnitType = \case
  TimeUnitType'HOUR -> "HOUR"
  TimeUnitType'DAY -> "DAY"
  TimeUnitType'WEEK -> "WEEK"
  TimeUnitType'MONTH -> "MONTH"
  TimeUnitType'YEAR -> "YEAR"

-- | parse 'TimeUnitType' enum
toTimeUnitType :: Text -> P.Either String TimeUnitType
toTimeUnitType = \case
  "HOUR" -> P.Right TimeUnitType'HOUR
  "DAY" -> P.Right TimeUnitType'DAY
  "WEEK" -> P.Right TimeUnitType'WEEK
  "MONTH" -> P.Right TimeUnitType'MONTH
  "YEAR" -> P.Right TimeUnitType'YEAR
  s -> P.Left $ "toTimeUnitType: enum parse failure: " P.++ P.show s


-- ** TurnoverType

-- | Enum of 'Text' .
-- Оценка оборачиваемости.  |enum|Диапазон оборачиваемости|Комментарий| |-|-|-| |`LOW`|`turnoverDays` ≥ 120|| |`ALMOST_LOW`|100 ≤ `turnoverDays` < 120|| |`HIGH`|45 ≤ `turnoverDays` < 100|| |`VERY_HIGH`|0 ≤ `turnoverDays` < 45|| |`NO_SALES`|—|Продаж нет.| |`FREE_STORE`|Любое значение.|Товары этой категории сейчас хранятся бесплатно.| 
data TurnoverType
  = TurnoverType'LOW -- ^ @"LOW"@
  | TurnoverType'ALMOST_LOW -- ^ @"ALMOST_LOW"@
  | TurnoverType'HIGH -- ^ @"HIGH"@
  | TurnoverType'VERY_HIGH -- ^ @"VERY_HIGH"@
  | TurnoverType'NO_SALES -- ^ @"NO_SALES"@
  | TurnoverType'FREE_STORE -- ^ @"FREE_STORE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TurnoverType where toJSON = A.toJSON . fromTurnoverType
instance A.FromJSON TurnoverType where parseJSON o = P.either P.fail (pure . P.id) . toTurnoverType =<< A.parseJSON o
instance WH.ToHttpApiData TurnoverType where toQueryParam = WH.toQueryParam . fromTurnoverType
instance WH.FromHttpApiData TurnoverType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTurnoverType
instance MimeRender MimeMultipartFormData TurnoverType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TurnoverType' enum
fromTurnoverType :: TurnoverType -> Text
fromTurnoverType = \case
  TurnoverType'LOW -> "LOW"
  TurnoverType'ALMOST_LOW -> "ALMOST_LOW"
  TurnoverType'HIGH -> "HIGH"
  TurnoverType'VERY_HIGH -> "VERY_HIGH"
  TurnoverType'NO_SALES -> "NO_SALES"
  TurnoverType'FREE_STORE -> "FREE_STORE"

-- | parse 'TurnoverType' enum
toTurnoverType :: Text -> P.Either String TurnoverType
toTurnoverType = \case
  "LOW" -> P.Right TurnoverType'LOW
  "ALMOST_LOW" -> P.Right TurnoverType'ALMOST_LOW
  "HIGH" -> P.Right TurnoverType'HIGH
  "VERY_HIGH" -> P.Right TurnoverType'VERY_HIGH
  "NO_SALES" -> P.Right TurnoverType'NO_SALES
  "FREE_STORE" -> P.Right TurnoverType'FREE_STORE
  s -> P.Left $ "toTurnoverType: enum parse failure: " P.++ P.show s


-- ** WarehouseStockType

-- | Enum of 'Text' .
-- Тип остатков товаров на складе:  * `AVAILABLE` (соответствует типу «Доступный к заказу» в отчете «Остатки на складе» в кабинете продавца на Маркете) — товар, доступный для продажи.  * `DEFECT` (соответствует типу «Брак») — товар с браком.  * `EXPIRED` (соответствует типу «Просрочен») — товар с истекшим сроком годности.  * `FIT` (соответствует типу «Годный») — товар, который доступен для продажи или уже зарезервирован.  * `FREEZE` — товар, который зарезервирован для заказов.  * `QUARANTINE` (соответствует типу «Карантин») — товар, временно недоступный для продажи (например, товар перемещают из одного помещения склада в другое).  * `UTILIZATION` — товар, который будет утилизирован. 
data WarehouseStockType
  = WarehouseStockType'FIT -- ^ @"FIT"@
  | WarehouseStockType'FREEZE -- ^ @"FREEZE"@
  | WarehouseStockType'AVAILABLE -- ^ @"AVAILABLE"@
  | WarehouseStockType'QUARANTINE -- ^ @"QUARANTINE"@
  | WarehouseStockType'UTILIZATION -- ^ @"UTILIZATION"@
  | WarehouseStockType'DEFECT -- ^ @"DEFECT"@
  | WarehouseStockType'EXPIRED -- ^ @"EXPIRED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON WarehouseStockType where toJSON = A.toJSON . fromWarehouseStockType
instance A.FromJSON WarehouseStockType where parseJSON o = P.either P.fail (pure . P.id) . toWarehouseStockType =<< A.parseJSON o
instance WH.ToHttpApiData WarehouseStockType where toQueryParam = WH.toQueryParam . fromWarehouseStockType
instance WH.FromHttpApiData WarehouseStockType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toWarehouseStockType
instance MimeRender MimeMultipartFormData WarehouseStockType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'WarehouseStockType' enum
fromWarehouseStockType :: WarehouseStockType -> Text
fromWarehouseStockType = \case
  WarehouseStockType'FIT -> "FIT"
  WarehouseStockType'FREEZE -> "FREEZE"
  WarehouseStockType'AVAILABLE -> "AVAILABLE"
  WarehouseStockType'QUARANTINE -> "QUARANTINE"
  WarehouseStockType'UTILIZATION -> "UTILIZATION"
  WarehouseStockType'DEFECT -> "DEFECT"
  WarehouseStockType'EXPIRED -> "EXPIRED"

-- | parse 'WarehouseStockType' enum
toWarehouseStockType :: Text -> P.Either String WarehouseStockType
toWarehouseStockType = \case
  "FIT" -> P.Right WarehouseStockType'FIT
  "FREEZE" -> P.Right WarehouseStockType'FREEZE
  "AVAILABLE" -> P.Right WarehouseStockType'AVAILABLE
  "QUARANTINE" -> P.Right WarehouseStockType'QUARANTINE
  "UTILIZATION" -> P.Right WarehouseStockType'UTILIZATION
  "DEFECT" -> P.Right WarehouseStockType'DEFECT
  "EXPIRED" -> P.Right WarehouseStockType'EXPIRED
  s -> P.Left $ "toWarehouseStockType: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthOAuthOAuth
data AuthOAuthOAuth =
  AuthOAuthOAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthOAuthOAuth where
  applyAuthMethod _ a@(AuthOAuthOAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", "Bearer " <> secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


