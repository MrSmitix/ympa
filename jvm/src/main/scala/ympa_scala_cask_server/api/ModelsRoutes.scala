//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * OpenAPI spec version: LATEST
 *
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 *
 * https://openapi-generator.tech
 */


// this is generated from apiRoutes.mustache
package ympa_scala_cask_server.api

import ympa_scala_cask_server.model.*

import upickle.default.{ReadWriter => RW, macroRW}
import upickle.default.*

import ympa_scala_cask_server.model.ApiClientDataErrorResponse
import ympa_scala_cask_server.model.ApiForbiddenErrorResponse
import ympa_scala_cask_server.model.ApiLimitErrorResponse
import ympa_scala_cask_server.model.ApiNotFoundErrorResponse
import ympa_scala_cask_server.model.ApiServerErrorResponse
import ympa_scala_cask_server.model.ApiUnauthorizedErrorResponse
import ympa_scala_cask_server.model.CurrencyType
import ympa_scala_cask_server.model.GetModelsOffersResponse
import ympa_scala_cask_server.model.GetModelsRequest
import ympa_scala_cask_server.model.GetModelsResponse
import ympa_scala_cask_server.model.SearchModelsResponse
import ympa_scala_cask_server.model.SortOrderType

class ModelsRoutes(service : ModelsService) extends cask.Routes {

    // route group for routeWorkAroundForGETModels
    @cask.get("/models", true)
    def routeWorkAroundForGETModels(request: cask.Request,query : Option[String] = None,regionId : Option[Long] = None,currency : Option[CurrencyType] = None,page : Option[Int] = None,pageSize : Option[Int] = None,regionId : Option[Long] = None,currency : Option[CurrencyType] = None,regionId : Option[Long] = None,currency : Option[CurrencyType] = None,orderByPrice : Option[SortOrderType] = None,count : Option[Int] = None,page : Option[Int] = None) = {
        request.remainingPathSegments match {
            case Seq() => searchModels(request,query.getOrElse(""), regionId.getOrElse(), currency, page, pageSize)
            case Seq(modelId) => getModel(modelId.toLong,request,regionId.getOrElse(), currency)
            case Seq(modelId,"offers") => getModelOffers(modelId.toLong,request,regionId.getOrElse(), currency, orderByPrice, count, page)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }

        /** Информация об одной модели
         * 
         */
        // conflicts with [/models/{modelId}, /models/{modelId}/offers, /models] after/models, ignoring @cask.get("/models/:modelId")
        def getModel(modelId : Long, request: cask.Request, regionId : Long, currency : Option[CurrencyType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            modelId <- Parsed(modelId)
            result <- Parsed.eval(service.getModel(modelId, regionId, currency))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetModelsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список предложений для одной модели
         * 
         */
        // conflicts with [/models/{modelId}, /models/{modelId}/offers, /models] after/models, ignoring @cask.get("/models/:modelId/offers")
        def getModelOffers(modelId : Long, request: cask.Request, regionId : Long, currency : Option[CurrencyType], orderByPrice : Option[SortOrderType], count : Option[Int], page : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            modelId <- Parsed(modelId)
            result <- Parsed.eval(service.getModelOffers(modelId, regionId, currency, orderByPrice, count, page))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetModelsOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о нескольких моделях
         * 
         */
        @cask.post("/models")
        def getModels(request: cask.Request, regionId : Long, currency : Option[CurrencyType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              getModelsRequestData <- Parsed.eval(GetModelsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetModelsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getModelsRequest <- Parsed.fromTry(getModelsRequestData.validated(failFast))
            result <- Parsed.eval(service.getModels(regionId, getModelsRequest, currency))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetModelsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список предложений для нескольких моделей
         * 
         */
        @cask.post("/models/offers")
        def getModelsOffers(request: cask.Request, regionId : Long, currency : Option[CurrencyType], orderByPrice : Option[SortOrderType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              getModelsRequestData <- Parsed.eval(GetModelsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetModelsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getModelsRequest <- Parsed.fromTry(getModelsRequestData.validated(failFast))
            result <- Parsed.eval(service.getModelsOffers(regionId, getModelsRequest, currency, orderByPrice))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetModelsOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Поиск модели товара
         * 
         */
        // conflicts with [/models/{modelId}, /models/{modelId}/offers, /models] after/models, ignoring @cask.get("/models")
        def searchModels(request: cask.Request, query : String, regionId : Long, currency : Option[CurrencyType], page : Option[Int], pageSize : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            result <- Parsed.eval(service.searchModels(query, regionId, currency, page, pageSize))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : SearchModelsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }

    initialize()
}
