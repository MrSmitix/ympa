//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * OpenAPI spec version: LATEST
 *
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 *
 * https://openapi-generator.tech
 */


// this is generated from apiRoutes.mustache
package ympa_scala_cask_server.api

import ympa_scala_cask_server.model.*

import upickle.default.{ReadWriter => RW, macroRW}
import upickle.default.*

import ympa_scala_cask_server.model.ApiClientDataErrorResponse
import ympa_scala_cask_server.model.ApiForbiddenErrorResponse
import ympa_scala_cask_server.model.ApiLimitErrorResponse
import ympa_scala_cask_server.model.ApiNotFoundErrorResponse
import ympa_scala_cask_server.model.ApiServerErrorResponse
import ympa_scala_cask_server.model.ApiUnauthorizedErrorResponse
import ympa_scala_cask_server.model.EmptyApiResponse
import java.io.File
import ympa_scala_cask_server.model.GetReturnResponse
import ympa_scala_cask_server.model.GetReturnsResponse
import java.time.LocalDate
import ympa_scala_cask_server.model.RefundStatusType
import ympa_scala_cask_server.model.ReturnType
import ympa_scala_cask_server.model.SetReturnDecisionRequest

class ReturnsRoutes(service : ReturnsService) extends cask.Routes {

    // route group for routeWorkAroundForPOSTCampaigns
    @cask.post("/campaigns", true)
    def routeWorkAroundForPOSTCampaigns(request: cask.Request) = {
        request.remainingPathSegments match {
            case Seq(campaignId,"orders",orderId,"returns",returnId,"decision") => setReturnDecision(campaignId.toLong, orderId.toLong, returnId.toLong,request)
            case Seq(campaignId,"orders",orderId,"returns",returnId,"decision","submit") => submitReturnDecision(campaignId.toLong, orderId.toLong, returnId.toLong,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }
    // route group for routeWorkAroundForGETCampaigns
    @cask.get("/campaigns", true)
    def routeWorkAroundForGETCampaigns(request: cask.Request,pageToken : Option[String] = None,limit : Option[Int] = None,orderIds : Seq[Long] = Nil,statuses : Seq[RefundStatusType] = Nil,`type` : Option[ReturnType] = None,fromDate : Option[LocalDate] = None,toDate : Option[LocalDate] = None,fromDate2 : Option[LocalDate] = None,toDate2 : Option[LocalDate] = None) = {
        request.remainingPathSegments match {
            case Seq(campaignId,"returns") => getReturns(campaignId.toLong,request,pageToken, limit, orderIds, statuses, `type`, fromDate, toDate, fromDate2, toDate2)
            case Seq(campaignId,"orders",orderId,"returns",returnId) => getReturn(campaignId.toLong, orderId.toLong, returnId.toLong,request)
            case Seq(campaignId,"orders",orderId,"returns",returnId,"application") => getReturnApplication(campaignId.toLong, orderId.toLong, returnId.toLong,request)
            case Seq(campaignId,"orders",orderId,"returns",returnId,"decision",itemId,"image",imageHash) => getReturnPhoto(campaignId.toLong, orderId.toLong, returnId.toLong, itemId.toLong, imageHash,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }

        /** Информация о невыкупе или возврате
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/orders/:orderId/returns/:returnId")
        def getReturn(campaignId : Long, orderId : Long, returnId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            returnId <- Parsed(returnId)
            result <- Parsed.eval(service.getReturn(campaignId, orderId, returnId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetReturnResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение заявления на возврат
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/orders/:orderId/returns/:returnId/application")
        def getReturnApplication(campaignId : Long, orderId : Long, returnId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            returnId <- Parsed(returnId)
            result <- Parsed.eval(service.getReturnApplication(campaignId, orderId, returnId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : File) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение фотографии возврата
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/orders/:orderId/returns/:returnId/decision/:itemId/image/:imageHash")
        def getReturnPhoto(campaignId : Long, orderId : Long, returnId : Long, itemId : Long, imageHash : String, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            returnId <- Parsed(returnId)
            itemId <- Parsed(itemId)
            imageHash <- Parsed(imageHash)
            result <- Parsed.eval(service.getReturnPhoto(campaignId, orderId, returnId, itemId, imageHash))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : File) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список невыкупов и возвратов
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/returns")
        def getReturns(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int], orderIds : Seq[Long], statuses : Seq[RefundStatusType], &#x60;type&#x60; : Option[ReturnType], fromDate : Option[LocalDate], toDate : Option[LocalDate], fromDate2 : Option[LocalDate], toDate2 : Option[LocalDate]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getReturns(campaignId, pageToken, limit, orderIds, statuses, &#x60;type&#x60;, fromDate, toDate, fromDate2, toDate2))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetReturnsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Принятие или изменение решения по возврату
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/orders/:orderId/returns/:returnId/decision")
        def setReturnDecision(campaignId : Long, orderId : Long, returnId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            returnId <- Parsed(returnId)
              setReturnDecisionRequestData <- Parsed.eval(SetReturnDecisionRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as SetReturnDecisionRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              setReturnDecisionRequest <- Parsed.fromTry(setReturnDecisionRequestData.validated(failFast))
            result <- Parsed.eval(service.setReturnDecision(campaignId, orderId, returnId, setReturnDecisionRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Подтверждение решения по возврату
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/orders/:orderId/returns/:returnId/decision/submit")
        def submitReturnDecision(campaignId : Long, orderId : Long, returnId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            returnId <- Parsed(returnId)
            result <- Parsed.eval(service.submitReturnDecision(campaignId, orderId, returnId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }

    initialize()
}
