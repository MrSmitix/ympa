//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * OpenAPI spec version: LATEST
 *
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 *
 * https://openapi-generator.tech
 */


// this is generated from apiRoutes.mustache
package ympa_scala_cask_server.api

import ympa_scala_cask_server.model.*

import upickle.default.{ReadWriter => RW, macroRW}
import upickle.default.*

import ympa_scala_cask_server.model.AcceptOrderCancellationRequest
import ympa_scala_cask_server.model.ApiClientDataErrorResponse
import ympa_scala_cask_server.model.ApiForbiddenErrorResponse
import ympa_scala_cask_server.model.ApiLimitErrorResponse
import ympa_scala_cask_server.model.ApiNotFoundErrorResponse
import ympa_scala_cask_server.model.ApiServerErrorResponse
import ympa_scala_cask_server.model.ApiUnauthorizedErrorResponse
import ympa_scala_cask_server.model.EmptyApiResponse
import ympa_scala_cask_server.model.GetOrderResponse
import ympa_scala_cask_server.model.GetOrdersResponse
import java.time.LocalDate
import java.time.OffsetDateTime
import ympa_scala_cask_server.model.OrderBuyerType
import ympa_scala_cask_server.model.OrderDeliveryDispatchType
import ympa_scala_cask_server.model.OrderStatusType
import ympa_scala_cask_server.model.OrderSubstatusType
import ympa_scala_cask_server.model.ProvideOrderDigitalCodesRequest
import ympa_scala_cask_server.model.ProvideOrderItemIdentifiersRequest
import ympa_scala_cask_server.model.ProvideOrderItemIdentifiersResponse
import ympa_scala_cask_server.model.SetOrderBoxLayoutRequest
import ympa_scala_cask_server.model.SetOrderBoxLayoutResponse
import ympa_scala_cask_server.model.SetOrderShipmentBoxesRequest
import ympa_scala_cask_server.model.SetOrderShipmentBoxesResponse
import ympa_scala_cask_server.model.UpdateOrderItemRequest
import ympa_scala_cask_server.model.UpdateOrderStatusRequest
import ympa_scala_cask_server.model.UpdateOrderStatusResponse
import ympa_scala_cask_server.model.UpdateOrderStatusesRequest
import ympa_scala_cask_server.model.UpdateOrderStatusesResponse

class OrdersRoutes(service : OrdersService) extends cask.Routes {

    // route group for routeWorkAroundForPOSTCampaigns
    @cask.post("/campaigns", true)
    def routeWorkAroundForPOSTCampaigns(request: cask.Request) = {
        request.remainingPathSegments match {
            case Seq(campaignId,"orders","status-update") => updateOrderStatuses(campaignId.toLong,request)
            case Seq(campaignId,"orders",orderId,"deliverDigitalGoods") => provideOrderDigitalCodes(campaignId.toLong, orderId.toLong,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }
    // route group for routeWorkAroundForPUTCampaigns
    @cask.put("/campaigns", true)
    def routeWorkAroundForPUTCampaigns(request: cask.Request) = {
        request.remainingPathSegments match {
            case Seq(campaignId,"orders",orderId,"cancellation","accept") => acceptOrderCancellation(campaignId.toLong, orderId.toLong,request)
            case Seq(campaignId,"orders",orderId,"identifiers") => provideOrderItemIdentifiers(campaignId.toLong, orderId.toLong,request)
            case Seq(campaignId,"orders",orderId,"boxes") => setOrderBoxLayout(campaignId.toLong, orderId.toLong,request)
            case Seq(campaignId,"orders",orderId,"items") => updateOrderItems(campaignId.toLong, orderId.toLong,request)
            case Seq(campaignId,"orders",orderId,"status") => updateOrderStatus(campaignId.toLong, orderId.toLong,request)
            case Seq(campaignId,"orders",orderId,"delivery","shipments",shipmentId,"boxes") => setOrderShipmentBoxes(campaignId.toLong, orderId.toLong, shipmentId.toLong,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }
    // route group for routeWorkAroundForGETCampaigns
    @cask.get("/campaigns", true)
    def routeWorkAroundForGETCampaigns(request: cask.Request,orderIds : Seq[Long] = Nil,status : Set[OrderStatusType] = Set.empty,substatus : Set[OrderSubstatusType] = Set.empty,fromDate : Option[LocalDate] = None,toDate : Option[LocalDate] = None,supplierShipmentDateFrom : Option[LocalDate] = None,supplierShipmentDateTo : Option[LocalDate] = None,updatedAtFrom : Option[OffsetDateTime] = None,updatedAtTo : Option[OffsetDateTime] = None,dispatchType : Option[OrderDeliveryDispatchType] = None,fake : Option[Boolean] = None,hasCis : Option[Boolean] = None,onlyWaitingForCancellationApprove : Option[Boolean] = None,onlyEstimatedDelivery : Option[Boolean] = None,buyerType : Option[OrderBuyerType] = None,page : Option[Int] = None,pageSize : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None) = {
        request.remainingPathSegments match {
            case Seq(campaignId,"orders") => getOrders(campaignId.toLong,request,orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit)
            case Seq(campaignId,"orders",orderId) => getOrder(campaignId.toLong, orderId.toLong,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }

        /** Отмена заказа покупателем
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/cancellation/accept, /campaigns/{campaignId}/orders/{orderId}/identifiers, /campaigns/{campaignId}/orders/{orderId}/boxes, /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes, /campaigns/{campaignId}/orders/{orderId}/items, /campaigns/{campaignId}/orders/{orderId}/status] after/campaigns, ignoring @cask.put("/campaigns/:campaignId/orders/:orderId/cancellation/accept")
        def acceptOrderCancellation(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
              acceptOrderCancellationRequestData <- Parsed.eval(AcceptOrderCancellationRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as AcceptOrderCancellationRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              acceptOrderCancellationRequest <- Parsed.fromTry(acceptOrderCancellationRequestData.validated(failFast))
            result <- Parsed.eval(service.acceptOrderCancellation(campaignId, orderId, acceptOrderCancellationRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация об одном заказе
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/orders/:orderId")
        def getOrder(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            result <- Parsed.eval(service.getOrder(campaignId, orderId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOrderResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о нескольких заказах
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/orders")
        def getOrders(campaignId : Long, request: cask.Request, orderIds : Seq[Long], status : Set[OrderStatusType], substatus : Set[OrderSubstatusType], fromDate : Option[LocalDate], toDate : Option[LocalDate], supplierShipmentDateFrom : Option[LocalDate], supplierShipmentDateTo : Option[LocalDate], updatedAtFrom : Option[OffsetDateTime], updatedAtTo : Option[OffsetDateTime], dispatchType : Option[OrderDeliveryDispatchType], fake : Option[Boolean], hasCis : Option[Boolean], onlyWaitingForCancellationApprove : Option[Boolean], onlyEstimatedDelivery : Option[Boolean], buyerType : Option[OrderBuyerType], page : Option[Int], pageSize : Option[Int], pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getOrders(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOrdersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Передача ключей цифровых товаров
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/deliverDigitalGoods, /campaigns/{campaignId}/orders/status-update] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/orders/:orderId/deliverDigitalGoods")
        def provideOrderDigitalCodes(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
              provideOrderDigitalCodesRequestData <- Parsed.eval(ProvideOrderDigitalCodesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as ProvideOrderDigitalCodesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              provideOrderDigitalCodesRequest <- Parsed.fromTry(provideOrderDigitalCodesRequestData.validated(failFast))
            result <- Parsed.eval(service.provideOrderDigitalCodes(campaignId, orderId, provideOrderDigitalCodesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Передача кодов маркировки единиц товара
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/cancellation/accept, /campaigns/{campaignId}/orders/{orderId}/identifiers, /campaigns/{campaignId}/orders/{orderId}/boxes, /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes, /campaigns/{campaignId}/orders/{orderId}/items, /campaigns/{campaignId}/orders/{orderId}/status] after/campaigns, ignoring @cask.put("/campaigns/:campaignId/orders/:orderId/identifiers")
        def provideOrderItemIdentifiers(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
              provideOrderItemIdentifiersRequestData <- Parsed.eval(ProvideOrderItemIdentifiersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as ProvideOrderItemIdentifiersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              provideOrderItemIdentifiersRequest <- Parsed.fromTry(provideOrderItemIdentifiersRequestData.validated(failFast))
            result <- Parsed.eval(service.provideOrderItemIdentifiers(campaignId, orderId, provideOrderItemIdentifiersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : ProvideOrderItemIdentifiersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Подготовка заказа
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/cancellation/accept, /campaigns/{campaignId}/orders/{orderId}/identifiers, /campaigns/{campaignId}/orders/{orderId}/boxes, /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes, /campaigns/{campaignId}/orders/{orderId}/items, /campaigns/{campaignId}/orders/{orderId}/status] after/campaigns, ignoring @cask.put("/campaigns/:campaignId/orders/:orderId/boxes")
        def setOrderBoxLayout(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
              setOrderBoxLayoutRequestData <- Parsed.eval(SetOrderBoxLayoutRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as SetOrderBoxLayoutRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              setOrderBoxLayoutRequest <- Parsed.fromTry(setOrderBoxLayoutRequestData.validated(failFast))
            result <- Parsed.eval(service.setOrderBoxLayout(campaignId, orderId, setOrderBoxLayoutRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : SetOrderBoxLayoutResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Передача количества грузовых мест в заказе
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/cancellation/accept, /campaigns/{campaignId}/orders/{orderId}/identifiers, /campaigns/{campaignId}/orders/{orderId}/boxes, /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes, /campaigns/{campaignId}/orders/{orderId}/items, /campaigns/{campaignId}/orders/{orderId}/status] after/campaigns, ignoring @cask.put("/campaigns/:campaignId/orders/:orderId/delivery/shipments/:shipmentId/boxes")
        def setOrderShipmentBoxes(campaignId : Long, orderId : Long, shipmentId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            shipmentId <- Parsed(shipmentId)
              setOrderShipmentBoxesRequestData <- Parsed.eval(SetOrderShipmentBoxesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as SetOrderShipmentBoxesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              setOrderShipmentBoxesRequest <- Parsed.fromTry(setOrderShipmentBoxesRequestData.validated(failFast))
            result <- Parsed.eval(service.setOrderShipmentBoxes(campaignId, orderId, shipmentId, setOrderShipmentBoxesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : SetOrderShipmentBoxesResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление товара из заказа или уменьшение числа единиц
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/cancellation/accept, /campaigns/{campaignId}/orders/{orderId}/identifiers, /campaigns/{campaignId}/orders/{orderId}/boxes, /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes, /campaigns/{campaignId}/orders/{orderId}/items, /campaigns/{campaignId}/orders/{orderId}/status] after/campaigns, ignoring @cask.put("/campaigns/:campaignId/orders/:orderId/items")
        def updateOrderItems(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
              updateOrderItemRequestData <- Parsed.eval(UpdateOrderItemRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateOrderItemRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateOrderItemRequest <- Parsed.fromTry(updateOrderItemRequestData.validated(failFast))
            result <- Parsed.eval(service.updateOrderItems(campaignId, orderId, updateOrderItemRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Изменение статуса одного заказа
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/cancellation/accept, /campaigns/{campaignId}/orders/{orderId}/identifiers, /campaigns/{campaignId}/orders/{orderId}/boxes, /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes, /campaigns/{campaignId}/orders/{orderId}/items, /campaigns/{campaignId}/orders/{orderId}/status] after/campaigns, ignoring @cask.put("/campaigns/:campaignId/orders/:orderId/status")
        def updateOrderStatus(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
              updateOrderStatusRequestData <- Parsed.eval(UpdateOrderStatusRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateOrderStatusRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateOrderStatusRequest <- Parsed.fromTry(updateOrderStatusRequestData.validated(failFast))
            result <- Parsed.eval(service.updateOrderStatus(campaignId, orderId, updateOrderStatusRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : UpdateOrderStatusResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Изменение статусов нескольких заказов
         * 
         */
        // conflicts with [/campaigns/{campaignId}/orders/{orderId}/deliverDigitalGoods, /campaigns/{campaignId}/orders/status-update] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/orders/status-update")
        def updateOrderStatuses(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              updateOrderStatusesRequestData <- Parsed.eval(UpdateOrderStatusesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateOrderStatusesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateOrderStatusesRequest <- Parsed.fromTry(updateOrderStatusesRequestData.validated(failFast))
            result <- Parsed.eval(service.updateOrderStatuses(campaignId, updateOrderStatusesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : UpdateOrderStatusesResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }

    initialize()
}
