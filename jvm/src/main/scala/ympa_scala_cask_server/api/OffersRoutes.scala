//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * OpenAPI spec version: LATEST
 *
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 *
 * https://openapi-generator.tech
 */


// this is generated from apiRoutes.mustache
package ympa_scala_cask_server.api

import ympa_scala_cask_server.model.*

import upickle.default.{ReadWriter => RW, macroRW}
import upickle.default.*

import ympa_scala_cask_server.model.ApiClientDataErrorResponse
import ympa_scala_cask_server.model.ApiForbiddenErrorResponse
import ympa_scala_cask_server.model.ApiLimitErrorResponse
import ympa_scala_cask_server.model.ApiLockedErrorResponse
import ympa_scala_cask_server.model.ApiNotFoundErrorResponse
import ympa_scala_cask_server.model.ApiServerErrorResponse
import ympa_scala_cask_server.model.ApiUnauthorizedErrorResponse
import ympa_scala_cask_server.model.CurrencyType
import ympa_scala_cask_server.model.DeleteCampaignOffersRequest
import ympa_scala_cask_server.model.DeleteCampaignOffersResponse
import ympa_scala_cask_server.model.EmptyApiResponse
import ympa_scala_cask_server.model.GetAllOffersResponse
import ympa_scala_cask_server.model.GetCampaignOffersRequest
import ympa_scala_cask_server.model.GetCampaignOffersResponse
import ympa_scala_cask_server.model.GetOfferRecommendationsRequest
import ympa_scala_cask_server.model.GetOfferRecommendationsResponse
import ympa_scala_cask_server.model.GetOffersResponse
import ympa_scala_cask_server.model.UpdateCampaignOffersRequest

class OffersRoutes(service : OffersService) extends cask.Routes {

    // route group for routeWorkAroundForPOSTCampaigns
    @cask.post("/campaigns", true)
    def routeWorkAroundForPOSTCampaigns(request: cask.Request,pageToken : Option[String] = None,limit : Option[Int] = None) = {
        request.remainingPathSegments match {
            case Seq(campaignId,"offers","delete") => deleteCampaignOffers(campaignId.toLong,request)
            case Seq(campaignId,"offers") => getCampaignOffers(campaignId.toLong,request,pageToken, limit)
            case Seq(campaignId,"offers","update") => updateCampaignOffers(campaignId.toLong,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }
    // route group for routeWorkAroundForGETCampaigns
    @cask.get("/campaigns", true)
    def routeWorkAroundForGETCampaigns(request: cask.Request,feedId : Option[Long] = None,chunk : Option[Int] = None,query : Option[String] = None,feedId : Option[Long] = None,shopCategoryId : Option[String] = None,currency : Option[CurrencyType] = None,matched : Option[Boolean] = None,page : Option[Int] = None,pageSize : Option[Int] = None) = {
        request.remainingPathSegments match {
            case Seq(campaignId,"offers","all") => getAllOffers(campaignId.toLong,request,feedId, chunk)
            case Seq(campaignId,"offers") => getOffers(campaignId.toLong,request,query, feedId, shopCategoryId, currency, matched, page, pageSize)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }

        /** Удаление товаров из ассортимента магазина
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/offers/update] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offers/delete")
        def deleteCampaignOffers(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              deleteCampaignOffersRequestData <- Parsed.eval(DeleteCampaignOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as DeleteCampaignOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              deleteCampaignOffersRequest <- Parsed.fromTry(deleteCampaignOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.deleteCampaignOffers(campaignId, deleteCampaignOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : DeleteCampaignOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Все предложения магазина
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}/offers] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/offers/all")
        def getAllOffers(campaignId : Long, request: cask.Request, feedId : Option[Long], chunk : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getAllOffers(campaignId, feedId, chunk))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetAllOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о товарах, которые размещены в заданном магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/offers/update] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offers")
        def getCampaignOffers(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              getCampaignOffersRequestData <- Parsed.eval(GetCampaignOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetCampaignOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getCampaignOffersRequest <- Parsed.fromTry(getCampaignOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.getCampaignOffers(campaignId, getCampaignOffersRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCampaignOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Рекомендации Маркета, касающиеся цен
         * 
         */
        @cask.post("/businesses/:businessId/offers/recommendations")
        def getOfferRecommendations(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getOfferRecommendationsRequestData <- Parsed.eval(GetOfferRecommendationsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetOfferRecommendationsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getOfferRecommendationsRequest <- Parsed.fromTry(getOfferRecommendationsRequestData.validated(failFast))
            result <- Parsed.eval(service.getOfferRecommendations(businessId, getOfferRecommendationsRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOfferRecommendationsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Предложения магазина
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}/offers] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/offers")
        def getOffers(campaignId : Long, request: cask.Request, query : Option[String], feedId : Option[Long], shopCategoryId : Option[String], currency : Option[CurrencyType], matched : Option[Boolean], page : Option[Int], pageSize : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getOffers(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Изменение условий продажи товаров в магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/offers/update] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offers/update")
        def updateCampaignOffers(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              updateCampaignOffersRequestData <- Parsed.eval(UpdateCampaignOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateCampaignOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateCampaignOffersRequest <- Parsed.fromTry(updateCampaignOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.updateCampaignOffers(campaignId, updateCampaignOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }

    initialize()
}
