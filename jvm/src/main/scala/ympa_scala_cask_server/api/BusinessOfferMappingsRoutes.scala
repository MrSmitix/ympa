//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * OpenAPI spec version: LATEST
 *
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 *
 * https://openapi-generator.tech
 */


// this is generated from apiRoutes.mustache
package ympa_scala_cask_server.api

import ympa_scala_cask_server.model.*

import upickle.default.{ReadWriter => RW, macroRW}
import upickle.default.*

import ympa_scala_cask_server.model.AddOffersToArchiveRequest
import ympa_scala_cask_server.model.AddOffersToArchiveResponse
import ympa_scala_cask_server.model.ApiClientDataErrorResponse
import ympa_scala_cask_server.model.ApiForbiddenErrorResponse
import ympa_scala_cask_server.model.ApiLimitErrorResponse
import ympa_scala_cask_server.model.ApiLockedErrorResponse
import ympa_scala_cask_server.model.ApiNotFoundErrorResponse
import ympa_scala_cask_server.model.ApiServerErrorResponse
import ympa_scala_cask_server.model.ApiUnauthorizedErrorResponse
import ympa_scala_cask_server.model.DeleteOffersFromArchiveRequest
import ympa_scala_cask_server.model.DeleteOffersFromArchiveResponse
import ympa_scala_cask_server.model.DeleteOffersRequest
import ympa_scala_cask_server.model.DeleteOffersResponse
import ympa_scala_cask_server.model.GetOfferMappingsRequest
import ympa_scala_cask_server.model.GetOfferMappingsResponse
import ympa_scala_cask_server.model.GetSuggestedOfferMappingsRequest
import ympa_scala_cask_server.model.GetSuggestedOfferMappingsResponse
import ympa_scala_cask_server.model.UpdateOfferMappingsRequest
import ympa_scala_cask_server.model.UpdateOfferMappingsResponse

class BusinessOfferMappingsRoutes(service : BusinessOfferMappingsService) extends cask.Routes {

    // route group for routeWorkAroundForPOSTBusinesses
    @cask.post("/businesses", true)
    def routeWorkAroundForPOSTBusinesses(request: cask.Request,pageToken : Option[String] = None,limit : Option[Int] = None) = {
        request.remainingPathSegments match {
            case Seq(businessId,"offer-mappings","archive") => addOffersToArchive(businessId.toLong,request)
            case Seq(businessId,"offer-mappings","delete") => deleteOffers(businessId.toLong,request)
            case Seq(businessId,"offer-mappings","unarchive") => deleteOffersFromArchive(businessId.toLong,request)
            case Seq(businessId,"offer-mappings") => getOfferMappings(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"offer-mappings","suggestions") => getSuggestedOfferMappings(businessId.toLong,request)
            case Seq(businessId,"offer-mappings","update") => updateOfferMappings(businessId.toLong,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }

        /** Добавление товаров в архив
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/offer-mappings/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/archive")
        def addOffersToArchive(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              addOffersToArchiveRequestData <- Parsed.eval(AddOffersToArchiveRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as AddOffersToArchiveRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              addOffersToArchiveRequest <- Parsed.fromTry(addOffersToArchiveRequestData.validated(failFast))
            result <- Parsed.eval(service.addOffersToArchive(businessId, addOffersToArchiveRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : AddOffersToArchiveResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление товаров из каталога
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/offer-mappings/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/delete")
        def deleteOffers(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              deleteOffersRequestData <- Parsed.eval(DeleteOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as DeleteOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              deleteOffersRequest <- Parsed.fromTry(deleteOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.deleteOffers(businessId, deleteOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : DeleteOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление товаров из архива
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/offer-mappings/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/unarchive")
        def deleteOffersFromArchive(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              deleteOffersFromArchiveRequestData <- Parsed.eval(DeleteOffersFromArchiveRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as DeleteOffersFromArchiveRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              deleteOffersFromArchiveRequest <- Parsed.fromTry(deleteOffersFromArchiveRequestData.validated(failFast))
            result <- Parsed.eval(service.deleteOffersFromArchive(businessId, deleteOffersFromArchiveRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : DeleteOffersFromArchiveResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о товарах в каталоге
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/offer-mappings/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings")
        def getOfferMappings(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getOfferMappingsRequestData <- Parsed.eval(GetOfferMappingsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetOfferMappingsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getOfferMappingsRequest <- Parsed.fromTry(getOfferMappingsRequestData.validated(failFast))
            result <- Parsed.eval(service.getOfferMappings(businessId, pageToken, limit, getOfferMappingsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOfferMappingsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Просмотр карточек на Маркете, которые подходят вашим товарам
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/offer-mappings/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/suggestions")
        def getSuggestedOfferMappings(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getSuggestedOfferMappingsRequestData <- Parsed.eval(GetSuggestedOfferMappingsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetSuggestedOfferMappingsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getSuggestedOfferMappingsRequest <- Parsed.fromTry(getSuggestedOfferMappingsRequestData.validated(failFast))
            result <- Parsed.eval(service.getSuggestedOfferMappings(businessId, getSuggestedOfferMappingsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetSuggestedOfferMappingsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Добавление товаров в каталог и изменение информации о них
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/offer-mappings/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/update")
        def updateOfferMappings(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              updateOfferMappingsRequestData <- Parsed.eval(UpdateOfferMappingsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateOfferMappingsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateOfferMappingsRequest <- Parsed.fromTry(updateOfferMappingsRequestData.validated(failFast))
            result <- Parsed.eval(service.updateOfferMappings(businessId, updateOfferMappingsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : UpdateOfferMappingsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }

    initialize()
}
