//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * OpenAPI spec version: LATEST
 *
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 *
 * https://openapi-generator.tech
 */


// this is generated from apiRoutes.mustache
package ympa_scala_cask_server.api

import ympa_scala_cask_server.model.*

import upickle.default.{ReadWriter => RW, macroRW}
import upickle.default.*

import ympa_scala_cask_server.model.ApiClientDataErrorResponse
import ympa_scala_cask_server.model.ApiForbiddenErrorResponse
import ympa_scala_cask_server.model.ApiLimitErrorResponse
import ympa_scala_cask_server.model.ApiNotFoundErrorResponse
import ympa_scala_cask_server.model.ApiServerErrorResponse
import ympa_scala_cask_server.model.ApiUnauthorizedErrorResponse
import ympa_scala_cask_server.model.CreateChatRequest
import ympa_scala_cask_server.model.CreateChatResponse
import ympa_scala_cask_server.model.EmptyApiResponse
import java.io.File
import ympa_scala_cask_server.model.GetChatHistoryRequest
import ympa_scala_cask_server.model.GetChatHistoryResponse
import ympa_scala_cask_server.model.GetChatsRequest
import ympa_scala_cask_server.model.GetChatsResponse
import ympa_scala_cask_server.model.SendMessageToChatRequest

class ChatsRoutes(service : ChatsService) extends cask.Routes {

    // route group for routeWorkAroundForPOSTBusinesses
    @cask.post("/businesses", true)
    def routeWorkAroundForPOSTBusinesses(request: cask.Request,chatId : Option[Long] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,chatId : Option[Long] = None,chatId : Option[Long] = None) = {
        request.remainingPathSegments match {
            case Seq(businessId,"chats","new") => createChat(businessId.toLong,request)
            case Seq(businessId,"chats","history") => getChatHistory(businessId.toLong,request,chatId.getOrElse(), pageToken, limit)
            case Seq(businessId,"chats") => getChats(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"chats","file","send") => sendFileToChat(businessId.toLong,request,chatId.getOrElse())
            case Seq(businessId,"chats","message") => sendMessageToChat(businessId.toLong,request,chatId.getOrElse())
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }

        /** Создание нового чата с покупателем
         * 
         */
        // conflicts with [/businesses/{businessId}/chats/new, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message] after/businesses, ignoring @cask.post("/businesses/:businessId/chats/new")
        def createChat(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              createChatRequestData <- Parsed.eval(CreateChatRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as CreateChatRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              createChatRequest <- Parsed.fromTry(createChatRequestData.validated(failFast))
            result <- Parsed.eval(service.createChat(businessId, createChatRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : CreateChatResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение истории сообщений в чате
         * 
         */
        // conflicts with [/businesses/{businessId}/chats/new, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message] after/businesses, ignoring @cask.post("/businesses/:businessId/chats/history")
        def getChatHistory(businessId : Long, request: cask.Request, chatId : Long, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getChatHistoryRequestData <- Parsed.eval(GetChatHistoryRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetChatHistoryRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getChatHistoryRequest <- Parsed.fromTry(getChatHistoryRequestData.validated(failFast))
            result <- Parsed.eval(service.getChatHistory(businessId, chatId, getChatHistoryRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetChatHistoryResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение доступных чатов
         * 
         */
        // conflicts with [/businesses/{businessId}/chats/new, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message] after/businesses, ignoring @cask.post("/businesses/:businessId/chats")
        def getChats(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getChatsRequestData <- Parsed.eval(GetChatsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetChatsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getChatsRequest <- Parsed.fromTry(getChatsRequestData.validated(failFast))
            result <- Parsed.eval(service.getChats(businessId, getChatsRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetChatsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отправка файла в чат
         * 
         */
        // conflicts with [/businesses/{businessId}/chats/new, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message] after/businesses, ignoring @cask.post("/businesses/:businessId/chats/file/send")
        def sendFileToChat(businessId : Long, request: cask.Request, chatId : Long) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
        file <- request.formValueAsFileRequired("file")
            result <- Parsed.eval(service.sendFileToChat(businessId, chatId, file))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отправка сообщения в чат
         * 
         */
        // conflicts with [/businesses/{businessId}/chats/new, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message] after/businesses, ignoring @cask.post("/businesses/:businessId/chats/message")
        def sendMessageToChat(businessId : Long, request: cask.Request, chatId : Long) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              sendMessageToChatRequestData <- Parsed.eval(SendMessageToChatRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as SendMessageToChatRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              sendMessageToChatRequest <- Parsed.fromTry(sendMessageToChatRequestData.validated(failFast))
            result <- Parsed.eval(service.sendMessageToChat(businessId, chatId, sendMessageToChatRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }

    initialize()
}
