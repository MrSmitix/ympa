//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * OpenAPI spec version: LATEST
 *
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 *
 * https://openapi-generator.tech
 */


// this is generated from apiRoutes.mustache
package ympa_scala_cask_server.api

import ympa_scala_cask_server.model.*

import upickle.default.{ReadWriter => RW, macroRW}
import upickle.default.*

import ympa_scala_cask_server.model.AddHiddenOffersRequest
import ympa_scala_cask_server.model.AddOffersToArchiveRequest
import ympa_scala_cask_server.model.AddOffersToArchiveResponse
import ympa_scala_cask_server.model.ApiClientDataErrorResponse
import ympa_scala_cask_server.model.ApiForbiddenErrorResponse
import ympa_scala_cask_server.model.ApiLimitErrorResponse
import ympa_scala_cask_server.model.ApiLockedErrorResponse
import ympa_scala_cask_server.model.ApiNotFoundErrorResponse
import ympa_scala_cask_server.model.ApiServerErrorResponse
import ympa_scala_cask_server.model.ApiUnauthorizedErrorResponse
import ympa_scala_cask_server.model.CalculateTariffsRequest
import ympa_scala_cask_server.model.CalculateTariffsResponse
import ympa_scala_cask_server.model.ConfirmPricesRequest
import ympa_scala_cask_server.model.CreateChatRequest
import ympa_scala_cask_server.model.CreateChatResponse
import ympa_scala_cask_server.model.CurrencyType
import ympa_scala_cask_server.model.DeleteCampaignOffersRequest
import ympa_scala_cask_server.model.DeleteCampaignOffersResponse
import ympa_scala_cask_server.model.DeleteGoodsFeedbackCommentRequest
import ympa_scala_cask_server.model.DeleteHiddenOffersRequest
import ympa_scala_cask_server.model.DeleteOffersFromArchiveRequest
import ympa_scala_cask_server.model.DeleteOffersFromArchiveResponse
import ympa_scala_cask_server.model.DeleteOffersRequest
import ympa_scala_cask_server.model.DeleteOffersResponse
import ympa_scala_cask_server.model.DeletePromoOffersRequest
import ympa_scala_cask_server.model.DeletePromoOffersResponse
import ympa_scala_cask_server.model.EmptyApiResponse
import ympa_scala_cask_server.model.FeedIndexLogsStatusType
import java.io.File
import ympa_scala_cask_server.model.GenerateBoostConsolidatedRequest
import ympa_scala_cask_server.model.GenerateCompetitorsPositionReportRequest
import ympa_scala_cask_server.model.GenerateGoodsFeedbackRequest
import ympa_scala_cask_server.model.GenerateGoodsMovementReportRequest
import ympa_scala_cask_server.model.GenerateGoodsRealizationReportRequest
import ympa_scala_cask_server.model.GenerateGoodsTurnoverRequest
import ympa_scala_cask_server.model.GeneratePricesReportRequest
import ympa_scala_cask_server.model.GenerateReportResponse
import ympa_scala_cask_server.model.GenerateShelfsStatisticsRequest
import ympa_scala_cask_server.model.GenerateShowsSalesReportRequest
import ympa_scala_cask_server.model.GenerateStocksOnWarehousesReportRequest
import ympa_scala_cask_server.model.GenerateUnitedMarketplaceServicesReportRequest
import ympa_scala_cask_server.model.GenerateUnitedNettingReportRequest
import ympa_scala_cask_server.model.GenerateUnitedOrdersRequest
import ympa_scala_cask_server.model.GetAllOffersResponse
import ympa_scala_cask_server.model.GetBidsInfoRequest
import ympa_scala_cask_server.model.GetBidsInfoResponse
import ympa_scala_cask_server.model.GetBidsRecommendationsRequest
import ympa_scala_cask_server.model.GetBidsRecommendationsResponse
import ympa_scala_cask_server.model.GetBusinessBuyerInfoResponse
import ympa_scala_cask_server.model.GetBusinessDocumentsInfoResponse
import ympa_scala_cask_server.model.GetBusinessSettingsResponse
import ympa_scala_cask_server.model.GetCampaignLoginsResponse
import ympa_scala_cask_server.model.GetCampaignOffersRequest
import ympa_scala_cask_server.model.GetCampaignOffersResponse
import ympa_scala_cask_server.model.GetCampaignRegionResponse
import ympa_scala_cask_server.model.GetCampaignResponse
import ympa_scala_cask_server.model.GetCampaignSettingsResponse
import ympa_scala_cask_server.model.GetCampaignsResponse
import ympa_scala_cask_server.model.GetCategoriesMaxSaleQuantumRequest
import ympa_scala_cask_server.model.GetCategoriesMaxSaleQuantumResponse
import ympa_scala_cask_server.model.GetCategoriesRequest
import ympa_scala_cask_server.model.GetCategoriesResponse
import ympa_scala_cask_server.model.GetCategoryContentParametersResponse
import ympa_scala_cask_server.model.GetChatHistoryRequest
import ympa_scala_cask_server.model.GetChatHistoryResponse
import ympa_scala_cask_server.model.GetChatsRequest
import ympa_scala_cask_server.model.GetChatsResponse
import ympa_scala_cask_server.model.GetFeedIndexLogsResponse
import ympa_scala_cask_server.model.GetFeedResponse
import ympa_scala_cask_server.model.GetFeedbackListResponse
import ympa_scala_cask_server.model.GetFeedsResponse
import ympa_scala_cask_server.model.GetFulfillmentWarehousesResponse
import ympa_scala_cask_server.model.GetGoodsFeedbackCommentsRequest
import ympa_scala_cask_server.model.GetGoodsFeedbackCommentsResponse
import ympa_scala_cask_server.model.GetGoodsFeedbackRequest
import ympa_scala_cask_server.model.GetGoodsFeedbackResponse
import ympa_scala_cask_server.model.GetGoodsStatsRequest
import ympa_scala_cask_server.model.GetGoodsStatsResponse
import ympa_scala_cask_server.model.GetHiddenOffersResponse
import ympa_scala_cask_server.model.GetOfferCardsContentStatusRequest
import ympa_scala_cask_server.model.GetOfferCardsContentStatusResponse
import ympa_scala_cask_server.model.GetOfferMappingEntriesResponse
import ympa_scala_cask_server.model.GetOfferMappingsRequest
import ympa_scala_cask_server.model.GetOfferMappingsResponse
import ympa_scala_cask_server.model.GetOfferRecommendationsRequest
import ympa_scala_cask_server.model.GetOfferRecommendationsResponse
import ympa_scala_cask_server.model.GetOffersResponse
import ympa_scala_cask_server.model.GetOrderResponse
import ympa_scala_cask_server.model.GetOrdersResponse
import ympa_scala_cask_server.model.GetOrdersStatsRequest
import ympa_scala_cask_server.model.GetOrdersStatsResponse
import ympa_scala_cask_server.model.GetPricesByOfferIdsRequest
import ympa_scala_cask_server.model.GetPricesByOfferIdsResponse
import ympa_scala_cask_server.model.GetPricesResponse
import ympa_scala_cask_server.model.GetPromoOffersRequest
import ympa_scala_cask_server.model.GetPromoOffersResponse
import ympa_scala_cask_server.model.GetPromosRequest
import ympa_scala_cask_server.model.GetPromosResponse
import ympa_scala_cask_server.model.GetQualityRatingRequest
import ympa_scala_cask_server.model.GetQualityRatingResponse
import ympa_scala_cask_server.model.GetQuarantineOffersRequest
import ympa_scala_cask_server.model.GetQuarantineOffersResponse
import ympa_scala_cask_server.model.GetRegionWithChildrenResponse
import ympa_scala_cask_server.model.GetRegionsResponse
import ympa_scala_cask_server.model.GetReportInfoResponse
import ympa_scala_cask_server.model.GetReturnResponse
import ympa_scala_cask_server.model.GetReturnsResponse
import ympa_scala_cask_server.model.GetSuggestedOfferMappingEntriesRequest
import ympa_scala_cask_server.model.GetSuggestedOfferMappingEntriesResponse
import ympa_scala_cask_server.model.GetSuggestedOfferMappingsRequest
import ympa_scala_cask_server.model.GetSuggestedOfferMappingsResponse
import ympa_scala_cask_server.model.GetWarehouseStocksRequest
import ympa_scala_cask_server.model.GetWarehouseStocksResponse
import java.time.LocalDate
import ympa_scala_cask_server.model.OfferAvailabilityStatusType
import ympa_scala_cask_server.model.OfferMappingKindType
import ympa_scala_cask_server.model.OfferProcessingStatusType
import java.time.OffsetDateTime
import ympa_scala_cask_server.model.OrderBuyerType
import ympa_scala_cask_server.model.OrderDeliveryDispatchType
import ympa_scala_cask_server.model.OrderStatusType
import ympa_scala_cask_server.model.OrderSubstatusType
import ympa_scala_cask_server.model.PutSkuBidsRequest
import ympa_scala_cask_server.model.RefundStatusType
import ympa_scala_cask_server.model.ReportFormatType
import ympa_scala_cask_server.model.ReturnType
import ympa_scala_cask_server.model.SendMessageToChatRequest
import ympa_scala_cask_server.model.SetFeedParamsRequest
import ympa_scala_cask_server.model.SkipGoodsFeedbackReactionRequest
import ympa_scala_cask_server.model.SuggestPricesRequest
import ympa_scala_cask_server.model.SuggestPricesResponse
import ympa_scala_cask_server.model.UpdateBusinessPricesRequest
import ympa_scala_cask_server.model.UpdateCampaignOffersRequest
import ympa_scala_cask_server.model.UpdateGoodsFeedbackCommentRequest
import ympa_scala_cask_server.model.UpdateGoodsFeedbackCommentResponse
import ympa_scala_cask_server.model.UpdateOfferContentRequest
import ympa_scala_cask_server.model.UpdateOfferContentResponse
import ympa_scala_cask_server.model.UpdateOfferMappingEntryRequest
import ympa_scala_cask_server.model.UpdateOfferMappingsRequest
import ympa_scala_cask_server.model.UpdateOfferMappingsResponse
import ympa_scala_cask_server.model.UpdatePricesRequest
import ympa_scala_cask_server.model.UpdatePromoOffersRequest
import ympa_scala_cask_server.model.UpdatePromoOffersResponse

class FbyRoutes(service : FbyService) extends cask.Routes {

    // route group for routeWorkAroundForPOSTCampaigns
    @cask.post("/campaigns", true)
    def routeWorkAroundForPOSTCampaigns(request: cask.Request,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None) = {
        request.remainingPathSegments match {
            case Seq(campaignId,"hidden-offers") => addHiddenOffers(campaignId.toLong,request)
            case Seq(campaignId,"price-quarantine","confirm") => confirmCampaignPrices(campaignId.toLong,request)
            case Seq(campaignId,"offers","delete") => deleteCampaignOffers(campaignId.toLong,request)
            case Seq(campaignId,"hidden-offers","delete") => deleteHiddenOffers(campaignId.toLong,request)
            case Seq(campaignId,"offers") => getCampaignOffers(campaignId.toLong,request,pageToken, limit)
            case Seq(campaignId,"price-quarantine") => getCampaignQuarantineOffers(campaignId.toLong,request,pageToken, limit)
            case Seq(campaignId,"stats","skus") => getGoodsStats(campaignId.toLong,request)
            case Seq(campaignId,"stats","orders") => getOrdersStats(campaignId.toLong,request,pageToken, limit)
            case Seq(campaignId,"offer-prices") => getPricesByOfferIds(campaignId.toLong,request,pageToken, limit)
            case Seq(campaignId,"offers","stocks") => getStocks(campaignId.toLong,request,pageToken, limit)
            case Seq(campaignId,"offer-mapping-entries","suggestions") => getSuggestedOfferMappingEntries(campaignId.toLong,request)
            case Seq(campaignId,"offer-prices","suggestions") => getSuggestedPrices(campaignId.toLong,request)
            case Seq(campaignId,"offers","update") => updateCampaignOffers(campaignId.toLong,request)
            case Seq(campaignId,"offer-mapping-entries","updates") => updateOfferMappingEntries(campaignId.toLong,request)
            case Seq(campaignId,"offer-prices","updates") => updatePrices(campaignId.toLong,request)
            case Seq(campaignId,"orders",orderId,"business-buyer") => getOrderBusinessBuyerInfo(campaignId.toLong, orderId.toLong,request)
            case Seq(campaignId,"orders",orderId,"documents") => getOrderBusinessDocumentsInfo(campaignId.toLong, orderId.toLong,request)
            case Seq(campaignId,"feeds",feedId,"refresh") => refreshFeed(campaignId.toLong, feedId.toLong,request)
            case Seq(campaignId,"feeds",feedId,"params") => setFeedParams(campaignId.toLong, feedId.toLong,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }
    // route group for routeWorkAroundForGETCampaigns
    @cask.get("/campaigns", true)
    def routeWorkAroundForGETCampaigns(request: cask.Request,page : Option[Int] = None,pageSize : Option[Int] = None,feedId : Option[Long] = None,chunk : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,fromDate : Option[LocalDate] = None,offerId : Seq[String] = Nil,pageToken : Option[String] = None,limit : Option[Int] = None,offset : Option[Int] = None,page : Option[Int] = None,pageSize : Option[Int] = None,offerId : Seq[String] = Nil,shopSku : Seq[String] = Nil,mappingKind : Option[OfferMappingKindType] = None,status : Seq[OfferProcessingStatusType] = Nil,availability : Seq[OfferAvailabilityStatusType] = Nil,categoryId : Seq[Int] = Nil,vendor : Seq[String] = Nil,pageToken : Option[String] = None,limit : Option[Int] = None,query : Option[String] = None,feedId : Option[Long] = None,shopCategoryId : Option[String] = None,currency : Option[CurrencyType] = None,matched : Option[Boolean] = None,page : Option[Int] = None,pageSize : Option[Int] = None,orderIds : Seq[Long] = Nil,status : Set[OrderStatusType] = Set.empty,substatus : Set[OrderSubstatusType] = Set.empty,fromDate : Option[LocalDate] = None,toDate : Option[LocalDate] = None,supplierShipmentDateFrom : Option[LocalDate] = None,supplierShipmentDateTo : Option[LocalDate] = None,updatedAtFrom : Option[OffsetDateTime] = None,updatedAtTo : Option[OffsetDateTime] = None,dispatchType : Option[OrderDeliveryDispatchType] = None,fake : Option[Boolean] = None,hasCis : Option[Boolean] = None,onlyWaitingForCancellationApprove : Option[Boolean] = None,onlyEstimatedDelivery : Option[Boolean] = None,buyerType : Option[OrderBuyerType] = None,page : Option[Int] = None,pageSize : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,archived : Option[Boolean] = None,pageToken : Option[String] = None,limit : Option[Int] = None,orderIds : Seq[Long] = Nil,statuses : Seq[RefundStatusType] = Nil,`type` : Option[ReturnType] = None,fromDate : Option[LocalDate] = None,toDate : Option[LocalDate] = None,fromDate2 : Option[LocalDate] = None,toDate2 : Option[LocalDate] = None,page : Option[Int] = None,pageSize : Option[Int] = None,limit : Option[Int] = None,publishedTimeFrom : Option[OffsetDateTime] = None,publishedTimeTo : Option[OffsetDateTime] = None,status : Option[FeedIndexLogsStatusType] = None) = {
        request.remainingPathSegments match {
            case Seq() => getCampaigns(request,page, pageSize)
            case Seq(campaignId,"offers","all") => getAllOffers(campaignId.toLong,request,feedId, chunk)
            case Seq(campaignId) => getCampaign(campaignId.toLong,request)
            case Seq(campaignId,"logins") => getCampaignLogins(campaignId.toLong,request)
            case Seq(campaignId,"region") => getCampaignRegion(campaignId.toLong,request)
            case Seq(campaignId,"settings") => getCampaignSettings(campaignId.toLong,request)
            case Seq(campaignId,"feedback","updates") => getFeedbackAndCommentUpdates(campaignId.toLong,request,pageToken, limit, fromDate)
            case Seq(campaignId,"feeds") => getFeeds(campaignId.toLong,request)
            case Seq(campaignId,"hidden-offers") => getHiddenOffers(campaignId.toLong,request,offerId, pageToken, limit, offset, page, pageSize)
            case Seq(campaignId,"offer-mapping-entries") => getOfferMappingEntries(campaignId.toLong,request,offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit)
            case Seq(campaignId,"offers") => getOffers(campaignId.toLong,request,query, feedId, shopCategoryId, currency, matched, page, pageSize)
            case Seq(campaignId,"orders") => getOrders(campaignId.toLong,request,orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit)
            case Seq(campaignId,"offer-prices") => getPrices(campaignId.toLong,request,pageToken, limit, archived)
            case Seq(campaignId,"returns") => getReturns(campaignId.toLong,request,pageToken, limit, orderIds, statuses, `type`, fromDate, toDate, fromDate2, toDate2)
            case Seq("by_login",login) => getCampaignsByLogin(login,request,page, pageSize)
            case Seq(campaignId,"feeds",feedId) => getFeed(campaignId.toLong, feedId.toLong,request)
            case Seq(campaignId,"feeds",feedId,"index-logs") => getFeedIndexLogs(campaignId.toLong, feedId.toLong,request,limit, publishedTimeFrom, publishedTimeTo, status)
            case Seq(campaignId,"orders",orderId) => getOrder(campaignId.toLong, orderId.toLong,request)
            case Seq(campaignId,"orders",orderId,"returns",returnId) => getReturn(campaignId.toLong, orderId.toLong, returnId.toLong,request)
            case Seq(campaignId,"orders",orderId,"returns",returnId,"decision",itemId,"image",imageHash) => getReturnPhoto(campaignId.toLong, orderId.toLong, returnId.toLong, itemId.toLong, imageHash,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }
    // route group for routeWorkAroundForGETRegions
    @cask.get("/regions", true)
    def routeWorkAroundForGETRegions(request: cask.Request,name : Option[String] = None,pageToken : Option[String] = None,limit : Option[Int] = None,page : Option[Int] = None,pageSize : Option[Int] = None) = {
        request.remainingPathSegments match {
            case Seq() => searchRegionsByName(request,name.getOrElse(""), pageToken, limit)
            case Seq(regionId,"children") => searchRegionChildren(regionId.toLong,request,page, pageSize)
            case Seq(regionId) => searchRegionsById(regionId.toLong,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }
    // route group for routeWorkAroundForPOSTBusinesses
    @cask.post("/businesses", true)
    def routeWorkAroundForPOSTBusinesses(request: cask.Request,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,chatId : Option[Long] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,pageToken : Option[String] = None,limit : Option[Int] = None,chatId : Option[Long] = None,chatId : Option[Long] = None) = {
        request.remainingPathSegments match {
            case Seq(businessId,"offer-mappings","archive") => addOffersToArchive(businessId.toLong,request)
            case Seq(businessId,"price-quarantine","confirm") => confirmBusinessPrices(businessId.toLong,request)
            case Seq(businessId,"chats","new") => createChat(businessId.toLong,request)
            case Seq(businessId,"goods-feedback","comments","delete") => deleteGoodsFeedbackComment(businessId.toLong,request)
            case Seq(businessId,"offer-mappings","delete") => deleteOffers(businessId.toLong,request)
            case Seq(businessId,"offer-mappings","unarchive") => deleteOffersFromArchive(businessId.toLong,request)
            case Seq(businessId,"promos","offers","delete") => deletePromoOffers(businessId.toLong,request)
            case Seq(businessId,"bids","info") => getBidsInfoForBusiness(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"bids","recommendations") => getBidsRecommendations(businessId.toLong,request)
            case Seq(businessId,"price-quarantine") => getBusinessQuarantineOffers(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"settings") => getBusinessSettings(businessId.toLong,request)
            case Seq(businessId,"chats","history") => getChatHistory(businessId.toLong,request,chatId.getOrElse(), pageToken, limit)
            case Seq(businessId,"chats") => getChats(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"goods-feedback","comments") => getGoodsFeedbackComments(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"goods-feedback") => getGoodsFeedbacks(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"offer-cards") => getOfferCardsContentStatus(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"offer-mappings") => getOfferMappings(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"offers","recommendations") => getOfferRecommendations(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"promos","offers") => getPromoOffers(businessId.toLong,request,pageToken, limit)
            case Seq(businessId,"promos") => getPromos(businessId.toLong,request)
            case Seq(businessId,"ratings","quality") => getQualityRatings(businessId.toLong,request)
            case Seq(businessId,"offer-mappings","suggestions") => getSuggestedOfferMappings(businessId.toLong,request)
            case Seq(businessId,"chats","file","send") => sendFileToChat(businessId.toLong,request,chatId.getOrElse())
            case Seq(businessId,"chats","message") => sendMessageToChat(businessId.toLong,request,chatId.getOrElse())
            case Seq(businessId,"goods-feedback","skip-reaction") => skipGoodsFeedbacksReaction(businessId.toLong,request)
            case Seq(businessId,"offer-prices","updates") => updateBusinessPrices(businessId.toLong,request)
            case Seq(businessId,"goods-feedback","comments","update") => updateGoodsFeedbackComment(businessId.toLong,request)
            case Seq(businessId,"offer-cards","update") => updateOfferContent(businessId.toLong,request)
            case Seq(businessId,"offer-mappings","update") => updateOfferMappings(businessId.toLong,request)
            case Seq(businessId,"promos","offers","update") => updatePromoOffers(businessId.toLong,request)
            case _          => cask.Response("Not Found", statusCode = 404)
        }
    }

        /** Скрытие товаров и настройки скрытия
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/hidden-offers")
        def addHiddenOffers(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              addHiddenOffersRequestData <- Parsed.eval(AddHiddenOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as AddHiddenOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              addHiddenOffersRequest <- Parsed.fromTry(addHiddenOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.addHiddenOffers(campaignId, addHiddenOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Добавление товаров в архив
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/archive")
        def addOffersToArchive(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              addOffersToArchiveRequestData <- Parsed.eval(AddOffersToArchiveRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as AddOffersToArchiveRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              addOffersToArchiveRequest <- Parsed.fromTry(addOffersToArchiveRequestData.validated(failFast))
            result <- Parsed.eval(service.addOffersToArchive(businessId, addOffersToArchiveRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : AddOffersToArchiveResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Калькулятор стоимости услуг
         * 
         */
        @cask.post("/tariffs/calculate")
        def calculateTariffs(request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              calculateTariffsRequestData <- Parsed.eval(CalculateTariffsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as CalculateTariffsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              calculateTariffsRequest <- Parsed.fromTry(calculateTariffsRequestData.validated(failFast))
            result <- Parsed.eval(service.calculateTariffs(calculateTariffsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : CalculateTariffsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление товара из карантина по цене в кабинете
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/price-quarantine/confirm")
        def confirmBusinessPrices(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              confirmPricesRequestData <- Parsed.eval(ConfirmPricesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as ConfirmPricesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              confirmPricesRequest <- Parsed.fromTry(confirmPricesRequestData.validated(failFast))
            result <- Parsed.eval(service.confirmBusinessPrices(businessId, confirmPricesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление товара из карантина по цене в магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/price-quarantine/confirm")
        def confirmCampaignPrices(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              confirmPricesRequestData <- Parsed.eval(ConfirmPricesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as ConfirmPricesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              confirmPricesRequest <- Parsed.fromTry(confirmPricesRequestData.validated(failFast))
            result <- Parsed.eval(service.confirmCampaignPrices(campaignId, confirmPricesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Создание нового чата с покупателем
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/chats/new")
        def createChat(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              createChatRequestData <- Parsed.eval(CreateChatRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as CreateChatRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              createChatRequest <- Parsed.fromTry(createChatRequestData.validated(failFast))
            result <- Parsed.eval(service.createChat(businessId, createChatRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : CreateChatResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление товаров из ассортимента магазина
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offers/delete")
        def deleteCampaignOffers(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              deleteCampaignOffersRequestData <- Parsed.eval(DeleteCampaignOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as DeleteCampaignOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              deleteCampaignOffersRequest <- Parsed.fromTry(deleteCampaignOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.deleteCampaignOffers(campaignId, deleteCampaignOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : DeleteCampaignOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление комментария к отзыву
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/goods-feedback/comments/delete")
        def deleteGoodsFeedbackComment(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              deleteGoodsFeedbackCommentRequestData <- Parsed.eval(DeleteGoodsFeedbackCommentRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as DeleteGoodsFeedbackCommentRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              deleteGoodsFeedbackCommentRequest <- Parsed.fromTry(deleteGoodsFeedbackCommentRequestData.validated(failFast))
            result <- Parsed.eval(service.deleteGoodsFeedbackComment(businessId, deleteGoodsFeedbackCommentRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Возобновление показа товаров
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/hidden-offers/delete")
        def deleteHiddenOffers(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              deleteHiddenOffersRequestData <- Parsed.eval(DeleteHiddenOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as DeleteHiddenOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              deleteHiddenOffersRequest <- Parsed.fromTry(deleteHiddenOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.deleteHiddenOffers(campaignId, deleteHiddenOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление товаров из каталога
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/delete")
        def deleteOffers(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              deleteOffersRequestData <- Parsed.eval(DeleteOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as DeleteOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              deleteOffersRequest <- Parsed.fromTry(deleteOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.deleteOffers(businessId, deleteOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : DeleteOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление товаров из архива
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/unarchive")
        def deleteOffersFromArchive(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              deleteOffersFromArchiveRequestData <- Parsed.eval(DeleteOffersFromArchiveRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as DeleteOffersFromArchiveRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              deleteOffersFromArchiveRequest <- Parsed.fromTry(deleteOffersFromArchiveRequestData.validated(failFast))
            result <- Parsed.eval(service.deleteOffersFromArchive(businessId, deleteOffersFromArchiveRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : DeleteOffersFromArchiveResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Удаление товаров из акции
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/promos/offers/delete")
        def deletePromoOffers(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              deletePromoOffersRequestData <- Parsed.eval(DeletePromoOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as DeletePromoOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              deletePromoOffersRequest <- Parsed.fromTry(deletePromoOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.deletePromoOffers(businessId, deletePromoOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : DeletePromoOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по бусту продаж
         * 
         */
        @cask.post("/reports/boost-consolidated/generate")
        def generateBoostConsolidatedReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateBoostConsolidatedRequestData <- Parsed.eval(GenerateBoostConsolidatedRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateBoostConsolidatedRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateBoostConsolidatedRequest <- Parsed.fromTry(generateBoostConsolidatedRequestData.validated(failFast))
            result <- Parsed.eval(service.generateBoostConsolidatedReport(generateBoostConsolidatedRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет «Конкурентная позиция»
         * 
         */
        @cask.post("/reports/competitors-position/generate")
        def generateCompetitorsPositionReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateCompetitorsPositionReportRequestData <- Parsed.eval(GenerateCompetitorsPositionReportRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateCompetitorsPositionReportRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateCompetitorsPositionReportRequest <- Parsed.fromTry(generateCompetitorsPositionReportRequestData.validated(failFast))
            result <- Parsed.eval(service.generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по отзывам о товарах
         * 
         */
        @cask.post("/reports/goods-feedback/generate")
        def generateGoodsFeedbackReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateGoodsFeedbackRequestData <- Parsed.eval(GenerateGoodsFeedbackRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateGoodsFeedbackRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateGoodsFeedbackRequest <- Parsed.fromTry(generateGoodsFeedbackRequestData.validated(failFast))
            result <- Parsed.eval(service.generateGoodsFeedbackReport(generateGoodsFeedbackRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по движению товаров
         * 
         */
        @cask.post("/reports/goods-movement/generate")
        def generateGoodsMovementReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateGoodsMovementReportRequestData <- Parsed.eval(GenerateGoodsMovementReportRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateGoodsMovementReportRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateGoodsMovementReportRequest <- Parsed.fromTry(generateGoodsMovementReportRequestData.validated(failFast))
            result <- Parsed.eval(service.generateGoodsMovementReport(generateGoodsMovementReportRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по реализации
         * 
         */
        @cask.post("/reports/goods-realization/generate")
        def generateGoodsRealizationReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateGoodsRealizationReportRequestData <- Parsed.eval(GenerateGoodsRealizationReportRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateGoodsRealizationReportRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateGoodsRealizationReportRequest <- Parsed.fromTry(generateGoodsRealizationReportRequestData.validated(failFast))
            result <- Parsed.eval(service.generateGoodsRealizationReport(generateGoodsRealizationReportRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по оборачиваемости
         * 
         */
        @cask.post("/reports/goods-turnover/generate")
        def generateGoodsTurnoverReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateGoodsTurnoverRequestData <- Parsed.eval(GenerateGoodsTurnoverRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateGoodsTurnoverRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateGoodsTurnoverRequest <- Parsed.fromTry(generateGoodsTurnoverRequestData.validated(failFast))
            result <- Parsed.eval(service.generateGoodsTurnoverReport(generateGoodsTurnoverRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет «Цены на рынке»
         * 
         */
        @cask.post("/reports/prices/generate")
        def generatePricesReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generatePricesReportRequestData <- Parsed.eval(GeneratePricesReportRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GeneratePricesReportRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generatePricesReportRequest <- Parsed.fromTry(generatePricesReportRequestData.validated(failFast))
            result <- Parsed.eval(service.generatePricesReport(generatePricesReportRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по полкам
         * 
         */
        @cask.post("/reports/shelf-statistics/generate")
        def generateShelfsStatisticsReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateShelfsStatisticsRequestData <- Parsed.eval(GenerateShelfsStatisticsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateShelfsStatisticsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateShelfsStatisticsRequest <- Parsed.fromTry(generateShelfsStatisticsRequestData.validated(failFast))
            result <- Parsed.eval(service.generateShelfsStatisticsReport(generateShelfsStatisticsRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет «Аналитика продаж»
         * 
         */
        @cask.post("/reports/shows-sales/generate")
        def generateShowsSalesReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateShowsSalesReportRequestData <- Parsed.eval(GenerateShowsSalesReportRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateShowsSalesReportRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateShowsSalesReportRequest <- Parsed.fromTry(generateShowsSalesReportRequestData.validated(failFast))
            result <- Parsed.eval(service.generateShowsSalesReport(generateShowsSalesReportRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по остаткам на складах
         * 
         */
        @cask.post("/reports/stocks-on-warehouses/generate")
        def generateStocksOnWarehousesReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateStocksOnWarehousesReportRequestData <- Parsed.eval(GenerateStocksOnWarehousesReportRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateStocksOnWarehousesReportRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateStocksOnWarehousesReportRequest <- Parsed.fromTry(generateStocksOnWarehousesReportRequestData.validated(failFast))
            result <- Parsed.eval(service.generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по стоимости услуг
         * 
         */
        @cask.post("/reports/united-marketplace-services/generate")
        def generateUnitedMarketplaceServicesReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateUnitedMarketplaceServicesReportRequestData <- Parsed.eval(GenerateUnitedMarketplaceServicesReportRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateUnitedMarketplaceServicesReportRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateUnitedMarketplaceServicesReportRequest <- Parsed.fromTry(generateUnitedMarketplaceServicesReportRequestData.validated(failFast))
            result <- Parsed.eval(service.generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по платежам
         * 
         */
        @cask.post("/reports/united-netting/generate")
        def generateUnitedNettingReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateUnitedNettingReportRequestData <- Parsed.eval(GenerateUnitedNettingReportRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateUnitedNettingReportRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateUnitedNettingReportRequest <- Parsed.fromTry(generateUnitedNettingReportRequestData.validated(failFast))
            result <- Parsed.eval(service.generateUnitedNettingReport(generateUnitedNettingReportRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по заказам
         * 
         */
        @cask.post("/reports/united-orders/generate")
        def generateUnitedOrdersReport(request: cask.Request, format : Option[ReportFormatType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              generateUnitedOrdersRequestData <- Parsed.eval(GenerateUnitedOrdersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GenerateUnitedOrdersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              generateUnitedOrdersRequest <- Parsed.fromTry(generateUnitedOrdersRequestData.validated(failFast))
            result <- Parsed.eval(service.generateUnitedOrdersReport(generateUnitedOrdersRequest, format))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GenerateReportResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Все предложения магазина
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/offers/all")
        def getAllOffers(campaignId : Long, request: cask.Request, feedId : Option[Long], chunk : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getAllOffers(campaignId, feedId, chunk))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetAllOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация об установленных ставках
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/bids/info")
        def getBidsInfoForBusiness(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getBidsInfoRequestData <- Parsed.eval(GetBidsInfoRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetBidsInfoRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getBidsInfoRequest <- Parsed.fromTry(getBidsInfoRequestData.validated(failFast))
            result <- Parsed.eval(service.getBidsInfoForBusiness(businessId, pageToken, limit, getBidsInfoRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetBidsInfoResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Рекомендованные ставки для заданных товаров
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/bids/recommendations")
        def getBidsRecommendations(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getBidsRecommendationsRequestData <- Parsed.eval(GetBidsRecommendationsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetBidsRecommendationsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getBidsRecommendationsRequest <- Parsed.fromTry(getBidsRecommendationsRequestData.validated(failFast))
            result <- Parsed.eval(service.getBidsRecommendations(businessId, getBidsRecommendationsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetBidsRecommendationsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список товаров, находящихся в карантине по цене в кабинете
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/price-quarantine")
        def getBusinessQuarantineOffers(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getQuarantineOffersRequestData <- Parsed.eval(GetQuarantineOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetQuarantineOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getQuarantineOffersRequest <- Parsed.fromTry(getQuarantineOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.getBusinessQuarantineOffers(businessId, getQuarantineOffersRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetQuarantineOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Настройки кабинета
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/settings")
        def getBusinessSettings(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
            result <- Parsed.eval(service.getBusinessSettings(businessId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetBusinessSettingsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId")
        def getCampaign(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getCampaign(campaignId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCampaignResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Логины, связанные с магазином
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/logins")
        def getCampaignLogins(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getCampaignLogins(campaignId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCampaignLoginsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о товарах, которые размещены в заданном магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offers")
        def getCampaignOffers(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              getCampaignOffersRequestData <- Parsed.eval(GetCampaignOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetCampaignOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getCampaignOffersRequest <- Parsed.fromTry(getCampaignOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.getCampaignOffers(campaignId, getCampaignOffersRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCampaignOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список товаров, находящихся в карантине по цене в магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/price-quarantine")
        def getCampaignQuarantineOffers(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              getQuarantineOffersRequestData <- Parsed.eval(GetQuarantineOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetQuarantineOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getQuarantineOffersRequest <- Parsed.fromTry(getQuarantineOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.getCampaignQuarantineOffers(campaignId, getQuarantineOffersRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetQuarantineOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Регион магазина
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/region")
        def getCampaignRegion(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getCampaignRegion(campaignId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCampaignRegionResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Настройки магазина
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/settings")
        def getCampaignSettings(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getCampaignSettings(campaignId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCampaignSettingsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список магазинов пользователя
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns")
        def getCampaigns(request: cask.Request, page : Option[Int], pageSize : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            result <- Parsed.eval(service.getCampaigns(page, pageSize))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCampaignsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Магазины, доступные логину
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/by_login/:login")
        def getCampaignsByLogin(login : String, request: cask.Request, page : Option[Int], pageSize : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            login <- Parsed(login)
            result <- Parsed.eval(service.getCampaignsByLogin(login, page, pageSize))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCampaignsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Лимит на установку кванта продажи и минимального количества товаров в заказе
         * 
         */
        @cask.post("/categories/max-sale-quantum")
        def getCategoriesMaxSaleQuantum(request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              getCategoriesMaxSaleQuantumRequestData <- Parsed.eval(GetCategoriesMaxSaleQuantumRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetCategoriesMaxSaleQuantumRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getCategoriesMaxSaleQuantumRequest <- Parsed.fromTry(getCategoriesMaxSaleQuantumRequestData.validated(failFast))
            result <- Parsed.eval(service.getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCategoriesMaxSaleQuantumResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Дерево категорий
         * 
         */
        @cask.post("/categories/tree")
        def getCategoriesTree(request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
              getCategoriesRequestData <- Parsed.eval(GetCategoriesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetCategoriesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getCategoriesRequest <- Parsed.fromTry(getCategoriesRequestData.validated(failFast))
            result <- Parsed.eval(service.getCategoriesTree(getCategoriesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCategoriesResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Списки характеристик товаров по категориям
         * 
         */
        @cask.post("/category/:categoryId/parameters")
        def getCategoryContentParameters(categoryId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            categoryId <- Parsed(categoryId)
            result <- Parsed.eval(service.getCategoryContentParameters(categoryId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetCategoryContentParametersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение истории сообщений в чате
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/chats/history")
        def getChatHistory(businessId : Long, request: cask.Request, chatId : Long, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getChatHistoryRequestData <- Parsed.eval(GetChatHistoryRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetChatHistoryRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getChatHistoryRequest <- Parsed.fromTry(getChatHistoryRequestData.validated(failFast))
            result <- Parsed.eval(service.getChatHistory(businessId, chatId, getChatHistoryRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetChatHistoryResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение доступных чатов
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/chats")
        def getChats(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getChatsRequestData <- Parsed.eval(GetChatsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetChatsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getChatsRequest <- Parsed.fromTry(getChatsRequestData.validated(failFast))
            result <- Parsed.eval(service.getChats(businessId, getChatsRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetChatsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о прайс-листе
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/feeds/:feedId")
        def getFeed(campaignId : Long, feedId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            feedId <- Parsed(feedId)
            result <- Parsed.eval(service.getFeed(campaignId, feedId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetFeedResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по индексации прайс-листа
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/feeds/:feedId/index-logs")
        def getFeedIndexLogs(campaignId : Long, feedId : Long, request: cask.Request, limit : Option[Int], publishedTimeFrom : Option[OffsetDateTime], publishedTimeTo : Option[OffsetDateTime], status : Option[FeedIndexLogsStatusType]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            feedId <- Parsed(feedId)
            result <- Parsed.eval(service.getFeedIndexLogs(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetFeedIndexLogsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Новые и обновленные отзывы о магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/feedback/updates")
        def getFeedbackAndCommentUpdates(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int], fromDate : Option[LocalDate]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getFeedbackAndCommentUpdates(campaignId, pageToken, limit, fromDate))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetFeedbackListResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список прайс-листов магазина
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/feeds")
        def getFeeds(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getFeeds(campaignId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetFeedsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Идентификаторы складов Маркета (FBY)
         * 
         */
        @cask.get("/warehouses")
        def getFulfillmentWarehouses(request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            result <- Parsed.eval(service.getFulfillmentWarehouses())
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetFulfillmentWarehousesResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение комментариев к отзыву
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/goods-feedback/comments")
        def getGoodsFeedbackComments(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getGoodsFeedbackCommentsRequestData <- Parsed.eval(GetGoodsFeedbackCommentsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetGoodsFeedbackCommentsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getGoodsFeedbackCommentsRequest <- Parsed.fromTry(getGoodsFeedbackCommentsRequestData.validated(failFast))
            result <- Parsed.eval(service.getGoodsFeedbackComments(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetGoodsFeedbackCommentsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение отзывов о товарах продавца
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/goods-feedback")
        def getGoodsFeedbacks(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getGoodsFeedbackRequestData <- Parsed.eval(GetGoodsFeedbackRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetGoodsFeedbackRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getGoodsFeedbackRequest <- Parsed.fromTry(getGoodsFeedbackRequestData.validated(failFast))
            result <- Parsed.eval(service.getGoodsFeedbacks(businessId, pageToken, limit, getGoodsFeedbackRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetGoodsFeedbackResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отчет по товарам
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/stats/skus")
        def getGoodsStats(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              getGoodsStatsRequestData <- Parsed.eval(GetGoodsStatsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetGoodsStatsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getGoodsStatsRequest <- Parsed.fromTry(getGoodsStatsRequestData.validated(failFast))
            result <- Parsed.eval(service.getGoodsStats(campaignId, getGoodsStatsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetGoodsStatsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о скрытых вами товарах
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/hidden-offers")
        def getHiddenOffers(campaignId : Long, request: cask.Request, offerId : Seq[String], pageToken : Option[String], limit : Option[Int], offset : Option[Int], page : Option[Int], pageSize : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getHiddenOffers(campaignId, offerId, pageToken, limit, offset, page, pageSize))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetHiddenOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение информации о заполненности карточек магазина
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-cards")
        def getOfferCardsContentStatus(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getOfferCardsContentStatusRequestData <- Parsed.eval(GetOfferCardsContentStatusRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetOfferCardsContentStatusRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getOfferCardsContentStatusRequest <- Parsed.fromTry(getOfferCardsContentStatusRequestData.validated(failFast))
            result <- Parsed.eval(service.getOfferCardsContentStatus(businessId, pageToken, limit, getOfferCardsContentStatusRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOfferCardsContentStatusResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список товаров в каталоге
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/offer-mapping-entries")
        def getOfferMappingEntries(campaignId : Long, request: cask.Request, offerId : Seq[String], shopSku : Seq[String], mappingKind : Option[OfferMappingKindType], status : Seq[OfferProcessingStatusType], availability : Seq[OfferAvailabilityStatusType], categoryId : Seq[Int], vendor : Seq[String], pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getOfferMappingEntries(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOfferMappingEntriesResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о товарах в каталоге
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings")
        def getOfferMappings(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getOfferMappingsRequestData <- Parsed.eval(GetOfferMappingsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetOfferMappingsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getOfferMappingsRequest <- Parsed.fromTry(getOfferMappingsRequestData.validated(failFast))
            result <- Parsed.eval(service.getOfferMappings(businessId, pageToken, limit, getOfferMappingsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOfferMappingsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Рекомендации Маркета, касающиеся цен
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offers/recommendations")
        def getOfferRecommendations(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getOfferRecommendationsRequestData <- Parsed.eval(GetOfferRecommendationsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetOfferRecommendationsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getOfferRecommendationsRequest <- Parsed.fromTry(getOfferRecommendationsRequestData.validated(failFast))
            result <- Parsed.eval(service.getOfferRecommendations(businessId, getOfferRecommendationsRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOfferRecommendationsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Предложения магазина
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/offers")
        def getOffers(campaignId : Long, request: cask.Request, query : Option[String], feedId : Option[Long], shopCategoryId : Option[String], currency : Option[CurrencyType], matched : Option[Boolean], page : Option[Int], pageSize : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getOffers(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация об одном заказе
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/orders/:orderId")
        def getOrder(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            result <- Parsed.eval(service.getOrder(campaignId, orderId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOrderResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о покупателе — юридическом лице
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/orders/:orderId/business-buyer")
        def getOrderBusinessBuyerInfo(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            result <- Parsed.eval(service.getOrderBusinessBuyerInfo(campaignId, orderId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetBusinessBuyerInfoResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о документах
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/orders/:orderId/documents")
        def getOrderBusinessDocumentsInfo(campaignId : Long, orderId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            result <- Parsed.eval(service.getOrderBusinessDocumentsInfo(campaignId, orderId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetBusinessDocumentsInfoResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о нескольких заказах
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/orders")
        def getOrders(campaignId : Long, request: cask.Request, orderIds : Seq[Long], status : Set[OrderStatusType], substatus : Set[OrderSubstatusType], fromDate : Option[LocalDate], toDate : Option[LocalDate], supplierShipmentDateFrom : Option[LocalDate], supplierShipmentDateTo : Option[LocalDate], updatedAtFrom : Option[OffsetDateTime], updatedAtTo : Option[OffsetDateTime], dispatchType : Option[OrderDeliveryDispatchType], fake : Option[Boolean], hasCis : Option[Boolean], onlyWaitingForCancellationApprove : Option[Boolean], onlyEstimatedDelivery : Option[Boolean], buyerType : Option[OrderBuyerType], page : Option[Int], pageSize : Option[Int], pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getOrders(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOrdersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Детальная информация по заказам
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/stats/orders")
        def getOrdersStats(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              getOrdersStatsRequestData <- Parsed.eval(GetOrdersStatsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetOrdersStatsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getOrdersStatsRequest <- Parsed.fromTry(getOrdersStatsRequestData.validated(failFast))
            result <- Parsed.eval(service.getOrdersStats(campaignId, pageToken, limit, getOrdersStatsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetOrdersStatsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список цен
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/offer-prices")
        def getPrices(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int], archived : Option[Boolean]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getPrices(campaignId, pageToken, limit, archived))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetPricesResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Просмотр цен на указанные товары в магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offer-prices")
        def getPricesByOfferIds(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              getPricesByOfferIdsRequestData <- Parsed.eval(GetPricesByOfferIdsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetPricesByOfferIdsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getPricesByOfferIdsRequest <- Parsed.fromTry(getPricesByOfferIdsRequestData.validated(failFast))
            result <- Parsed.eval(service.getPricesByOfferIds(campaignId, pageToken, limit, getPricesByOfferIdsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetPricesByOfferIdsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение списка товаров, которые участвуют или могут участвовать в акции
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/promos/offers")
        def getPromoOffers(businessId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getPromoOffersRequestData <- Parsed.eval(GetPromoOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetPromoOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getPromoOffersRequest <- Parsed.fromTry(getPromoOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.getPromoOffers(businessId, getPromoOffersRequest, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetPromoOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение списка акций
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/promos")
        def getPromos(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getPromosRequestData <- Parsed.eval(GetPromosRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetPromosRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getPromosRequest <- Parsed.fromTry(getPromosRequestData.validated(failFast))
            result <- Parsed.eval(service.getPromos(businessId, getPromosRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetPromosResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Индекс качества магазинов
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/ratings/quality")
        def getQualityRatings(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getQualityRatingRequestData <- Parsed.eval(GetQualityRatingRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetQualityRatingRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getQualityRatingRequest <- Parsed.fromTry(getQualityRatingRequestData.validated(failFast))
            result <- Parsed.eval(service.getQualityRatings(businessId, getQualityRatingRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetQualityRatingResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение заданного отчета
         * 
         */
        @cask.get("/reports/info/:reportId")
        def getReportInfo(reportId : String, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            reportId <- Parsed(reportId)
            result <- Parsed.eval(service.getReportInfo(reportId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetReportInfoResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о невыкупе или возврате
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/orders/:orderId/returns/:returnId")
        def getReturn(campaignId : Long, orderId : Long, returnId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            returnId <- Parsed(returnId)
            result <- Parsed.eval(service.getReturn(campaignId, orderId, returnId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetReturnResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Получение фотографии возврата
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/orders/:orderId/returns/:returnId/decision/:itemId/image/:imageHash")
        def getReturnPhoto(campaignId : Long, orderId : Long, returnId : Long, itemId : Long, imageHash : String, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            orderId <- Parsed(orderId)
            returnId <- Parsed(returnId)
            itemId <- Parsed(itemId)
            imageHash <- Parsed(imageHash)
            result <- Parsed.eval(service.getReturnPhoto(campaignId, orderId, returnId, itemId, imageHash))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : File) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Список невыкупов и возвратов
         * 
         */
        // conflicts with [/campaigns/{campaignId}/offers/all, /campaigns/{campaignId}, /campaigns/{campaignId}/logins, /campaigns/{campaignId}/region, /campaigns/{campaignId}/settings, /campaigns/{campaignId}/feeds/{feedId}, /campaigns/{campaignId}/feeds/{feedId}/index-logs, /campaigns/{campaignId}/feedback/updates, /campaigns/{campaignId}/feeds, /campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/offer-mapping-entries, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/orders/{orderId}, /campaigns/{campaignId}/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}, /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}, /campaigns/{campaignId}/returns, /campaigns, /campaigns/by_login/{login}] after/campaigns, ignoring @cask.get("/campaigns/:campaignId/returns")
        def getReturns(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int], orderIds : Seq[Long], statuses : Seq[RefundStatusType], &#x60;type&#x60; : Option[ReturnType], fromDate : Option[LocalDate], toDate : Option[LocalDate], fromDate2 : Option[LocalDate], toDate2 : Option[LocalDate]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            result <- Parsed.eval(service.getReturns(campaignId, pageToken, limit, orderIds, statuses, &#x60;type&#x60;, fromDate, toDate, fromDate2, toDate2))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetReturnsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация об остатках и оборачиваемости
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offers/stocks")
        def getStocks(campaignId : Long, request: cask.Request, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              getWarehouseStocksRequestData <- Parsed.eval(GetWarehouseStocksRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetWarehouseStocksRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getWarehouseStocksRequest <- Parsed.fromTry(getWarehouseStocksRequestData.validated(failFast))
            result <- Parsed.eval(service.getStocks(campaignId, pageToken, limit, getWarehouseStocksRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetWarehouseStocksResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Рекомендованные карточки для товаров
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offer-mapping-entries/suggestions")
        def getSuggestedOfferMappingEntries(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              getSuggestedOfferMappingEntriesRequestData <- Parsed.eval(GetSuggestedOfferMappingEntriesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetSuggestedOfferMappingEntriesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getSuggestedOfferMappingEntriesRequest <- Parsed.fromTry(getSuggestedOfferMappingEntriesRequestData.validated(failFast))
            result <- Parsed.eval(service.getSuggestedOfferMappingEntries(campaignId, getSuggestedOfferMappingEntriesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetSuggestedOfferMappingEntriesResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Просмотр карточек на Маркете, которые подходят вашим товарам
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/suggestions")
        def getSuggestedOfferMappings(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              getSuggestedOfferMappingsRequestData <- Parsed.eval(GetSuggestedOfferMappingsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as GetSuggestedOfferMappingsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              getSuggestedOfferMappingsRequest <- Parsed.fromTry(getSuggestedOfferMappingsRequestData.validated(failFast))
            result <- Parsed.eval(service.getSuggestedOfferMappings(businessId, getSuggestedOfferMappingsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetSuggestedOfferMappingsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Цены для продвижения товаров
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offer-prices/suggestions")
        def getSuggestedPrices(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              suggestPricesRequestData <- Parsed.eval(SuggestPricesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as SuggestPricesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              suggestPricesRequest <- Parsed.fromTry(suggestPricesRequestData.validated(failFast))
            result <- Parsed.eval(service.getSuggestedPrices(campaignId, suggestPricesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : SuggestPricesResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Включение буста продаж и установка ставок
         * 
         */
        @cask.put("/businesses/:businessId/bids")
        def putBidsForBusiness(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              putSkuBidsRequestData <- Parsed.eval(PutSkuBidsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as PutSkuBidsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              putSkuBidsRequest <- Parsed.fromTry(putSkuBidsRequestData.validated(failFast))
            result <- Parsed.eval(service.putBidsForBusiness(businessId, putSkuBidsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Включение буста продаж и установка ставок для магазина
         * 
         */
        @cask.put("/campaigns/:campaignId/bids")
        def putBidsForCampaign(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              putSkuBidsRequestData <- Parsed.eval(PutSkuBidsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as PutSkuBidsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              putSkuBidsRequest <- Parsed.fromTry(putSkuBidsRequestData.validated(failFast))
            result <- Parsed.eval(service.putBidsForCampaign(campaignId, putSkuBidsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Сообщить, что прайс-лист обновился
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/feeds/:feedId/refresh")
        def refreshFeed(campaignId : Long, feedId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            feedId <- Parsed(feedId)
            result <- Parsed.eval(service.refreshFeed(campaignId, feedId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о дочерних регионах
         * 
         */
        // conflicts with [/regions/{regionId}/children, /regions/{regionId}, /regions] after/regions, ignoring @cask.get("/regions/:regionId/children")
        def searchRegionChildren(regionId : Long, request: cask.Request, page : Option[Int], pageSize : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            regionId <- Parsed(regionId)
            result <- Parsed.eval(service.searchRegionChildren(regionId, page, pageSize))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetRegionWithChildrenResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Информация о регионе
         * 
         */
        // conflicts with [/regions/{regionId}/children, /regions/{regionId}, /regions] after/regions, ignoring @cask.get("/regions/:regionId")
        def searchRegionsById(regionId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            regionId <- Parsed(regionId)
            result <- Parsed.eval(service.searchRegionsById(regionId))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetRegionsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Поиск регионов по их имени
         * 
         */
        // conflicts with [/regions/{regionId}/children, /regions/{regionId}, /regions] after/regions, ignoring @cask.get("/regions")
        def searchRegionsByName(request: cask.Request, name : String, pageToken : Option[String], limit : Option[Int]) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            result <- Parsed.eval(service.searchRegionsByName(name, pageToken, limit))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : GetRegionsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отправка файла в чат
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/chats/file/send")
        def sendFileToChat(businessId : Long, request: cask.Request, chatId : Long) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
        file <- request.formValueAsFileRequired("file")
            result <- Parsed.eval(service.sendFileToChat(businessId, chatId, file))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отправка сообщения в чат
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/chats/message")
        def sendMessageToChat(businessId : Long, request: cask.Request, chatId : Long) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              sendMessageToChatRequestData <- Parsed.eval(SendMessageToChatRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as SendMessageToChatRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              sendMessageToChatRequest <- Parsed.fromTry(sendMessageToChatRequestData.validated(failFast))
            result <- Parsed.eval(service.sendMessageToChat(businessId, chatId, sendMessageToChatRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Изменение параметров прайс-листа
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/feeds/:feedId/params")
        def setFeedParams(campaignId : Long, feedId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
            feedId <- Parsed(feedId)
              setFeedParamsRequestData <- Parsed.eval(SetFeedParamsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as SetFeedParamsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              setFeedParamsRequest <- Parsed.fromTry(setFeedParamsRequestData.validated(failFast))
            result <- Parsed.eval(service.setFeedParams(campaignId, feedId, setFeedParamsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Отказ от ответа на отзывы
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/goods-feedback/skip-reaction")
        def skipGoodsFeedbacksReaction(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              skipGoodsFeedbackReactionRequestData <- Parsed.eval(SkipGoodsFeedbackReactionRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as SkipGoodsFeedbackReactionRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              skipGoodsFeedbackReactionRequest <- Parsed.fromTry(skipGoodsFeedbackReactionRequestData.validated(failFast))
            result <- Parsed.eval(service.skipGoodsFeedbacksReaction(businessId, skipGoodsFeedbackReactionRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Установка цен на товары во всех магазинах
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-prices/updates")
        def updateBusinessPrices(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              updateBusinessPricesRequestData <- Parsed.eval(UpdateBusinessPricesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateBusinessPricesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateBusinessPricesRequest <- Parsed.fromTry(updateBusinessPricesRequestData.validated(failFast))
            result <- Parsed.eval(service.updateBusinessPrices(businessId, updateBusinessPricesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Изменение условий продажи товаров в магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offers/update")
        def updateCampaignOffers(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              updateCampaignOffersRequestData <- Parsed.eval(UpdateCampaignOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateCampaignOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateCampaignOffersRequest <- Parsed.fromTry(updateCampaignOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.updateCampaignOffers(campaignId, updateCampaignOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Добавление нового или изменение созданного комментария
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/goods-feedback/comments/update")
        def updateGoodsFeedbackComment(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              updateGoodsFeedbackCommentRequestData <- Parsed.eval(UpdateGoodsFeedbackCommentRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateGoodsFeedbackCommentRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateGoodsFeedbackCommentRequest <- Parsed.fromTry(updateGoodsFeedbackCommentRequestData.validated(failFast))
            result <- Parsed.eval(service.updateGoodsFeedbackComment(businessId, updateGoodsFeedbackCommentRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : UpdateGoodsFeedbackCommentResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Редактирование категорийных характеристик товара
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-cards/update")
        def updateOfferContent(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              updateOfferContentRequestData <- Parsed.eval(UpdateOfferContentRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateOfferContentRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateOfferContentRequest <- Parsed.fromTry(updateOfferContentRequestData.validated(failFast))
            result <- Parsed.eval(service.updateOfferContent(businessId, updateOfferContentRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : UpdateOfferContentResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Добавление и редактирование товаров в каталоге
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offer-mapping-entries/updates")
        def updateOfferMappingEntries(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              updateOfferMappingEntryRequestData <- Parsed.eval(UpdateOfferMappingEntryRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateOfferMappingEntryRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateOfferMappingEntryRequest <- Parsed.fromTry(updateOfferMappingEntryRequestData.validated(failFast))
            result <- Parsed.eval(service.updateOfferMappingEntries(campaignId, updateOfferMappingEntryRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Добавление товаров в каталог и изменение информации о них
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/offer-mappings/update")
        def updateOfferMappings(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              updateOfferMappingsRequestData <- Parsed.eval(UpdateOfferMappingsRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdateOfferMappingsRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updateOfferMappingsRequest <- Parsed.fromTry(updateOfferMappingsRequestData.validated(failFast))
            result <- Parsed.eval(service.updateOfferMappings(businessId, updateOfferMappingsRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : UpdateOfferMappingsResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Установка цен на товары в конкретном магазине
         * 
         */
        // conflicts with [/campaigns/{campaignId}/hidden-offers, /campaigns/{campaignId}/price-quarantine/confirm, /campaigns/{campaignId}/offers/delete, /campaigns/{campaignId}/hidden-offers/delete, /campaigns/{campaignId}/offers, /campaigns/{campaignId}/price-quarantine, /campaigns/{campaignId}/stats/skus, /campaigns/{campaignId}/orders/{orderId}/business-buyer, /campaigns/{campaignId}/orders/{orderId}/documents, /campaigns/{campaignId}/stats/orders, /campaigns/{campaignId}/offer-prices, /campaigns/{campaignId}/offers/stocks, /campaigns/{campaignId}/offer-mapping-entries/suggestions, /campaigns/{campaignId}/offer-prices/suggestions, /campaigns/{campaignId}/feeds/{feedId}/refresh, /campaigns/{campaignId}/feeds/{feedId}/params, /campaigns/{campaignId}/offers/update, /campaigns/{campaignId}/offer-mapping-entries/updates, /campaigns/{campaignId}/offer-prices/updates] after/campaigns, ignoring @cask.post("/campaigns/:campaignId/offer-prices/updates")
        def updatePrices(campaignId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            campaignId <- Parsed(campaignId)
              updatePricesRequestData <- Parsed.eval(UpdatePricesRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdatePricesRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updatePricesRequest <- Parsed.fromTry(updatePricesRequestData.validated(failFast))
            result <- Parsed.eval(service.updatePrices(campaignId, updatePricesRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : EmptyApiResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLockedErrorResponse) => cask.Response(data = write(value), 423, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }
        /** Добавление товаров в акцию или изменение их цен
         * 
         */
        // conflicts with [/businesses/{businessId}/offer-mappings/archive, /businesses/{businessId}/price-quarantine/confirm, /businesses/{businessId}/chats/new, /businesses/{businessId}/goods-feedback/comments/delete, /businesses/{businessId}/offer-mappings/delete, /businesses/{businessId}/offer-mappings/unarchive, /businesses/{businessId}/promos/offers/delete, /businesses/{businessId}/bids/info, /businesses/{businessId}/bids/recommendations, /businesses/{businessId}/price-quarantine, /businesses/{businessId}/settings, /businesses/{businessId}/chats/history, /businesses/{businessId}/chats, /businesses/{businessId}/goods-feedback/comments, /businesses/{businessId}/goods-feedback, /businesses/{businessId}/offer-cards, /businesses/{businessId}/offer-mappings, /businesses/{businessId}/offers/recommendations, /businesses/{businessId}/promos/offers, /businesses/{businessId}/promos, /businesses/{businessId}/ratings/quality, /businesses/{businessId}/offer-mappings/suggestions, /businesses/{businessId}/chats/file/send, /businesses/{businessId}/chats/message, /businesses/{businessId}/goods-feedback/skip-reaction, /businesses/{businessId}/offer-prices/updates, /businesses/{businessId}/goods-feedback/comments/update, /businesses/{businessId}/offer-cards/update, /businesses/{businessId}/offer-mappings/update, /businesses/{businessId}/promos/offers/update] after/businesses, ignoring @cask.post("/businesses/:businessId/promos/offers/update")
        def updatePromoOffers(businessId : Long, request: cask.Request) = {
            // auth method OAuth : oauth2, keyParamName: 

        def failFast = request.queryParams.keySet.contains("failFast")

        val result =         for {
            businessId <- Parsed(businessId)
              updatePromoOffersRequestData <- Parsed.eval(UpdatePromoOffersRequestData.fromJsonString(request.bodyAsString)).mapError(e => s"Error parsing json as UpdatePromoOffersRequest from >${request.bodyAsString}< : ${e}") /* not array or map */
              updatePromoOffersRequest <- Parsed.fromTry(updatePromoOffersRequestData.validated(failFast))
            result <- Parsed.eval(service.updatePromoOffers(businessId, updatePromoOffersRequest))
        } yield result

        result match {
          case Left(error) => cask.Response(error, 500)
          case Right(value : UpdatePromoOffersResponse) => cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiClientDataErrorResponse) => cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiUnauthorizedErrorResponse) => cask.Response(data = write(value), 401, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiForbiddenErrorResponse) => cask.Response(data = write(value), 403, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiNotFoundErrorResponse) => cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiLimitErrorResponse) => cask.Response(data = write(value), 420, headers = Seq("Content-Type" -> "application/json"))
          case Right(value : ApiServerErrorResponse) => cask.Response(data = write(value), 500, headers = Seq("Content-Type" -> "application/json"))
          case Right(other) => cask.Response(s"$other", 200)
        }
      }

    initialize()
}
