#
# Партнерский API Маркета
# 
# API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
# The version of the OpenAPI document: LATEST
# 
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_api_client_data_error_response
import ../models/model_api_forbidden_error_response
import ../models/model_api_limit_error_response
import ../models/model_api_locked_error_response
import ../models/model_api_not_found_error_response
import ../models/model_api_server_error_response
import ../models/model_api_unauthorized_error_response
import ../models/model_currency_type
import ../models/model_delete_campaign_offers_request
import ../models/model_delete_campaign_offers_response
import ../models/model_empty_api_response
import ../models/model_get_all_offers_response
import ../models/model_get_campaign_offers_request
import ../models/model_get_campaign_offers_response
import ../models/model_get_offer_recommendations_request
import ../models/model_get_offer_recommendations_response
import ../models/model_get_offers_response
import ../models/model_update_campaign_offers_request

const basepath = "https://api.partner.market.yandex.ru"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      when name(stripGenericParams(T.typedesc).typedesc) == name(Table):
        (some(json.to(parseJson(response.body), T.typedesc)), response)
      else:
        (some(marshal.to[T](response.body)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc deleteCampaignOffers*(httpClient: HttpClient, campaignId: int64, deleteCampaignOffersRequest: DeleteCampaignOffersRequest): (Option[DeleteCampaignOffersResponse], Response) =
  ## Удаление товаров из ассортимента магазина
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offers/delete", $(%deleteCampaignOffersRequest))
  constructResult[DeleteCampaignOffersResponse](response)


proc getAllOffers*(httpClient: HttpClient, campaignId: int64, feedId: int64, chunk: int): (Option[GetAllOffersResponse], Response) {.deprecated.} =
  ## Все предложения магазина
  let query_for_api_call = encodeQuery([
    ("feedId", $feedId), # Идентификатор прайс-листа.
    ("chunk", $chunk), # Номер сегмента с результатами.  Значение по умолчанию: `0`.  {% note info %}  Номера сегментов запрашиваются последовательно, пока не будет получен сегмент с пустым ответом. Пустой ответ означает, что все предложения магазина получены.  {% endnote %}  {% note alert %}  Нумерация начинается с 0. Чтобы запросить первую страницу, необходимо указать `chunk=0` и т. д.  {% endnote %} 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/offers/all" & "?" & query_for_api_call)
  constructResult[GetAllOffersResponse](response)


proc getCampaignOffers*(httpClient: HttpClient, campaignId: int64, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken: string, limit: int): (Option[GetCampaignOffersResponse], Response) =
  ## Информация о товарах, которые размещены в заданном магазине
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offers" & "?" & query_for_api_call, $(%getCampaignOffersRequest))
  constructResult[GetCampaignOffersResponse](response)


proc getOfferRecommendations*(httpClient: HttpClient, businessId: int64, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken: string, limit: int): (Option[GetOfferRecommendationsResponse], Response) =
  ## Рекомендации Маркета, касающиеся цен
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offers/recommendations" & "?" & query_for_api_call, $(%getOfferRecommendationsRequest))
  constructResult[GetOfferRecommendationsResponse](response)


proc getOffers*(httpClient: HttpClient, campaignId: int64, query: string, feedId: int64, shopCategoryId: string, currency: CurrencyType, matched: bool, page: int, pageSize: int): (Option[GetOffersResponse], Response) {.deprecated.} =
  ## Предложения магазина
  let query_for_api_call = encodeQuery([
    ("query", $query), # Поисковый запрос.  Поддерживается язык запросов.  Значение по умолчанию: все предложения магазина, размещенные на Маркете. 
    ("feedId", $feedId), # Идентификатор прайс-листа.
    ("shopCategoryId", $shopCategoryId), # Идентификатор категории предложения, указанный магазином в прайс-листе.  Параметр выводится только для предложений, у которых указана категория в прайс-листе.  Параметр доступен начиная с версии 2.0 партнерского API. 
    ("currency", $currency), # Валюта, в которой указана цена предложения.  Возможные значения:  * `BYN` — белорусский рубль.  * `KZT` — казахстанский тенге.  * `RUR` — российский рубль.  * `UAH` — украинская гривна. 
    ("matched", $matched), # Фильтр по признаку соотнесения предложения и карточки модели.  Возможные значения:  * `0 / FALSE / NO` — поиск выполняется среди предложений, не соотнесенных ни с какой карточкой модели.  * `1 / TRUE / YES` — поиск выполняется среди предложений, соотнесенных с карточками моделей). 
    ("page", $page), # Номер страницы результатов.  Значение по умолчанию: 1.  Используется вместе с параметром `page_size`.  `page_number` игнорируется, если задан `page_token`, `limit` или `offset`. 
    ("pageSize", $pageSize), # Размер страницы.  Используется вместе с параметром `page_number`.  `page_size` игнорируется, если задан `page_token`, `limit` или `offset`. 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/offers" & "?" & query_for_api_call)
  constructResult[GetOffersResponse](response)


proc updateCampaignOffers*(httpClient: HttpClient, campaignId: int64, updateCampaignOffersRequest: UpdateCampaignOffersRequest): (Option[EmptyApiResponse], Response) =
  ## Изменение условий продажи товаров в магазине
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offers/update", $(%updateCampaignOffersRequest))
  constructResult[EmptyApiResponse](response)

