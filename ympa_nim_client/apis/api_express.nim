#
# Партнерский API Маркета
# 
# API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
# The version of the OpenAPI document: LATEST
# 
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_add_hidden_offers_request
import ../models/model_add_offers_to_archive_request
import ../models/model_add_offers_to_archive_response
import ../models/model_api_client_data_error_response
import ../models/model_api_forbidden_error_response
import ../models/model_api_limit_error_response
import ../models/model_api_locked_error_response
import ../models/model_api_not_found_error_response
import ../models/model_api_server_error_response
import ../models/model_api_unauthorized_error_response
import ../models/model_calculate_tariffs_request
import ../models/model_calculate_tariffs_response
import ../models/model_confirm_prices_request
import ../models/model_create_chat_request
import ../models/model_create_chat_response
import ../models/model_currency_type
import ../models/model_delete_campaign_offers_request
import ../models/model_delete_campaign_offers_response
import ../models/model_delete_goods_feedback_comment_request
import ../models/model_delete_hidden_offers_request
import ../models/model_delete_offers_from_archive_request
import ../models/model_delete_offers_from_archive_response
import ../models/model_delete_offers_request
import ../models/model_delete_offers_response
import ../models/model_delete_promo_offers_request
import ../models/model_delete_promo_offers_response
import ../models/model_empty_api_response
import ../models/model_feed_index_logs_status_type
import ../models/model_generate_boost_consolidated_request
import ../models/model_generate_competitors_position_report_request
import ../models/model_generate_goods_feedback_request
import ../models/model_generate_goods_realization_report_request
import ../models/model_generate_mass_order_labels_request
import ../models/model_generate_prices_report_request
import ../models/model_generate_report_response
import ../models/model_generate_shelfs_statistics_request
import ../models/model_generate_shows_sales_report_request
import ../models/model_generate_stocks_on_warehouses_report_request
import ../models/model_generate_united_marketplace_services_report_request
import ../models/model_generate_united_netting_report_request
import ../models/model_generate_united_orders_request
import ../models/model_get_all_offers_response
import ../models/model_get_bids_info_request
import ../models/model_get_bids_info_response
import ../models/model_get_bids_recommendations_request
import ../models/model_get_bids_recommendations_response
import ../models/model_get_business_buyer_info_response
import ../models/model_get_business_documents_info_response
import ../models/model_get_business_settings_response
import ../models/model_get_campaign_logins_response
import ../models/model_get_campaign_offers_request
import ../models/model_get_campaign_offers_response
import ../models/model_get_campaign_region_response
import ../models/model_get_campaign_response
import ../models/model_get_campaign_settings_response
import ../models/model_get_campaigns_response
import ../models/model_get_categories_max_sale_quantum_request
import ../models/model_get_categories_max_sale_quantum_response
import ../models/model_get_categories_request
import ../models/model_get_categories_response
import ../models/model_get_category_content_parameters_response
import ../models/model_get_chat_history_request
import ../models/model_get_chat_history_response
import ../models/model_get_chats_request
import ../models/model_get_chats_response
import ../models/model_get_delivery_services_response
import ../models/model_get_feed_index_logs_response
import ../models/model_get_feed_response
import ../models/model_get_feedback_list_response
import ../models/model_get_feeds_response
import ../models/model_get_goods_feedback_comments_request
import ../models/model_get_goods_feedback_comments_response
import ../models/model_get_goods_feedback_request
import ../models/model_get_goods_feedback_response
import ../models/model_get_goods_stats_request
import ../models/model_get_goods_stats_response
import ../models/model_get_hidden_offers_response
import ../models/model_get_offer_cards_content_status_request
import ../models/model_get_offer_cards_content_status_response
import ../models/model_get_offer_mapping_entries_response
import ../models/model_get_offer_mappings_request
import ../models/model_get_offer_mappings_response
import ../models/model_get_offer_recommendations_request
import ../models/model_get_offer_recommendations_response
import ../models/model_get_offers_response
import ../models/model_get_order_labels_data_response
import ../models/model_get_order_response
import ../models/model_get_orders_response
import ../models/model_get_orders_stats_request
import ../models/model_get_orders_stats_response
import ../models/model_get_prices_by_offer_ids_request
import ../models/model_get_prices_by_offer_ids_response
import ../models/model_get_prices_response
import ../models/model_get_promo_offers_request
import ../models/model_get_promo_offers_response
import ../models/model_get_promos_request
import ../models/model_get_promos_response
import ../models/model_get_quality_rating_details_response
import ../models/model_get_quality_rating_request
import ../models/model_get_quality_rating_response
import ../models/model_get_quarantine_offers_request
import ../models/model_get_quarantine_offers_response
import ../models/model_get_region_with_children_response
import ../models/model_get_regions_response
import ../models/model_get_report_info_response
import ../models/model_get_return_response
import ../models/model_get_returns_response
import ../models/model_get_suggested_offer_mapping_entries_request
import ../models/model_get_suggested_offer_mapping_entries_response
import ../models/model_get_suggested_offer_mappings_request
import ../models/model_get_suggested_offer_mappings_response
import ../models/model_get_warehouse_stocks_request
import ../models/model_get_warehouse_stocks_response
import ../models/model_get_warehouses_response
import ../models/model_offer_availability_status_type
import ../models/model_offer_mapping_kind_type
import ../models/model_offer_processing_status_type
import ../models/model_order_buyer_type
import ../models/model_order_delivery_dispatch_type
import ../models/model_order_status_type
import ../models/model_order_substatus_type
import ../models/model_page_format_type
import ../models/model_provide_order_item_identifiers_request
import ../models/model_provide_order_item_identifiers_response
import ../models/model_put_sku_bids_request
import ../models/model_refund_status_type
import ../models/model_report_format_type
import ../models/model_return_type
import ../models/model_send_message_to_chat_request
import ../models/model_set_feed_params_request
import ../models/model_set_order_box_layout_request
import ../models/model_set_order_box_layout_response
import ../models/model_set_order_shipment_boxes_request
import ../models/model_set_order_shipment_boxes_response
import ../models/model_skip_goods_feedback_reaction_request
import ../models/model_suggest_prices_request
import ../models/model_suggest_prices_response
import ../models/model_update_business_prices_request
import ../models/model_update_campaign_offers_request
import ../models/model_update_goods_feedback_comment_request
import ../models/model_update_goods_feedback_comment_response
import ../models/model_update_offer_content_request
import ../models/model_update_offer_content_response
import ../models/model_update_offer_mapping_entry_request
import ../models/model_update_offer_mappings_request
import ../models/model_update_offer_mappings_response
import ../models/model_update_order_item_request
import ../models/model_update_order_status_request
import ../models/model_update_order_status_response
import ../models/model_update_order_statuses_request
import ../models/model_update_order_statuses_response
import ../models/model_update_prices_request
import ../models/model_update_promo_offers_request
import ../models/model_update_promo_offers_response
import ../models/model_update_stocks_request
import ../models/model_verify_order_eac_request
import ../models/model_verify_order_eac_response
import ../models/model_set

const basepath = "https://api.partner.market.yandex.ru"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      when name(stripGenericParams(T.typedesc).typedesc) == name(Table):
        (some(json.to(parseJson(response.body), T.typedesc)), response)
      else:
        (some(marshal.to[T](response.body)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc addHiddenOffers*(httpClient: HttpClient, campaignId: int64, addHiddenOffersRequest: AddHiddenOffersRequest): (Option[EmptyApiResponse], Response) =
  ## Скрытие товаров и настройки скрытия
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/hidden-offers", $(%addHiddenOffersRequest))
  constructResult[EmptyApiResponse](response)


proc addOffersToArchive*(httpClient: HttpClient, businessId: int64, addOffersToArchiveRequest: AddOffersToArchiveRequest): (Option[AddOffersToArchiveResponse], Response) =
  ## Добавление товаров в архив
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offer-mappings/archive", $(%addOffersToArchiveRequest))
  constructResult[AddOffersToArchiveResponse](response)


proc calculateTariffs*(httpClient: HttpClient, calculateTariffsRequest: CalculateTariffsRequest): (Option[CalculateTariffsResponse], Response) =
  ## Калькулятор стоимости услуг
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/tariffs/calculate", $(%calculateTariffsRequest))
  constructResult[CalculateTariffsResponse](response)


proc confirmBusinessPrices*(httpClient: HttpClient, businessId: int64, confirmPricesRequest: ConfirmPricesRequest): (Option[EmptyApiResponse], Response) =
  ## Удаление товара из карантина по цене в кабинете
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/price-quarantine/confirm", $(%confirmPricesRequest))
  constructResult[EmptyApiResponse](response)


proc confirmCampaignPrices*(httpClient: HttpClient, campaignId: int64, confirmPricesRequest: ConfirmPricesRequest): (Option[EmptyApiResponse], Response) =
  ## Удаление товара из карантина по цене в магазине
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/price-quarantine/confirm", $(%confirmPricesRequest))
  constructResult[EmptyApiResponse](response)


proc createChat*(httpClient: HttpClient, businessId: int64, createChatRequest: CreateChatRequest): (Option[CreateChatResponse], Response) =
  ## Создание нового чата с покупателем
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/chats/new", $(%createChatRequest))
  constructResult[CreateChatResponse](response)


proc deleteCampaignOffers*(httpClient: HttpClient, campaignId: int64, deleteCampaignOffersRequest: DeleteCampaignOffersRequest): (Option[DeleteCampaignOffersResponse], Response) =
  ## Удаление товаров из ассортимента магазина
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offers/delete", $(%deleteCampaignOffersRequest))
  constructResult[DeleteCampaignOffersResponse](response)


proc deleteGoodsFeedbackComment*(httpClient: HttpClient, businessId: int64, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest): (Option[EmptyApiResponse], Response) =
  ## Удаление комментария к отзыву
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/goods-feedback/comments/delete", $(%deleteGoodsFeedbackCommentRequest))
  constructResult[EmptyApiResponse](response)


proc deleteHiddenOffers*(httpClient: HttpClient, campaignId: int64, deleteHiddenOffersRequest: DeleteHiddenOffersRequest): (Option[EmptyApiResponse], Response) =
  ## Возобновление показа товаров
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/hidden-offers/delete", $(%deleteHiddenOffersRequest))
  constructResult[EmptyApiResponse](response)


proc deleteOffers*(httpClient: HttpClient, businessId: int64, deleteOffersRequest: DeleteOffersRequest): (Option[DeleteOffersResponse], Response) =
  ## Удаление товаров из каталога
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offer-mappings/delete", $(%deleteOffersRequest))
  constructResult[DeleteOffersResponse](response)


proc deleteOffersFromArchive*(httpClient: HttpClient, businessId: int64, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest): (Option[DeleteOffersFromArchiveResponse], Response) =
  ## Удаление товаров из архива
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offer-mappings/unarchive", $(%deleteOffersFromArchiveRequest))
  constructResult[DeleteOffersFromArchiveResponse](response)


proc deletePromoOffers*(httpClient: HttpClient, businessId: int64, deletePromoOffersRequest: DeletePromoOffersRequest): (Option[DeletePromoOffersResponse], Response) =
  ## Удаление товаров из акции
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/promos/offers/delete", $(%deletePromoOffersRequest))
  constructResult[DeletePromoOffersResponse](response)


proc generateBoostConsolidatedReport*(httpClient: HttpClient, generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет по бусту продаж
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/boost-consolidated/generate" & "?" & query_for_api_call, $(%generateBoostConsolidatedRequest))
  constructResult[GenerateReportResponse](response)


proc generateCompetitorsPositionReport*(httpClient: HttpClient, generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет «Конкурентная позиция»
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/competitors-position/generate" & "?" & query_for_api_call, $(%generateCompetitorsPositionReportRequest))
  constructResult[GenerateReportResponse](response)


proc generateGoodsFeedbackReport*(httpClient: HttpClient, generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет по отзывам о товарах
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/goods-feedback/generate" & "?" & query_for_api_call, $(%generateGoodsFeedbackRequest))
  constructResult[GenerateReportResponse](response)


proc generateGoodsRealizationReport*(httpClient: HttpClient, generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет по реализации
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/goods-realization/generate" & "?" & query_for_api_call, $(%generateGoodsRealizationReportRequest))
  constructResult[GenerateReportResponse](response)


proc generateMassOrderLabelsReport*(httpClient: HttpClient, generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format: PageFormatType): (Option[GenerateReportResponse], Response) =
  ## Готовые ярлыки‑наклейки на все коробки в нескольких заказах
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Настройка размещения ярлыков на странице. Если параметра нет, возвращается PDF с ярлыками формата A7.
  ])

  let response = httpClient.post(basepath & "/reports/documents/labels/generate" & "?" & query_for_api_call, $(%generateMassOrderLabelsRequest))
  constructResult[GenerateReportResponse](response)


proc generateOrderLabel*(httpClient: HttpClient, campaignId: int64, orderId: int64, shipmentId: int64, boxId: int64, format: PageFormatType): (Option[string], Response) =
  ## Готовый ярлык‑наклейка для коробки в заказе
  let query_for_api_call = encodeQuery([
    ("format", $format), # Настройка размещения ярлыков на странице. Если параметра нет, возвращается PDF с ярлыками формата A6.
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label" & "?" & query_for_api_call)
  constructResult[string](response)


proc generateOrderLabels*(httpClient: HttpClient, campaignId: int64, orderId: int64, format: PageFormatType): (Option[string], Response) =
  ## Готовые ярлыки‑наклейки на все коробки в одном заказе
  let query_for_api_call = encodeQuery([
    ("format", $format), # Настройка размещения ярлыков на странице. Если параметра нет, возвращается PDF с ярлыками формата A6.
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/delivery/labels" & "?" & query_for_api_call)
  constructResult[string](response)


proc generatePricesReport*(httpClient: HttpClient, generatePricesReportRequest: GeneratePricesReportRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет «Цены на рынке»
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/prices/generate" & "?" & query_for_api_call, $(%generatePricesReportRequest))
  constructResult[GenerateReportResponse](response)


proc generateShelfsStatisticsReport*(httpClient: HttpClient, generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет по полкам
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/shelf-statistics/generate" & "?" & query_for_api_call, $(%generateShelfsStatisticsRequest))
  constructResult[GenerateReportResponse](response)


proc generateShowsSalesReport*(httpClient: HttpClient, generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет «Аналитика продаж»
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/shows-sales/generate" & "?" & query_for_api_call, $(%generateShowsSalesReportRequest))
  constructResult[GenerateReportResponse](response)


proc generateStocksOnWarehousesReport*(httpClient: HttpClient, generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет по остаткам на складах
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/stocks-on-warehouses/generate" & "?" & query_for_api_call, $(%generateStocksOnWarehousesReportRequest))
  constructResult[GenerateReportResponse](response)


proc generateUnitedMarketplaceServicesReport*(httpClient: HttpClient, generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет по стоимости услуг
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/united-marketplace-services/generate" & "?" & query_for_api_call, $(%generateUnitedMarketplaceServicesReportRequest))
  constructResult[GenerateReportResponse](response)


proc generateUnitedNettingReport*(httpClient: HttpClient, generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет по платежам
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/united-netting/generate" & "?" & query_for_api_call, $(%generateUnitedNettingReportRequest))
  constructResult[GenerateReportResponse](response)


proc generateUnitedOrdersReport*(httpClient: HttpClient, generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format: ReportFormatType): (Option[GenerateReportResponse], Response) =
  ## Отчет по заказам
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("format", $format), # Формат отчета.
  ])

  let response = httpClient.post(basepath & "/reports/united-orders/generate" & "?" & query_for_api_call, $(%generateUnitedOrdersRequest))
  constructResult[GenerateReportResponse](response)


proc getAllOffers*(httpClient: HttpClient, campaignId: int64, feedId: int64, chunk: int): (Option[GetAllOffersResponse], Response) {.deprecated.} =
  ## Все предложения магазина
  let query_for_api_call = encodeQuery([
    ("feedId", $feedId), # Идентификатор прайс-листа.
    ("chunk", $chunk), # Номер сегмента с результатами.  Значение по умолчанию: `0`.  {% note info %}  Номера сегментов запрашиваются последовательно, пока не будет получен сегмент с пустым ответом. Пустой ответ означает, что все предложения магазина получены.  {% endnote %}  {% note alert %}  Нумерация начинается с 0. Чтобы запросить первую страницу, необходимо указать `chunk=0` и т. д.  {% endnote %} 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/offers/all" & "?" & query_for_api_call)
  constructResult[GetAllOffersResponse](response)


proc getBidsInfoForBusiness*(httpClient: HttpClient, businessId: int64, pageToken: string, limit: int, getBidsInfoRequest: GetBidsInfoRequest): (Option[GetBidsInfoResponse], Response) =
  ## Информация об установленных ставках
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/bids/info" & "?" & query_for_api_call, $(%getBidsInfoRequest))
  constructResult[GetBidsInfoResponse](response)


proc getBidsRecommendations*(httpClient: HttpClient, businessId: int64, getBidsRecommendationsRequest: GetBidsRecommendationsRequest): (Option[GetBidsRecommendationsResponse], Response) =
  ## Рекомендованные ставки для заданных товаров
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/bids/recommendations", $(%getBidsRecommendationsRequest))
  constructResult[GetBidsRecommendationsResponse](response)


proc getBusinessQuarantineOffers*(httpClient: HttpClient, businessId: int64, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken: string, limit: int): (Option[GetQuarantineOffersResponse], Response) =
  ## Список товаров, находящихся в карантине по цене в кабинете
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/price-quarantine" & "?" & query_for_api_call, $(%getQuarantineOffersRequest))
  constructResult[GetQuarantineOffersResponse](response)


proc getBusinessSettings*(httpClient: HttpClient, businessId: int64): (Option[GetBusinessSettingsResponse], Response) =
  ## Настройки кабинета

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/settings")
  constructResult[GetBusinessSettingsResponse](response)


proc getCampaign*(httpClient: HttpClient, campaignId: int64): (Option[GetCampaignResponse], Response) =
  ## Информация о магазине

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}")
  constructResult[GetCampaignResponse](response)


proc getCampaignLogins*(httpClient: HttpClient, campaignId: int64): (Option[GetCampaignLoginsResponse], Response) =
  ## Логины, связанные с магазином

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/logins")
  constructResult[GetCampaignLoginsResponse](response)


proc getCampaignOffers*(httpClient: HttpClient, campaignId: int64, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken: string, limit: int): (Option[GetCampaignOffersResponse], Response) =
  ## Информация о товарах, которые размещены в заданном магазине
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offers" & "?" & query_for_api_call, $(%getCampaignOffersRequest))
  constructResult[GetCampaignOffersResponse](response)


proc getCampaignQuarantineOffers*(httpClient: HttpClient, campaignId: int64, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken: string, limit: int): (Option[GetQuarantineOffersResponse], Response) =
  ## Список товаров, находящихся в карантине по цене в магазине
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/price-quarantine" & "?" & query_for_api_call, $(%getQuarantineOffersRequest))
  constructResult[GetQuarantineOffersResponse](response)


proc getCampaignRegion*(httpClient: HttpClient, campaignId: int64): (Option[GetCampaignRegionResponse], Response) {.deprecated.} =
  ## Регион магазина

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/region")
  constructResult[GetCampaignRegionResponse](response)


proc getCampaignSettings*(httpClient: HttpClient, campaignId: int64): (Option[GetCampaignSettingsResponse], Response) =
  ## Настройки магазина

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/settings")
  constructResult[GetCampaignSettingsResponse](response)


proc getCampaigns*(httpClient: HttpClient, page: int, pageSize: int): (Option[GetCampaignsResponse], Response) =
  ## Список магазинов пользователя
  let query_for_api_call = encodeQuery([
    ("page", $page), # Номер страницы результатов.  Значение по умолчанию: 1.  Используется вместе с параметром `page_size`.  `page_number` игнорируется, если задан `page_token`, `limit` или `offset`. 
    ("pageSize", $pageSize), # Размер страницы.  Используется вместе с параметром `page_number`.  `page_size` игнорируется, если задан `page_token`, `limit` или `offset`. 
  ])

  let response = httpClient.get(basepath & "/campaigns" & "?" & query_for_api_call)
  constructResult[GetCampaignsResponse](response)


proc getCampaignsByLogin*(httpClient: HttpClient, login: string, page: int, pageSize: int): (Option[GetCampaignsResponse], Response) =
  ## Магазины, доступные логину
  let query_for_api_call = encodeQuery([
    ("page", $page), # Номер страницы результатов.  Значение по умолчанию: 1.  Используется вместе с параметром `page_size`.  `page_number` игнорируется, если задан `page_token`, `limit` или `offset`. 
    ("pageSize", $pageSize), # Размер страницы.  Используется вместе с параметром `page_number`.  `page_size` игнорируется, если задан `page_token`, `limit` или `offset`. 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/by_login/{login}" & "?" & query_for_api_call)
  constructResult[GetCampaignsResponse](response)


proc getCategoriesMaxSaleQuantum*(httpClient: HttpClient, getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest): (Option[GetCategoriesMaxSaleQuantumResponse], Response) =
  ## Лимит на установку кванта продажи и минимального количества товаров в заказе
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/categories/max-sale-quantum", $(%getCategoriesMaxSaleQuantumRequest))
  constructResult[GetCategoriesMaxSaleQuantumResponse](response)


proc getCategoriesTree*(httpClient: HttpClient, getCategoriesRequest: GetCategoriesRequest): (Option[GetCategoriesResponse], Response) =
  ## Дерево категорий
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/categories/tree", $(%getCategoriesRequest))
  constructResult[GetCategoriesResponse](response)


proc getCategoryContentParameters*(httpClient: HttpClient, categoryId: int64): (Option[GetCategoryContentParametersResponse], Response) =
  ## Списки характеристик товаров по категориям

  let response = httpClient.post(basepath & fmt"/category/{categoryId}/parameters")
  constructResult[GetCategoryContentParametersResponse](response)


proc getChatHistory*(httpClient: HttpClient, businessId: int64, chatId: int64, getChatHistoryRequest: GetChatHistoryRequest, pageToken: string, limit: int): (Option[GetChatHistoryResponse], Response) =
  ## Получение истории сообщений в чате
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("chatId", $chatId), # Идентификатор чата.
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/chats/history" & "?" & query_for_api_call, $(%getChatHistoryRequest))
  constructResult[GetChatHistoryResponse](response)


proc getChats*(httpClient: HttpClient, businessId: int64, getChatsRequest: GetChatsRequest, pageToken: string, limit: int): (Option[GetChatsResponse], Response) =
  ## Получение доступных чатов
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/chats" & "?" & query_for_api_call, $(%getChatsRequest))
  constructResult[GetChatsResponse](response)


proc getDeliveryServices*(httpClient: HttpClient): (Option[GetDeliveryServicesResponse], Response) =
  ## Справочник служб доставки

  let response = httpClient.get(basepath & "/delivery/services")
  constructResult[GetDeliveryServicesResponse](response)


proc getFeed*(httpClient: HttpClient, campaignId: int64, feedId: int64): (Option[GetFeedResponse], Response) {.deprecated.} =
  ## Информация о прайс-листе

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/feeds/{feedId}")
  constructResult[GetFeedResponse](response)


proc getFeedIndexLogs*(httpClient: HttpClient, campaignId: int64, feedId: int64, limit: int, publishedTimeFrom: string, publishedTimeTo: string, status: FeedIndexLogsStatusType): (Option[GetFeedIndexLogsResponse], Response) {.deprecated.} =
  ## Отчет по индексации прайс-листа
  let query_for_api_call = encodeQuery([
    ("limit", $limit), # Количество значений на одной странице. 
    ("published_time_from", $publishedTimeFrom), # Начальная дата. Используется для фильтрации записей — по дате и времени публикации предложений на Яндекс Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`.  Значение по умолчанию: последние восемь дней со времени отправки запроса. 
    ("published_time_to", $publishedTimeTo), # Конечная дата. Используется для фильтрации записей — по дате и времени публикации предложений на Яндекс Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-31T00:42:42+03:00`.  Значение по умолчанию: дата и время отправки запроса.  {% note info %}  Если во время переключения между страницами выходных данных на Яндекс Маркете появятся новые результаты индексации прайс-листа, вы не получите часть данных. Чтобы этого не произошло, зафиксируйте выходные данные с помощью входного параметра `published_time_to`. Значение параметра не должно быть датой из будущего.  {% endnote %} 
    ("status", $status), # Статус индексации и проверки прайс-листа на соответствие техническим требованиям.  Возможные значения: * `ERROR` — произошли ошибки. * `OK` — обработан без ошибок. * `WARNING` — наблюдались некритичные проблемы. 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/feeds/{feedId}/index-logs" & "?" & query_for_api_call)
  constructResult[GetFeedIndexLogsResponse](response)


proc getFeedbackAndCommentUpdates*(httpClient: HttpClient, campaignId: int64, pageToken: string, limit: int, fromDate: string): (Option[GetFeedbackListResponse], Response) {.deprecated.} =
  ## Новые и обновленные отзывы о магазине
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
    ("from_date", $fromDate), # Начальная дата обновления отзывов.  Если параметр указан, возвращаются отзывы, которые были написаны или обновлены с этой даты.  Формат даты: `ГГГГ-ММ-ДД`. 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/feedback/updates" & "?" & query_for_api_call)
  constructResult[GetFeedbackListResponse](response)


proc getFeeds*(httpClient: HttpClient, campaignId: int64): (Option[GetFeedsResponse], Response) {.deprecated.} =
  ## Список прайс-листов магазина

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/feeds")
  constructResult[GetFeedsResponse](response)


proc getGoodsFeedbackComments*(httpClient: HttpClient, businessId: int64, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken: string, limit: int): (Option[GetGoodsFeedbackCommentsResponse], Response) =
  ## Получение комментариев к отзыву
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/goods-feedback/comments" & "?" & query_for_api_call, $(%getGoodsFeedbackCommentsRequest))
  constructResult[GetGoodsFeedbackCommentsResponse](response)


proc getGoodsFeedbacks*(httpClient: HttpClient, businessId: int64, pageToken: string, limit: int, getGoodsFeedbackRequest: GetGoodsFeedbackRequest): (Option[GetGoodsFeedbackResponse], Response) =
  ## Получение отзывов о товарах продавца
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/goods-feedback" & "?" & query_for_api_call, $(%getGoodsFeedbackRequest))
  constructResult[GetGoodsFeedbackResponse](response)


proc getGoodsStats*(httpClient: HttpClient, campaignId: int64, getGoodsStatsRequest: GetGoodsStatsRequest): (Option[GetGoodsStatsResponse], Response) =
  ## Отчет по товарам
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/stats/skus", $(%getGoodsStatsRequest))
  constructResult[GetGoodsStatsResponse](response)


proc getHiddenOffers*(httpClient: HttpClient, campaignId: int64, offerId: seq[string], pageToken: string, limit: int, offset: int, page: int, pageSize: int): (Option[GetHiddenOffersResponse], Response) =
  ## Информация о скрытых вами товарах
  let query_for_api_call = encodeQuery([
    ("offer_id", $offerId.join(",")), # Идентификатор скрытого предложения. 
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
    ("offset", $offset), # Позиция в списке, начиная с которой возвращаются результаты ответа.  Используется вместе с параметром `limit`.  Если задан `offset`, параметры `page_number` и `page_size` игнорируются.  `offset` игнорируется, если задан `page_token`. 
    ("page", $page), # Номер страницы результатов.  Значение по умолчанию: 1.  Используется вместе с параметром `page_size`.  `page_number` игнорируется, если задан `page_token`, `limit` или `offset`. 
    ("pageSize", $pageSize), # Размер страницы.  Используется вместе с параметром `page_number`.  `page_size` игнорируется, если задан `page_token`, `limit` или `offset`. 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/hidden-offers" & "?" & query_for_api_call)
  constructResult[GetHiddenOffersResponse](response)


proc getOfferCardsContentStatus*(httpClient: HttpClient, businessId: int64, pageToken: string, limit: int, getOfferCardsContentStatusRequest: GetOfferCardsContentStatusRequest): (Option[GetOfferCardsContentStatusResponse], Response) =
  ## Получение информации о заполненности карточек магазина
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offer-cards" & "?" & query_for_api_call, $(%getOfferCardsContentStatusRequest))
  constructResult[GetOfferCardsContentStatusResponse](response)


proc getOfferMappingEntries*(httpClient: HttpClient, campaignId: int64, offerId: seq[string], shopSku: seq[string], mappingKind: OfferMappingKindType, status: seq[OfferProcessingStatusType], availability: seq[OfferAvailabilityStatusType], categoryId: seq[int], vendor: seq[string], pageToken: string, limit: int): (Option[GetOfferMappingEntriesResponse], Response) {.deprecated.} =
  ## Список товаров в каталоге
  let query_for_api_call = encodeQuery([
    ("offer_id", $offerId.join(",")), # Идентификатор товара в каталоге.
    ("shop_sku", $shopSku.join(",")), # Ваш SKU товара.  Параметр может быть указан несколько раз, например:  ``` ...shop_sku=123&shop_sku=129&shop_sku=141... ```  В запросе можно указать либо параметр `shopSku`, либо любые параметры для фильтрации товаров. Совместное использование параметра `shopSku` и параметров для фильтрации приведет к ошибке. 
    ("mapping_kind", $mappingKind), # Тип маппинга.
    ("status", $status.join(",")), # Фильтрация по статусу публикации товара:  * `READY` — товар прошел модерацию. * `IN_WORK` — товар проходит модерацию. * `NEED_CONTENT` — для товара без SKU на Маркете marketSku нужно найти карточку самостоятельно или создать ее. * `NEED_INFO` — товар не прошел модерацию из-за ошибок или недостающих сведений в описании товара. * `REJECTED` — товар не прошел модерацию, так как Маркет не планирует размещать подобные товары. * `SUSPENDED` — товар не прошел модерацию, так как Маркет пока не размещает подобные товары. * `OTHER` — товар не прошел модерацию по другой причине.  Можно указать несколько статусов в одном параметре, через запятую, или в нескольких одинаковых параметрах. Например:  ``` ...status=READY,IN_WORK... ...status=READY&status=IN_WORK... ```  В запросе можно указать либо параметр shopSku, либо любые параметры для фильтрации товаров. Совместное использование параметра shopSku и параметров для фильтрации приведет к ошибке. 
    ("availability", $availability.join(",")), # Фильтрация по планам поставок товара:  * `ACTIVE` — поставки будут. * `INACTIVE` — поставок не будет: товар есть на складе, но вы больше не планируете его поставлять. * `DELISTED` — архив: товар закончился на складе, и его поставок больше не будет.  Можно указать несколько значений в одном параметре, через запятую, или в нескольких одинаковых параметрах. Например:  ``` ...availability=INACTIVE,DELISTED... ...availability=INACTIVE&availability=DELISTED... ```  В запросе можно указать либо параметр `shopSku`, либо любые параметры для фильтрации товаров. Совместное использование параметра `shopSku` и параметров для фильтрации приведет к ошибке. 
    ("category_id", $categoryId.join(",")), # Фильтрация по идентификатору категории на Маркете.  Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).  Можно указать несколько идентификаторов в одном параметре, через запятую, или в нескольких одинаковых параметрах. Например:  ``` ...category_id=14727164,14382343... ...category_id=14727164&category_id=14382343... ```  В запросе можно указать либо параметр `shopSku`, либо любые параметры для фильтрации товаров. Совместное использование параметра `shopSku` и параметров для фильтрации приведет к ошибке. 
    ("vendor", $vendor.join(",")), # Фильтрация по бренду товара.  Можно указать несколько брендов в одном параметре, через запятую, или в нескольких одинаковых параметрах. Например:  ``` ...vendor=Aqua%20Minerale,Borjomi... ...vendor=Aqua%20Minerale&vendor=Borjomi... ```  Чтобы товар попал в результаты фильтрации, его бренд должен точно совпадать с одним из указанных в запросе. Например, если указан бренд Schwarzkopf, то в результатах не будет товаров Schwarzkopf Professional.  Если в названии бренда есть символы, которые не входят в таблицу ASCII (в том числе кириллические символы), используйте для них URL-кодирование. Например, пробел — %20, апостроф «'» — %27 и т. д. Подробнее см. в разделе [Кодирование URL русскоязычной Википедии](https://ru.wikipedia.org/wiki/URL#Кодирование_URL).  В запросе можно указать либо параметр shopSku, либо любые параметры для фильтрации товаров. Совместное использование параметра shopSku и параметров для фильтрации приведет к ошибке. 
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/offer-mapping-entries" & "?" & query_for_api_call)
  constructResult[GetOfferMappingEntriesResponse](response)


proc getOfferMappings*(httpClient: HttpClient, businessId: int64, pageToken: string, limit: int, getOfferMappingsRequest: GetOfferMappingsRequest): (Option[GetOfferMappingsResponse], Response) =
  ## Информация о товарах в каталоге
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offer-mappings" & "?" & query_for_api_call, $(%getOfferMappingsRequest))
  constructResult[GetOfferMappingsResponse](response)


proc getOfferRecommendations*(httpClient: HttpClient, businessId: int64, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken: string, limit: int): (Option[GetOfferRecommendationsResponse], Response) =
  ## Рекомендации Маркета, касающиеся цен
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offers/recommendations" & "?" & query_for_api_call, $(%getOfferRecommendationsRequest))
  constructResult[GetOfferRecommendationsResponse](response)


proc getOffers*(httpClient: HttpClient, campaignId: int64, query: string, feedId: int64, shopCategoryId: string, currency: CurrencyType, matched: bool, page: int, pageSize: int): (Option[GetOffersResponse], Response) {.deprecated.} =
  ## Предложения магазина
  let query_for_api_call = encodeQuery([
    ("query", $query), # Поисковый запрос.  Поддерживается язык запросов.  Значение по умолчанию: все предложения магазина, размещенные на Маркете. 
    ("feedId", $feedId), # Идентификатор прайс-листа.
    ("shopCategoryId", $shopCategoryId), # Идентификатор категории предложения, указанный магазином в прайс-листе.  Параметр выводится только для предложений, у которых указана категория в прайс-листе.  Параметр доступен начиная с версии 2.0 партнерского API. 
    ("currency", $currency), # Валюта, в которой указана цена предложения.  Возможные значения:  * `BYN` — белорусский рубль.  * `KZT` — казахстанский тенге.  * `RUR` — российский рубль.  * `UAH` — украинская гривна. 
    ("matched", $matched), # Фильтр по признаку соотнесения предложения и карточки модели.  Возможные значения:  * `0 / FALSE / NO` — поиск выполняется среди предложений, не соотнесенных ни с какой карточкой модели.  * `1 / TRUE / YES` — поиск выполняется среди предложений, соотнесенных с карточками моделей). 
    ("page", $page), # Номер страницы результатов.  Значение по умолчанию: 1.  Используется вместе с параметром `page_size`.  `page_number` игнорируется, если задан `page_token`, `limit` или `offset`. 
    ("pageSize", $pageSize), # Размер страницы.  Используется вместе с параметром `page_number`.  `page_size` игнорируется, если задан `page_token`, `limit` или `offset`. 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/offers" & "?" & query_for_api_call)
  constructResult[GetOffersResponse](response)


proc getOrder*(httpClient: HttpClient, campaignId: int64, orderId: int64): (Option[GetOrderResponse], Response) =
  ## Информация об одном заказе

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}")
  constructResult[GetOrderResponse](response)


proc getOrderBusinessBuyerInfo*(httpClient: HttpClient, campaignId: int64, orderId: int64): (Option[GetBusinessBuyerInfoResponse], Response) =
  ## Информация о покупателе — юридическом лице

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/business-buyer")
  constructResult[GetBusinessBuyerInfoResponse](response)


proc getOrderBusinessDocumentsInfo*(httpClient: HttpClient, campaignId: int64, orderId: int64): (Option[GetBusinessDocumentsInfoResponse], Response) =
  ## Информация о документах

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/documents")
  constructResult[GetBusinessDocumentsInfoResponse](response)


proc getOrderLabelsData*(httpClient: HttpClient, campaignId: int64, orderId: int64): (Option[GetOrderLabelsDataResponse], Response) =
  ## Данные для самостоятельного изготовления ярлыков

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/delivery/labels/data")
  constructResult[GetOrderLabelsDataResponse](response)


proc getOrders*(httpClient: HttpClient, campaignId: int64, orderIds: seq[int64], status: seq[OrderStatusType], substatus: seq[OrderSubstatusType], fromDate: string, toDate: string, supplierShipmentDateFrom: string, supplierShipmentDateTo: string, updatedAtFrom: string, updatedAtTo: string, dispatchType: OrderDeliveryDispatchType, fake: bool, hasCis: bool, onlyWaitingForCancellationApprove: bool, onlyEstimatedDelivery: bool, buyerType: OrderBuyerType, page: int, pageSize: int, pageToken: string, limit: int): (Option[GetOrdersResponse], Response) =
  ## Информация о нескольких заказах
  let query_for_api_call = encodeQuery([
    ("orderIds", $orderIds.join(",")), # Фильтрация заказов по идентификаторам. <br><br> ⚠️ Не используйте это поле одновременно с другими фильтрами. Если вы хотите воспользоваться ими, оставьте поле пустым. 
    ("status", $status.join(",")), # Статус заказа:  * `CANCELLED` — заказ отменен.  * `DELIVERED` — заказ получен покупателем.  * `DELIVERY` — заказ передан в службу доставки.  * `PICKUP` — заказ доставлен в пункт самовывоза.  * `PROCESSING` — заказ находится в обработке.  * `UNPAID` — заказ оформлен, но еще не оплачен (если выбрана оплата при оформлении).  Также могут возвращаться другие значения. Обрабатывать их не требуется. 
    ("substatus", $substatus.join(",")), # Этап обработки заказа (если он имеет статус `PROCESSING`) или причина отмены заказа (если он имеет статус `CANCELLED`).  Возможные значения для заказа в статусе `PROCESSING`:  * `STARTED` — заказ подтвержден, его можно начать обрабатывать. * `READY_TO_SHIP` — заказ собран и готов к отправке. * `SHIPPED` — заказ передан службе доставки.  Возможные значения для заказа в статусе `CANCELLED`:  * `DELIVERY_SERVICE_UNDELIVERED` — служба доставки не смогла доставить заказ.  * `PROCESSING_EXPIRED` — значение более не используется.  * `REPLACING_ORDER` — покупатель решил заменить товар другим по собственной инициативе.  * `RESERVATION_EXPIRED` — покупатель не завершил оформление зарезервированного заказа в течение 10 минут.  * `RESERVATION_FAILED` — Маркет не может продолжить дальнейшую обработку заказа.  * `SHOP_FAILED` — магазин не может выполнить заказ.  * `USER_CHANGED_MIND` — покупатель отменил заказ по личным причинам.  * `USER_NOT_PAID` — покупатель не оплатил заказ (для типа оплаты `PREPAID`) в течение 30 минут.  * `USER_REFUSED_DELIVERY` — покупателя не устроили условия доставки.  * `USER_REFUSED_PRODUCT` — покупателю не подошел товар.  * `USER_REFUSED_QUALITY` — покупателя не устроило качество товара.  * `USER_UNREACHABLE` — не удалось связаться с покупателем. Для отмены с этой причиной необходимо выполнить условия:    * не менее 3 звонков с 8 до 21 в часовом поясе покупателя;   * перерыв между первым и третьим звонком не менее 90 минут;   * соединение не короче 5 секунд.    Если хотя бы одно из этих условий не выполнено (кроме случая, когда номер недоступен), отменить заказ не получится. Вернется ответ с кодом ошибки 400. * `USER_WANTS_TO_CHANGE_DELIVERY_DATE` — покупатель хочет получить заказ в другой день. * `CANCELLED_COURIER_NOT_FOUND` — не удалось найти курьера.  Также могут возвращаться другие значения. Обрабатывать их не требуется. 
    ("fromDate", $fromDate), # Начальная дата для фильтрации заказов по дате оформления.  Формат даты: `ДД-ММ-ГГГГ`.  Между начальной и конечной датой (параметр `toDate`) должно быть не больше 30 дней.  Значение по умолчанию: 30 дней назад от текущей даты. 
    ("toDate", $toDate), # Конечная дата для фильтрации заказов по дате оформления.  Показываются заказы, созданные до 00:00 указанного дня.  Формат даты: `ДД-ММ-ГГГГ`.  Между начальной (параметр `fromDate`) и конечной датой должно быть не больше 30 дней.  Значение по умолчанию: текущая дата. 
    ("supplierShipmentDateFrom", $supplierShipmentDateFrom), # Начальная дата для фильтрации заказов по дате отгрузки в службу доставки (параметр `shipmentDate`).  Формат даты: `ДД-ММ-ГГГГ`.  Между начальной и конечной датой (параметр `supplierShipmentDateTo`) должно быть не больше 30 дней.  Начальная дата включается в интервал для фильтрации. 
    ("supplierShipmentDateTo", $supplierShipmentDateTo), # Конечная дата для фильтрации заказов по дате отгрузки в службу доставки (параметр `shipmentDate`).  Формат даты: `ДД-ММ-ГГГГ`.  Между начальной (параметр `supplierShipmentDateFrom`) и конечной датой должно быть не больше 30 дней.  Конечная дата не включается в интервал для фильтрации. 
    ("updatedAtFrom", $updatedAtFrom), # Начальная дата для фильтрации заказов по дате и времени обновления (параметр `updatedAt`).  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`.  Между начальной и конечной датой (параметр `updatedAtTo`) должно быть не больше 30 дней.  Начальная дата включается в интервал для фильтрации. 
    ("updatedAtTo", $updatedAtTo), # Конечная дата для фильтрации заказов по дате и времени обновления (параметр `updatedAt`).  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`.  Между начальной (параметр `updatedAtFrom`) и конечной датой должно быть не больше 30 дней.  Конечная дата не включается в интервал для фильтрации. 
    ("dispatchType", $dispatchType), # Способ отгрузки
    ("fake", $fake), # Фильтрация заказов по типам:  * `false` — настоящий заказ покупателя.  * `true` — [тестовый](../../pushapi/concepts/sandbox.md) заказ Маркета. 
    ("hasCis", $hasCis), # Нужно ли вернуть только те заказы, в составе которых есть хотя бы один товар с кодом идентификации [в системе «Честный ЗНАК»](https://честныйзнак.рф/):  * `true` — да.  * `false` — нет.  Такие коды присваиваются товарам, которые подлежат маркировке и относятся к определенным категориям. 
    ("onlyWaitingForCancellationApprove", $onlyWaitingForCancellationApprove), # **Только для модели DBS**  Фильтрация заказов по наличию запросов покупателей на отмену.  При значение `true` возвращаются только заказы, которые находятся в статусе `DELIVERY` или `PICKUP` и которые пользователи решили отменить.  Чтобы подтвердить или отклонить отмену, отправьте запрос [PUT campaigns/{campaignId}/orders/{orderId}/cancellation/accept](../../reference/orders/acceptOrderCancellation). 
    ("onlyEstimatedDelivery", $onlyEstimatedDelivery), # Фильтрация заказов с долгой доставкой (31-60 дней) по подтвержденной дате доставки:  * `true` — возвращаются только заказы с неподтвержденной датой доставки. * `false` — фильтрация не применяется. 
    ("buyerType", $buyerType), # Фильтрация заказов по типу покупателя. 
    ("page", $page), # Номер страницы результатов.  Значение по умолчанию: 1.  Используется вместе с параметром `page_size`.  `page_number` игнорируется, если задан `page_token`, `limit` или `offset`. 
    ("pageSize", $pageSize), # Размер страницы.  Используется вместе с параметром `page_number`.  `page_size` игнорируется, если задан `page_token`, `limit` или `offset`. 
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/orders" & "?" & query_for_api_call)
  constructResult[GetOrdersResponse](response)


proc getOrdersStats*(httpClient: HttpClient, campaignId: int64, pageToken: string, limit: int, getOrdersStatsRequest: GetOrdersStatsRequest): (Option[GetOrdersStatsResponse], Response) =
  ## Детальная информация по заказам
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/stats/orders" & "?" & query_for_api_call, $(%getOrdersStatsRequest))
  constructResult[GetOrdersStatsResponse](response)


proc getPrices*(httpClient: HttpClient, campaignId: int64, pageToken: string, limit: int, archived: bool): (Option[GetPricesResponse], Response) {.deprecated.} =
  ## Список цен
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
    ("archived", $archived), # Фильтр по нахождению в архиве.
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/offer-prices" & "?" & query_for_api_call)
  constructResult[GetPricesResponse](response)


proc getPricesByOfferIds*(httpClient: HttpClient, campaignId: int64, pageToken: string, limit: int, getPricesByOfferIdsRequest: GetPricesByOfferIdsRequest): (Option[GetPricesByOfferIdsResponse], Response) =
  ## Просмотр цен на указанные товары в магазине
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offer-prices" & "?" & query_for_api_call, $(%getPricesByOfferIdsRequest))
  constructResult[GetPricesByOfferIdsResponse](response)


proc getPromoOffers*(httpClient: HttpClient, businessId: int64, getPromoOffersRequest: GetPromoOffersRequest, pageToken: string, limit: int): (Option[GetPromoOffersResponse], Response) =
  ## Получение списка товаров, которые участвуют или могут участвовать в акции
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/promos/offers" & "?" & query_for_api_call, $(%getPromoOffersRequest))
  constructResult[GetPromoOffersResponse](response)


proc getPromos*(httpClient: HttpClient, businessId: int64, getPromosRequest: GetPromosRequest): (Option[GetPromosResponse], Response) =
  ## Получение списка акций
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/promos", $(%getPromosRequest))
  constructResult[GetPromosResponse](response)


proc getQualityRatingDetails*(httpClient: HttpClient, campaignId: int64): (Option[GetQualityRatingDetailsResponse], Response) =
  ## Заказы, которые повлияли на индекс качества

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/ratings/quality/details")
  constructResult[GetQualityRatingDetailsResponse](response)


proc getQualityRatings*(httpClient: HttpClient, businessId: int64, getQualityRatingRequest: GetQualityRatingRequest): (Option[GetQualityRatingResponse], Response) =
  ## Индекс качества магазинов
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/ratings/quality", $(%getQualityRatingRequest))
  constructResult[GetQualityRatingResponse](response)


proc getReportInfo*(httpClient: HttpClient, reportId: string): (Option[GetReportInfoResponse], Response) =
  ## Получение заданного отчета

  let response = httpClient.get(basepath & fmt"/reports/info/{reportId}")
  constructResult[GetReportInfoResponse](response)


proc getReturn*(httpClient: HttpClient, campaignId: int64, orderId: int64, returnId: int64): (Option[GetReturnResponse], Response) =
  ## Информация о невыкупе или возврате

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}")
  constructResult[GetReturnResponse](response)


proc getReturnApplication*(httpClient: HttpClient, campaignId: int64, orderId: int64, returnId: int64): (Option[string], Response) =
  ## Получение заявления на возврат

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application")
  constructResult[string](response)


proc getReturnPhoto*(httpClient: HttpClient, campaignId: int64, orderId: int64, returnId: int64, itemId: int64, imageHash: string): (Option[string], Response) =
  ## Получение фотографии возврата

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}")
  constructResult[string](response)


proc getReturns*(httpClient: HttpClient, campaignId: int64, pageToken: string, limit: int, orderIds: seq[int64], statuses: seq[RefundStatusType], `type`: ReturnType, fromDate: string, toDate: string, fromDate2: string, toDate2: string): (Option[GetReturnsResponse], Response) =
  ## Список невыкупов и возвратов
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
    ("orderIds", $orderIds.join(",")), # Идентификаторы заказов — для фильтрации результатов.  Несколько идентификаторов перечисляются через запятую без пробела. Максимальное количество идентификаторов — 50. 
    ("statuses", $statuses.join(",")), # Статусы возвратов или невыкупов — для фильтрации результатов.  Несколько статусов перечисляются через запятую. 
    ("type", $`type`), # Тип заказа для фильтрации:  * `RETURN` — возврат.  * `UNREDEEMED` — невыкуп.  Если не указывать, в ответе будут и возвраты, и невыкупы. 
    ("fromDate", $fromDate), # Начальная дата для фильтрации возвратов или невыкупов по дате обновления.  Формат: `ГГГГ-ММ-ДД`. 
    ("toDate", $toDate), # Конечная дата для фильтрации возвратов или невыкупов по дате обновления.  Формат: `ГГГГ-ММ-ДД`. 
    ("from_date", $fromDate2), # {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `fromDate`.  {% endnote %}  Начальная дата для фильтрации возвратов или невыкупов по дате обновления. 
    ("to_date", $toDate2), # {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `toDate`.  {% endnote %}  Конечная дата для фильтрации возвратов или невыкупов по дате обновления. 
  ])

  let response = httpClient.get(basepath & fmt"/campaigns/{campaignId}/returns" & "?" & query_for_api_call)
  constructResult[GetReturnsResponse](response)


proc getStocks*(httpClient: HttpClient, campaignId: int64, pageToken: string, limit: int, getWarehouseStocksRequest: GetWarehouseStocksRequest): (Option[GetWarehouseStocksResponse], Response) =
  ## Информация об остатках и оборачиваемости
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offers/stocks" & "?" & query_for_api_call, $(%getWarehouseStocksRequest))
  constructResult[GetWarehouseStocksResponse](response)


proc getSuggestedOfferMappingEntries*(httpClient: HttpClient, campaignId: int64, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest): (Option[GetSuggestedOfferMappingEntriesResponse], Response) {.deprecated.} =
  ## Рекомендованные карточки для товаров
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offer-mapping-entries/suggestions", $(%getSuggestedOfferMappingEntriesRequest))
  constructResult[GetSuggestedOfferMappingEntriesResponse](response)


proc getSuggestedOfferMappings*(httpClient: HttpClient, businessId: int64, getSuggestedOfferMappingsRequest: GetSuggestedOfferMappingsRequest): (Option[GetSuggestedOfferMappingsResponse], Response) =
  ## Просмотр карточек на Маркете, которые подходят вашим товарам
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offer-mappings/suggestions", $(%getSuggestedOfferMappingsRequest))
  constructResult[GetSuggestedOfferMappingsResponse](response)


proc getSuggestedPrices*(httpClient: HttpClient, campaignId: int64, suggestPricesRequest: SuggestPricesRequest): (Option[SuggestPricesResponse], Response) {.deprecated.} =
  ## Цены для продвижения товаров
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offer-prices/suggestions", $(%suggestPricesRequest))
  constructResult[SuggestPricesResponse](response)


proc getWarehouses*(httpClient: HttpClient, businessId: int64): (Option[GetWarehousesResponse], Response) =
  ## Список складов и групп складов

  let response = httpClient.get(basepath & fmt"/businesses/{businessId}/warehouses")
  constructResult[GetWarehousesResponse](response)


proc provideOrderItemIdentifiers*(httpClient: HttpClient, campaignId: int64, orderId: int64, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest): (Option[ProvideOrderItemIdentifiersResponse], Response) =
  ## Передача кодов маркировки единиц товара
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/identifiers", $(%provideOrderItemIdentifiersRequest))
  constructResult[ProvideOrderItemIdentifiersResponse](response)


proc putBidsForBusiness*(httpClient: HttpClient, businessId: int64, putSkuBidsRequest: PutSkuBidsRequest): (Option[EmptyApiResponse], Response) =
  ## Включение буста продаж и установка ставок
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/businesses/{businessId}/bids", $(%putSkuBidsRequest))
  constructResult[EmptyApiResponse](response)


proc putBidsForCampaign*(httpClient: HttpClient, campaignId: int64, putSkuBidsRequest: PutSkuBidsRequest): (Option[EmptyApiResponse], Response) =
  ## Включение буста продаж и установка ставок для магазина
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/campaigns/{campaignId}/bids", $(%putSkuBidsRequest))
  constructResult[EmptyApiResponse](response)


proc refreshFeed*(httpClient: HttpClient, campaignId: int64, feedId: int64): (Option[EmptyApiResponse], Response) {.deprecated.} =
  ## Сообщить, что прайс-лист обновился

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/feeds/{feedId}/refresh")
  constructResult[EmptyApiResponse](response)


proc searchRegionChildren*(httpClient: HttpClient, regionId: int64, page: int, pageSize: int): (Option[GetRegionWithChildrenResponse], Response) =
  ## Информация о дочерних регионах
  let query_for_api_call = encodeQuery([
    ("page", $page), # Номер страницы результатов.  Значение по умолчанию: 1.  Используется вместе с параметром `page_size`.  `page_number` игнорируется, если задан `page_token`, `limit` или `offset`. 
    ("pageSize", $pageSize), # Размер страницы.  Используется вместе с параметром `page_number`.  `page_size` игнорируется, если задан `page_token`, `limit` или `offset`. 
  ])

  let response = httpClient.get(basepath & fmt"/regions/{regionId}/children" & "?" & query_for_api_call)
  constructResult[GetRegionWithChildrenResponse](response)


proc searchRegionsById*(httpClient: HttpClient, regionId: int64): (Option[GetRegionsResponse], Response) =
  ## Информация о регионе

  let response = httpClient.get(basepath & fmt"/regions/{regionId}")
  constructResult[GetRegionsResponse](response)


proc searchRegionsByName*(httpClient: HttpClient, name: string, pageToken: string, limit: int): (Option[GetRegionsResponse], Response) =
  ## Поиск регионов по их имени
  let query_for_api_call = encodeQuery([
    ("name", $name), # Название региона.  Важно учитывать регистр: первая буква должна быть заглавной, остальные — строчными. Например, `Москва`. 
    ("page_token", $pageToken), # Идентификатор страницы c результатами.  Если параметр не указан, возвращается первая страница.  Рекомендуется передавать значение выходного параметра `nextPageToken`, полученное при последнем запросе.  Если задан `page_token` и в запросе есть параметры `offset`, `page_number` и `page_size`, они игнорируются. 
    ("limit", $limit), # Количество значений на одной странице. 
  ])

  let response = httpClient.get(basepath & "/regions" & "?" & query_for_api_call)
  constructResult[GetRegionsResponse](response)


proc sendFileToChat*(httpClient: HttpClient, businessId: int64, chatId: int64, file: string): (Option[EmptyApiResponse], Response) =
  ## Отправка файла в чат
  httpClient.headers["Content-Type"] = "multipart/form-data"
  let query_for_api_call = encodeQuery([
    ("chatId", $chatId), # Идентификатор чата.
  ])
  let query_for_api_call = newMultipartData({
    "file": $file, # Содержимое файла. Максимальный размер файла — 5 Мбайт.
  })

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/chats/file/send" & "?" & query_for_api_call, multipart=query_for_api_call)
  constructResult[EmptyApiResponse](response)


proc sendMessageToChat*(httpClient: HttpClient, businessId: int64, chatId: int64, sendMessageToChatRequest: SendMessageToChatRequest): (Option[EmptyApiResponse], Response) =
  ## Отправка сообщения в чат
  httpClient.headers["Content-Type"] = "application/json"
  let query_for_api_call = encodeQuery([
    ("chatId", $chatId), # Идентификатор чата.
  ])

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/chats/message" & "?" & query_for_api_call, $(%sendMessageToChatRequest))
  constructResult[EmptyApiResponse](response)


proc setFeedParams*(httpClient: HttpClient, campaignId: int64, feedId: int64, setFeedParamsRequest: SetFeedParamsRequest): (Option[EmptyApiResponse], Response) {.deprecated.} =
  ## Изменение параметров прайс-листа
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/feeds/{feedId}/params", $(%setFeedParamsRequest))
  constructResult[EmptyApiResponse](response)


proc setOrderBoxLayout*(httpClient: HttpClient, campaignId: int64, orderId: int64, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest): (Option[SetOrderBoxLayoutResponse], Response) =
  ## Подготовка заказа
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/boxes", $(%setOrderBoxLayoutRequest))
  constructResult[SetOrderBoxLayoutResponse](response)


proc setOrderShipmentBoxes*(httpClient: HttpClient, campaignId: int64, orderId: int64, shipmentId: int64, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest): (Option[SetOrderShipmentBoxesResponse], Response) =
  ## Передача количества грузовых мест в заказе
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes", $(%setOrderShipmentBoxesRequest))
  constructResult[SetOrderShipmentBoxesResponse](response)


proc skipGoodsFeedbacksReaction*(httpClient: HttpClient, businessId: int64, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest): (Option[EmptyApiResponse], Response) =
  ## Отказ от ответа на отзывы
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/goods-feedback/skip-reaction", $(%skipGoodsFeedbackReactionRequest))
  constructResult[EmptyApiResponse](response)


proc updateBusinessPrices*(httpClient: HttpClient, businessId: int64, updateBusinessPricesRequest: UpdateBusinessPricesRequest): (Option[EmptyApiResponse], Response) =
  ## Установка цен на товары во всех магазинах
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offer-prices/updates", $(%updateBusinessPricesRequest))
  constructResult[EmptyApiResponse](response)


proc updateCampaignOffers*(httpClient: HttpClient, campaignId: int64, updateCampaignOffersRequest: UpdateCampaignOffersRequest): (Option[EmptyApiResponse], Response) =
  ## Изменение условий продажи товаров в магазине
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offers/update", $(%updateCampaignOffersRequest))
  constructResult[EmptyApiResponse](response)


proc updateGoodsFeedbackComment*(httpClient: HttpClient, businessId: int64, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest): (Option[UpdateGoodsFeedbackCommentResponse], Response) =
  ## Добавление нового или изменение созданного комментария
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/goods-feedback/comments/update", $(%updateGoodsFeedbackCommentRequest))
  constructResult[UpdateGoodsFeedbackCommentResponse](response)


proc updateOfferContent*(httpClient: HttpClient, businessId: int64, updateOfferContentRequest: UpdateOfferContentRequest): (Option[UpdateOfferContentResponse], Response) =
  ## Редактирование категорийных характеристик товара
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offer-cards/update", $(%updateOfferContentRequest))
  constructResult[UpdateOfferContentResponse](response)


proc updateOfferMappingEntries*(httpClient: HttpClient, campaignId: int64, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest): (Option[EmptyApiResponse], Response) {.deprecated.} =
  ## Добавление и редактирование товаров в каталоге
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offer-mapping-entries/updates", $(%updateOfferMappingEntryRequest))
  constructResult[EmptyApiResponse](response)


proc updateOfferMappings*(httpClient: HttpClient, businessId: int64, updateOfferMappingsRequest: UpdateOfferMappingsRequest): (Option[UpdateOfferMappingsResponse], Response) =
  ## Добавление товаров в каталог и изменение информации о них
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/offer-mappings/update", $(%updateOfferMappingsRequest))
  constructResult[UpdateOfferMappingsResponse](response)


proc updateOrderItems*(httpClient: HttpClient, campaignId: int64, orderId: int64, updateOrderItemRequest: UpdateOrderItemRequest): Response =
  ## Удаление товара из заказа или уменьшение числа единиц
  httpClient.headers["Content-Type"] = "application/json"
  httpClient.put(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/items", $(%updateOrderItemRequest))


proc updateOrderStatus*(httpClient: HttpClient, campaignId: int64, orderId: int64, updateOrderStatusRequest: UpdateOrderStatusRequest): (Option[UpdateOrderStatusResponse], Response) =
  ## Изменение статуса одного заказа
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/status", $(%updateOrderStatusRequest))
  constructResult[UpdateOrderStatusResponse](response)


proc updateOrderStatuses*(httpClient: HttpClient, campaignId: int64, updateOrderStatusesRequest: UpdateOrderStatusesRequest): (Option[UpdateOrderStatusesResponse], Response) =
  ## Изменение статусов нескольких заказов
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/orders/status-update", $(%updateOrderStatusesRequest))
  constructResult[UpdateOrderStatusesResponse](response)


proc updatePrices*(httpClient: HttpClient, campaignId: int64, updatePricesRequest: UpdatePricesRequest): (Option[EmptyApiResponse], Response) =
  ## Установка цен на товары в конкретном магазине
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/campaigns/{campaignId}/offer-prices/updates", $(%updatePricesRequest))
  constructResult[EmptyApiResponse](response)


proc updatePromoOffers*(httpClient: HttpClient, businessId: int64, updatePromoOffersRequest: UpdatePromoOffersRequest): (Option[UpdatePromoOffersResponse], Response) =
  ## Добавление товаров в акцию или изменение их цен
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{businessId}/promos/offers/update", $(%updatePromoOffersRequest))
  constructResult[UpdatePromoOffersResponse](response)


proc updateStocks*(httpClient: HttpClient, campaignId: int64, updateStocksRequest: UpdateStocksRequest): (Option[EmptyApiResponse], Response) =
  ## Передача информации об остатках
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/campaigns/{campaignId}/offers/stocks", $(%updateStocksRequest))
  constructResult[EmptyApiResponse](response)


proc verifyOrderEac*(httpClient: HttpClient, campaignId: int64, orderId: int64, verifyOrderEacRequest: VerifyOrderEacRequest): (Option[VerifyOrderEacResponse], Response) =
  ## Передача кода подтверждения
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/campaigns/{campaignId}/orders/{orderId}/verifyEac", $(%verifyOrderEacRequest))
  constructResult[VerifyOrderEacResponse](response)

