/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include <corvusoft/restbed/byte.hpp>
#include <corvusoft/restbed/string.hpp>
#include <corvusoft/restbed/settings.hpp>
#include <corvusoft/restbed/request.hpp>
#include <corvusoft/restbed/uri.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>

#include "DbsApi.h"

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

namespace {
[[maybe_unused]]
std::string selectPreferredContentType(const std::vector<std::string>& contentTypes) {
    if (contentTypes.size() == 0) {
        return "application/json";
    }

    if (contentTypes.size() == 1) {
        return contentTypes.at(0);
    }

    static const std::array<std::string, 2> preferredTypes = {"json", "xml"};
    for (const auto& preferredType: preferredTypes) {
        const auto ret = std::find_if(contentTypes.cbegin(),
        contentTypes.cend(),
        [preferredType](const std::string& str) {
            return str.find(preferredType) != std::string::npos;});
        if (ret != contentTypes.cend()) {
            return *ret;
        }
    }

    return contentTypes.at(0);
}
}

DbsApiException::DbsApiException(int status_code, std::string what)
  : m_status(status_code),
    m_what(what)
{

}
int DbsApiException::getStatus() const
{
    return m_status;
}
const char* DbsApiException::what() const noexcept
{
    return m_what.c_str();
}


template<class MODEL_T>
MODEL_T extractJsonModelBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto model = MODEL_T(pt);
    return model;
}

template<class MODEL_T>
std::vector<MODEL_T> extractJsonArrayBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto arrayRet = std::vector<MODEL_T>();
    for (const auto& child: pt) {
        arrayRet.emplace_back(MODEL_T(child.second));
    }
    return arrayRet;
}

template <class KEY_T, class VAL_T>
std::string convertMapResponse(const std::map<KEY_T, VAL_T>& map)
{
    boost::property_tree::ptree pt;
    for(const auto &kv: map) {
    pt.push_back(boost::property_tree::ptree::value_type(
        boost::lexical_cast<std::string>(kv.first),
        boost::property_tree::ptree(
        boost::lexical_cast<std::string>(kv.second))));
    }
    std::stringstream sstream;
    write_json(sstream, pt);
    std::string result = sstream.str();
    return result;
}

namespace DbsApiResources {
CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/cancellation/accept");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto acceptOrderCancellationRequest = extractJsonModelBodyParam<AcceptOrderCancellationRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, orderId, acceptOrderCancellationRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::handler_PUT(
        int64_t & campaignId, int64_t & orderId, AcceptOrderCancellationRequest & acceptOrderCancellationRequest)
{
    return handler_PUT_func(campaignId, orderId, acceptOrderCancellationRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdHidden_offersResource::CampaignsCampaignIdHidden_offersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/hidden-offers");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdHidden_offersResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdHidden_offersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdHidden_offersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdHidden_offersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdHidden_offersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdHidden_offersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto addHiddenOffersRequest = extractJsonModelBodyParam<AddHiddenOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, addHiddenOffersRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdHidden_offersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string offerId_raw = request->get_query_parameter("offerId");
    std::vector<std::string> offerId;
    std::vector<std::string> offerId_temp;
    boost::split(offerId_temp, offerId_raw, boost::is_any_of(","));
    std::copy(offerId_temp.begin(), offerId_temp.end(), std::inserter(offerId, std::next(offerId.begin())));
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    int32_t offset = request->get_query_parameter("offset", 0);
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetHiddenOffersResponse resultObject = GetHiddenOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, offerId, pageToken, limit, offset, page, pageSize);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, EmptyApiResponse> CampaignsCampaignIdHidden_offersResource::handler_POST(
        int64_t & campaignId, AddHiddenOffersRequest & addHiddenOffersRequest)
{
    return handler_POST_func(campaignId, addHiddenOffersRequest);
}

std::pair<int, GetHiddenOffersResponse> CampaignsCampaignIdHidden_offersResource::handler_GET(
    int64_t & campaignId, std::vector<std::string> & offerId, std::string & pageToken, int32_t & limit, int32_t & offset, int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(campaignId, offerId, pageToken, limit, offset, page, pageSize);
}

std::string CampaignsCampaignIdHidden_offersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdHidden_offersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsArchiveResource::BusinessesBusinessIdOffer_mappingsArchiveResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/archive");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsArchiveResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsArchiveResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsArchiveResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsArchiveResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsArchiveResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsArchiveResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsArchiveResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsArchiveResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto addOffersToArchiveRequest = extractJsonModelBodyParam<AddOffersToArchiveRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    AddOffersToArchiveResponse resultObject = AddOffersToArchiveResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, addOffersToArchiveRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, AddOffersToArchiveResponse> BusinessesBusinessIdOffer_mappingsArchiveResource::handler_POST(
        int64_t & businessId, AddOffersToArchiveRequest & addOffersToArchiveRequest)
{
    return handler_POST_func(businessId, addOffersToArchiveRequest);
}


std::string BusinessesBusinessIdOffer_mappingsArchiveResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsArchiveResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
TariffsCalculateResource::TariffsCalculateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/tariffs/calculate");
	this->set_method_handler("POST",
		std::bind(&TariffsCalculateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> TariffsCalculateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> TariffsCalculateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> TariffsCalculateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void TariffsCalculateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void TariffsCalculateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void TariffsCalculateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void TariffsCalculateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto calculateTariffsRequest = extractJsonModelBodyParam<CalculateTariffsRequest>(bodyContent);
    
    int status_code = 500;
    CalculateTariffsResponse resultObject = CalculateTariffsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(calculateTariffsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, CalculateTariffsResponse> TariffsCalculateResource::handler_POST(
        CalculateTariffsRequest & calculateTariffsRequest)
{
    return handler_POST_func(calculateTariffsRequest);
}


std::string TariffsCalculateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string TariffsCalculateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPrice_quarantineConfirmResource::BusinessesBusinessIdPrice_quarantineConfirmResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/price-quarantine/confirm");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPrice_quarantineConfirmResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineConfirmResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineConfirmResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineConfirmResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPrice_quarantineConfirmResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPrice_quarantineConfirmResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPrice_quarantineConfirmResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPrice_quarantineConfirmResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto confirmPricesRequest = extractJsonModelBodyParam<ConfirmPricesRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, confirmPricesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdPrice_quarantineConfirmResource::handler_POST(
        int64_t & businessId, ConfirmPricesRequest & confirmPricesRequest)
{
    return handler_POST_func(businessId, confirmPricesRequest);
}


std::string BusinessesBusinessIdPrice_quarantineConfirmResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPrice_quarantineConfirmResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdPrice_quarantineConfirmResource::CampaignsCampaignIdPrice_quarantineConfirmResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/price-quarantine/confirm");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdPrice_quarantineConfirmResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineConfirmResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineConfirmResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineConfirmResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdPrice_quarantineConfirmResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdPrice_quarantineConfirmResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdPrice_quarantineConfirmResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdPrice_quarantineConfirmResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto confirmPricesRequest = extractJsonModelBodyParam<ConfirmPricesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, confirmPricesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdPrice_quarantineConfirmResource::handler_POST(
        int64_t & campaignId, ConfirmPricesRequest & confirmPricesRequest)
{
    return handler_POST_func(campaignId, confirmPricesRequest);
}


std::string CampaignsCampaignIdPrice_quarantineConfirmResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdPrice_quarantineConfirmResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsNewResource::BusinessesBusinessIdChatsNewResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/new");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsNewResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsNewResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsNewResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsNewResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsNewResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsNewResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsNewResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsNewResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto createChatRequest = extractJsonModelBodyParam<CreateChatRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    CreateChatResponse resultObject = CreateChatResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, createChatRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, CreateChatResponse> BusinessesBusinessIdChatsNewResource::handler_POST(
        int64_t & businessId, CreateChatRequest & createChatRequest)
{
    return handler_POST_func(businessId, createChatRequest);
}


std::string BusinessesBusinessIdChatsNewResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsNewResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOutletsResource::CampaignsCampaignIdOutletsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/outlets");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOutletsResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOutletsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOutletsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOutletsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOutletsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOutletsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOutletsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOutletsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOutletsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto changeOutletRequest = extractJsonModelBodyParam<ChangeOutletRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    CreateOutletResponse resultObject = CreateOutletResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, changeOutletRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdOutletsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int64_t regionId = request->get_query_parameter("regionId", 0L);
    std::string shopOutletCode = request->get_query_parameter("shopOutletCode", "");
    int64_t regionId2 = request->get_query_parameter("regionId2", 0L);
    
    int status_code = 500;
    GetOutletsResponse resultObject = GetOutletsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, pageToken, regionId, shopOutletCode, regionId2);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, CreateOutletResponse> CampaignsCampaignIdOutletsResource::handler_POST(
        int64_t & campaignId, ChangeOutletRequest & changeOutletRequest)
{
    return handler_POST_func(campaignId, changeOutletRequest);
}

std::pair<int, GetOutletsResponse> CampaignsCampaignIdOutletsResource::handler_GET(
    int64_t & campaignId, std::string & pageToken, int64_t & regionId, std::string & shopOutletCode, int64_t & regionId2)
{
    return handler_GET_func(campaignId, pageToken, regionId, shopOutletCode, regionId2);
}

std::string CampaignsCampaignIdOutletsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOutletsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersDeleteResource::CampaignsCampaignIdOffersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/delete");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersDeleteResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteCampaignOffersRequest = extractJsonModelBodyParam<DeleteCampaignOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    DeleteCampaignOffersResponse resultObject = DeleteCampaignOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, deleteCampaignOffersRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, DeleteCampaignOffersResponse> CampaignsCampaignIdOffersDeleteResource::handler_POST(
        int64_t & campaignId, DeleteCampaignOffersRequest & deleteCampaignOffersRequest)
{
    return handler_POST_func(campaignId, deleteCampaignOffersRequest);
}


std::string CampaignsCampaignIdOffersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/delete");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteGoodsFeedbackCommentRequest = extractJsonModelBodyParam<DeleteGoodsFeedbackCommentRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, deleteGoodsFeedbackCommentRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handler_POST(
        int64_t & businessId, DeleteGoodsFeedbackCommentRequest & deleteGoodsFeedbackCommentRequest)
{
    return handler_POST_func(businessId, deleteGoodsFeedbackCommentRequest);
}


std::string BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdHidden_offersDeleteResource::CampaignsCampaignIdHidden_offersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/hidden-offers/delete");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdHidden_offersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersDeleteResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdHidden_offersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdHidden_offersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdHidden_offersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdHidden_offersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteHiddenOffersRequest = extractJsonModelBodyParam<DeleteHiddenOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, deleteHiddenOffersRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdHidden_offersDeleteResource::handler_POST(
        int64_t & campaignId, DeleteHiddenOffersRequest & deleteHiddenOffersRequest)
{
    return handler_POST_func(campaignId, deleteHiddenOffersRequest);
}


std::string CampaignsCampaignIdHidden_offersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdHidden_offersDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsDeleteResource::BusinessesBusinessIdOffer_mappingsDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/delete");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsDeleteResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteOffersRequest = extractJsonModelBodyParam<DeleteOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    DeleteOffersResponse resultObject = DeleteOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, deleteOffersRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, DeleteOffersResponse> BusinessesBusinessIdOffer_mappingsDeleteResource::handler_POST(
        int64_t & businessId, DeleteOffersRequest & deleteOffersRequest)
{
    return handler_POST_func(businessId, deleteOffersRequest);
}


std::string BusinessesBusinessIdOffer_mappingsDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsUnarchiveResource::BusinessesBusinessIdOffer_mappingsUnarchiveResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/unarchive");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsUnarchiveResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUnarchiveResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUnarchiveResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUnarchiveResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsUnarchiveResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsUnarchiveResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsUnarchiveResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsUnarchiveResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteOffersFromArchiveRequest = extractJsonModelBodyParam<DeleteOffersFromArchiveRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    DeleteOffersFromArchiveResponse resultObject = DeleteOffersFromArchiveResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, deleteOffersFromArchiveRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, DeleteOffersFromArchiveResponse> BusinessesBusinessIdOffer_mappingsUnarchiveResource::handler_POST(
        int64_t & businessId, DeleteOffersFromArchiveRequest & deleteOffersFromArchiveRequest)
{
    return handler_POST_func(businessId, deleteOffersFromArchiveRequest);
}


std::string BusinessesBusinessIdOffer_mappingsUnarchiveResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsUnarchiveResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOutletsOutletIdResource::CampaignsCampaignIdOutletsOutletIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/outlets/{outletId: .*}");
	this->set_method_handler("DELETE",
		std::bind(&CampaignsCampaignIdOutletsOutletIdResource::handler_DELETE_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOutletsOutletIdResource::handler_GET_internal, this,
			std::placeholders::_1));
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOutletsOutletIdResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOutletsOutletIdResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOutletsOutletIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOutletsOutletIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOutletsOutletIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOutletsOutletIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOutletsOutletIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOutletsOutletIdResource::handler_DELETE_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t outletId = request->get_path_parameter("outletId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_DELETE(campaignId, outletId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdOutletsOutletIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t outletId = request->get_path_parameter("outletId", 0L);
    
    int status_code = 500;
    GetOutletResponse resultObject = GetOutletResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, outletId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}
// x-extension
void CampaignsCampaignIdOutletsOutletIdResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto changeOutletRequest = extractJsonModelBodyParam<ChangeOutletRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t outletId = request->get_path_parameter("outletId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, outletId, changeOutletRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, EmptyApiResponse> CampaignsCampaignIdOutletsOutletIdResource::handler_DELETE(
        int64_t & campaignId, int64_t & outletId)
{
    return handler_DELETE_func(campaignId, outletId);
}

std::pair<int, GetOutletResponse> CampaignsCampaignIdOutletsOutletIdResource::handler_GET(
    int64_t & campaignId, int64_t & outletId)
{
    return handler_GET_func(campaignId, outletId);
}
std::pair<int, EmptyApiResponse> CampaignsCampaignIdOutletsOutletIdResource::handler_PUT(
    int64_t & campaignId, int64_t & outletId, ChangeOutletRequest & changeOutletRequest)
{
    return handler_PUT_func(campaignId, outletId, changeOutletRequest);
}

std::string CampaignsCampaignIdOutletsOutletIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOutletsOutletIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOutletsLicensesResource::CampaignsCampaignIdOutletsLicensesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/outlets/licenses");
	this->set_method_handler("DELETE",
		std::bind(&CampaignsCampaignIdOutletsLicensesResource::handler_DELETE_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOutletsLicensesResource::handler_GET_internal, this,
			std::placeholders::_1));
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOutletsLicensesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOutletsLicensesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOutletsLicensesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOutletsLicensesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOutletsLicensesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOutletsLicensesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOutletsLicensesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOutletsLicensesResource::handler_DELETE_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string ids_raw = request->get_query_parameter("ids");
    std::set<int64_t> ids;
    std::vector<std::string> ids_temp;
    boost::split(ids_temp, ids_raw, boost::is_any_of(","));
    std::transform(ids_temp.begin(), ids_temp.end(), std::back_inserter(ids), [](const auto& i){ int64_t ret; ret.fromString(i); return ret;});
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_DELETE(campaignId, ids);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdOutletsLicensesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string outletIds_raw = request->get_query_parameter("outletIds");
    std::set<int64_t> outletIds;
    std::vector<std::string> outletIds_temp;
    boost::split(outletIds_temp, outletIds_raw, boost::is_any_of(","));
    std::transform(outletIds_temp.begin(), outletIds_temp.end(), std::back_inserter(outletIds), [](const auto& i){ int64_t ret; ret.fromString(i); return ret;});
    std::string ids_raw = request->get_query_parameter("ids");
    std::set<int64_t> ids;
    std::vector<std::string> ids_temp;
    boost::split(ids_temp, ids_raw, boost::is_any_of(","));
    std::transform(ids_temp.begin(), ids_temp.end(), std::back_inserter(ids), [](const auto& i){ int64_t ret; ret.fromString(i); return ret;});
    
    int status_code = 500;
    GetOutletLicensesResponse resultObject = GetOutletLicensesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, outletIds, ids);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}
// x-extension
void CampaignsCampaignIdOutletsLicensesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOutletLicenseRequest = extractJsonModelBodyParam<UpdateOutletLicenseRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, updateOutletLicenseRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, EmptyApiResponse> CampaignsCampaignIdOutletsLicensesResource::handler_DELETE(
        int64_t & campaignId, std::set<int64_t> & ids)
{
    return handler_DELETE_func(campaignId, ids);
}

std::pair<int, GetOutletLicensesResponse> CampaignsCampaignIdOutletsLicensesResource::handler_GET(
    int64_t & campaignId, std::set<int64_t> & outletIds, std::set<int64_t> & ids)
{
    return handler_GET_func(campaignId, outletIds, ids);
}
std::pair<int, EmptyApiResponse> CampaignsCampaignIdOutletsLicensesResource::handler_POST(
    int64_t & campaignId, UpdateOutletLicenseRequest & updateOutletLicenseRequest)
{
    return handler_POST_func(campaignId, updateOutletLicenseRequest);
}

std::string CampaignsCampaignIdOutletsLicensesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOutletsLicensesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPromosOffersDeleteResource::BusinessesBusinessIdPromosOffersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/delete");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPromosOffersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersDeleteResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPromosOffersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPromosOffersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPromosOffersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPromosOffersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deletePromoOffersRequest = extractJsonModelBodyParam<DeletePromoOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    DeletePromoOffersResponse resultObject = DeletePromoOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, deletePromoOffersRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, DeletePromoOffersResponse> BusinessesBusinessIdPromosOffersDeleteResource::handler_POST(
        int64_t & businessId, DeletePromoOffersRequest & deletePromoOffersRequest)
{
    return handler_POST_func(businessId, deletePromoOffersRequest);
}


std::string BusinessesBusinessIdPromosOffersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPromosOffersDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsBoost_consolidatedGenerateResource::ReportsBoost_consolidatedGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/boost-consolidated/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsBoost_consolidatedGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsBoost_consolidatedGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsBoost_consolidatedGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsBoost_consolidatedGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsBoost_consolidatedGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsBoost_consolidatedGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsBoost_consolidatedGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsBoost_consolidatedGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateBoostConsolidatedRequest = extractJsonModelBodyParam<GenerateBoostConsolidatedRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateBoostConsolidatedRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsBoost_consolidatedGenerateResource::handler_POST(
        GenerateBoostConsolidatedRequest & generateBoostConsolidatedRequest, ReportFormatType & format)
{
    return handler_POST_func(generateBoostConsolidatedRequest, format);
}


std::string ReportsBoost_consolidatedGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsBoost_consolidatedGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsCompetitors_positionGenerateResource::ReportsCompetitors_positionGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/competitors-position/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsCompetitors_positionGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsCompetitors_positionGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsCompetitors_positionGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsCompetitors_positionGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsCompetitors_positionGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsCompetitors_positionGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsCompetitors_positionGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsCompetitors_positionGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateCompetitorsPositionReportRequest = extractJsonModelBodyParam<GenerateCompetitorsPositionReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateCompetitorsPositionReportRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsCompetitors_positionGenerateResource::handler_POST(
        GenerateCompetitorsPositionReportRequest & generateCompetitorsPositionReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateCompetitorsPositionReportRequest, format);
}


std::string ReportsCompetitors_positionGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsCompetitors_positionGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsGoods_feedbackGenerateResource::ReportsGoods_feedbackGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-feedback/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsGoods_feedbackGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsGoods_feedbackGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsGoods_feedbackGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsGoods_feedbackGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsGoods_feedbackGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsGoods_feedbackGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsGoods_feedbackGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsGoods_feedbackGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateGoodsFeedbackRequest = extractJsonModelBodyParam<GenerateGoodsFeedbackRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateGoodsFeedbackRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsGoods_feedbackGenerateResource::handler_POST(
        GenerateGoodsFeedbackRequest & generateGoodsFeedbackRequest, ReportFormatType & format)
{
    return handler_POST_func(generateGoodsFeedbackRequest, format);
}


std::string ReportsGoods_feedbackGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsGoods_feedbackGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsDocumentsLabelsGenerateResource::ReportsDocumentsLabelsGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/documents/labels/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsDocumentsLabelsGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsDocumentsLabelsGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsDocumentsLabelsGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsDocumentsLabelsGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsDocumentsLabelsGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsDocumentsLabelsGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsDocumentsLabelsGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsDocumentsLabelsGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateMassOrderLabelsRequest = extractJsonModelBodyParam<GenerateMassOrderLabelsRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateMassOrderLabelsRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsDocumentsLabelsGenerateResource::handler_POST(
        GenerateMassOrderLabelsRequest & generateMassOrderLabelsRequest, PageFormatType & format)
{
    return handler_POST_func(generateMassOrderLabelsRequest, format);
}


std::string ReportsDocumentsLabelsGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsDocumentsLabelsGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/shipments/{shipmentId: .*}/boxes/{boxId: .*}/label");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    int64_t shipmentId = request->get_path_parameter("shipmentId", 0L);
    int64_t boxId = request->get_path_parameter("boxId", 0L);
    // Getting the query params
    
    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId, shipmentId, boxId, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/pdf","application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handler_GET(
        int64_t & campaignId, int64_t & orderId, int64_t & shipmentId, int64_t & boxId, PageFormatType & format)
{
    return handler_GET_func(campaignId, orderId, shipmentId, boxId, format);
}


std::string CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/labels");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    // Getting the query params
    
    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/pdf","application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handler_GET(
        int64_t & campaignId, int64_t & orderId, PageFormatType & format)
{
    return handler_GET_func(campaignId, orderId, format);
}


std::string CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsPricesGenerateResource::ReportsPricesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/prices/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsPricesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsPricesGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsPricesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsPricesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsPricesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsPricesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsPricesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsPricesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generatePricesReportRequest = extractJsonModelBodyParam<GeneratePricesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generatePricesReportRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsPricesGenerateResource::handler_POST(
        GeneratePricesReportRequest & generatePricesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generatePricesReportRequest, format);
}


std::string ReportsPricesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsPricesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsShelf_statisticsGenerateResource::ReportsShelf_statisticsGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shelf-statistics/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsShelf_statisticsGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsShelf_statisticsGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsShelf_statisticsGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsShelf_statisticsGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsShelf_statisticsGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsShelf_statisticsGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsShelf_statisticsGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsShelf_statisticsGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateShelfsStatisticsRequest = extractJsonModelBodyParam<GenerateShelfsStatisticsRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateShelfsStatisticsRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsShelf_statisticsGenerateResource::handler_POST(
        GenerateShelfsStatisticsRequest & generateShelfsStatisticsRequest, ReportFormatType & format)
{
    return handler_POST_func(generateShelfsStatisticsRequest, format);
}


std::string ReportsShelf_statisticsGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsShelf_statisticsGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsShows_salesGenerateResource::ReportsShows_salesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shows-sales/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsShows_salesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsShows_salesGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsShows_salesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsShows_salesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsShows_salesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsShows_salesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsShows_salesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsShows_salesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateShowsSalesReportRequest = extractJsonModelBodyParam<GenerateShowsSalesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateShowsSalesReportRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsShows_salesGenerateResource::handler_POST(
        GenerateShowsSalesReportRequest & generateShowsSalesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateShowsSalesReportRequest, format);
}


std::string ReportsShows_salesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsShows_salesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsStocks_on_warehousesGenerateResource::ReportsStocks_on_warehousesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/stocks-on-warehouses/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsStocks_on_warehousesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsStocks_on_warehousesGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsStocks_on_warehousesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsStocks_on_warehousesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsStocks_on_warehousesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsStocks_on_warehousesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsStocks_on_warehousesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsStocks_on_warehousesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateStocksOnWarehousesReportRequest = extractJsonModelBodyParam<GenerateStocksOnWarehousesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateStocksOnWarehousesReportRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsStocks_on_warehousesGenerateResource::handler_POST(
        GenerateStocksOnWarehousesReportRequest & generateStocksOnWarehousesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateStocksOnWarehousesReportRequest, format);
}


std::string ReportsStocks_on_warehousesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsStocks_on_warehousesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsUnited_marketplace_servicesGenerateResource::ReportsUnited_marketplace_servicesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-marketplace-services/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsUnited_marketplace_servicesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsUnited_marketplace_servicesGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsUnited_marketplace_servicesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsUnited_marketplace_servicesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsUnited_marketplace_servicesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsUnited_marketplace_servicesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsUnited_marketplace_servicesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsUnited_marketplace_servicesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateUnitedMarketplaceServicesReportRequest = extractJsonModelBodyParam<GenerateUnitedMarketplaceServicesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateUnitedMarketplaceServicesReportRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsUnited_marketplace_servicesGenerateResource::handler_POST(
        GenerateUnitedMarketplaceServicesReportRequest & generateUnitedMarketplaceServicesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateUnitedMarketplaceServicesReportRequest, format);
}


std::string ReportsUnited_marketplace_servicesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsUnited_marketplace_servicesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsUnited_nettingGenerateResource::ReportsUnited_nettingGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-netting/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsUnited_nettingGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsUnited_nettingGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsUnited_nettingGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsUnited_nettingGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsUnited_nettingGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsUnited_nettingGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsUnited_nettingGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsUnited_nettingGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateUnitedNettingReportRequest = extractJsonModelBodyParam<GenerateUnitedNettingReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateUnitedNettingReportRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsUnited_nettingGenerateResource::handler_POST(
        GenerateUnitedNettingReportRequest & generateUnitedNettingReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateUnitedNettingReportRequest, format);
}


std::string ReportsUnited_nettingGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsUnited_nettingGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsUnited_ordersGenerateResource::ReportsUnited_ordersGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-orders/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsUnited_ordersGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsUnited_ordersGenerateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsUnited_ordersGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsUnited_ordersGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsUnited_ordersGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsUnited_ordersGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsUnited_ordersGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsUnited_ordersGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateUnitedOrdersRequest = extractJsonModelBodyParam<GenerateUnitedOrdersRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateUnitedOrdersRequest, format);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsUnited_ordersGenerateResource::handler_POST(
        GenerateUnitedOrdersRequest & generateUnitedOrdersRequest, ReportFormatType & format)
{
    return handler_POST_func(generateUnitedOrdersRequest, format);
}


std::string ReportsUnited_ordersGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsUnited_ordersGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersAllResource::CampaignsCampaignIdOffersAllResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/all");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOffersAllResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersAllResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersAllResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersAllResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersAllResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersAllResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersAllResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersAllResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    int64_t feedId = request->get_query_parameter("feedId", 0L);
    int32_t chunk = request->get_query_parameter("chunk", 0);
    
    int status_code = 500;
    GetAllOffersResponse resultObject = GetAllOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, feedId, chunk);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetAllOffersResponse> CampaignsCampaignIdOffersAllResource::handler_GET(
        int64_t & campaignId, int64_t & feedId, int32_t & chunk)
{
    return handler_GET_func(campaignId, feedId, chunk);
}


std::string CampaignsCampaignIdOffersAllResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersAllResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdBidsInfoResource::BusinessesBusinessIdBidsInfoResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/info");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdBidsInfoResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdBidsInfoResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsInfoResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsInfoResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdBidsInfoResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdBidsInfoResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdBidsInfoResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdBidsInfoResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getBidsInfoRequest = extractJsonModelBodyParam<GetBidsInfoRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetBidsInfoResponse resultObject = GetBidsInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, pageToken, limit, getBidsInfoRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBidsInfoResponse> BusinessesBusinessIdBidsInfoResource::handler_POST(
        int64_t & businessId, std::string & pageToken, int32_t & limit, GetBidsInfoRequest & getBidsInfoRequest)
{
    return handler_POST_func(businessId, pageToken, limit, getBidsInfoRequest);
}


std::string BusinessesBusinessIdBidsInfoResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdBidsInfoResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdBidsRecommendationsResource::BusinessesBusinessIdBidsRecommendationsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/recommendations");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdBidsRecommendationsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdBidsRecommendationsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsRecommendationsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsRecommendationsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdBidsRecommendationsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdBidsRecommendationsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdBidsRecommendationsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdBidsRecommendationsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getBidsRecommendationsRequest = extractJsonModelBodyParam<GetBidsRecommendationsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetBidsRecommendationsResponse resultObject = GetBidsRecommendationsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getBidsRecommendationsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBidsRecommendationsResponse> BusinessesBusinessIdBidsRecommendationsResource::handler_POST(
        int64_t & businessId, GetBidsRecommendationsRequest & getBidsRecommendationsRequest)
{
    return handler_POST_func(businessId, getBidsRecommendationsRequest);
}


std::string BusinessesBusinessIdBidsRecommendationsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdBidsRecommendationsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPrice_quarantineResource::BusinessesBusinessIdPrice_quarantineResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/price-quarantine");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPrice_quarantineResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPrice_quarantineResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPrice_quarantineResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPrice_quarantineResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPrice_quarantineResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getQuarantineOffersRequest = extractJsonModelBodyParam<GetQuarantineOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetQuarantineOffersResponse resultObject = GetQuarantineOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getQuarantineOffersRequest, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetQuarantineOffersResponse> BusinessesBusinessIdPrice_quarantineResource::handler_POST(
        int64_t & businessId, GetQuarantineOffersRequest & getQuarantineOffersRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getQuarantineOffersRequest, pageToken, limit);
}


std::string BusinessesBusinessIdPrice_quarantineResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPrice_quarantineResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdSettingsResource::BusinessesBusinessIdSettingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/settings");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdSettingsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdSettingsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdSettingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdSettingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdSettingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdSettingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdSettingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdSettingsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetBusinessSettingsResponse resultObject = GetBusinessSettingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBusinessSettingsResponse> BusinessesBusinessIdSettingsResource::handler_POST(
        int64_t & businessId)
{
    return handler_POST_func(businessId);
}


std::string BusinessesBusinessIdSettingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdSettingsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdResource::CampaignsCampaignIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetCampaignResponse resultObject = GetCampaignResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignResponse> CampaignsCampaignIdResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdLoginsResource::CampaignsCampaignIdLoginsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/logins");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdLoginsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdLoginsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdLoginsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdLoginsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdLoginsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdLoginsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdLoginsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdLoginsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetCampaignLoginsResponse resultObject = GetCampaignLoginsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignLoginsResponse> CampaignsCampaignIdLoginsResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdLoginsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdLoginsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersResource::CampaignsCampaignIdOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffersResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOffersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getCampaignOffersRequest = extractJsonModelBodyParam<GetCampaignOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetCampaignOffersResponse resultObject = GetCampaignOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, getCampaignOffersRequest, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdOffersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string query = request->get_query_parameter("query", "");
    int64_t feedId = request->get_query_parameter("feedId", 0L);
    std::string shopCategoryId = request->get_query_parameter("shopCategoryId", "");
    bool matched = request->get_query_parameter("matched", false);
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetOffersResponse resultObject = GetOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, GetCampaignOffersResponse> CampaignsCampaignIdOffersResource::handler_POST(
        int64_t & campaignId, GetCampaignOffersRequest & getCampaignOffersRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(campaignId, getCampaignOffersRequest, pageToken, limit);
}

std::pair<int, GetOffersResponse> CampaignsCampaignIdOffersResource::handler_GET(
    int64_t & campaignId, std::string & query, int64_t & feedId, std::string & shopCategoryId, CurrencyType & currency, bool & matched, int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize);
}

std::string CampaignsCampaignIdOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdPrice_quarantineResource::CampaignsCampaignIdPrice_quarantineResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/price-quarantine");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdPrice_quarantineResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdPrice_quarantineResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdPrice_quarantineResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdPrice_quarantineResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdPrice_quarantineResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getQuarantineOffersRequest = extractJsonModelBodyParam<GetQuarantineOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetQuarantineOffersResponse resultObject = GetQuarantineOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, getQuarantineOffersRequest, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetQuarantineOffersResponse> CampaignsCampaignIdPrice_quarantineResource::handler_POST(
        int64_t & campaignId, GetQuarantineOffersRequest & getQuarantineOffersRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(campaignId, getQuarantineOffersRequest, pageToken, limit);
}


std::string CampaignsCampaignIdPrice_quarantineResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdPrice_quarantineResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdRegionResource::CampaignsCampaignIdRegionResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/region");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdRegionResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdRegionResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdRegionResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdRegionResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdRegionResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdRegionResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdRegionResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdRegionResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetCampaignRegionResponse resultObject = GetCampaignRegionResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignRegionResponse> CampaignsCampaignIdRegionResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdRegionResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdRegionResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdSettingsResource::CampaignsCampaignIdSettingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/settings");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdSettingsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdSettingsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdSettingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdSettingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdSettingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdSettingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdSettingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdSettingsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetCampaignSettingsResponse resultObject = GetCampaignSettingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignSettingsResponse> CampaignsCampaignIdSettingsResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdSettingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdSettingsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsResource::CampaignsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns");
	this->set_method_handler("GET",
		std::bind(&CampaignsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the query params
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetCampaignsResponse resultObject = GetCampaignsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(page, pageSize);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignsResponse> CampaignsResource::handler_GET(
        int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(page, pageSize);
}


std::string CampaignsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsBy_loginLoginResource::CampaignsBy_loginLoginResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/by_login/{login: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsBy_loginLoginResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsBy_loginLoginResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsBy_loginLoginResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsBy_loginLoginResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsBy_loginLoginResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsBy_loginLoginResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsBy_loginLoginResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsBy_loginLoginResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    std::string login = request->get_path_parameter("login", "");
    // Getting the query params
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetCampaignsResponse resultObject = GetCampaignsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(login, page, pageSize);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignsResponse> CampaignsBy_loginLoginResource::handler_GET(
        std::string & login, int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(login, page, pageSize);
}


std::string CampaignsBy_loginLoginResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsBy_loginLoginResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CategoriesMax_sale_quantumResource::CategoriesMax_sale_quantumResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/categories/max-sale-quantum");
	this->set_method_handler("POST",
		std::bind(&CategoriesMax_sale_quantumResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CategoriesMax_sale_quantumResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CategoriesMax_sale_quantumResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CategoriesMax_sale_quantumResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CategoriesMax_sale_quantumResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CategoriesMax_sale_quantumResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CategoriesMax_sale_quantumResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CategoriesMax_sale_quantumResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getCategoriesMaxSaleQuantumRequest = extractJsonModelBodyParam<GetCategoriesMaxSaleQuantumRequest>(bodyContent);
    
    int status_code = 500;
    GetCategoriesMaxSaleQuantumResponse resultObject = GetCategoriesMaxSaleQuantumResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(getCategoriesMaxSaleQuantumRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCategoriesMaxSaleQuantumResponse> CategoriesMax_sale_quantumResource::handler_POST(
        GetCategoriesMaxSaleQuantumRequest & getCategoriesMaxSaleQuantumRequest)
{
    return handler_POST_func(getCategoriesMaxSaleQuantumRequest);
}


std::string CategoriesMax_sale_quantumResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CategoriesMax_sale_quantumResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CategoriesTreeResource::CategoriesTreeResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/categories/tree");
	this->set_method_handler("POST",
		std::bind(&CategoriesTreeResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CategoriesTreeResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CategoriesTreeResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CategoriesTreeResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CategoriesTreeResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CategoriesTreeResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CategoriesTreeResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CategoriesTreeResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getCategoriesRequest = extractJsonModelBodyParam<GetCategoriesRequest>(bodyContent);
    
    int status_code = 500;
    GetCategoriesResponse resultObject = GetCategoriesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(getCategoriesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCategoriesResponse> CategoriesTreeResource::handler_POST(
        GetCategoriesRequest & getCategoriesRequest)
{
    return handler_POST_func(getCategoriesRequest);
}


std::string CategoriesTreeResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CategoriesTreeResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CategoryCategoryIdParametersResource::CategoryCategoryIdParametersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/category/{categoryId: .*}/parameters");
	this->set_method_handler("POST",
		std::bind(&CategoryCategoryIdParametersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CategoryCategoryIdParametersResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CategoryCategoryIdParametersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CategoryCategoryIdParametersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CategoryCategoryIdParametersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CategoryCategoryIdParametersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CategoryCategoryIdParametersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CategoryCategoryIdParametersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t categoryId = request->get_path_parameter("categoryId", 0L);
    
    int status_code = 500;
    GetCategoryContentParametersResponse resultObject = GetCategoryContentParametersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(categoryId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCategoryContentParametersResponse> CategoryCategoryIdParametersResource::handler_POST(
        int64_t & categoryId)
{
    return handler_POST_func(categoryId);
}


std::string CategoryCategoryIdParametersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CategoryCategoryIdParametersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsHistoryResource::BusinessesBusinessIdChatsHistoryResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/history");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsHistoryResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsHistoryResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsHistoryResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsHistoryResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsHistoryResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsHistoryResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsHistoryResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsHistoryResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getChatHistoryRequest = extractJsonModelBodyParam<GetChatHistoryRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    int64_t chatId = request->get_query_parameter("chatId", 0L);
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetChatHistoryResponse resultObject = GetChatHistoryResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, chatId, getChatHistoryRequest, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetChatHistoryResponse> BusinessesBusinessIdChatsHistoryResource::handler_POST(
        int64_t & businessId, int64_t & chatId, GetChatHistoryRequest & getChatHistoryRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, chatId, getChatHistoryRequest, pageToken, limit);
}


std::string BusinessesBusinessIdChatsHistoryResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsHistoryResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsResource::BusinessesBusinessIdChatsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getChatsRequest = extractJsonModelBodyParam<GetChatsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetChatsResponse resultObject = GetChatsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getChatsRequest, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetChatsResponse> BusinessesBusinessIdChatsResource::handler_POST(
        int64_t & businessId, GetChatsRequest & getChatsRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getChatsRequest, pageToken, limit);
}


std::string BusinessesBusinessIdChatsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
DeliveryServicesResource::DeliveryServicesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/delivery/services");
	this->set_method_handler("GET",
		std::bind(&DeliveryServicesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> DeliveryServicesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> DeliveryServicesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> DeliveryServicesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void DeliveryServicesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void DeliveryServicesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void DeliveryServicesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void DeliveryServicesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    
    int status_code = 500;
    GetDeliveryServicesResponse resultObject = GetDeliveryServicesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET();
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetDeliveryServicesResponse> DeliveryServicesResource::handler_GET(
        )
{
    return handler_GET_func();
}


std::string DeliveryServicesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string DeliveryServicesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsFeedIdResource::CampaignsCampaignIdFeedsFeedIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdFeedsFeedIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsFeedIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsFeedIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsFeedIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsFeedIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t feedId = request->get_path_parameter("feedId", 0L);
    
    int status_code = 500;
    GetFeedResponse resultObject = GetFeedResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, feedId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetFeedResponse> CampaignsCampaignIdFeedsFeedIdResource::handler_GET(
        int64_t & campaignId, int64_t & feedId)
{
    return handler_GET_func(campaignId, feedId);
}


std::string CampaignsCampaignIdFeedsFeedIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsFeedIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsFeedIdIndex_logsResource::CampaignsCampaignIdFeedsFeedIdIndex_logsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/index-logs");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsFeedIdIndex_logsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsFeedIdIndex_logsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsFeedIdIndex_logsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t feedId = request->get_path_parameter("feedId", 0L);
    // Getting the query params
    int32_t limit = request->get_query_parameter("limit", 0);
    std::string publishedTimeFrom = request->get_query_parameter("publishedTimeFrom", "");
    std::string publishedTimeTo = request->get_query_parameter("publishedTimeTo", "");
    
    int status_code = 500;
    GetFeedIndexLogsResponse resultObject = GetFeedIndexLogsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetFeedIndexLogsResponse> CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handler_GET(
        int64_t & campaignId, int64_t & feedId, int32_t & limit, std::string & publishedTimeFrom, std::string & publishedTimeTo, FeedIndexLogsStatusType & status)
{
    return handler_GET_func(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status);
}


std::string CampaignsCampaignIdFeedsFeedIdIndex_logsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsFeedIdIndex_logsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedbackUpdatesResource::CampaignsCampaignIdFeedbackUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feedback/updates");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdFeedbackUpdatesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedbackUpdatesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedbackUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedbackUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedbackUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedbackUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedbackUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedbackUpdatesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    std::string fromDate = request->get_query_parameter("fromDate", "");
    
    int status_code = 500;
    GetFeedbackListResponse resultObject = GetFeedbackListResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, pageToken, limit, fromDate);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetFeedbackListResponse> CampaignsCampaignIdFeedbackUpdatesResource::handler_GET(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, std::string & fromDate)
{
    return handler_GET_func(campaignId, pageToken, limit, fromDate);
}


std::string CampaignsCampaignIdFeedbackUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedbackUpdatesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsResource::CampaignsCampaignIdFeedsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdFeedsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetFeedsResponse resultObject = GetFeedsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetFeedsResponse> CampaignsCampaignIdFeedsResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdFeedsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackCommentsResource::BusinessesBusinessIdGoods_feedbackCommentsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackCommentsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackCommentsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackCommentsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackCommentsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackCommentsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getGoodsFeedbackCommentsRequest = extractJsonModelBodyParam<GetGoodsFeedbackCommentsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetGoodsFeedbackCommentsResponse resultObject = GetGoodsFeedbackCommentsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetGoodsFeedbackCommentsResponse> BusinessesBusinessIdGoods_feedbackCommentsResource::handler_POST(
        int64_t & businessId, GetGoodsFeedbackCommentsRequest & getGoodsFeedbackCommentsRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit);
}


std::string BusinessesBusinessIdGoods_feedbackCommentsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackCommentsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackResource::BusinessesBusinessIdGoods_feedbackResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getGoodsFeedbackRequest = extractJsonModelBodyParam<GetGoodsFeedbackRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetGoodsFeedbackResponse resultObject = GetGoodsFeedbackResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, pageToken, limit, getGoodsFeedbackRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetGoodsFeedbackResponse> BusinessesBusinessIdGoods_feedbackResource::handler_POST(
        int64_t & businessId, std::string & pageToken, int32_t & limit, GetGoodsFeedbackRequest & getGoodsFeedbackRequest)
{
    return handler_POST_func(businessId, pageToken, limit, getGoodsFeedbackRequest);
}


std::string BusinessesBusinessIdGoods_feedbackResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdStatsSkusResource::CampaignsCampaignIdStatsSkusResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/stats/skus");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdStatsSkusResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdStatsSkusResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdStatsSkusResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdStatsSkusResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdStatsSkusResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdStatsSkusResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdStatsSkusResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdStatsSkusResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getGoodsStatsRequest = extractJsonModelBodyParam<GetGoodsStatsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetGoodsStatsResponse resultObject = GetGoodsStatsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, getGoodsStatsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetGoodsStatsResponse> CampaignsCampaignIdStatsSkusResource::handler_POST(
        int64_t & campaignId, GetGoodsStatsRequest & getGoodsStatsRequest)
{
    return handler_POST_func(campaignId, getGoodsStatsRequest);
}


std::string CampaignsCampaignIdStatsSkusResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdStatsSkusResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ModelsModelIdResource::ModelsModelIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/models/{modelId: .*}");
	this->set_method_handler("GET",
		std::bind(&ModelsModelIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ModelsModelIdResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ModelsModelIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ModelsModelIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ModelsModelIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ModelsModelIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ModelsModelIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ModelsModelIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t modelId = request->get_path_parameter("modelId", 0L);
    // Getting the query params
    int64_t regionId = request->get_query_parameter("regionId", 0L);
    
    int status_code = 500;
    GetModelsResponse resultObject = GetModelsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(modelId, regionId, currency);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetModelsResponse> ModelsModelIdResource::handler_GET(
        int64_t & modelId, int64_t & regionId, CurrencyType & currency)
{
    return handler_GET_func(modelId, regionId, currency);
}


std::string ModelsModelIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ModelsModelIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ModelsModelIdOffersResource::ModelsModelIdOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/models/{modelId: .*}/offers");
	this->set_method_handler("GET",
		std::bind(&ModelsModelIdOffersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ModelsModelIdOffersResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ModelsModelIdOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ModelsModelIdOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ModelsModelIdOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ModelsModelIdOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ModelsModelIdOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ModelsModelIdOffersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t modelId = request->get_path_parameter("modelId", 0L);
    // Getting the query params
    int64_t regionId = request->get_query_parameter("regionId", 0L);
    int32_t count = request->get_query_parameter("count", 10);
    int32_t page = request->get_query_parameter("page", 1);
    
    int status_code = 500;
    GetModelsOffersResponse resultObject = GetModelsOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(modelId, regionId, currency, orderByPrice, count, page);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetModelsOffersResponse> ModelsModelIdOffersResource::handler_GET(
        int64_t & modelId, int64_t & regionId, CurrencyType & currency, SortOrderType & orderByPrice, int32_t & count, int32_t & page)
{
    return handler_GET_func(modelId, regionId, currency, orderByPrice, count, page);
}


std::string ModelsModelIdOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ModelsModelIdOffersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ModelsResource::ModelsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/models");
	this->set_method_handler("POST",
		std::bind(&ModelsResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&ModelsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ModelsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ModelsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ModelsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ModelsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ModelsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ModelsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ModelsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getModelsRequest = extractJsonModelBodyParam<GetModelsRequest>(bodyContent);
    // Getting the query params
    int64_t regionId = request->get_query_parameter("regionId", 0L);
    
    int status_code = 500;
    GetModelsResponse resultObject = GetModelsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(regionId, getModelsRequest, currency);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void ModelsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // Getting the query params
    std::string query = request->get_query_parameter("query", "");
    int64_t regionId = request->get_query_parameter("regionId", 0L);
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    SearchModelsResponse resultObject = SearchModelsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(query, regionId, currency, page, pageSize);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, GetModelsResponse> ModelsResource::handler_POST(
        int64_t & regionId, GetModelsRequest & getModelsRequest, CurrencyType & currency)
{
    return handler_POST_func(regionId, getModelsRequest, currency);
}

std::pair<int, SearchModelsResponse> ModelsResource::handler_GET(
    std::string & query, int64_t & regionId, CurrencyType & currency, int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(query, regionId, currency, page, pageSize);
}

std::string ModelsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ModelsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ModelsOffersResource::ModelsOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/models/offers");
	this->set_method_handler("POST",
		std::bind(&ModelsOffersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ModelsOffersResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ModelsOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ModelsOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ModelsOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ModelsOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ModelsOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ModelsOffersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getModelsRequest = extractJsonModelBodyParam<GetModelsRequest>(bodyContent);
    // Getting the query params
    int64_t regionId = request->get_query_parameter("regionId", 0L);
    
    int status_code = 500;
    GetModelsOffersResponse resultObject = GetModelsOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(regionId, getModelsRequest, currency, orderByPrice);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetModelsOffersResponse> ModelsOffersResource::handler_POST(
        int64_t & regionId, GetModelsRequest & getModelsRequest, CurrencyType & currency, SortOrderType & orderByPrice)
{
    return handler_POST_func(regionId, getModelsRequest, currency, orderByPrice);
}


std::string ModelsOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ModelsOffersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_cardsResource::BusinessesBusinessIdOffer_cardsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-cards");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_cardsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_cardsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_cardsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_cardsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_cardsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getOfferCardsContentStatusRequest = extractJsonModelBodyParam<GetOfferCardsContentStatusRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOfferCardsContentStatusResponse resultObject = GetOfferCardsContentStatusResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, pageToken, limit, getOfferCardsContentStatusRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOfferCardsContentStatusResponse> BusinessesBusinessIdOffer_cardsResource::handler_POST(
        int64_t & businessId, std::string & pageToken, int32_t & limit, GetOfferCardsContentStatusRequest & getOfferCardsContentStatusRequest)
{
    return handler_POST_func(businessId, pageToken, limit, getOfferCardsContentStatusRequest);
}


std::string BusinessesBusinessIdOffer_cardsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_cardsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_mapping_entriesResource::CampaignsCampaignIdOffer_mapping_entriesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOffer_mapping_entriesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_mapping_entriesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_mapping_entriesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_mapping_entriesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_mapping_entriesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string offerId_raw = request->get_query_parameter("offerId");
    std::vector<std::string> offerId;
    std::vector<std::string> offerId_temp;
    boost::split(offerId_temp, offerId_raw, boost::is_any_of(","));
    std::copy(offerId_temp.begin(), offerId_temp.end(), std::inserter(offerId, std::next(offerId.begin())));
    std::string shopSku_raw = request->get_query_parameter("shopSku");
    std::vector<std::string> shopSku;
    std::vector<std::string> shopSku_temp;
    boost::split(shopSku_temp, shopSku_raw, boost::is_any_of(","));
    std::copy(shopSku_temp.begin(), shopSku_temp.end(), std::inserter(shopSku, std::next(shopSku.begin())));
    std::string status_raw = request->get_query_parameter("status");
    std::vector<OfferProcessingStatusType> status;
    std::vector<std::string> status_temp;
    boost::split(status_temp, status_raw, boost::is_any_of(","));
    std::transform(status_temp.begin(), status_temp.end(), std::back_inserter(status), [](const auto& i){ OfferProcessingStatusType ret; ret.fromString(i); return ret;});
    std::string availability_raw = request->get_query_parameter("availability");
    std::vector<OfferAvailabilityStatusType> availability;
    std::vector<std::string> availability_temp;
    boost::split(availability_temp, availability_raw, boost::is_any_of(","));
    std::transform(availability_temp.begin(), availability_temp.end(), std::back_inserter(availability), [](const auto& i){ OfferAvailabilityStatusType ret; ret.fromString(i); return ret;});
    std::string categoryId_raw = request->get_query_parameter("categoryId");
    std::vector<int32_t> categoryId;
    std::vector<std::string> categoryId_temp;
    boost::split(categoryId_temp, categoryId_raw, boost::is_any_of(","));
    std::transform(categoryId_temp.begin(), categoryId_temp.end(), std::back_inserter(categoryId), [](const auto& i){ int32_t ret; ret.fromString(i); return ret;});
    std::string vendor_raw = request->get_query_parameter("vendor");
    std::vector<std::string> vendor;
    std::vector<std::string> vendor_temp;
    boost::split(vendor_temp, vendor_raw, boost::is_any_of(","));
    std::copy(vendor_temp.begin(), vendor_temp.end(), std::inserter(vendor, std::next(vendor.begin())));
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOfferMappingEntriesResponse resultObject = GetOfferMappingEntriesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOfferMappingEntriesResponse> CampaignsCampaignIdOffer_mapping_entriesResource::handler_GET(
        int64_t & campaignId, std::vector<std::string> & offerId, std::vector<std::string> & shopSku, OfferMappingKindType & mappingKind, std::vector<OfferProcessingStatusType> & status, std::vector<OfferAvailabilityStatusType> & availability, std::vector<int32_t> & categoryId, std::vector<std::string> & vendor, std::string & pageToken, int32_t & limit)
{
    return handler_GET_func(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit);
}


std::string CampaignsCampaignIdOffer_mapping_entriesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_mapping_entriesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsResource::BusinessesBusinessIdOffer_mappingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getOfferMappingsRequest = extractJsonModelBodyParam<GetOfferMappingsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOfferMappingsResponse resultObject = GetOfferMappingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, pageToken, limit, getOfferMappingsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOfferMappingsResponse> BusinessesBusinessIdOffer_mappingsResource::handler_POST(
        int64_t & businessId, std::string & pageToken, int32_t & limit, GetOfferMappingsRequest & getOfferMappingsRequest)
{
    return handler_POST_func(businessId, pageToken, limit, getOfferMappingsRequest);
}


std::string BusinessesBusinessIdOffer_mappingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffersRecommendationsResource::BusinessesBusinessIdOffersRecommendationsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offers/recommendations");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffersRecommendationsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffersRecommendationsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffersRecommendationsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffersRecommendationsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffersRecommendationsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffersRecommendationsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffersRecommendationsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffersRecommendationsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getOfferRecommendationsRequest = extractJsonModelBodyParam<GetOfferRecommendationsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOfferRecommendationsResponse resultObject = GetOfferRecommendationsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getOfferRecommendationsRequest, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOfferRecommendationsResponse> BusinessesBusinessIdOffersRecommendationsResource::handler_POST(
        int64_t & businessId, GetOfferRecommendationsRequest & getOfferRecommendationsRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getOfferRecommendationsRequest, pageToken, limit);
}


std::string BusinessesBusinessIdOffersRecommendationsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffersRecommendationsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdResource::CampaignsCampaignIdOrdersOrderIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    GetOrderResponse resultObject = GetOrderResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOrderResponse> CampaignsCampaignIdOrdersOrderIdResource::handler_GET(
        int64_t & campaignId, int64_t & orderId)
{
    return handler_GET_func(campaignId, orderId);
}


std::string CampaignsCampaignIdOrdersOrderIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/business-buyer");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    GetBusinessBuyerInfoResponse resultObject = GetBusinessBuyerInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, orderId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBusinessBuyerInfoResponse> CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handler_POST(
        int64_t & campaignId, int64_t & orderId)
{
    return handler_POST_func(campaignId, orderId);
}


std::string CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDocumentsResource::CampaignsCampaignIdOrdersOrderIdDocumentsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/documents");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDocumentsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDocumentsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDocumentsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDocumentsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDocumentsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDocumentsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    GetBusinessDocumentsInfoResponse resultObject = GetBusinessDocumentsInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, orderId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBusinessDocumentsInfoResponse> CampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST(
        int64_t & campaignId, int64_t & orderId)
{
    return handler_POST_func(campaignId, orderId);
}


std::string CampaignsCampaignIdOrdersOrderIdDocumentsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDocumentsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdBuyerResource::CampaignsCampaignIdOrdersOrderIdBuyerResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/buyer");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdBuyerResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBuyerResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBuyerResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBuyerResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdBuyerResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdBuyerResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdBuyerResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdBuyerResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    GetOrderBuyerInfoResponse resultObject = GetOrderBuyerInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOrderBuyerInfoResponse> CampaignsCampaignIdOrdersOrderIdBuyerResource::handler_GET(
        int64_t & campaignId, int64_t & orderId)
{
    return handler_GET_func(campaignId, orderId);
}


std::string CampaignsCampaignIdOrdersOrderIdBuyerResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdBuyerResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/labels/data");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    GetOrderLabelsDataResponse resultObject = GetOrderLabelsDataResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOrderLabelsDataResponse> CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handler_GET(
        int64_t & campaignId, int64_t & orderId)
{
    return handler_GET_func(campaignId, orderId);
}


std::string CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersResource::CampaignsCampaignIdOrdersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string orderIds_raw = request->get_query_parameter("orderIds");
    std::vector<int64_t> orderIds;
    std::vector<std::string> orderIds_temp;
    boost::split(orderIds_temp, orderIds_raw, boost::is_any_of(","));
    std::transform(orderIds_temp.begin(), orderIds_temp.end(), std::back_inserter(orderIds), [](const auto& i){ int64_t ret; ret.fromString(i); return ret;});
    std::string status_raw = request->get_query_parameter("status");
    std::set<OrderStatusType> status;
    std::vector<std::string> status_temp;
    boost::split(status_temp, status_raw, boost::is_any_of(","));
    std::transform(status_temp.begin(), status_temp.end(), std::back_inserter(status), [](const auto& i){ OrderStatusType ret; ret.fromString(i); return ret;});
    std::string substatus_raw = request->get_query_parameter("substatus");
    std::set<OrderSubstatusType> substatus;
    std::vector<std::string> substatus_temp;
    boost::split(substatus_temp, substatus_raw, boost::is_any_of(","));
    std::transform(substatus_temp.begin(), substatus_temp.end(), std::back_inserter(substatus), [](const auto& i){ OrderSubstatusType ret; ret.fromString(i); return ret;});
    std::string fromDate = request->get_query_parameter("fromDate", "");
    std::string toDate = request->get_query_parameter("toDate", "");
    std::string supplierShipmentDateFrom = request->get_query_parameter("supplierShipmentDateFrom", "");
    std::string supplierShipmentDateTo = request->get_query_parameter("supplierShipmentDateTo", "");
    std::string updatedAtFrom = request->get_query_parameter("updatedAtFrom", "");
    std::string updatedAtTo = request->get_query_parameter("updatedAtTo", "");
    bool fake = request->get_query_parameter("fake", false);
    bool hasCis = request->get_query_parameter("hasCis", false);
    bool onlyWaitingForCancellationApprove = request->get_query_parameter("onlyWaitingForCancellationApprove", false);
    bool onlyEstimatedDelivery = request->get_query_parameter("onlyEstimatedDelivery", false);
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOrdersResponse resultObject = GetOrdersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOrdersResponse> CampaignsCampaignIdOrdersResource::handler_GET(
        int64_t & campaignId, std::vector<int64_t> & orderIds, std::set<OrderStatusType> & status, std::set<OrderSubstatusType> & substatus, std::string & fromDate, std::string & toDate, std::string & supplierShipmentDateFrom, std::string & supplierShipmentDateTo, std::string & updatedAtFrom, std::string & updatedAtTo, OrderDeliveryDispatchType & dispatchType, bool & fake, bool & hasCis, bool & onlyWaitingForCancellationApprove, bool & onlyEstimatedDelivery, OrderBuyerType & buyerType, int32_t & page, int32_t & pageSize, std::string & pageToken, int32_t & limit)
{
    return handler_GET_func(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit);
}


std::string CampaignsCampaignIdOrdersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdStatsOrdersResource::CampaignsCampaignIdStatsOrdersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/stats/orders");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdStatsOrdersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdStatsOrdersResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdStatsOrdersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdStatsOrdersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdStatsOrdersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdStatsOrdersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdStatsOrdersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdStatsOrdersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getOrdersStatsRequest = extractJsonModelBodyParam<GetOrdersStatsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOrdersStatsResponse resultObject = GetOrdersStatsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, pageToken, limit, getOrdersStatsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOrdersStatsResponse> CampaignsCampaignIdStatsOrdersResource::handler_POST(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, GetOrdersStatsRequest & getOrdersStatsRequest)
{
    return handler_POST_func(campaignId, pageToken, limit, getOrdersStatsRequest);
}


std::string CampaignsCampaignIdStatsOrdersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdStatsOrdersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_pricesResource::CampaignsCampaignIdOffer_pricesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOffer_pricesResource::handler_GET_internal, this,
			std::placeholders::_1));
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_pricesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_pricesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_pricesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_pricesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_pricesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    bool archived = request->get_query_parameter("archived", false);
    
    int status_code = 500;
    GetPricesResponse resultObject = GetPricesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, pageToken, limit, archived);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdOffer_pricesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getPricesByOfferIdsRequest = extractJsonModelBodyParam<GetPricesByOfferIdsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetPricesByOfferIdsResponse resultObject = GetPricesByOfferIdsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, pageToken, limit, getPricesByOfferIdsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, GetPricesResponse> CampaignsCampaignIdOffer_pricesResource::handler_GET(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, bool & archived)
{
    return handler_GET_func(campaignId, pageToken, limit, archived);
}

std::pair<int, GetPricesByOfferIdsResponse> CampaignsCampaignIdOffer_pricesResource::handler_POST(
    int64_t & campaignId, std::string & pageToken, int32_t & limit, GetPricesByOfferIdsRequest & getPricesByOfferIdsRequest)
{
    return handler_POST_func(campaignId, pageToken, limit, getPricesByOfferIdsRequest);
}

std::string CampaignsCampaignIdOffer_pricesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_pricesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPromosOffersResource::BusinessesBusinessIdPromosOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPromosOffersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPromosOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPromosOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPromosOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPromosOffersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getPromoOffersRequest = extractJsonModelBodyParam<GetPromoOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetPromoOffersResponse resultObject = GetPromoOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getPromoOffersRequest, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetPromoOffersResponse> BusinessesBusinessIdPromosOffersResource::handler_POST(
        int64_t & businessId, GetPromoOffersRequest & getPromoOffersRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getPromoOffersRequest, pageToken, limit);
}


std::string BusinessesBusinessIdPromosOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPromosOffersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPromosResource::BusinessesBusinessIdPromosResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPromosResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPromosResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPromosResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPromosResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPromosResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPromosResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getPromosRequest = extractJsonModelBodyParam<GetPromosRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetPromosResponse resultObject = GetPromosResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getPromosRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetPromosResponse> BusinessesBusinessIdPromosResource::handler_POST(
        int64_t & businessId, GetPromosRequest & getPromosRequest)
{
    return handler_POST_func(businessId, getPromosRequest);
}


std::string BusinessesBusinessIdPromosResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPromosResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdRatingsQualityDetailsResource::CampaignsCampaignIdRatingsQualityDetailsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/ratings/quality/details");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdRatingsQualityDetailsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdRatingsQualityDetailsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdRatingsQualityDetailsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdRatingsQualityDetailsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdRatingsQualityDetailsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdRatingsQualityDetailsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdRatingsQualityDetailsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdRatingsQualityDetailsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetQualityRatingDetailsResponse resultObject = GetQualityRatingDetailsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetQualityRatingDetailsResponse> CampaignsCampaignIdRatingsQualityDetailsResource::handler_POST(
        int64_t & campaignId)
{
    return handler_POST_func(campaignId);
}


std::string CampaignsCampaignIdRatingsQualityDetailsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdRatingsQualityDetailsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdRatingsQualityResource::BusinessesBusinessIdRatingsQualityResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/ratings/quality");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdRatingsQualityResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdRatingsQualityResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdRatingsQualityResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdRatingsQualityResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdRatingsQualityResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdRatingsQualityResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdRatingsQualityResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdRatingsQualityResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getQualityRatingRequest = extractJsonModelBodyParam<GetQualityRatingRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetQualityRatingResponse resultObject = GetQualityRatingResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getQualityRatingRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetQualityRatingResponse> BusinessesBusinessIdRatingsQualityResource::handler_POST(
        int64_t & businessId, GetQualityRatingRequest & getQualityRatingRequest)
{
    return handler_POST_func(businessId, getQualityRatingRequest);
}


std::string BusinessesBusinessIdRatingsQualityResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdRatingsQualityResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsInfoReportIdResource::ReportsInfoReportIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/info/{reportId: .*}");
	this->set_method_handler("GET",
		std::bind(&ReportsInfoReportIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsInfoReportIdResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsInfoReportIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsInfoReportIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsInfoReportIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsInfoReportIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsInfoReportIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsInfoReportIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    std::string reportId = request->get_path_parameter("reportId", "");
    
    int status_code = 500;
    GetReportInfoResponse resultObject = GetReportInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(reportId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetReportInfoResponse> ReportsInfoReportIdResource::handler_GET(
        std::string & reportId)
{
    return handler_GET_func(reportId);
}


std::string ReportsInfoReportIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsInfoReportIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    int64_t returnId = request->get_path_parameter("returnId", 0L);
    
    int status_code = 500;
    GetReturnResponse resultObject = GetReturnResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId, returnId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetReturnResponse> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET(
        int64_t & campaignId, int64_t & orderId, int64_t & returnId)
{
    return handler_GET_func(campaignId, orderId, returnId);
}


std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/application");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    int64_t returnId = request->get_path_parameter("returnId", 0L);
    
    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId, returnId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/octet-stream","application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handler_GET(
        int64_t & campaignId, int64_t & orderId, int64_t & returnId)
{
    return handler_GET_func(campaignId, orderId, returnId);
}


std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/decision/{itemId: .*}/image/{imageHash: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    int64_t returnId = request->get_path_parameter("returnId", 0L);
    int64_t itemId = request->get_path_parameter("itemId", 0L);
    std::string imageHash = request->get_path_parameter("imageHash", "");
    
    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId, returnId, itemId, imageHash);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/octet-stream","application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET(
        int64_t & campaignId, int64_t & orderId, int64_t & returnId, int64_t & itemId, std::string & imageHash)
{
    return handler_GET_func(campaignId, orderId, returnId, itemId, imageHash);
}


std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdReturnsResource::CampaignsCampaignIdReturnsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/returns");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdReturnsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdReturnsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdReturnsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdReturnsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdReturnsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdReturnsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdReturnsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdReturnsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    std::string orderIds_raw = request->get_query_parameter("orderIds");
    std::vector<int64_t> orderIds;
    std::vector<std::string> orderIds_temp;
    boost::split(orderIds_temp, orderIds_raw, boost::is_any_of(","));
    std::transform(orderIds_temp.begin(), orderIds_temp.end(), std::back_inserter(orderIds), [](const auto& i){ int64_t ret; ret.fromString(i); return ret;});
    std::string statuses_raw = request->get_query_parameter("statuses");
    std::vector<RefundStatusType> statuses;
    std::vector<std::string> statuses_temp;
    boost::split(statuses_temp, statuses_raw, boost::is_any_of(","));
    std::transform(statuses_temp.begin(), statuses_temp.end(), std::back_inserter(statuses), [](const auto& i){ RefundStatusType ret; ret.fromString(i); return ret;});
    std::string fromDate = request->get_query_parameter("fromDate", "");
    std::string toDate = request->get_query_parameter("toDate", "");
    std::string fromDate2 = request->get_query_parameter("fromDate2", "");
    std::string toDate2 = request->get_query_parameter("toDate2", "");
    
    int status_code = 500;
    GetReturnsResponse resultObject = GetReturnsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetReturnsResponse> CampaignsCampaignIdReturnsResource::handler_GET(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, std::vector<int64_t> & orderIds, std::vector<RefundStatusType> & statuses, ReturnType & type, std::string & fromDate, std::string & toDate, std::string & fromDate2, std::string & toDate2)
{
    return handler_GET_func(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2);
}


std::string CampaignsCampaignIdReturnsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdReturnsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersStocksResource::CampaignsCampaignIdOffersStocksResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/stocks");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffersStocksResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOffersStocksResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersStocksResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersStocksResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersStocksResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersStocksResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersStocksResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersStocksResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersStocksResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getWarehouseStocksRequest = extractJsonModelBodyParam<GetWarehouseStocksRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetWarehouseStocksResponse resultObject = GetWarehouseStocksResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, pageToken, limit, getWarehouseStocksRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdOffersStocksResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateStocksRequest = extractJsonModelBodyParam<UpdateStocksRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, updateStocksRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, GetWarehouseStocksResponse> CampaignsCampaignIdOffersStocksResource::handler_POST(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, GetWarehouseStocksRequest & getWarehouseStocksRequest)
{
    return handler_POST_func(campaignId, pageToken, limit, getWarehouseStocksRequest);
}

std::pair<int, EmptyApiResponse> CampaignsCampaignIdOffersStocksResource::handler_PUT(
    int64_t & campaignId, UpdateStocksRequest & updateStocksRequest)
{
    return handler_PUT_func(campaignId, updateStocksRequest);
}

std::string CampaignsCampaignIdOffersStocksResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersStocksResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/suggestions");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getSuggestedOfferMappingEntriesRequest = extractJsonModelBodyParam<GetSuggestedOfferMappingEntriesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetSuggestedOfferMappingEntriesResponse resultObject = GetSuggestedOfferMappingEntriesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, getSuggestedOfferMappingEntriesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetSuggestedOfferMappingEntriesResponse> CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handler_POST(
        int64_t & campaignId, GetSuggestedOfferMappingEntriesRequest & getSuggestedOfferMappingEntriesRequest)
{
    return handler_POST_func(campaignId, getSuggestedOfferMappingEntriesRequest);
}


std::string CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsSuggestionsResource::BusinessesBusinessIdOffer_mappingsSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/suggestions");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsSuggestionsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getSuggestedOfferMappingsRequest = extractJsonModelBodyParam<GetSuggestedOfferMappingsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetSuggestedOfferMappingsResponse resultObject = GetSuggestedOfferMappingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getSuggestedOfferMappingsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetSuggestedOfferMappingsResponse> BusinessesBusinessIdOffer_mappingsSuggestionsResource::handler_POST(
        int64_t & businessId, GetSuggestedOfferMappingsRequest & getSuggestedOfferMappingsRequest)
{
    return handler_POST_func(businessId, getSuggestedOfferMappingsRequest);
}


std::string BusinessesBusinessIdOffer_mappingsSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsSuggestionsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_pricesSuggestionsResource::CampaignsCampaignIdOffer_pricesSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/suggestions");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_pricesSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesSuggestionsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_pricesSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_pricesSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_pricesSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_pricesSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto suggestPricesRequest = extractJsonModelBodyParam<SuggestPricesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    SuggestPricesResponse resultObject = SuggestPricesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, suggestPricesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, SuggestPricesResponse> CampaignsCampaignIdOffer_pricesSuggestionsResource::handler_POST(
        int64_t & campaignId, SuggestPricesRequest & suggestPricesRequest)
{
    return handler_POST_func(campaignId, suggestPricesRequest);
}


std::string CampaignsCampaignIdOffer_pricesSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_pricesSuggestionsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdWarehousesResource::BusinessesBusinessIdWarehousesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/warehouses");
	this->set_method_handler("GET",
		std::bind(&BusinessesBusinessIdWarehousesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdWarehousesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdWarehousesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdWarehousesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdWarehousesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdWarehousesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdWarehousesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdWarehousesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetWarehousesResponse resultObject = GetWarehousesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(businessId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetWarehousesResponse> BusinessesBusinessIdWarehousesResource::handler_GET(
        int64_t & businessId)
{
    return handler_GET_func(businessId);
}


std::string BusinessesBusinessIdWarehousesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdWarehousesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/deliverDigitalGoods");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto provideOrderDigitalCodesRequest = extractJsonModelBodyParam<ProvideOrderDigitalCodesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, orderId, provideOrderDigitalCodesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::handler_POST(
        int64_t & campaignId, int64_t & orderId, ProvideOrderDigitalCodesRequest & provideOrderDigitalCodesRequest)
{
    return handler_POST_func(campaignId, orderId, provideOrderDigitalCodesRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdIdentifiersResource::CampaignsCampaignIdOrdersOrderIdIdentifiersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/identifiers");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOrdersOrderIdIdentifiersResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdIdentifiersResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdIdentifiersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdIdentifiersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdIdentifiersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdIdentifiersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdIdentifiersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdIdentifiersResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto provideOrderItemIdentifiersRequest = extractJsonModelBodyParam<ProvideOrderItemIdentifiersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    ProvideOrderItemIdentifiersResponse resultObject = ProvideOrderItemIdentifiersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, orderId, provideOrderItemIdentifiersRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, ProvideOrderItemIdentifiersResponse> CampaignsCampaignIdOrdersOrderIdIdentifiersResource::handler_PUT(
        int64_t & campaignId, int64_t & orderId, ProvideOrderItemIdentifiersRequest & provideOrderItemIdentifiersRequest)
{
    return handler_PUT_func(campaignId, orderId, provideOrderItemIdentifiersRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdIdentifiersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdIdentifiersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdBidsResource::BusinessesBusinessIdBidsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids");
	this->set_method_handler("PUT",
		std::bind(&BusinessesBusinessIdBidsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdBidsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdBidsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdBidsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdBidsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdBidsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto putSkuBidsRequest = extractJsonModelBodyParam<PutSkuBidsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(businessId, putSkuBidsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdBidsResource::handler_PUT(
        int64_t & businessId, PutSkuBidsRequest & putSkuBidsRequest)
{
    return handler_PUT_func(businessId, putSkuBidsRequest);
}


std::string BusinessesBusinessIdBidsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdBidsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdBidsResource::CampaignsCampaignIdBidsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/bids");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdBidsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdBidsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdBidsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdBidsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdBidsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdBidsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdBidsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdBidsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto putSkuBidsRequest = extractJsonModelBodyParam<PutSkuBidsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, putSkuBidsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdBidsResource::handler_PUT(
        int64_t & campaignId, PutSkuBidsRequest & putSkuBidsRequest)
{
    return handler_PUT_func(campaignId, putSkuBidsRequest);
}


std::string CampaignsCampaignIdBidsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdBidsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsFeedIdRefreshResource::CampaignsCampaignIdFeedsFeedIdRefreshResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/refresh");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdRefreshResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdRefreshResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdRefreshResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsFeedIdRefreshResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsFeedIdRefreshResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsFeedIdRefreshResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t feedId = request->get_path_parameter("feedId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, feedId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST(
        int64_t & campaignId, int64_t & feedId)
{
    return handler_POST_func(campaignId, feedId);
}


std::string CampaignsCampaignIdFeedsFeedIdRefreshResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsFeedIdRefreshResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
RegionsRegionIdChildrenResource::RegionsRegionIdChildrenResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/{regionId: .*}/children");
	this->set_method_handler("GET",
		std::bind(&RegionsRegionIdChildrenResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> RegionsRegionIdChildrenResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> RegionsRegionIdChildrenResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> RegionsRegionIdChildrenResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void RegionsRegionIdChildrenResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void RegionsRegionIdChildrenResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void RegionsRegionIdChildrenResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void RegionsRegionIdChildrenResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t regionId = request->get_path_parameter("regionId", 0L);
    // Getting the query params
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetRegionWithChildrenResponse resultObject = GetRegionWithChildrenResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(regionId, page, pageSize);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetRegionWithChildrenResponse> RegionsRegionIdChildrenResource::handler_GET(
        int64_t & regionId, int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(regionId, page, pageSize);
}


std::string RegionsRegionIdChildrenResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string RegionsRegionIdChildrenResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
RegionsRegionIdResource::RegionsRegionIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/{regionId: .*}");
	this->set_method_handler("GET",
		std::bind(&RegionsRegionIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> RegionsRegionIdResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> RegionsRegionIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> RegionsRegionIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void RegionsRegionIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void RegionsRegionIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void RegionsRegionIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void RegionsRegionIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t regionId = request->get_path_parameter("regionId", 0L);
    
    int status_code = 500;
    GetRegionsResponse resultObject = GetRegionsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(regionId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetRegionsResponse> RegionsRegionIdResource::handler_GET(
        int64_t & regionId)
{
    return handler_GET_func(regionId);
}


std::string RegionsRegionIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string RegionsRegionIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
RegionsResource::RegionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions");
	this->set_method_handler("GET",
		std::bind(&RegionsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> RegionsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> RegionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> RegionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void RegionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void RegionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void RegionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void RegionsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the query params
    std::string name = request->get_query_parameter("name", "");
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetRegionsResponse resultObject = GetRegionsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(name, pageToken, limit);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetRegionsResponse> RegionsResource::handler_GET(
        std::string & name, std::string & pageToken, int32_t & limit)
{
    return handler_GET_func(name, pageToken, limit);
}


std::string RegionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string RegionsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsFileSendResource::BusinessesBusinessIdChatsFileSendResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/file/send");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsFileSendResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsFileSendResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsFileSendResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsFileSendResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsFileSendResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsFileSendResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsFileSendResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsFileSendResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    auto file = boost::lexical_cast<std::string>(extractFormParamsFromBody("file", extractBodyContent(session)));
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    int64_t chatId = request->get_query_parameter("chatId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, chatId, file);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "multipart/form-data, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdChatsFileSendResource::handler_POST(
        int64_t & businessId, int64_t & chatId, std::string & file)
{
    return handler_POST_func(businessId, chatId, file);
}


std::string BusinessesBusinessIdChatsFileSendResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsFileSendResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsMessageResource::BusinessesBusinessIdChatsMessageResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/message");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsMessageResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsMessageResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsMessageResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsMessageResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsMessageResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsMessageResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsMessageResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsMessageResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto sendMessageToChatRequest = extractJsonModelBodyParam<SendMessageToChatRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    int64_t chatId = request->get_query_parameter("chatId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, chatId, sendMessageToChatRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdChatsMessageResource::handler_POST(
        int64_t & businessId, int64_t & chatId, SendMessageToChatRequest & sendMessageToChatRequest)
{
    return handler_POST_func(businessId, chatId, sendMessageToChatRequest);
}


std::string BusinessesBusinessIdChatsMessageResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsMessageResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsFeedIdParamsResource::CampaignsCampaignIdFeedsFeedIdParamsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/params");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdParamsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdParamsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdParamsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsFeedIdParamsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsFeedIdParamsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsFeedIdParamsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto setFeedParamsRequest = extractJsonModelBodyParam<SetFeedParamsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t feedId = request->get_path_parameter("feedId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, feedId, setFeedParamsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST(
        int64_t & campaignId, int64_t & feedId, SetFeedParamsRequest & setFeedParamsRequest)
{
    return handler_POST_func(campaignId, feedId, setFeedParamsRequest);
}


std::string CampaignsCampaignIdFeedsFeedIdParamsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsFeedIdParamsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdBoxesResource::CampaignsCampaignIdOrdersOrderIdBoxesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/boxes");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOrdersOrderIdBoxesResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBoxesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBoxesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBoxesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdBoxesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdBoxesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdBoxesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdBoxesResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto setOrderBoxLayoutRequest = extractJsonModelBodyParam<SetOrderBoxLayoutRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    SetOrderBoxLayoutResponse resultObject = SetOrderBoxLayoutResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, orderId, setOrderBoxLayoutRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, SetOrderBoxLayoutResponse> CampaignsCampaignIdOrdersOrderIdBoxesResource::handler_PUT(
        int64_t & campaignId, int64_t & orderId, SetOrderBoxLayoutRequest & setOrderBoxLayoutRequest)
{
    return handler_PUT_func(campaignId, orderId, setOrderBoxLayoutRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdBoxesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdBoxesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::CampaignsCampaignIdOrdersOrderIdDeliveryDateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/date");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto setOrderDeliveryDateRequest = extractJsonModelBodyParam<SetOrderDeliveryDateRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, orderId, setOrderDeliveryDateRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::handler_PUT(
        int64_t & campaignId, int64_t & orderId, SetOrderDeliveryDateRequest & setOrderDeliveryDateRequest)
{
    return handler_PUT_func(campaignId, orderId, setOrderDeliveryDateRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDeliveryDateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/track");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto setOrderDeliveryTrackCodeRequest = extractJsonModelBodyParam<SetOrderDeliveryTrackCodeRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, orderId, setOrderDeliveryTrackCodeRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::handler_POST(
        int64_t & campaignId, int64_t & orderId, SetOrderDeliveryTrackCodeRequest & setOrderDeliveryTrackCodeRequest)
{
    return handler_POST_func(campaignId, orderId, setOrderDeliveryTrackCodeRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/shipments/{shipmentId: .*}/boxes");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto setOrderShipmentBoxesRequest = extractJsonModelBodyParam<SetOrderShipmentBoxesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    int64_t shipmentId = request->get_path_parameter("shipmentId", 0L);
    
    int status_code = 500;
    SetOrderShipmentBoxesResponse resultObject = SetOrderShipmentBoxesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, orderId, shipmentId, setOrderShipmentBoxesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, SetOrderShipmentBoxesResponse> CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handler_PUT(
        int64_t & campaignId, int64_t & orderId, int64_t & shipmentId, SetOrderShipmentBoxesRequest & setOrderShipmentBoxesRequest)
{
    return handler_PUT_func(campaignId, orderId, shipmentId, setOrderShipmentBoxesRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/decision");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto setReturnDecisionRequest = extractJsonModelBodyParam<SetReturnDecisionRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    int64_t returnId = request->get_path_parameter("returnId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, orderId, returnId, setReturnDecisionRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::handler_POST(
        int64_t & campaignId, int64_t & orderId, int64_t & returnId, SetReturnDecisionRequest & setReturnDecisionRequest)
{
    return handler_POST_func(campaignId, orderId, returnId, setReturnDecisionRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackSkip_reactionResource::BusinessesBusinessIdGoods_feedbackSkip_reactionResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/skip-reaction");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackSkip_reactionResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackSkip_reactionResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackSkip_reactionResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto skipGoodsFeedbackReactionRequest = extractJsonModelBodyParam<SkipGoodsFeedbackReactionRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, skipGoodsFeedbackReactionRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handler_POST(
        int64_t & businessId, SkipGoodsFeedbackReactionRequest & skipGoodsFeedbackReactionRequest)
{
    return handler_POST_func(businessId, skipGoodsFeedbackReactionRequest);
}


std::string BusinessesBusinessIdGoods_feedbackSkip_reactionResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackSkip_reactionResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/decision/submit");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    int64_t returnId = request->get_path_parameter("returnId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, orderId, returnId);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::handler_POST(
        int64_t & campaignId, int64_t & orderId, int64_t & returnId)
{
    return handler_POST_func(campaignId, orderId, returnId);
}


std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_pricesUpdatesResource::BusinessesBusinessIdOffer_pricesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-prices/updates");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_pricesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_pricesUpdatesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_pricesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_pricesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_pricesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_pricesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_pricesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_pricesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateBusinessPricesRequest = extractJsonModelBodyParam<UpdateBusinessPricesRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updateBusinessPricesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdOffer_pricesUpdatesResource::handler_POST(
        int64_t & businessId, UpdateBusinessPricesRequest & updateBusinessPricesRequest)
{
    return handler_POST_func(businessId, updateBusinessPricesRequest);
}


std::string BusinessesBusinessIdOffer_pricesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_pricesUpdatesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersUpdateResource::CampaignsCampaignIdOffersUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/update");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffersUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersUpdateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateCampaignOffersRequest = extractJsonModelBodyParam<UpdateCampaignOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, updateCampaignOffersRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOffersUpdateResource::handler_POST(
        int64_t & campaignId, UpdateCampaignOffersRequest & updateCampaignOffersRequest)
{
    return handler_POST_func(campaignId, updateCampaignOffersRequest);
}


std::string CampaignsCampaignIdOffersUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/update");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateGoodsFeedbackCommentRequest = extractJsonModelBodyParam<UpdateGoodsFeedbackCommentRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    UpdateGoodsFeedbackCommentResponse resultObject = UpdateGoodsFeedbackCommentResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updateGoodsFeedbackCommentRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdateGoodsFeedbackCommentResponse> BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handler_POST(
        int64_t & businessId, UpdateGoodsFeedbackCommentRequest & updateGoodsFeedbackCommentRequest)
{
    return handler_POST_func(businessId, updateGoodsFeedbackCommentRequest);
}


std::string BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_cardsUpdateResource::BusinessesBusinessIdOffer_cardsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-cards/update");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_cardsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsUpdateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_cardsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_cardsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_cardsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_cardsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOfferContentRequest = extractJsonModelBodyParam<UpdateOfferContentRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    UpdateOfferContentResponse resultObject = UpdateOfferContentResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updateOfferContentRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdateOfferContentResponse> BusinessesBusinessIdOffer_cardsUpdateResource::handler_POST(
        int64_t & businessId, UpdateOfferContentRequest & updateOfferContentRequest)
{
    return handler_POST_func(businessId, updateOfferContentRequest);
}


std::string BusinessesBusinessIdOffer_cardsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_cardsUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/updates");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOfferMappingEntryRequest = extractJsonModelBodyParam<UpdateOfferMappingEntryRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, updateOfferMappingEntryRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handler_POST(
        int64_t & campaignId, UpdateOfferMappingEntryRequest & updateOfferMappingEntryRequest)
{
    return handler_POST_func(campaignId, updateOfferMappingEntryRequest);
}


std::string CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsUpdateResource::BusinessesBusinessIdOffer_mappingsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/update");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUpdateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOfferMappingsRequest = extractJsonModelBodyParam<UpdateOfferMappingsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    UpdateOfferMappingsResponse resultObject = UpdateOfferMappingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updateOfferMappingsRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdateOfferMappingsResponse> BusinessesBusinessIdOffer_mappingsUpdateResource::handler_POST(
        int64_t & businessId, UpdateOfferMappingsRequest & updateOfferMappingsRequest)
{
    return handler_POST_func(businessId, updateOfferMappingsRequest);
}


std::string BusinessesBusinessIdOffer_mappingsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdItemsResource::CampaignsCampaignIdOrdersOrderIdItemsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/items");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOrdersOrderIdItemsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdItemsResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdItemsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdItemsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdItemsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdItemsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdItemsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdItemsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOrderItemRequest = extractJsonModelBodyParam<UpdateOrderItemRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    std::string result = "";
    
    try {
        status_code =
            handler_PUT(campaignId, orderId, updateOrderItemRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


int CampaignsCampaignIdOrdersOrderIdItemsResource::handler_PUT(
        int64_t & campaignId, int64_t & orderId, UpdateOrderItemRequest & updateOrderItemRequest)
{
    return handler_PUT_func(campaignId, orderId, updateOrderItemRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdItemsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdItemsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdStatusResource::CampaignsCampaignIdOrdersOrderIdStatusResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/status");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOrdersOrderIdStatusResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdStatusResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdStatusResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdStatusResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdStatusResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdStatusResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdStatusResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdStatusResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOrderStatusRequest = extractJsonModelBodyParam<UpdateOrderStatusRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    UpdateOrderStatusResponse resultObject = UpdateOrderStatusResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, orderId, updateOrderStatusRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdateOrderStatusResponse> CampaignsCampaignIdOrdersOrderIdStatusResource::handler_PUT(
        int64_t & campaignId, int64_t & orderId, UpdateOrderStatusRequest & updateOrderStatusRequest)
{
    return handler_PUT_func(campaignId, orderId, updateOrderStatusRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdStatusResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdStatusResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersStatus_updateResource::CampaignsCampaignIdOrdersStatus_updateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/status-update");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOrdersStatus_updateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersStatus_updateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersStatus_updateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersStatus_updateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersStatus_updateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersStatus_updateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersStatus_updateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersStatus_updateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOrderStatusesRequest = extractJsonModelBodyParam<UpdateOrderStatusesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    UpdateOrderStatusesResponse resultObject = UpdateOrderStatusesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, updateOrderStatusesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdateOrderStatusesResponse> CampaignsCampaignIdOrdersStatus_updateResource::handler_POST(
        int64_t & campaignId, UpdateOrderStatusesRequest & updateOrderStatusesRequest)
{
    return handler_POST_func(campaignId, updateOrderStatusesRequest);
}


std::string CampaignsCampaignIdOrdersStatus_updateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersStatus_updateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/storage-limit");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOrderStorageLimitRequest = extractJsonModelBodyParam<UpdateOrderStorageLimitRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, orderId, updateOrderStorageLimitRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::handler_PUT(
        int64_t & campaignId, int64_t & orderId, UpdateOrderStorageLimitRequest & updateOrderStorageLimitRequest)
{
    return handler_PUT_func(campaignId, orderId, updateOrderStorageLimitRequest);
}


std::string CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_pricesUpdatesResource::CampaignsCampaignIdOffer_pricesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/updates");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_pricesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesUpdatesResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_pricesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_pricesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_pricesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_pricesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updatePricesRequest = extractJsonModelBodyParam<UpdatePricesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, updatePricesRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOffer_pricesUpdatesResource::handler_POST(
        int64_t & campaignId, UpdatePricesRequest & updatePricesRequest)
{
    return handler_POST_func(campaignId, updatePricesRequest);
}


std::string CampaignsCampaignIdOffer_pricesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_pricesUpdatesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPromosOffersUpdateResource::BusinessesBusinessIdPromosOffersUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/update");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPromosOffersUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersUpdateResource::handleDbsApiException(const DbsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPromosOffersUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPromosOffersUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPromosOffersUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPromosOffersUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updatePromoOffersRequest = extractJsonModelBodyParam<UpdatePromoOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    UpdatePromoOffersResponse resultObject = UpdatePromoOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updatePromoOffersRequest);
    }
    catch(const DbsApiException& e) {
        std::tie(status_code, result) = handleDbsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdatePromoOffersResponse> BusinessesBusinessIdPromosOffersUpdateResource::handler_POST(
        int64_t & businessId, UpdatePromoOffersRequest & updatePromoOffersRequest)
{
    return handler_POST_func(businessId, updatePromoOffersRequest);
}


std::string BusinessesBusinessIdPromosOffersUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPromosOffersUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}

} /* namespace DbsApiResources */

DbsApi::DbsApi(std::shared_ptr<restbed::Service> const& restbedService)
: m_service(restbedService)
{
}

DbsApi::~DbsApi() {}

std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdHidden_offersResource> DbsApi::getCampaignsCampaignIdHidden_offersResource() {
    if (!m_spCampaignsCampaignIdHidden_offersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdHidden_offersResource>());
    }
    return m_spCampaignsCampaignIdHidden_offersResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource> DbsApi::getBusinessesBusinessIdOffer_mappingsArchiveResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsArchiveResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsArchiveResource;
}
std::shared_ptr<DbsApiResources::TariffsCalculateResource> DbsApi::getTariffsCalculateResource() {
    if (!m_spTariffsCalculateResource) {
        setResource(std::make_shared<DbsApiResources::TariffsCalculateResource>());
    }
    return m_spTariffsCalculateResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource> DbsApi::getBusinessesBusinessIdPrice_quarantineConfirmResource() {
    if (!m_spBusinessesBusinessIdPrice_quarantineConfirmResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource>());
    }
    return m_spBusinessesBusinessIdPrice_quarantineConfirmResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource> DbsApi::getCampaignsCampaignIdPrice_quarantineConfirmResource() {
    if (!m_spCampaignsCampaignIdPrice_quarantineConfirmResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource>());
    }
    return m_spCampaignsCampaignIdPrice_quarantineConfirmResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsNewResource> DbsApi::getBusinessesBusinessIdChatsNewResource() {
    if (!m_spBusinessesBusinessIdChatsNewResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsNewResource>());
    }
    return m_spBusinessesBusinessIdChatsNewResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOutletsResource> DbsApi::getCampaignsCampaignIdOutletsResource() {
    if (!m_spCampaignsCampaignIdOutletsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOutletsResource>());
    }
    return m_spCampaignsCampaignIdOutletsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersDeleteResource> DbsApi::getCampaignsCampaignIdOffersDeleteResource() {
    if (!m_spCampaignsCampaignIdOffersDeleteResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersDeleteResource>());
    }
    return m_spCampaignsCampaignIdOffersDeleteResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource> DbsApi::getBusinessesBusinessIdGoods_feedbackCommentsDeleteResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdHidden_offersDeleteResource> DbsApi::getCampaignsCampaignIdHidden_offersDeleteResource() {
    if (!m_spCampaignsCampaignIdHidden_offersDeleteResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdHidden_offersDeleteResource>());
    }
    return m_spCampaignsCampaignIdHidden_offersDeleteResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource> DbsApi::getBusinessesBusinessIdOffer_mappingsDeleteResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsDeleteResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsDeleteResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource> DbsApi::getBusinessesBusinessIdOffer_mappingsUnarchiveResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOutletsOutletIdResource> DbsApi::getCampaignsCampaignIdOutletsOutletIdResource() {
    if (!m_spCampaignsCampaignIdOutletsOutletIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOutletsOutletIdResource>());
    }
    return m_spCampaignsCampaignIdOutletsOutletIdResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOutletsLicensesResource> DbsApi::getCampaignsCampaignIdOutletsLicensesResource() {
    if (!m_spCampaignsCampaignIdOutletsLicensesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOutletsLicensesResource>());
    }
    return m_spCampaignsCampaignIdOutletsLicensesResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosOffersDeleteResource> DbsApi::getBusinessesBusinessIdPromosOffersDeleteResource() {
    if (!m_spBusinessesBusinessIdPromosOffersDeleteResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPromosOffersDeleteResource>());
    }
    return m_spBusinessesBusinessIdPromosOffersDeleteResource;
}
std::shared_ptr<DbsApiResources::ReportsBoost_consolidatedGenerateResource> DbsApi::getReportsBoost_consolidatedGenerateResource() {
    if (!m_spReportsBoost_consolidatedGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsBoost_consolidatedGenerateResource>());
    }
    return m_spReportsBoost_consolidatedGenerateResource;
}
std::shared_ptr<DbsApiResources::ReportsCompetitors_positionGenerateResource> DbsApi::getReportsCompetitors_positionGenerateResource() {
    if (!m_spReportsCompetitors_positionGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsCompetitors_positionGenerateResource>());
    }
    return m_spReportsCompetitors_positionGenerateResource;
}
std::shared_ptr<DbsApiResources::ReportsGoods_feedbackGenerateResource> DbsApi::getReportsGoods_feedbackGenerateResource() {
    if (!m_spReportsGoods_feedbackGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsGoods_feedbackGenerateResource>());
    }
    return m_spReportsGoods_feedbackGenerateResource;
}
std::shared_ptr<DbsApiResources::ReportsDocumentsLabelsGenerateResource> DbsApi::getReportsDocumentsLabelsGenerateResource() {
    if (!m_spReportsDocumentsLabelsGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsDocumentsLabelsGenerateResource>());
    }
    return m_spReportsDocumentsLabelsGenerateResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource;
}
std::shared_ptr<DbsApiResources::ReportsPricesGenerateResource> DbsApi::getReportsPricesGenerateResource() {
    if (!m_spReportsPricesGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsPricesGenerateResource>());
    }
    return m_spReportsPricesGenerateResource;
}
std::shared_ptr<DbsApiResources::ReportsShelf_statisticsGenerateResource> DbsApi::getReportsShelf_statisticsGenerateResource() {
    if (!m_spReportsShelf_statisticsGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsShelf_statisticsGenerateResource>());
    }
    return m_spReportsShelf_statisticsGenerateResource;
}
std::shared_ptr<DbsApiResources::ReportsShows_salesGenerateResource> DbsApi::getReportsShows_salesGenerateResource() {
    if (!m_spReportsShows_salesGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsShows_salesGenerateResource>());
    }
    return m_spReportsShows_salesGenerateResource;
}
std::shared_ptr<DbsApiResources::ReportsStocks_on_warehousesGenerateResource> DbsApi::getReportsStocks_on_warehousesGenerateResource() {
    if (!m_spReportsStocks_on_warehousesGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsStocks_on_warehousesGenerateResource>());
    }
    return m_spReportsStocks_on_warehousesGenerateResource;
}
std::shared_ptr<DbsApiResources::ReportsUnited_marketplace_servicesGenerateResource> DbsApi::getReportsUnited_marketplace_servicesGenerateResource() {
    if (!m_spReportsUnited_marketplace_servicesGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsUnited_marketplace_servicesGenerateResource>());
    }
    return m_spReportsUnited_marketplace_servicesGenerateResource;
}
std::shared_ptr<DbsApiResources::ReportsUnited_nettingGenerateResource> DbsApi::getReportsUnited_nettingGenerateResource() {
    if (!m_spReportsUnited_nettingGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsUnited_nettingGenerateResource>());
    }
    return m_spReportsUnited_nettingGenerateResource;
}
std::shared_ptr<DbsApiResources::ReportsUnited_ordersGenerateResource> DbsApi::getReportsUnited_ordersGenerateResource() {
    if (!m_spReportsUnited_ordersGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsUnited_ordersGenerateResource>());
    }
    return m_spReportsUnited_ordersGenerateResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersAllResource> DbsApi::getCampaignsCampaignIdOffersAllResource() {
    if (!m_spCampaignsCampaignIdOffersAllResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersAllResource>());
    }
    return m_spCampaignsCampaignIdOffersAllResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdBidsInfoResource> DbsApi::getBusinessesBusinessIdBidsInfoResource() {
    if (!m_spBusinessesBusinessIdBidsInfoResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdBidsInfoResource>());
    }
    return m_spBusinessesBusinessIdBidsInfoResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdBidsRecommendationsResource> DbsApi::getBusinessesBusinessIdBidsRecommendationsResource() {
    if (!m_spBusinessesBusinessIdBidsRecommendationsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdBidsRecommendationsResource>());
    }
    return m_spBusinessesBusinessIdBidsRecommendationsResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdPrice_quarantineResource> DbsApi::getBusinessesBusinessIdPrice_quarantineResource() {
    if (!m_spBusinessesBusinessIdPrice_quarantineResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPrice_quarantineResource>());
    }
    return m_spBusinessesBusinessIdPrice_quarantineResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdSettingsResource> DbsApi::getBusinessesBusinessIdSettingsResource() {
    if (!m_spBusinessesBusinessIdSettingsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdSettingsResource>());
    }
    return m_spBusinessesBusinessIdSettingsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdResource> DbsApi::getCampaignsCampaignIdResource() {
    if (!m_spCampaignsCampaignIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdResource>());
    }
    return m_spCampaignsCampaignIdResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdLoginsResource> DbsApi::getCampaignsCampaignIdLoginsResource() {
    if (!m_spCampaignsCampaignIdLoginsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdLoginsResource>());
    }
    return m_spCampaignsCampaignIdLoginsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersResource> DbsApi::getCampaignsCampaignIdOffersResource() {
    if (!m_spCampaignsCampaignIdOffersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersResource>());
    }
    return m_spCampaignsCampaignIdOffersResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdPrice_quarantineResource> DbsApi::getCampaignsCampaignIdPrice_quarantineResource() {
    if (!m_spCampaignsCampaignIdPrice_quarantineResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdPrice_quarantineResource>());
    }
    return m_spCampaignsCampaignIdPrice_quarantineResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdRegionResource> DbsApi::getCampaignsCampaignIdRegionResource() {
    if (!m_spCampaignsCampaignIdRegionResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdRegionResource>());
    }
    return m_spCampaignsCampaignIdRegionResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdSettingsResource> DbsApi::getCampaignsCampaignIdSettingsResource() {
    if (!m_spCampaignsCampaignIdSettingsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdSettingsResource>());
    }
    return m_spCampaignsCampaignIdSettingsResource;
}
std::shared_ptr<DbsApiResources::CampaignsResource> DbsApi::getCampaignsResource() {
    if (!m_spCampaignsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsResource>());
    }
    return m_spCampaignsResource;
}
std::shared_ptr<DbsApiResources::CampaignsBy_loginLoginResource> DbsApi::getCampaignsBy_loginLoginResource() {
    if (!m_spCampaignsBy_loginLoginResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsBy_loginLoginResource>());
    }
    return m_spCampaignsBy_loginLoginResource;
}
std::shared_ptr<DbsApiResources::CategoriesMax_sale_quantumResource> DbsApi::getCategoriesMax_sale_quantumResource() {
    if (!m_spCategoriesMax_sale_quantumResource) {
        setResource(std::make_shared<DbsApiResources::CategoriesMax_sale_quantumResource>());
    }
    return m_spCategoriesMax_sale_quantumResource;
}
std::shared_ptr<DbsApiResources::CategoriesTreeResource> DbsApi::getCategoriesTreeResource() {
    if (!m_spCategoriesTreeResource) {
        setResource(std::make_shared<DbsApiResources::CategoriesTreeResource>());
    }
    return m_spCategoriesTreeResource;
}
std::shared_ptr<DbsApiResources::CategoryCategoryIdParametersResource> DbsApi::getCategoryCategoryIdParametersResource() {
    if (!m_spCategoryCategoryIdParametersResource) {
        setResource(std::make_shared<DbsApiResources::CategoryCategoryIdParametersResource>());
    }
    return m_spCategoryCategoryIdParametersResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsHistoryResource> DbsApi::getBusinessesBusinessIdChatsHistoryResource() {
    if (!m_spBusinessesBusinessIdChatsHistoryResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsHistoryResource>());
    }
    return m_spBusinessesBusinessIdChatsHistoryResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsResource> DbsApi::getBusinessesBusinessIdChatsResource() {
    if (!m_spBusinessesBusinessIdChatsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsResource>());
    }
    return m_spBusinessesBusinessIdChatsResource;
}
std::shared_ptr<DbsApiResources::DeliveryServicesResource> DbsApi::getDeliveryServicesResource() {
    if (!m_spDeliveryServicesResource) {
        setResource(std::make_shared<DbsApiResources::DeliveryServicesResource>());
    }
    return m_spDeliveryServicesResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdResource> DbsApi::getCampaignsCampaignIdFeedsFeedIdResource() {
    if (!m_spCampaignsCampaignIdFeedsFeedIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsFeedIdResource>());
    }
    return m_spCampaignsCampaignIdFeedsFeedIdResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource> DbsApi::getCampaignsCampaignIdFeedsFeedIdIndex_logsResource() {
    if (!m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource>());
    }
    return m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedbackUpdatesResource> DbsApi::getCampaignsCampaignIdFeedbackUpdatesResource() {
    if (!m_spCampaignsCampaignIdFeedbackUpdatesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedbackUpdatesResource>());
    }
    return m_spCampaignsCampaignIdFeedbackUpdatesResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsResource> DbsApi::getCampaignsCampaignIdFeedsResource() {
    if (!m_spCampaignsCampaignIdFeedsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsResource>());
    }
    return m_spCampaignsCampaignIdFeedsResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource> DbsApi::getBusinessesBusinessIdGoods_feedbackCommentsResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackCommentsResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackResource> DbsApi::getBusinessesBusinessIdGoods_feedbackResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdStatsSkusResource> DbsApi::getCampaignsCampaignIdStatsSkusResource() {
    if (!m_spCampaignsCampaignIdStatsSkusResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdStatsSkusResource>());
    }
    return m_spCampaignsCampaignIdStatsSkusResource;
}
std::shared_ptr<DbsApiResources::ModelsModelIdResource> DbsApi::getModelsModelIdResource() {
    if (!m_spModelsModelIdResource) {
        setResource(std::make_shared<DbsApiResources::ModelsModelIdResource>());
    }
    return m_spModelsModelIdResource;
}
std::shared_ptr<DbsApiResources::ModelsModelIdOffersResource> DbsApi::getModelsModelIdOffersResource() {
    if (!m_spModelsModelIdOffersResource) {
        setResource(std::make_shared<DbsApiResources::ModelsModelIdOffersResource>());
    }
    return m_spModelsModelIdOffersResource;
}
std::shared_ptr<DbsApiResources::ModelsResource> DbsApi::getModelsResource() {
    if (!m_spModelsResource) {
        setResource(std::make_shared<DbsApiResources::ModelsResource>());
    }
    return m_spModelsResource;
}
std::shared_ptr<DbsApiResources::ModelsOffersResource> DbsApi::getModelsOffersResource() {
    if (!m_spModelsOffersResource) {
        setResource(std::make_shared<DbsApiResources::ModelsOffersResource>());
    }
    return m_spModelsOffersResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_cardsResource> DbsApi::getBusinessesBusinessIdOffer_cardsResource() {
    if (!m_spBusinessesBusinessIdOffer_cardsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_cardsResource>());
    }
    return m_spBusinessesBusinessIdOffer_cardsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesResource> DbsApi::getCampaignsCampaignIdOffer_mapping_entriesResource() {
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesResource>());
    }
    return m_spCampaignsCampaignIdOffer_mapping_entriesResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsResource> DbsApi::getBusinessesBusinessIdOffer_mappingsResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffersRecommendationsResource> DbsApi::getBusinessesBusinessIdOffersRecommendationsResource() {
    if (!m_spBusinessesBusinessIdOffersRecommendationsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffersRecommendationsResource>());
    }
    return m_spBusinessesBusinessIdOffersRecommendationsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdDocumentsResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBuyerResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdBuyerResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdBuyerResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBuyerResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdBuyerResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersResource> DbsApi::getCampaignsCampaignIdOrdersResource() {
    if (!m_spCampaignsCampaignIdOrdersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersResource>());
    }
    return m_spCampaignsCampaignIdOrdersResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdStatsOrdersResource> DbsApi::getCampaignsCampaignIdStatsOrdersResource() {
    if (!m_spCampaignsCampaignIdStatsOrdersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdStatsOrdersResource>());
    }
    return m_spCampaignsCampaignIdStatsOrdersResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_pricesResource> DbsApi::getCampaignsCampaignIdOffer_pricesResource() {
    if (!m_spCampaignsCampaignIdOffer_pricesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_pricesResource>());
    }
    return m_spCampaignsCampaignIdOffer_pricesResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosOffersResource> DbsApi::getBusinessesBusinessIdPromosOffersResource() {
    if (!m_spBusinessesBusinessIdPromosOffersResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPromosOffersResource>());
    }
    return m_spBusinessesBusinessIdPromosOffersResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosResource> DbsApi::getBusinessesBusinessIdPromosResource() {
    if (!m_spBusinessesBusinessIdPromosResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPromosResource>());
    }
    return m_spBusinessesBusinessIdPromosResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdRatingsQualityDetailsResource> DbsApi::getCampaignsCampaignIdRatingsQualityDetailsResource() {
    if (!m_spCampaignsCampaignIdRatingsQualityDetailsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdRatingsQualityDetailsResource>());
    }
    return m_spCampaignsCampaignIdRatingsQualityDetailsResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdRatingsQualityResource> DbsApi::getBusinessesBusinessIdRatingsQualityResource() {
    if (!m_spBusinessesBusinessIdRatingsQualityResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdRatingsQualityResource>());
    }
    return m_spBusinessesBusinessIdRatingsQualityResource;
}
std::shared_ptr<DbsApiResources::ReportsInfoReportIdResource> DbsApi::getReportsInfoReportIdResource() {
    if (!m_spReportsInfoReportIdResource) {
        setResource(std::make_shared<DbsApiResources::ReportsInfoReportIdResource>());
    }
    return m_spReportsInfoReportIdResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdReturnsResource> DbsApi::getCampaignsCampaignIdReturnsResource() {
    if (!m_spCampaignsCampaignIdReturnsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdReturnsResource>());
    }
    return m_spCampaignsCampaignIdReturnsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersStocksResource> DbsApi::getCampaignsCampaignIdOffersStocksResource() {
    if (!m_spCampaignsCampaignIdOffersStocksResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersStocksResource>());
    }
    return m_spCampaignsCampaignIdOffersStocksResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource> DbsApi::getCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource() {
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource>());
    }
    return m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource> DbsApi::getBusinessesBusinessIdOffer_mappingsSuggestionsResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource> DbsApi::getCampaignsCampaignIdOffer_pricesSuggestionsResource() {
    if (!m_spCampaignsCampaignIdOffer_pricesSuggestionsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource>());
    }
    return m_spCampaignsCampaignIdOffer_pricesSuggestionsResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdWarehousesResource> DbsApi::getBusinessesBusinessIdWarehousesResource() {
    if (!m_spBusinessesBusinessIdWarehousesResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdWarehousesResource>());
    }
    return m_spBusinessesBusinessIdWarehousesResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdIdentifiersResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdIdentifiersResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdIdentifiersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdIdentifiersResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdIdentifiersResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdBidsResource> DbsApi::getBusinessesBusinessIdBidsResource() {
    if (!m_spBusinessesBusinessIdBidsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdBidsResource>());
    }
    return m_spBusinessesBusinessIdBidsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdBidsResource> DbsApi::getCampaignsCampaignIdBidsResource() {
    if (!m_spCampaignsCampaignIdBidsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdBidsResource>());
    }
    return m_spCampaignsCampaignIdBidsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource> DbsApi::getCampaignsCampaignIdFeedsFeedIdRefreshResource() {
    if (!m_spCampaignsCampaignIdFeedsFeedIdRefreshResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource>());
    }
    return m_spCampaignsCampaignIdFeedsFeedIdRefreshResource;
}
std::shared_ptr<DbsApiResources::RegionsRegionIdChildrenResource> DbsApi::getRegionsRegionIdChildrenResource() {
    if (!m_spRegionsRegionIdChildrenResource) {
        setResource(std::make_shared<DbsApiResources::RegionsRegionIdChildrenResource>());
    }
    return m_spRegionsRegionIdChildrenResource;
}
std::shared_ptr<DbsApiResources::RegionsRegionIdResource> DbsApi::getRegionsRegionIdResource() {
    if (!m_spRegionsRegionIdResource) {
        setResource(std::make_shared<DbsApiResources::RegionsRegionIdResource>());
    }
    return m_spRegionsRegionIdResource;
}
std::shared_ptr<DbsApiResources::RegionsResource> DbsApi::getRegionsResource() {
    if (!m_spRegionsResource) {
        setResource(std::make_shared<DbsApiResources::RegionsResource>());
    }
    return m_spRegionsResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsFileSendResource> DbsApi::getBusinessesBusinessIdChatsFileSendResource() {
    if (!m_spBusinessesBusinessIdChatsFileSendResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsFileSendResource>());
    }
    return m_spBusinessesBusinessIdChatsFileSendResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsMessageResource> DbsApi::getBusinessesBusinessIdChatsMessageResource() {
    if (!m_spBusinessesBusinessIdChatsMessageResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsMessageResource>());
    }
    return m_spBusinessesBusinessIdChatsMessageResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource> DbsApi::getCampaignsCampaignIdFeedsFeedIdParamsResource() {
    if (!m_spCampaignsCampaignIdFeedsFeedIdParamsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource>());
    }
    return m_spCampaignsCampaignIdFeedsFeedIdParamsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBoxesResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdBoxesResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdBoxesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBoxesResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdBoxesResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryDateResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdDeliveryDateResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryDateResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryDateResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDeliveryDateResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource> DbsApi::getBusinessesBusinessIdGoods_feedbackSkip_reactionResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource> DbsApi::getBusinessesBusinessIdOffer_pricesUpdatesResource() {
    if (!m_spBusinessesBusinessIdOffer_pricesUpdatesResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource>());
    }
    return m_spBusinessesBusinessIdOffer_pricesUpdatesResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersUpdateResource> DbsApi::getCampaignsCampaignIdOffersUpdateResource() {
    if (!m_spCampaignsCampaignIdOffersUpdateResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersUpdateResource>());
    }
    return m_spCampaignsCampaignIdOffersUpdateResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource> DbsApi::getBusinessesBusinessIdGoods_feedbackCommentsUpdateResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_cardsUpdateResource> DbsApi::getBusinessesBusinessIdOffer_cardsUpdateResource() {
    if (!m_spBusinessesBusinessIdOffer_cardsUpdateResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_cardsUpdateResource>());
    }
    return m_spBusinessesBusinessIdOffer_cardsUpdateResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource> DbsApi::getCampaignsCampaignIdOffer_mapping_entriesUpdatesResource() {
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource>());
    }
    return m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource> DbsApi::getBusinessesBusinessIdOffer_mappingsUpdateResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsUpdateResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsUpdateResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdItemsResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdItemsResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdItemsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdItemsResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdItemsResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdStatusResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdStatusResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdStatusResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdStatusResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdStatusResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersStatus_updateResource> DbsApi::getCampaignsCampaignIdOrdersStatus_updateResource() {
    if (!m_spCampaignsCampaignIdOrdersStatus_updateResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersStatus_updateResource>());
    }
    return m_spCampaignsCampaignIdOrdersStatus_updateResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource> DbsApi::getCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource;
}
std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource> DbsApi::getCampaignsCampaignIdOffer_pricesUpdatesResource() {
    if (!m_spCampaignsCampaignIdOffer_pricesUpdatesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource>());
    }
    return m_spCampaignsCampaignIdOffer_pricesUpdatesResource;
}
std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosOffersUpdateResource> DbsApi::getBusinessesBusinessIdPromosOffersUpdateResource() {
    if (!m_spBusinessesBusinessIdPromosOffersUpdateResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPromosOffersUpdateResource>());
    }
    return m_spBusinessesBusinessIdPromosOffersUpdateResource;
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdHidden_offersResource> resource) {
    m_spCampaignsCampaignIdHidden_offersResource = resource;
    m_service->publish(m_spCampaignsCampaignIdHidden_offersResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsArchiveResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsArchiveResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::TariffsCalculateResource> resource) {
    m_spTariffsCalculateResource = resource;
    m_service->publish(m_spTariffsCalculateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource> resource) {
    m_spBusinessesBusinessIdPrice_quarantineConfirmResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPrice_quarantineConfirmResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource> resource) {
    m_spCampaignsCampaignIdPrice_quarantineConfirmResource = resource;
    m_service->publish(m_spCampaignsCampaignIdPrice_quarantineConfirmResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsNewResource> resource) {
    m_spBusinessesBusinessIdChatsNewResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsNewResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOutletsResource> resource) {
    m_spCampaignsCampaignIdOutletsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOutletsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersDeleteResource> resource) {
    m_spCampaignsCampaignIdOffersDeleteResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersDeleteResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdHidden_offersDeleteResource> resource) {
    m_spCampaignsCampaignIdHidden_offersDeleteResource = resource;
    m_service->publish(m_spCampaignsCampaignIdHidden_offersDeleteResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsDeleteResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsDeleteResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOutletsOutletIdResource> resource) {
    m_spCampaignsCampaignIdOutletsOutletIdResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOutletsOutletIdResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOutletsLicensesResource> resource) {
    m_spCampaignsCampaignIdOutletsLicensesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOutletsLicensesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosOffersDeleteResource> resource) {
    m_spBusinessesBusinessIdPromosOffersDeleteResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersDeleteResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsBoost_consolidatedGenerateResource> resource) {
    m_spReportsBoost_consolidatedGenerateResource = resource;
    m_service->publish(m_spReportsBoost_consolidatedGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsCompetitors_positionGenerateResource> resource) {
    m_spReportsCompetitors_positionGenerateResource = resource;
    m_service->publish(m_spReportsCompetitors_positionGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsGoods_feedbackGenerateResource> resource) {
    m_spReportsGoods_feedbackGenerateResource = resource;
    m_service->publish(m_spReportsGoods_feedbackGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsDocumentsLabelsGenerateResource> resource) {
    m_spReportsDocumentsLabelsGenerateResource = resource;
    m_service->publish(m_spReportsDocumentsLabelsGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsPricesGenerateResource> resource) {
    m_spReportsPricesGenerateResource = resource;
    m_service->publish(m_spReportsPricesGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsShelf_statisticsGenerateResource> resource) {
    m_spReportsShelf_statisticsGenerateResource = resource;
    m_service->publish(m_spReportsShelf_statisticsGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsShows_salesGenerateResource> resource) {
    m_spReportsShows_salesGenerateResource = resource;
    m_service->publish(m_spReportsShows_salesGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsStocks_on_warehousesGenerateResource> resource) {
    m_spReportsStocks_on_warehousesGenerateResource = resource;
    m_service->publish(m_spReportsStocks_on_warehousesGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsUnited_marketplace_servicesGenerateResource> resource) {
    m_spReportsUnited_marketplace_servicesGenerateResource = resource;
    m_service->publish(m_spReportsUnited_marketplace_servicesGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsUnited_nettingGenerateResource> resource) {
    m_spReportsUnited_nettingGenerateResource = resource;
    m_service->publish(m_spReportsUnited_nettingGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsUnited_ordersGenerateResource> resource) {
    m_spReportsUnited_ordersGenerateResource = resource;
    m_service->publish(m_spReportsUnited_ordersGenerateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersAllResource> resource) {
    m_spCampaignsCampaignIdOffersAllResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersAllResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdBidsInfoResource> resource) {
    m_spBusinessesBusinessIdBidsInfoResource = resource;
    m_service->publish(m_spBusinessesBusinessIdBidsInfoResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdBidsRecommendationsResource> resource) {
    m_spBusinessesBusinessIdBidsRecommendationsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdBidsRecommendationsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPrice_quarantineResource> resource) {
    m_spBusinessesBusinessIdPrice_quarantineResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPrice_quarantineResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdSettingsResource> resource) {
    m_spBusinessesBusinessIdSettingsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdSettingsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdResource> resource) {
    m_spCampaignsCampaignIdResource = resource;
    m_service->publish(m_spCampaignsCampaignIdResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdLoginsResource> resource) {
    m_spCampaignsCampaignIdLoginsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdLoginsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersResource> resource) {
    m_spCampaignsCampaignIdOffersResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdPrice_quarantineResource> resource) {
    m_spCampaignsCampaignIdPrice_quarantineResource = resource;
    m_service->publish(m_spCampaignsCampaignIdPrice_quarantineResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdRegionResource> resource) {
    m_spCampaignsCampaignIdRegionResource = resource;
    m_service->publish(m_spCampaignsCampaignIdRegionResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdSettingsResource> resource) {
    m_spCampaignsCampaignIdSettingsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdSettingsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsResource> resource) {
    m_spCampaignsResource = resource;
    m_service->publish(m_spCampaignsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsBy_loginLoginResource> resource) {
    m_spCampaignsBy_loginLoginResource = resource;
    m_service->publish(m_spCampaignsBy_loginLoginResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CategoriesMax_sale_quantumResource> resource) {
    m_spCategoriesMax_sale_quantumResource = resource;
    m_service->publish(m_spCategoriesMax_sale_quantumResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CategoriesTreeResource> resource) {
    m_spCategoriesTreeResource = resource;
    m_service->publish(m_spCategoriesTreeResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CategoryCategoryIdParametersResource> resource) {
    m_spCategoryCategoryIdParametersResource = resource;
    m_service->publish(m_spCategoryCategoryIdParametersResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsHistoryResource> resource) {
    m_spBusinessesBusinessIdChatsHistoryResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsHistoryResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsResource> resource) {
    m_spBusinessesBusinessIdChatsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::DeliveryServicesResource> resource) {
    m_spDeliveryServicesResource = resource;
    m_service->publish(m_spDeliveryServicesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdResource> resource) {
    m_spCampaignsCampaignIdFeedsFeedIdResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource> resource) {
    m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedbackUpdatesResource> resource) {
    m_spCampaignsCampaignIdFeedbackUpdatesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedbackUpdatesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsResource> resource) {
    m_spCampaignsCampaignIdFeedsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdStatsSkusResource> resource) {
    m_spCampaignsCampaignIdStatsSkusResource = resource;
    m_service->publish(m_spCampaignsCampaignIdStatsSkusResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ModelsModelIdResource> resource) {
    m_spModelsModelIdResource = resource;
    m_service->publish(m_spModelsModelIdResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ModelsModelIdOffersResource> resource) {
    m_spModelsModelIdOffersResource = resource;
    m_service->publish(m_spModelsModelIdOffersResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ModelsResource> resource) {
    m_spModelsResource = resource;
    m_service->publish(m_spModelsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ModelsOffersResource> resource) {
    m_spModelsOffersResource = resource;
    m_service->publish(m_spModelsOffersResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_cardsResource> resource) {
    m_spBusinessesBusinessIdOffer_cardsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_cardsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesResource> resource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffersRecommendationsResource> resource) {
    m_spBusinessesBusinessIdOffersRecommendationsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffersRecommendationsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBuyerResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdBuyerResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdBuyerResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersResource> resource) {
    m_spCampaignsCampaignIdOrdersResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdStatsOrdersResource> resource) {
    m_spCampaignsCampaignIdStatsOrdersResource = resource;
    m_service->publish(m_spCampaignsCampaignIdStatsOrdersResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_pricesResource> resource) {
    m_spCampaignsCampaignIdOffer_pricesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosOffersResource> resource) {
    m_spBusinessesBusinessIdPromosOffersResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosResource> resource) {
    m_spBusinessesBusinessIdPromosResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPromosResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdRatingsQualityDetailsResource> resource) {
    m_spCampaignsCampaignIdRatingsQualityDetailsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdRatingsQualityDetailsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdRatingsQualityResource> resource) {
    m_spBusinessesBusinessIdRatingsQualityResource = resource;
    m_service->publish(m_spBusinessesBusinessIdRatingsQualityResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::ReportsInfoReportIdResource> resource) {
    m_spReportsInfoReportIdResource = resource;
    m_service->publish(m_spReportsInfoReportIdResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdReturnsResource> resource) {
    m_spCampaignsCampaignIdReturnsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdReturnsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersStocksResource> resource) {
    m_spCampaignsCampaignIdOffersStocksResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersStocksResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource> resource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource> resource) {
    m_spCampaignsCampaignIdOffer_pricesSuggestionsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesSuggestionsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdWarehousesResource> resource) {
    m_spBusinessesBusinessIdWarehousesResource = resource;
    m_service->publish(m_spBusinessesBusinessIdWarehousesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdIdentifiersResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdIdentifiersResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdIdentifiersResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdBidsResource> resource) {
    m_spBusinessesBusinessIdBidsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdBidsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdBidsResource> resource) {
    m_spCampaignsCampaignIdBidsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdBidsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource> resource) {
    m_spCampaignsCampaignIdFeedsFeedIdRefreshResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdRefreshResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::RegionsRegionIdChildrenResource> resource) {
    m_spRegionsRegionIdChildrenResource = resource;
    m_service->publish(m_spRegionsRegionIdChildrenResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::RegionsRegionIdResource> resource) {
    m_spRegionsRegionIdResource = resource;
    m_service->publish(m_spRegionsRegionIdResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::RegionsResource> resource) {
    m_spRegionsResource = resource;
    m_service->publish(m_spRegionsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsFileSendResource> resource) {
    m_spBusinessesBusinessIdChatsFileSendResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsFileSendResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsMessageResource> resource) {
    m_spBusinessesBusinessIdChatsMessageResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsMessageResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource> resource) {
    m_spCampaignsCampaignIdFeedsFeedIdParamsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdParamsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBoxesResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdBoxesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdBoxesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryDateResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryDateResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryDateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource> resource) {
    m_spBusinessesBusinessIdOffer_pricesUpdatesResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_pricesUpdatesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersUpdateResource> resource) {
    m_spCampaignsCampaignIdOffersUpdateResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersUpdateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_cardsUpdateResource> resource) {
    m_spBusinessesBusinessIdOffer_cardsUpdateResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_cardsUpdateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource> resource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsUpdateResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsUpdateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdItemsResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdItemsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdItemsResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdStatusResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdStatusResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdStatusResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersStatus_updateResource> resource) {
    m_spCampaignsCampaignIdOrdersStatus_updateResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersStatus_updateResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource> resource) {
    m_spCampaignsCampaignIdOffer_pricesUpdatesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesUpdatesResource);
}
void DbsApi::setResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosOffersUpdateResource> resource) {
    m_spBusinessesBusinessIdPromosOffersUpdateResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersUpdateResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource> spCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource) {
    m_spCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource = spCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdHidden_offersResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdHidden_offersResource> spCampaignsCampaignIdHidden_offersResource) {
    m_spCampaignsCampaignIdHidden_offersResource = spCampaignsCampaignIdHidden_offersResource;
    m_service->publish(m_spCampaignsCampaignIdHidden_offersResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffer_mappingsArchiveResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource> spBusinessesBusinessIdOffer_mappingsArchiveResource) {
    m_spBusinessesBusinessIdOffer_mappingsArchiveResource = spBusinessesBusinessIdOffer_mappingsArchiveResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsArchiveResource);
}
void DbsApi::setDbsApiTariffsCalculateResource(std::shared_ptr<DbsApiResources::TariffsCalculateResource> spTariffsCalculateResource) {
    m_spTariffsCalculateResource = spTariffsCalculateResource;
    m_service->publish(m_spTariffsCalculateResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdPrice_quarantineConfirmResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource> spBusinessesBusinessIdPrice_quarantineConfirmResource) {
    m_spBusinessesBusinessIdPrice_quarantineConfirmResource = spBusinessesBusinessIdPrice_quarantineConfirmResource;
    m_service->publish(m_spBusinessesBusinessIdPrice_quarantineConfirmResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdPrice_quarantineConfirmResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource> spCampaignsCampaignIdPrice_quarantineConfirmResource) {
    m_spCampaignsCampaignIdPrice_quarantineConfirmResource = spCampaignsCampaignIdPrice_quarantineConfirmResource;
    m_service->publish(m_spCampaignsCampaignIdPrice_quarantineConfirmResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdChatsNewResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsNewResource> spBusinessesBusinessIdChatsNewResource) {
    m_spBusinessesBusinessIdChatsNewResource = spBusinessesBusinessIdChatsNewResource;
    m_service->publish(m_spBusinessesBusinessIdChatsNewResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOutletsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOutletsResource> spCampaignsCampaignIdOutletsResource) {
    m_spCampaignsCampaignIdOutletsResource = spCampaignsCampaignIdOutletsResource;
    m_service->publish(m_spCampaignsCampaignIdOutletsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffersDeleteResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersDeleteResource> spCampaignsCampaignIdOffersDeleteResource) {
    m_spCampaignsCampaignIdOffersDeleteResource = spCampaignsCampaignIdOffersDeleteResource;
    m_service->publish(m_spCampaignsCampaignIdOffersDeleteResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdGoods_feedbackCommentsDeleteResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource> spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource = spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdHidden_offersDeleteResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdHidden_offersDeleteResource> spCampaignsCampaignIdHidden_offersDeleteResource) {
    m_spCampaignsCampaignIdHidden_offersDeleteResource = spCampaignsCampaignIdHidden_offersDeleteResource;
    m_service->publish(m_spCampaignsCampaignIdHidden_offersDeleteResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffer_mappingsDeleteResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource> spBusinessesBusinessIdOffer_mappingsDeleteResource) {
    m_spBusinessesBusinessIdOffer_mappingsDeleteResource = spBusinessesBusinessIdOffer_mappingsDeleteResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsDeleteResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffer_mappingsUnarchiveResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource> spBusinessesBusinessIdOffer_mappingsUnarchiveResource) {
    m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource = spBusinessesBusinessIdOffer_mappingsUnarchiveResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOutletsOutletIdResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOutletsOutletIdResource> spCampaignsCampaignIdOutletsOutletIdResource) {
    m_spCampaignsCampaignIdOutletsOutletIdResource = spCampaignsCampaignIdOutletsOutletIdResource;
    m_service->publish(m_spCampaignsCampaignIdOutletsOutletIdResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOutletsLicensesResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOutletsLicensesResource> spCampaignsCampaignIdOutletsLicensesResource) {
    m_spCampaignsCampaignIdOutletsLicensesResource = spCampaignsCampaignIdOutletsLicensesResource;
    m_service->publish(m_spCampaignsCampaignIdOutletsLicensesResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdPromosOffersDeleteResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosOffersDeleteResource> spBusinessesBusinessIdPromosOffersDeleteResource) {
    m_spBusinessesBusinessIdPromosOffersDeleteResource = spBusinessesBusinessIdPromosOffersDeleteResource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersDeleteResource);
}
void DbsApi::setDbsApiReportsBoost_consolidatedGenerateResource(std::shared_ptr<DbsApiResources::ReportsBoost_consolidatedGenerateResource> spReportsBoost_consolidatedGenerateResource) {
    m_spReportsBoost_consolidatedGenerateResource = spReportsBoost_consolidatedGenerateResource;
    m_service->publish(m_spReportsBoost_consolidatedGenerateResource);
}
void DbsApi::setDbsApiReportsCompetitors_positionGenerateResource(std::shared_ptr<DbsApiResources::ReportsCompetitors_positionGenerateResource> spReportsCompetitors_positionGenerateResource) {
    m_spReportsCompetitors_positionGenerateResource = spReportsCompetitors_positionGenerateResource;
    m_service->publish(m_spReportsCompetitors_positionGenerateResource);
}
void DbsApi::setDbsApiReportsGoods_feedbackGenerateResource(std::shared_ptr<DbsApiResources::ReportsGoods_feedbackGenerateResource> spReportsGoods_feedbackGenerateResource) {
    m_spReportsGoods_feedbackGenerateResource = spReportsGoods_feedbackGenerateResource;
    m_service->publish(m_spReportsGoods_feedbackGenerateResource);
}
void DbsApi::setDbsApiReportsDocumentsLabelsGenerateResource(std::shared_ptr<DbsApiResources::ReportsDocumentsLabelsGenerateResource> spReportsDocumentsLabelsGenerateResource) {
    m_spReportsDocumentsLabelsGenerateResource = spReportsDocumentsLabelsGenerateResource;
    m_service->publish(m_spReportsDocumentsLabelsGenerateResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource> spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource = spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource> spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource = spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource);
}
void DbsApi::setDbsApiReportsPricesGenerateResource(std::shared_ptr<DbsApiResources::ReportsPricesGenerateResource> spReportsPricesGenerateResource) {
    m_spReportsPricesGenerateResource = spReportsPricesGenerateResource;
    m_service->publish(m_spReportsPricesGenerateResource);
}
void DbsApi::setDbsApiReportsShelf_statisticsGenerateResource(std::shared_ptr<DbsApiResources::ReportsShelf_statisticsGenerateResource> spReportsShelf_statisticsGenerateResource) {
    m_spReportsShelf_statisticsGenerateResource = spReportsShelf_statisticsGenerateResource;
    m_service->publish(m_spReportsShelf_statisticsGenerateResource);
}
void DbsApi::setDbsApiReportsShows_salesGenerateResource(std::shared_ptr<DbsApiResources::ReportsShows_salesGenerateResource> spReportsShows_salesGenerateResource) {
    m_spReportsShows_salesGenerateResource = spReportsShows_salesGenerateResource;
    m_service->publish(m_spReportsShows_salesGenerateResource);
}
void DbsApi::setDbsApiReportsStocks_on_warehousesGenerateResource(std::shared_ptr<DbsApiResources::ReportsStocks_on_warehousesGenerateResource> spReportsStocks_on_warehousesGenerateResource) {
    m_spReportsStocks_on_warehousesGenerateResource = spReportsStocks_on_warehousesGenerateResource;
    m_service->publish(m_spReportsStocks_on_warehousesGenerateResource);
}
void DbsApi::setDbsApiReportsUnited_marketplace_servicesGenerateResource(std::shared_ptr<DbsApiResources::ReportsUnited_marketplace_servicesGenerateResource> spReportsUnited_marketplace_servicesGenerateResource) {
    m_spReportsUnited_marketplace_servicesGenerateResource = spReportsUnited_marketplace_servicesGenerateResource;
    m_service->publish(m_spReportsUnited_marketplace_servicesGenerateResource);
}
void DbsApi::setDbsApiReportsUnited_nettingGenerateResource(std::shared_ptr<DbsApiResources::ReportsUnited_nettingGenerateResource> spReportsUnited_nettingGenerateResource) {
    m_spReportsUnited_nettingGenerateResource = spReportsUnited_nettingGenerateResource;
    m_service->publish(m_spReportsUnited_nettingGenerateResource);
}
void DbsApi::setDbsApiReportsUnited_ordersGenerateResource(std::shared_ptr<DbsApiResources::ReportsUnited_ordersGenerateResource> spReportsUnited_ordersGenerateResource) {
    m_spReportsUnited_ordersGenerateResource = spReportsUnited_ordersGenerateResource;
    m_service->publish(m_spReportsUnited_ordersGenerateResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffersAllResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersAllResource> spCampaignsCampaignIdOffersAllResource) {
    m_spCampaignsCampaignIdOffersAllResource = spCampaignsCampaignIdOffersAllResource;
    m_service->publish(m_spCampaignsCampaignIdOffersAllResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdBidsInfoResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdBidsInfoResource> spBusinessesBusinessIdBidsInfoResource) {
    m_spBusinessesBusinessIdBidsInfoResource = spBusinessesBusinessIdBidsInfoResource;
    m_service->publish(m_spBusinessesBusinessIdBidsInfoResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdBidsRecommendationsResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdBidsRecommendationsResource> spBusinessesBusinessIdBidsRecommendationsResource) {
    m_spBusinessesBusinessIdBidsRecommendationsResource = spBusinessesBusinessIdBidsRecommendationsResource;
    m_service->publish(m_spBusinessesBusinessIdBidsRecommendationsResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdPrice_quarantineResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPrice_quarantineResource> spBusinessesBusinessIdPrice_quarantineResource) {
    m_spBusinessesBusinessIdPrice_quarantineResource = spBusinessesBusinessIdPrice_quarantineResource;
    m_service->publish(m_spBusinessesBusinessIdPrice_quarantineResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdSettingsResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdSettingsResource> spBusinessesBusinessIdSettingsResource) {
    m_spBusinessesBusinessIdSettingsResource = spBusinessesBusinessIdSettingsResource;
    m_service->publish(m_spBusinessesBusinessIdSettingsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdResource> spCampaignsCampaignIdResource) {
    m_spCampaignsCampaignIdResource = spCampaignsCampaignIdResource;
    m_service->publish(m_spCampaignsCampaignIdResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdLoginsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdLoginsResource> spCampaignsCampaignIdLoginsResource) {
    m_spCampaignsCampaignIdLoginsResource = spCampaignsCampaignIdLoginsResource;
    m_service->publish(m_spCampaignsCampaignIdLoginsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffersResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersResource> spCampaignsCampaignIdOffersResource) {
    m_spCampaignsCampaignIdOffersResource = spCampaignsCampaignIdOffersResource;
    m_service->publish(m_spCampaignsCampaignIdOffersResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdPrice_quarantineResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdPrice_quarantineResource> spCampaignsCampaignIdPrice_quarantineResource) {
    m_spCampaignsCampaignIdPrice_quarantineResource = spCampaignsCampaignIdPrice_quarantineResource;
    m_service->publish(m_spCampaignsCampaignIdPrice_quarantineResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdRegionResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdRegionResource> spCampaignsCampaignIdRegionResource) {
    m_spCampaignsCampaignIdRegionResource = spCampaignsCampaignIdRegionResource;
    m_service->publish(m_spCampaignsCampaignIdRegionResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdSettingsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdSettingsResource> spCampaignsCampaignIdSettingsResource) {
    m_spCampaignsCampaignIdSettingsResource = spCampaignsCampaignIdSettingsResource;
    m_service->publish(m_spCampaignsCampaignIdSettingsResource);
}
void DbsApi::setDbsApiCampaignsResource(std::shared_ptr<DbsApiResources::CampaignsResource> spCampaignsResource) {
    m_spCampaignsResource = spCampaignsResource;
    m_service->publish(m_spCampaignsResource);
}
void DbsApi::setDbsApiCampaignsBy_loginLoginResource(std::shared_ptr<DbsApiResources::CampaignsBy_loginLoginResource> spCampaignsBy_loginLoginResource) {
    m_spCampaignsBy_loginLoginResource = spCampaignsBy_loginLoginResource;
    m_service->publish(m_spCampaignsBy_loginLoginResource);
}
void DbsApi::setDbsApiCategoriesMax_sale_quantumResource(std::shared_ptr<DbsApiResources::CategoriesMax_sale_quantumResource> spCategoriesMax_sale_quantumResource) {
    m_spCategoriesMax_sale_quantumResource = spCategoriesMax_sale_quantumResource;
    m_service->publish(m_spCategoriesMax_sale_quantumResource);
}
void DbsApi::setDbsApiCategoriesTreeResource(std::shared_ptr<DbsApiResources::CategoriesTreeResource> spCategoriesTreeResource) {
    m_spCategoriesTreeResource = spCategoriesTreeResource;
    m_service->publish(m_spCategoriesTreeResource);
}
void DbsApi::setDbsApiCategoryCategoryIdParametersResource(std::shared_ptr<DbsApiResources::CategoryCategoryIdParametersResource> spCategoryCategoryIdParametersResource) {
    m_spCategoryCategoryIdParametersResource = spCategoryCategoryIdParametersResource;
    m_service->publish(m_spCategoryCategoryIdParametersResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdChatsHistoryResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsHistoryResource> spBusinessesBusinessIdChatsHistoryResource) {
    m_spBusinessesBusinessIdChatsHistoryResource = spBusinessesBusinessIdChatsHistoryResource;
    m_service->publish(m_spBusinessesBusinessIdChatsHistoryResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdChatsResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsResource> spBusinessesBusinessIdChatsResource) {
    m_spBusinessesBusinessIdChatsResource = spBusinessesBusinessIdChatsResource;
    m_service->publish(m_spBusinessesBusinessIdChatsResource);
}
void DbsApi::setDbsApiDeliveryServicesResource(std::shared_ptr<DbsApiResources::DeliveryServicesResource> spDeliveryServicesResource) {
    m_spDeliveryServicesResource = spDeliveryServicesResource;
    m_service->publish(m_spDeliveryServicesResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdFeedsFeedIdResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdResource> spCampaignsCampaignIdFeedsFeedIdResource) {
    m_spCampaignsCampaignIdFeedsFeedIdResource = spCampaignsCampaignIdFeedsFeedIdResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdFeedsFeedIdIndex_logsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource> spCampaignsCampaignIdFeedsFeedIdIndex_logsResource) {
    m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource = spCampaignsCampaignIdFeedsFeedIdIndex_logsResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdFeedbackUpdatesResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedbackUpdatesResource> spCampaignsCampaignIdFeedbackUpdatesResource) {
    m_spCampaignsCampaignIdFeedbackUpdatesResource = spCampaignsCampaignIdFeedbackUpdatesResource;
    m_service->publish(m_spCampaignsCampaignIdFeedbackUpdatesResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdFeedsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsResource> spCampaignsCampaignIdFeedsResource) {
    m_spCampaignsCampaignIdFeedsResource = spCampaignsCampaignIdFeedsResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdGoods_feedbackCommentsResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource> spBusinessesBusinessIdGoods_feedbackCommentsResource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsResource = spBusinessesBusinessIdGoods_feedbackCommentsResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdGoods_feedbackResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackResource> spBusinessesBusinessIdGoods_feedbackResource) {
    m_spBusinessesBusinessIdGoods_feedbackResource = spBusinessesBusinessIdGoods_feedbackResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdStatsSkusResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdStatsSkusResource> spCampaignsCampaignIdStatsSkusResource) {
    m_spCampaignsCampaignIdStatsSkusResource = spCampaignsCampaignIdStatsSkusResource;
    m_service->publish(m_spCampaignsCampaignIdStatsSkusResource);
}
void DbsApi::setDbsApiModelsModelIdResource(std::shared_ptr<DbsApiResources::ModelsModelIdResource> spModelsModelIdResource) {
    m_spModelsModelIdResource = spModelsModelIdResource;
    m_service->publish(m_spModelsModelIdResource);
}
void DbsApi::setDbsApiModelsModelIdOffersResource(std::shared_ptr<DbsApiResources::ModelsModelIdOffersResource> spModelsModelIdOffersResource) {
    m_spModelsModelIdOffersResource = spModelsModelIdOffersResource;
    m_service->publish(m_spModelsModelIdOffersResource);
}
void DbsApi::setDbsApiModelsResource(std::shared_ptr<DbsApiResources::ModelsResource> spModelsResource) {
    m_spModelsResource = spModelsResource;
    m_service->publish(m_spModelsResource);
}
void DbsApi::setDbsApiModelsOffersResource(std::shared_ptr<DbsApiResources::ModelsOffersResource> spModelsOffersResource) {
    m_spModelsOffersResource = spModelsOffersResource;
    m_service->publish(m_spModelsOffersResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffer_cardsResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_cardsResource> spBusinessesBusinessIdOffer_cardsResource) {
    m_spBusinessesBusinessIdOffer_cardsResource = spBusinessesBusinessIdOffer_cardsResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_cardsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffer_mapping_entriesResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesResource> spCampaignsCampaignIdOffer_mapping_entriesResource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesResource = spCampaignsCampaignIdOffer_mapping_entriesResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffer_mappingsResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsResource> spBusinessesBusinessIdOffer_mappingsResource) {
    m_spBusinessesBusinessIdOffer_mappingsResource = spBusinessesBusinessIdOffer_mappingsResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffersRecommendationsResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffersRecommendationsResource> spBusinessesBusinessIdOffersRecommendationsResource) {
    m_spBusinessesBusinessIdOffersRecommendationsResource = spBusinessesBusinessIdOffersRecommendationsResource;
    m_service->publish(m_spBusinessesBusinessIdOffersRecommendationsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdResource> spCampaignsCampaignIdOrdersOrderIdResource) {
    m_spCampaignsCampaignIdOrdersOrderIdResource = spCampaignsCampaignIdOrdersOrderIdResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource> spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource) {
    m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource = spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdDocumentsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource> spCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource = spCampaignsCampaignIdOrdersOrderIdDocumentsResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdBuyerResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBuyerResource> spCampaignsCampaignIdOrdersOrderIdBuyerResource) {
    m_spCampaignsCampaignIdOrdersOrderIdBuyerResource = spCampaignsCampaignIdOrdersOrderIdBuyerResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdBuyerResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource> spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource = spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersResource> spCampaignsCampaignIdOrdersResource) {
    m_spCampaignsCampaignIdOrdersResource = spCampaignsCampaignIdOrdersResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdStatsOrdersResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdStatsOrdersResource> spCampaignsCampaignIdStatsOrdersResource) {
    m_spCampaignsCampaignIdStatsOrdersResource = spCampaignsCampaignIdStatsOrdersResource;
    m_service->publish(m_spCampaignsCampaignIdStatsOrdersResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffer_pricesResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_pricesResource> spCampaignsCampaignIdOffer_pricesResource) {
    m_spCampaignsCampaignIdOffer_pricesResource = spCampaignsCampaignIdOffer_pricesResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdPromosOffersResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosOffersResource> spBusinessesBusinessIdPromosOffersResource) {
    m_spBusinessesBusinessIdPromosOffersResource = spBusinessesBusinessIdPromosOffersResource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdPromosResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosResource> spBusinessesBusinessIdPromosResource) {
    m_spBusinessesBusinessIdPromosResource = spBusinessesBusinessIdPromosResource;
    m_service->publish(m_spBusinessesBusinessIdPromosResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdRatingsQualityDetailsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdRatingsQualityDetailsResource> spCampaignsCampaignIdRatingsQualityDetailsResource) {
    m_spCampaignsCampaignIdRatingsQualityDetailsResource = spCampaignsCampaignIdRatingsQualityDetailsResource;
    m_service->publish(m_spCampaignsCampaignIdRatingsQualityDetailsResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdRatingsQualityResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdRatingsQualityResource> spBusinessesBusinessIdRatingsQualityResource) {
    m_spBusinessesBusinessIdRatingsQualityResource = spBusinessesBusinessIdRatingsQualityResource;
    m_service->publish(m_spBusinessesBusinessIdRatingsQualityResource);
}
void DbsApi::setDbsApiReportsInfoReportIdResource(std::shared_ptr<DbsApiResources::ReportsInfoReportIdResource> spReportsInfoReportIdResource) {
    m_spReportsInfoReportIdResource = spReportsInfoReportIdResource;
    m_service->publish(m_spReportsInfoReportIdResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource> spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource = spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource> spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource = spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource> spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource = spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdReturnsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdReturnsResource> spCampaignsCampaignIdReturnsResource) {
    m_spCampaignsCampaignIdReturnsResource = spCampaignsCampaignIdReturnsResource;
    m_service->publish(m_spCampaignsCampaignIdReturnsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffersStocksResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersStocksResource> spCampaignsCampaignIdOffersStocksResource) {
    m_spCampaignsCampaignIdOffersStocksResource = spCampaignsCampaignIdOffersStocksResource;
    m_service->publish(m_spCampaignsCampaignIdOffersStocksResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource> spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource = spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffer_mappingsSuggestionsResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource> spBusinessesBusinessIdOffer_mappingsSuggestionsResource) {
    m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource = spBusinessesBusinessIdOffer_mappingsSuggestionsResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffer_pricesSuggestionsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource> spCampaignsCampaignIdOffer_pricesSuggestionsResource) {
    m_spCampaignsCampaignIdOffer_pricesSuggestionsResource = spCampaignsCampaignIdOffer_pricesSuggestionsResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesSuggestionsResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdWarehousesResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdWarehousesResource> spBusinessesBusinessIdWarehousesResource) {
    m_spBusinessesBusinessIdWarehousesResource = spBusinessesBusinessIdWarehousesResource;
    m_service->publish(m_spBusinessesBusinessIdWarehousesResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource> spCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource = spCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdIdentifiersResource> spCampaignsCampaignIdOrdersOrderIdIdentifiersResource) {
    m_spCampaignsCampaignIdOrdersOrderIdIdentifiersResource = spCampaignsCampaignIdOrdersOrderIdIdentifiersResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdIdentifiersResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdBidsResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdBidsResource> spBusinessesBusinessIdBidsResource) {
    m_spBusinessesBusinessIdBidsResource = spBusinessesBusinessIdBidsResource;
    m_service->publish(m_spBusinessesBusinessIdBidsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdBidsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdBidsResource> spCampaignsCampaignIdBidsResource) {
    m_spCampaignsCampaignIdBidsResource = spCampaignsCampaignIdBidsResource;
    m_service->publish(m_spCampaignsCampaignIdBidsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdFeedsFeedIdRefreshResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource> spCampaignsCampaignIdFeedsFeedIdRefreshResource) {
    m_spCampaignsCampaignIdFeedsFeedIdRefreshResource = spCampaignsCampaignIdFeedsFeedIdRefreshResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdRefreshResource);
}
void DbsApi::setDbsApiRegionsRegionIdChildrenResource(std::shared_ptr<DbsApiResources::RegionsRegionIdChildrenResource> spRegionsRegionIdChildrenResource) {
    m_spRegionsRegionIdChildrenResource = spRegionsRegionIdChildrenResource;
    m_service->publish(m_spRegionsRegionIdChildrenResource);
}
void DbsApi::setDbsApiRegionsRegionIdResource(std::shared_ptr<DbsApiResources::RegionsRegionIdResource> spRegionsRegionIdResource) {
    m_spRegionsRegionIdResource = spRegionsRegionIdResource;
    m_service->publish(m_spRegionsRegionIdResource);
}
void DbsApi::setDbsApiRegionsResource(std::shared_ptr<DbsApiResources::RegionsResource> spRegionsResource) {
    m_spRegionsResource = spRegionsResource;
    m_service->publish(m_spRegionsResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdChatsFileSendResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsFileSendResource> spBusinessesBusinessIdChatsFileSendResource) {
    m_spBusinessesBusinessIdChatsFileSendResource = spBusinessesBusinessIdChatsFileSendResource;
    m_service->publish(m_spBusinessesBusinessIdChatsFileSendResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdChatsMessageResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdChatsMessageResource> spBusinessesBusinessIdChatsMessageResource) {
    m_spBusinessesBusinessIdChatsMessageResource = spBusinessesBusinessIdChatsMessageResource;
    m_service->publish(m_spBusinessesBusinessIdChatsMessageResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdFeedsFeedIdParamsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource> spCampaignsCampaignIdFeedsFeedIdParamsResource) {
    m_spCampaignsCampaignIdFeedsFeedIdParamsResource = spCampaignsCampaignIdFeedsFeedIdParamsResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdParamsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdBoxesResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBoxesResource> spCampaignsCampaignIdOrdersOrderIdBoxesResource) {
    m_spCampaignsCampaignIdOrdersOrderIdBoxesResource = spCampaignsCampaignIdOrdersOrderIdBoxesResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdBoxesResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdDeliveryDateResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryDateResource> spCampaignsCampaignIdOrdersOrderIdDeliveryDateResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryDateResource = spCampaignsCampaignIdOrdersOrderIdDeliveryDateResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryDateResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource> spCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource = spCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource> spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource = spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource> spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource = spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdGoods_feedbackSkip_reactionResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource> spBusinessesBusinessIdGoods_feedbackSkip_reactionResource) {
    m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource = spBusinessesBusinessIdGoods_feedbackSkip_reactionResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource> spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource = spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffer_pricesUpdatesResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource> spBusinessesBusinessIdOffer_pricesUpdatesResource) {
    m_spBusinessesBusinessIdOffer_pricesUpdatesResource = spBusinessesBusinessIdOffer_pricesUpdatesResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_pricesUpdatesResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffersUpdateResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffersUpdateResource> spCampaignsCampaignIdOffersUpdateResource) {
    m_spCampaignsCampaignIdOffersUpdateResource = spCampaignsCampaignIdOffersUpdateResource;
    m_service->publish(m_spCampaignsCampaignIdOffersUpdateResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdGoods_feedbackCommentsUpdateResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource> spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource = spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffer_cardsUpdateResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_cardsUpdateResource> spBusinessesBusinessIdOffer_cardsUpdateResource) {
    m_spBusinessesBusinessIdOffer_cardsUpdateResource = spBusinessesBusinessIdOffer_cardsUpdateResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_cardsUpdateResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffer_mapping_entriesUpdatesResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource> spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource = spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdOffer_mappingsUpdateResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource> spBusinessesBusinessIdOffer_mappingsUpdateResource) {
    m_spBusinessesBusinessIdOffer_mappingsUpdateResource = spBusinessesBusinessIdOffer_mappingsUpdateResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsUpdateResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdItemsResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdItemsResource> spCampaignsCampaignIdOrdersOrderIdItemsResource) {
    m_spCampaignsCampaignIdOrdersOrderIdItemsResource = spCampaignsCampaignIdOrdersOrderIdItemsResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdItemsResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdStatusResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdStatusResource> spCampaignsCampaignIdOrdersOrderIdStatusResource) {
    m_spCampaignsCampaignIdOrdersOrderIdStatusResource = spCampaignsCampaignIdOrdersOrderIdStatusResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdStatusResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersStatus_updateResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersStatus_updateResource> spCampaignsCampaignIdOrdersStatus_updateResource) {
    m_spCampaignsCampaignIdOrdersStatus_updateResource = spCampaignsCampaignIdOrdersStatus_updateResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersStatus_updateResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource> spCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource = spCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource);
}
void DbsApi::setDbsApiCampaignsCampaignIdOffer_pricesUpdatesResource(std::shared_ptr<DbsApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource> spCampaignsCampaignIdOffer_pricesUpdatesResource) {
    m_spCampaignsCampaignIdOffer_pricesUpdatesResource = spCampaignsCampaignIdOffer_pricesUpdatesResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesUpdatesResource);
}
void DbsApi::setDbsApiBusinessesBusinessIdPromosOffersUpdateResource(std::shared_ptr<DbsApiResources::BusinessesBusinessIdPromosOffersUpdateResource> spBusinessesBusinessIdPromosOffersUpdateResource) {
    m_spBusinessesBusinessIdPromosOffersUpdateResource = spBusinessesBusinessIdPromosOffersUpdateResource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersUpdateResource);
}


void DbsApi::publishDefaultResources() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdCancellationAcceptResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdCancellationAcceptResource>());
    }
    if (!m_spCampaignsCampaignIdHidden_offersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdHidden_offersResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsArchiveResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource>());
    }
    if (!m_spTariffsCalculateResource) {
        setResource(std::make_shared<DbsApiResources::TariffsCalculateResource>());
    }
    if (!m_spBusinessesBusinessIdPrice_quarantineConfirmResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource>());
    }
    if (!m_spCampaignsCampaignIdPrice_quarantineConfirmResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource>());
    }
    if (!m_spBusinessesBusinessIdChatsNewResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsNewResource>());
    }
    if (!m_spCampaignsCampaignIdOutletsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOutletsResource>());
    }
    if (!m_spCampaignsCampaignIdOffersDeleteResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersDeleteResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource>());
    }
    if (!m_spCampaignsCampaignIdHidden_offersDeleteResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdHidden_offersDeleteResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsDeleteResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource>());
    }
    if (!m_spCampaignsCampaignIdOutletsOutletIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOutletsOutletIdResource>());
    }
    if (!m_spCampaignsCampaignIdOutletsLicensesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOutletsLicensesResource>());
    }
    if (!m_spBusinessesBusinessIdPromosOffersDeleteResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPromosOffersDeleteResource>());
    }
    if (!m_spReportsBoost_consolidatedGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsBoost_consolidatedGenerateResource>());
    }
    if (!m_spReportsCompetitors_positionGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsCompetitors_positionGenerateResource>());
    }
    if (!m_spReportsGoods_feedbackGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsGoods_feedbackGenerateResource>());
    }
    if (!m_spReportsDocumentsLabelsGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsDocumentsLabelsGenerateResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource>());
    }
    if (!m_spReportsPricesGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsPricesGenerateResource>());
    }
    if (!m_spReportsShelf_statisticsGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsShelf_statisticsGenerateResource>());
    }
    if (!m_spReportsShows_salesGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsShows_salesGenerateResource>());
    }
    if (!m_spReportsStocks_on_warehousesGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsStocks_on_warehousesGenerateResource>());
    }
    if (!m_spReportsUnited_marketplace_servicesGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsUnited_marketplace_servicesGenerateResource>());
    }
    if (!m_spReportsUnited_nettingGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsUnited_nettingGenerateResource>());
    }
    if (!m_spReportsUnited_ordersGenerateResource) {
        setResource(std::make_shared<DbsApiResources::ReportsUnited_ordersGenerateResource>());
    }
    if (!m_spCampaignsCampaignIdOffersAllResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersAllResource>());
    }
    if (!m_spBusinessesBusinessIdBidsInfoResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdBidsInfoResource>());
    }
    if (!m_spBusinessesBusinessIdBidsRecommendationsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdBidsRecommendationsResource>());
    }
    if (!m_spBusinessesBusinessIdPrice_quarantineResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPrice_quarantineResource>());
    }
    if (!m_spBusinessesBusinessIdSettingsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdSettingsResource>());
    }
    if (!m_spCampaignsCampaignIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdResource>());
    }
    if (!m_spCampaignsCampaignIdLoginsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdLoginsResource>());
    }
    if (!m_spCampaignsCampaignIdOffersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersResource>());
    }
    if (!m_spCampaignsCampaignIdPrice_quarantineResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdPrice_quarantineResource>());
    }
    if (!m_spCampaignsCampaignIdRegionResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdRegionResource>());
    }
    if (!m_spCampaignsCampaignIdSettingsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdSettingsResource>());
    }
    if (!m_spCampaignsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsResource>());
    }
    if (!m_spCampaignsBy_loginLoginResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsBy_loginLoginResource>());
    }
    if (!m_spCategoriesMax_sale_quantumResource) {
        setResource(std::make_shared<DbsApiResources::CategoriesMax_sale_quantumResource>());
    }
    if (!m_spCategoriesTreeResource) {
        setResource(std::make_shared<DbsApiResources::CategoriesTreeResource>());
    }
    if (!m_spCategoryCategoryIdParametersResource) {
        setResource(std::make_shared<DbsApiResources::CategoryCategoryIdParametersResource>());
    }
    if (!m_spBusinessesBusinessIdChatsHistoryResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsHistoryResource>());
    }
    if (!m_spBusinessesBusinessIdChatsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsResource>());
    }
    if (!m_spDeliveryServicesResource) {
        setResource(std::make_shared<DbsApiResources::DeliveryServicesResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsFeedIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsFeedIdResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource>());
    }
    if (!m_spCampaignsCampaignIdFeedbackUpdatesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedbackUpdatesResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackResource>());
    }
    if (!m_spCampaignsCampaignIdStatsSkusResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdStatsSkusResource>());
    }
    if (!m_spModelsModelIdResource) {
        setResource(std::make_shared<DbsApiResources::ModelsModelIdResource>());
    }
    if (!m_spModelsModelIdOffersResource) {
        setResource(std::make_shared<DbsApiResources::ModelsModelIdOffersResource>());
    }
    if (!m_spModelsResource) {
        setResource(std::make_shared<DbsApiResources::ModelsResource>());
    }
    if (!m_spModelsOffersResource) {
        setResource(std::make_shared<DbsApiResources::ModelsOffersResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_cardsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_cardsResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsResource>());
    }
    if (!m_spBusinessesBusinessIdOffersRecommendationsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffersRecommendationsResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdBuyerResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBuyerResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersResource>());
    }
    if (!m_spCampaignsCampaignIdStatsOrdersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdStatsOrdersResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_pricesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_pricesResource>());
    }
    if (!m_spBusinessesBusinessIdPromosOffersResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPromosOffersResource>());
    }
    if (!m_spBusinessesBusinessIdPromosResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPromosResource>());
    }
    if (!m_spCampaignsCampaignIdRatingsQualityDetailsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdRatingsQualityDetailsResource>());
    }
    if (!m_spBusinessesBusinessIdRatingsQualityResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdRatingsQualityResource>());
    }
    if (!m_spReportsInfoReportIdResource) {
        setResource(std::make_shared<DbsApiResources::ReportsInfoReportIdResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource>());
    }
    if (!m_spCampaignsCampaignIdReturnsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdReturnsResource>());
    }
    if (!m_spCampaignsCampaignIdOffersStocksResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersStocksResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_pricesSuggestionsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource>());
    }
    if (!m_spBusinessesBusinessIdWarehousesResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdWarehousesResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliverDigitalGoodsResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdIdentifiersResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdIdentifiersResource>());
    }
    if (!m_spBusinessesBusinessIdBidsResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdBidsResource>());
    }
    if (!m_spCampaignsCampaignIdBidsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdBidsResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsFeedIdRefreshResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource>());
    }
    if (!m_spRegionsRegionIdChildrenResource) {
        setResource(std::make_shared<DbsApiResources::RegionsRegionIdChildrenResource>());
    }
    if (!m_spRegionsRegionIdResource) {
        setResource(std::make_shared<DbsApiResources::RegionsRegionIdResource>());
    }
    if (!m_spRegionsResource) {
        setResource(std::make_shared<DbsApiResources::RegionsResource>());
    }
    if (!m_spBusinessesBusinessIdChatsFileSendResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsFileSendResource>());
    }
    if (!m_spBusinessesBusinessIdChatsMessageResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdChatsMessageResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsFeedIdParamsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdBoxesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdBoxesResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryDateResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryDateResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryTrackResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryTrackResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionSubmitResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_pricesUpdatesResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource>());
    }
    if (!m_spCampaignsCampaignIdOffersUpdateResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffersUpdateResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_cardsUpdateResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_cardsUpdateResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsUpdateResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdItemsResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdItemsResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdStatusResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdStatusResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersStatus_updateResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersStatus_updateResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOrdersOrderIdDeliveryStorage_limitResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_pricesUpdatesResource) {
        setResource(std::make_shared<DbsApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource>());
    }
    if (!m_spBusinessesBusinessIdPromosOffersUpdateResource) {
        setResource(std::make_shared<DbsApiResources::BusinessesBusinessIdPromosOffersUpdateResource>());
    }
}

std::shared_ptr<restbed::Service> DbsApi::service() {
    return m_service;
}


}
}
}
}

