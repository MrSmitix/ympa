/**
* Партнерский API Маркета
* API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
*
* The version of the OpenAPI document: LATEST
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "ReportsApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string ReportsApi::base = "";

ReportsApi::ReportsApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{
}

void ReportsApi::init() {
    setupRoutes();
}

void ReportsApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/reports/boost-consolidated/generate", Routes::bind(&ReportsApi::generate_boost_consolidated_report_handler, this));
    Routes::Post(*router, base + "/reports/competitors-position/generate", Routes::bind(&ReportsApi::generate_competitors_position_report_handler, this));
    Routes::Post(*router, base + "/reports/goods-feedback/generate", Routes::bind(&ReportsApi::generate_goods_feedback_report_handler, this));
    Routes::Post(*router, base + "/reports/goods-movement/generate", Routes::bind(&ReportsApi::generate_goods_movement_report_handler, this));
    Routes::Post(*router, base + "/reports/goods-realization/generate", Routes::bind(&ReportsApi::generate_goods_realization_report_handler, this));
    Routes::Post(*router, base + "/reports/goods-turnover/generate", Routes::bind(&ReportsApi::generate_goods_turnover_report_handler, this));
    Routes::Post(*router, base + "/reports/documents/labels/generate", Routes::bind(&ReportsApi::generate_mass_order_labels_report_handler, this));
    Routes::Post(*router, base + "/reports/prices/generate", Routes::bind(&ReportsApi::generate_prices_report_handler, this));
    Routes::Post(*router, base + "/reports/shelf-statistics/generate", Routes::bind(&ReportsApi::generate_shelfs_statistics_report_handler, this));
    Routes::Post(*router, base + "/reports/documents/shipment-list/generate", Routes::bind(&ReportsApi::generate_shipment_list_document_report_handler, this));
    Routes::Post(*router, base + "/reports/shows-sales/generate", Routes::bind(&ReportsApi::generate_shows_sales_report_handler, this));
    Routes::Post(*router, base + "/reports/stocks-on-warehouses/generate", Routes::bind(&ReportsApi::generate_stocks_on_warehouses_report_handler, this));
    Routes::Post(*router, base + "/reports/united-marketplace-services/generate", Routes::bind(&ReportsApi::generate_united_marketplace_services_report_handler, this));
    Routes::Post(*router, base + "/reports/united-netting/generate", Routes::bind(&ReportsApi::generate_united_netting_report_handler, this));
    Routes::Post(*router, base + "/reports/united-orders/generate", Routes::bind(&ReportsApi::generate_united_orders_report_handler, this));
    Routes::Get(*router, base + "/reports/info/:reportId", Routes::bind(&ReportsApi::get_report_info_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&ReportsApi::reports_api_default_handler, this));
}

void ReportsApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept
{
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> ReportsApi::handleParsingException(const std::exception& ex) const noexcept
{
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void ReportsApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept
{
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> ReportsApi::handleOperationException(const std::exception& ex) const noexcept
{
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void ReportsApi::generate_boost_consolidated_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateBoostConsolidatedRequest generateBoostConsolidatedRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateBoostConsolidatedRequest);
        generateBoostConsolidatedRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_boost_consolidated_report(generateBoostConsolidatedRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_competitors_position_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateCompetitorsPositionReportRequest generateCompetitorsPositionReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateCompetitorsPositionReportRequest);
        generateCompetitorsPositionReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_competitors_position_report(generateCompetitorsPositionReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_goods_feedback_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateGoodsFeedbackRequest generateGoodsFeedbackRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateGoodsFeedbackRequest);
        generateGoodsFeedbackRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_goods_feedback_report(generateGoodsFeedbackRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_goods_movement_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateGoodsMovementReportRequest generateGoodsMovementReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateGoodsMovementReportRequest);
        generateGoodsMovementReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_goods_movement_report(generateGoodsMovementReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_goods_realization_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateGoodsRealizationReportRequest generateGoodsRealizationReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateGoodsRealizationReportRequest);
        generateGoodsRealizationReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_goods_realization_report(generateGoodsRealizationReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_goods_turnover_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateGoodsTurnoverRequest generateGoodsTurnoverRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateGoodsTurnoverRequest);
        generateGoodsTurnoverRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_goods_turnover_report(generateGoodsTurnoverRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_mass_order_labels_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateMassOrderLabelsRequest generateMassOrderLabelsRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<PageFormatType> format;
    if(formatQuery.has_value()){
        PageFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateMassOrderLabelsRequest);
        generateMassOrderLabelsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_mass_order_labels_report(generateMassOrderLabelsRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_prices_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GeneratePricesReportRequest generatePricesReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generatePricesReportRequest);
        generatePricesReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_prices_report(generatePricesReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_shelfs_statistics_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateShelfsStatisticsRequest generateShelfsStatisticsRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateShelfsStatisticsRequest);
        generateShelfsStatisticsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_shelfs_statistics_report(generateShelfsStatisticsRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_shipment_list_document_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateShipmentListDocumentReportRequest generateShipmentListDocumentReportRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateShipmentListDocumentReportRequest);
        generateShipmentListDocumentReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_shipment_list_document_report(generateShipmentListDocumentReportRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_shows_sales_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateShowsSalesReportRequest generateShowsSalesReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateShowsSalesReportRequest);
        generateShowsSalesReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_shows_sales_report(generateShowsSalesReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_stocks_on_warehouses_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateStocksOnWarehousesReportRequest generateStocksOnWarehousesReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateStocksOnWarehousesReportRequest);
        generateStocksOnWarehousesReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_stocks_on_warehouses_report(generateStocksOnWarehousesReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_united_marketplace_services_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateUnitedMarketplaceServicesReportRequest generateUnitedMarketplaceServicesReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateUnitedMarketplaceServicesReportRequest);
        generateUnitedMarketplaceServicesReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_united_marketplace_services_report(generateUnitedMarketplaceServicesReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_united_netting_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateUnitedNettingReportRequest generateUnitedNettingReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateUnitedNettingReportRequest);
        generateUnitedNettingReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_united_netting_report(generateUnitedNettingReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::generate_united_orders_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateUnitedOrdersRequest generateUnitedOrdersRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateUnitedOrdersRequest);
        generateUnitedOrdersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_united_orders_report(generateUnitedOrdersRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void ReportsApi::get_report_info_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto reportId = request.param(":reportId").as<std::string>();
    
    try {
        this->get_report_info(reportId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}

void ReportsApi::reports_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

