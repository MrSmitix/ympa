/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include <corvusoft/restbed/byte.hpp>
#include <corvusoft/restbed/string.hpp>
#include <corvusoft/restbed/settings.hpp>
#include <corvusoft/restbed/request.hpp>
#include <corvusoft/restbed/uri.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>

#include "ReportsApi.h"

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

namespace {
[[maybe_unused]]
std::string selectPreferredContentType(const std::vector<std::string>& contentTypes) {
    if (contentTypes.size() == 0) {
        return "application/json";
    }

    if (contentTypes.size() == 1) {
        return contentTypes.at(0);
    }

    static const std::array<std::string, 2> preferredTypes = {"json", "xml"};
    for (const auto& preferredType: preferredTypes) {
        const auto ret = std::find_if(contentTypes.cbegin(),
        contentTypes.cend(),
        [preferredType](const std::string& str) {
            return str.find(preferredType) != std::string::npos;});
        if (ret != contentTypes.cend()) {
            return *ret;
        }
    }

    return contentTypes.at(0);
}
}

ReportsApiException::ReportsApiException(int status_code, std::string what)
  : m_status(status_code),
    m_what(what)
{

}
int ReportsApiException::getStatus() const
{
    return m_status;
}
const char* ReportsApiException::what() const noexcept
{
    return m_what.c_str();
}


template<class MODEL_T>
MODEL_T extractJsonModelBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto model = MODEL_T(pt);
    return model;
}

template<class MODEL_T>
std::vector<MODEL_T> extractJsonArrayBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto arrayRet = std::vector<MODEL_T>();
    for (const auto& child: pt) {
        arrayRet.emplace_back(MODEL_T(child.second));
    }
    return arrayRet;
}

template <class KEY_T, class VAL_T>
std::string convertMapResponse(const std::map<KEY_T, VAL_T>& map)
{
    boost::property_tree::ptree pt;
    for(const auto &kv: map) {
    pt.push_back(boost::property_tree::ptree::value_type(
        boost::lexical_cast<std::string>(kv.first),
        boost::property_tree::ptree(
        boost::lexical_cast<std::string>(kv.second))));
    }
    std::stringstream sstream;
    write_json(sstream, pt);
    std::string result = sstream.str();
    return result;
}

namespace ReportsApiResources {
ReportsBoost_consolidatedGenerateResource::ReportsBoost_consolidatedGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/boost-consolidated/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsBoost_consolidatedGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsBoost_consolidatedGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsBoost_consolidatedGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsBoost_consolidatedGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsBoost_consolidatedGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsBoost_consolidatedGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsBoost_consolidatedGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsBoost_consolidatedGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateBoostConsolidatedRequest = extractJsonModelBodyParam<GenerateBoostConsolidatedRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateBoostConsolidatedRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsBoost_consolidatedGenerateResource::handler_POST(
        GenerateBoostConsolidatedRequest & generateBoostConsolidatedRequest, ReportFormatType & format)
{
    return handler_POST_func(generateBoostConsolidatedRequest, format);
}


std::string ReportsBoost_consolidatedGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsBoost_consolidatedGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsCompetitors_positionGenerateResource::ReportsCompetitors_positionGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/competitors-position/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsCompetitors_positionGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsCompetitors_positionGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsCompetitors_positionGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsCompetitors_positionGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsCompetitors_positionGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsCompetitors_positionGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsCompetitors_positionGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsCompetitors_positionGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateCompetitorsPositionReportRequest = extractJsonModelBodyParam<GenerateCompetitorsPositionReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateCompetitorsPositionReportRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsCompetitors_positionGenerateResource::handler_POST(
        GenerateCompetitorsPositionReportRequest & generateCompetitorsPositionReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateCompetitorsPositionReportRequest, format);
}


std::string ReportsCompetitors_positionGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsCompetitors_positionGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsGoods_feedbackGenerateResource::ReportsGoods_feedbackGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-feedback/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsGoods_feedbackGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsGoods_feedbackGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsGoods_feedbackGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsGoods_feedbackGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsGoods_feedbackGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsGoods_feedbackGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsGoods_feedbackGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsGoods_feedbackGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateGoodsFeedbackRequest = extractJsonModelBodyParam<GenerateGoodsFeedbackRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateGoodsFeedbackRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsGoods_feedbackGenerateResource::handler_POST(
        GenerateGoodsFeedbackRequest & generateGoodsFeedbackRequest, ReportFormatType & format)
{
    return handler_POST_func(generateGoodsFeedbackRequest, format);
}


std::string ReportsGoods_feedbackGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsGoods_feedbackGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsGoods_movementGenerateResource::ReportsGoods_movementGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-movement/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsGoods_movementGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsGoods_movementGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsGoods_movementGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsGoods_movementGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsGoods_movementGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsGoods_movementGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsGoods_movementGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsGoods_movementGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateGoodsMovementReportRequest = extractJsonModelBodyParam<GenerateGoodsMovementReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateGoodsMovementReportRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsGoods_movementGenerateResource::handler_POST(
        GenerateGoodsMovementReportRequest & generateGoodsMovementReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateGoodsMovementReportRequest, format);
}


std::string ReportsGoods_movementGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsGoods_movementGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsGoods_realizationGenerateResource::ReportsGoods_realizationGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-realization/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsGoods_realizationGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsGoods_realizationGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsGoods_realizationGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsGoods_realizationGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsGoods_realizationGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsGoods_realizationGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsGoods_realizationGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsGoods_realizationGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateGoodsRealizationReportRequest = extractJsonModelBodyParam<GenerateGoodsRealizationReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateGoodsRealizationReportRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsGoods_realizationGenerateResource::handler_POST(
        GenerateGoodsRealizationReportRequest & generateGoodsRealizationReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateGoodsRealizationReportRequest, format);
}


std::string ReportsGoods_realizationGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsGoods_realizationGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsGoods_turnoverGenerateResource::ReportsGoods_turnoverGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-turnover/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsGoods_turnoverGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsGoods_turnoverGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsGoods_turnoverGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsGoods_turnoverGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsGoods_turnoverGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsGoods_turnoverGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsGoods_turnoverGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsGoods_turnoverGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateGoodsTurnoverRequest = extractJsonModelBodyParam<GenerateGoodsTurnoverRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateGoodsTurnoverRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsGoods_turnoverGenerateResource::handler_POST(
        GenerateGoodsTurnoverRequest & generateGoodsTurnoverRequest, ReportFormatType & format)
{
    return handler_POST_func(generateGoodsTurnoverRequest, format);
}


std::string ReportsGoods_turnoverGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsGoods_turnoverGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsDocumentsLabelsGenerateResource::ReportsDocumentsLabelsGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/documents/labels/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsDocumentsLabelsGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsDocumentsLabelsGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsDocumentsLabelsGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsDocumentsLabelsGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsDocumentsLabelsGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsDocumentsLabelsGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsDocumentsLabelsGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsDocumentsLabelsGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateMassOrderLabelsRequest = extractJsonModelBodyParam<GenerateMassOrderLabelsRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateMassOrderLabelsRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsDocumentsLabelsGenerateResource::handler_POST(
        GenerateMassOrderLabelsRequest & generateMassOrderLabelsRequest, PageFormatType & format)
{
    return handler_POST_func(generateMassOrderLabelsRequest, format);
}


std::string ReportsDocumentsLabelsGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsDocumentsLabelsGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsPricesGenerateResource::ReportsPricesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/prices/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsPricesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsPricesGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsPricesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsPricesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsPricesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsPricesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsPricesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsPricesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generatePricesReportRequest = extractJsonModelBodyParam<GeneratePricesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generatePricesReportRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsPricesGenerateResource::handler_POST(
        GeneratePricesReportRequest & generatePricesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generatePricesReportRequest, format);
}


std::string ReportsPricesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsPricesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsShelf_statisticsGenerateResource::ReportsShelf_statisticsGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shelf-statistics/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsShelf_statisticsGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsShelf_statisticsGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsShelf_statisticsGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsShelf_statisticsGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsShelf_statisticsGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsShelf_statisticsGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsShelf_statisticsGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsShelf_statisticsGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateShelfsStatisticsRequest = extractJsonModelBodyParam<GenerateShelfsStatisticsRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateShelfsStatisticsRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsShelf_statisticsGenerateResource::handler_POST(
        GenerateShelfsStatisticsRequest & generateShelfsStatisticsRequest, ReportFormatType & format)
{
    return handler_POST_func(generateShelfsStatisticsRequest, format);
}


std::string ReportsShelf_statisticsGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsShelf_statisticsGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsDocumentsShipment_listGenerateResource::ReportsDocumentsShipment_listGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/documents/shipment-list/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsDocumentsShipment_listGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsDocumentsShipment_listGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsDocumentsShipment_listGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsDocumentsShipment_listGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsDocumentsShipment_listGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsDocumentsShipment_listGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsDocumentsShipment_listGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsDocumentsShipment_listGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateShipmentListDocumentReportRequest = extractJsonModelBodyParam<GenerateShipmentListDocumentReportRequest>(bodyContent);
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateShipmentListDocumentReportRequest);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsDocumentsShipment_listGenerateResource::handler_POST(
        GenerateShipmentListDocumentReportRequest & generateShipmentListDocumentReportRequest)
{
    return handler_POST_func(generateShipmentListDocumentReportRequest);
}


std::string ReportsDocumentsShipment_listGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsDocumentsShipment_listGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsShows_salesGenerateResource::ReportsShows_salesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shows-sales/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsShows_salesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsShows_salesGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsShows_salesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsShows_salesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsShows_salesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsShows_salesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsShows_salesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsShows_salesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateShowsSalesReportRequest = extractJsonModelBodyParam<GenerateShowsSalesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateShowsSalesReportRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsShows_salesGenerateResource::handler_POST(
        GenerateShowsSalesReportRequest & generateShowsSalesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateShowsSalesReportRequest, format);
}


std::string ReportsShows_salesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsShows_salesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsStocks_on_warehousesGenerateResource::ReportsStocks_on_warehousesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/stocks-on-warehouses/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsStocks_on_warehousesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsStocks_on_warehousesGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsStocks_on_warehousesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsStocks_on_warehousesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsStocks_on_warehousesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsStocks_on_warehousesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsStocks_on_warehousesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsStocks_on_warehousesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateStocksOnWarehousesReportRequest = extractJsonModelBodyParam<GenerateStocksOnWarehousesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateStocksOnWarehousesReportRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsStocks_on_warehousesGenerateResource::handler_POST(
        GenerateStocksOnWarehousesReportRequest & generateStocksOnWarehousesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateStocksOnWarehousesReportRequest, format);
}


std::string ReportsStocks_on_warehousesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsStocks_on_warehousesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsUnited_marketplace_servicesGenerateResource::ReportsUnited_marketplace_servicesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-marketplace-services/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsUnited_marketplace_servicesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsUnited_marketplace_servicesGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsUnited_marketplace_servicesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsUnited_marketplace_servicesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsUnited_marketplace_servicesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsUnited_marketplace_servicesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsUnited_marketplace_servicesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsUnited_marketplace_servicesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateUnitedMarketplaceServicesReportRequest = extractJsonModelBodyParam<GenerateUnitedMarketplaceServicesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateUnitedMarketplaceServicesReportRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsUnited_marketplace_servicesGenerateResource::handler_POST(
        GenerateUnitedMarketplaceServicesReportRequest & generateUnitedMarketplaceServicesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateUnitedMarketplaceServicesReportRequest, format);
}


std::string ReportsUnited_marketplace_servicesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsUnited_marketplace_servicesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsUnited_nettingGenerateResource::ReportsUnited_nettingGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-netting/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsUnited_nettingGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsUnited_nettingGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsUnited_nettingGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsUnited_nettingGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsUnited_nettingGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsUnited_nettingGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsUnited_nettingGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsUnited_nettingGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateUnitedNettingReportRequest = extractJsonModelBodyParam<GenerateUnitedNettingReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateUnitedNettingReportRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsUnited_nettingGenerateResource::handler_POST(
        GenerateUnitedNettingReportRequest & generateUnitedNettingReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateUnitedNettingReportRequest, format);
}


std::string ReportsUnited_nettingGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsUnited_nettingGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsUnited_ordersGenerateResource::ReportsUnited_ordersGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-orders/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsUnited_ordersGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsUnited_ordersGenerateResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsUnited_ordersGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsUnited_ordersGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsUnited_ordersGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsUnited_ordersGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsUnited_ordersGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsUnited_ordersGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateUnitedOrdersRequest = extractJsonModelBodyParam<GenerateUnitedOrdersRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateUnitedOrdersRequest, format);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsUnited_ordersGenerateResource::handler_POST(
        GenerateUnitedOrdersRequest & generateUnitedOrdersRequest, ReportFormatType & format)
{
    return handler_POST_func(generateUnitedOrdersRequest, format);
}


std::string ReportsUnited_ordersGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsUnited_ordersGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsInfoReportIdResource::ReportsInfoReportIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/info/{reportId: .*}");
	this->set_method_handler("GET",
		std::bind(&ReportsInfoReportIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsInfoReportIdResource::handleReportsApiException(const ReportsApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsInfoReportIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsInfoReportIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsInfoReportIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsInfoReportIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsInfoReportIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsInfoReportIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    std::string reportId = request->get_path_parameter("reportId", "");
    
    int status_code = 500;
    GetReportInfoResponse resultObject = GetReportInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(reportId);
    }
    catch(const ReportsApiException& e) {
        std::tie(status_code, result) = handleReportsApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetReportInfoResponse> ReportsInfoReportIdResource::handler_GET(
        std::string & reportId)
{
    return handler_GET_func(reportId);
}


std::string ReportsInfoReportIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsInfoReportIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}

} /* namespace ReportsApiResources */

ReportsApi::ReportsApi(std::shared_ptr<restbed::Service> const& restbedService)
: m_service(restbedService)
{
}

ReportsApi::~ReportsApi() {}

std::shared_ptr<ReportsApiResources::ReportsBoost_consolidatedGenerateResource> ReportsApi::getReportsBoost_consolidatedGenerateResource() {
    if (!m_spReportsBoost_consolidatedGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsBoost_consolidatedGenerateResource>());
    }
    return m_spReportsBoost_consolidatedGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsCompetitors_positionGenerateResource> ReportsApi::getReportsCompetitors_positionGenerateResource() {
    if (!m_spReportsCompetitors_positionGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsCompetitors_positionGenerateResource>());
    }
    return m_spReportsCompetitors_positionGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsGoods_feedbackGenerateResource> ReportsApi::getReportsGoods_feedbackGenerateResource() {
    if (!m_spReportsGoods_feedbackGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsGoods_feedbackGenerateResource>());
    }
    return m_spReportsGoods_feedbackGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsGoods_movementGenerateResource> ReportsApi::getReportsGoods_movementGenerateResource() {
    if (!m_spReportsGoods_movementGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsGoods_movementGenerateResource>());
    }
    return m_spReportsGoods_movementGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsGoods_realizationGenerateResource> ReportsApi::getReportsGoods_realizationGenerateResource() {
    if (!m_spReportsGoods_realizationGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsGoods_realizationGenerateResource>());
    }
    return m_spReportsGoods_realizationGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsGoods_turnoverGenerateResource> ReportsApi::getReportsGoods_turnoverGenerateResource() {
    if (!m_spReportsGoods_turnoverGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsGoods_turnoverGenerateResource>());
    }
    return m_spReportsGoods_turnoverGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsDocumentsLabelsGenerateResource> ReportsApi::getReportsDocumentsLabelsGenerateResource() {
    if (!m_spReportsDocumentsLabelsGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsDocumentsLabelsGenerateResource>());
    }
    return m_spReportsDocumentsLabelsGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsPricesGenerateResource> ReportsApi::getReportsPricesGenerateResource() {
    if (!m_spReportsPricesGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsPricesGenerateResource>());
    }
    return m_spReportsPricesGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsShelf_statisticsGenerateResource> ReportsApi::getReportsShelf_statisticsGenerateResource() {
    if (!m_spReportsShelf_statisticsGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsShelf_statisticsGenerateResource>());
    }
    return m_spReportsShelf_statisticsGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsDocumentsShipment_listGenerateResource> ReportsApi::getReportsDocumentsShipment_listGenerateResource() {
    if (!m_spReportsDocumentsShipment_listGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsDocumentsShipment_listGenerateResource>());
    }
    return m_spReportsDocumentsShipment_listGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsShows_salesGenerateResource> ReportsApi::getReportsShows_salesGenerateResource() {
    if (!m_spReportsShows_salesGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsShows_salesGenerateResource>());
    }
    return m_spReportsShows_salesGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsStocks_on_warehousesGenerateResource> ReportsApi::getReportsStocks_on_warehousesGenerateResource() {
    if (!m_spReportsStocks_on_warehousesGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsStocks_on_warehousesGenerateResource>());
    }
    return m_spReportsStocks_on_warehousesGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsUnited_marketplace_servicesGenerateResource> ReportsApi::getReportsUnited_marketplace_servicesGenerateResource() {
    if (!m_spReportsUnited_marketplace_servicesGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsUnited_marketplace_servicesGenerateResource>());
    }
    return m_spReportsUnited_marketplace_servicesGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsUnited_nettingGenerateResource> ReportsApi::getReportsUnited_nettingGenerateResource() {
    if (!m_spReportsUnited_nettingGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsUnited_nettingGenerateResource>());
    }
    return m_spReportsUnited_nettingGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsUnited_ordersGenerateResource> ReportsApi::getReportsUnited_ordersGenerateResource() {
    if (!m_spReportsUnited_ordersGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsUnited_ordersGenerateResource>());
    }
    return m_spReportsUnited_ordersGenerateResource;
}
std::shared_ptr<ReportsApiResources::ReportsInfoReportIdResource> ReportsApi::getReportsInfoReportIdResource() {
    if (!m_spReportsInfoReportIdResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsInfoReportIdResource>());
    }
    return m_spReportsInfoReportIdResource;
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsBoost_consolidatedGenerateResource> resource) {
    m_spReportsBoost_consolidatedGenerateResource = resource;
    m_service->publish(m_spReportsBoost_consolidatedGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsCompetitors_positionGenerateResource> resource) {
    m_spReportsCompetitors_positionGenerateResource = resource;
    m_service->publish(m_spReportsCompetitors_positionGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsGoods_feedbackGenerateResource> resource) {
    m_spReportsGoods_feedbackGenerateResource = resource;
    m_service->publish(m_spReportsGoods_feedbackGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsGoods_movementGenerateResource> resource) {
    m_spReportsGoods_movementGenerateResource = resource;
    m_service->publish(m_spReportsGoods_movementGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsGoods_realizationGenerateResource> resource) {
    m_spReportsGoods_realizationGenerateResource = resource;
    m_service->publish(m_spReportsGoods_realizationGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsGoods_turnoverGenerateResource> resource) {
    m_spReportsGoods_turnoverGenerateResource = resource;
    m_service->publish(m_spReportsGoods_turnoverGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsDocumentsLabelsGenerateResource> resource) {
    m_spReportsDocumentsLabelsGenerateResource = resource;
    m_service->publish(m_spReportsDocumentsLabelsGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsPricesGenerateResource> resource) {
    m_spReportsPricesGenerateResource = resource;
    m_service->publish(m_spReportsPricesGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsShelf_statisticsGenerateResource> resource) {
    m_spReportsShelf_statisticsGenerateResource = resource;
    m_service->publish(m_spReportsShelf_statisticsGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsDocumentsShipment_listGenerateResource> resource) {
    m_spReportsDocumentsShipment_listGenerateResource = resource;
    m_service->publish(m_spReportsDocumentsShipment_listGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsShows_salesGenerateResource> resource) {
    m_spReportsShows_salesGenerateResource = resource;
    m_service->publish(m_spReportsShows_salesGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsStocks_on_warehousesGenerateResource> resource) {
    m_spReportsStocks_on_warehousesGenerateResource = resource;
    m_service->publish(m_spReportsStocks_on_warehousesGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsUnited_marketplace_servicesGenerateResource> resource) {
    m_spReportsUnited_marketplace_servicesGenerateResource = resource;
    m_service->publish(m_spReportsUnited_marketplace_servicesGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsUnited_nettingGenerateResource> resource) {
    m_spReportsUnited_nettingGenerateResource = resource;
    m_service->publish(m_spReportsUnited_nettingGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsUnited_ordersGenerateResource> resource) {
    m_spReportsUnited_ordersGenerateResource = resource;
    m_service->publish(m_spReportsUnited_ordersGenerateResource);
}
void ReportsApi::setResource(std::shared_ptr<ReportsApiResources::ReportsInfoReportIdResource> resource) {
    m_spReportsInfoReportIdResource = resource;
    m_service->publish(m_spReportsInfoReportIdResource);
}
void ReportsApi::setReportsApiReportsBoost_consolidatedGenerateResource(std::shared_ptr<ReportsApiResources::ReportsBoost_consolidatedGenerateResource> spReportsBoost_consolidatedGenerateResource) {
    m_spReportsBoost_consolidatedGenerateResource = spReportsBoost_consolidatedGenerateResource;
    m_service->publish(m_spReportsBoost_consolidatedGenerateResource);
}
void ReportsApi::setReportsApiReportsCompetitors_positionGenerateResource(std::shared_ptr<ReportsApiResources::ReportsCompetitors_positionGenerateResource> spReportsCompetitors_positionGenerateResource) {
    m_spReportsCompetitors_positionGenerateResource = spReportsCompetitors_positionGenerateResource;
    m_service->publish(m_spReportsCompetitors_positionGenerateResource);
}
void ReportsApi::setReportsApiReportsGoods_feedbackGenerateResource(std::shared_ptr<ReportsApiResources::ReportsGoods_feedbackGenerateResource> spReportsGoods_feedbackGenerateResource) {
    m_spReportsGoods_feedbackGenerateResource = spReportsGoods_feedbackGenerateResource;
    m_service->publish(m_spReportsGoods_feedbackGenerateResource);
}
void ReportsApi::setReportsApiReportsGoods_movementGenerateResource(std::shared_ptr<ReportsApiResources::ReportsGoods_movementGenerateResource> spReportsGoods_movementGenerateResource) {
    m_spReportsGoods_movementGenerateResource = spReportsGoods_movementGenerateResource;
    m_service->publish(m_spReportsGoods_movementGenerateResource);
}
void ReportsApi::setReportsApiReportsGoods_realizationGenerateResource(std::shared_ptr<ReportsApiResources::ReportsGoods_realizationGenerateResource> spReportsGoods_realizationGenerateResource) {
    m_spReportsGoods_realizationGenerateResource = spReportsGoods_realizationGenerateResource;
    m_service->publish(m_spReportsGoods_realizationGenerateResource);
}
void ReportsApi::setReportsApiReportsGoods_turnoverGenerateResource(std::shared_ptr<ReportsApiResources::ReportsGoods_turnoverGenerateResource> spReportsGoods_turnoverGenerateResource) {
    m_spReportsGoods_turnoverGenerateResource = spReportsGoods_turnoverGenerateResource;
    m_service->publish(m_spReportsGoods_turnoverGenerateResource);
}
void ReportsApi::setReportsApiReportsDocumentsLabelsGenerateResource(std::shared_ptr<ReportsApiResources::ReportsDocumentsLabelsGenerateResource> spReportsDocumentsLabelsGenerateResource) {
    m_spReportsDocumentsLabelsGenerateResource = spReportsDocumentsLabelsGenerateResource;
    m_service->publish(m_spReportsDocumentsLabelsGenerateResource);
}
void ReportsApi::setReportsApiReportsPricesGenerateResource(std::shared_ptr<ReportsApiResources::ReportsPricesGenerateResource> spReportsPricesGenerateResource) {
    m_spReportsPricesGenerateResource = spReportsPricesGenerateResource;
    m_service->publish(m_spReportsPricesGenerateResource);
}
void ReportsApi::setReportsApiReportsShelf_statisticsGenerateResource(std::shared_ptr<ReportsApiResources::ReportsShelf_statisticsGenerateResource> spReportsShelf_statisticsGenerateResource) {
    m_spReportsShelf_statisticsGenerateResource = spReportsShelf_statisticsGenerateResource;
    m_service->publish(m_spReportsShelf_statisticsGenerateResource);
}
void ReportsApi::setReportsApiReportsDocumentsShipment_listGenerateResource(std::shared_ptr<ReportsApiResources::ReportsDocumentsShipment_listGenerateResource> spReportsDocumentsShipment_listGenerateResource) {
    m_spReportsDocumentsShipment_listGenerateResource = spReportsDocumentsShipment_listGenerateResource;
    m_service->publish(m_spReportsDocumentsShipment_listGenerateResource);
}
void ReportsApi::setReportsApiReportsShows_salesGenerateResource(std::shared_ptr<ReportsApiResources::ReportsShows_salesGenerateResource> spReportsShows_salesGenerateResource) {
    m_spReportsShows_salesGenerateResource = spReportsShows_salesGenerateResource;
    m_service->publish(m_spReportsShows_salesGenerateResource);
}
void ReportsApi::setReportsApiReportsStocks_on_warehousesGenerateResource(std::shared_ptr<ReportsApiResources::ReportsStocks_on_warehousesGenerateResource> spReportsStocks_on_warehousesGenerateResource) {
    m_spReportsStocks_on_warehousesGenerateResource = spReportsStocks_on_warehousesGenerateResource;
    m_service->publish(m_spReportsStocks_on_warehousesGenerateResource);
}
void ReportsApi::setReportsApiReportsUnited_marketplace_servicesGenerateResource(std::shared_ptr<ReportsApiResources::ReportsUnited_marketplace_servicesGenerateResource> spReportsUnited_marketplace_servicesGenerateResource) {
    m_spReportsUnited_marketplace_servicesGenerateResource = spReportsUnited_marketplace_servicesGenerateResource;
    m_service->publish(m_spReportsUnited_marketplace_servicesGenerateResource);
}
void ReportsApi::setReportsApiReportsUnited_nettingGenerateResource(std::shared_ptr<ReportsApiResources::ReportsUnited_nettingGenerateResource> spReportsUnited_nettingGenerateResource) {
    m_spReportsUnited_nettingGenerateResource = spReportsUnited_nettingGenerateResource;
    m_service->publish(m_spReportsUnited_nettingGenerateResource);
}
void ReportsApi::setReportsApiReportsUnited_ordersGenerateResource(std::shared_ptr<ReportsApiResources::ReportsUnited_ordersGenerateResource> spReportsUnited_ordersGenerateResource) {
    m_spReportsUnited_ordersGenerateResource = spReportsUnited_ordersGenerateResource;
    m_service->publish(m_spReportsUnited_ordersGenerateResource);
}
void ReportsApi::setReportsApiReportsInfoReportIdResource(std::shared_ptr<ReportsApiResources::ReportsInfoReportIdResource> spReportsInfoReportIdResource) {
    m_spReportsInfoReportIdResource = spReportsInfoReportIdResource;
    m_service->publish(m_spReportsInfoReportIdResource);
}


void ReportsApi::publishDefaultResources() {
    if (!m_spReportsBoost_consolidatedGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsBoost_consolidatedGenerateResource>());
    }
    if (!m_spReportsCompetitors_positionGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsCompetitors_positionGenerateResource>());
    }
    if (!m_spReportsGoods_feedbackGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsGoods_feedbackGenerateResource>());
    }
    if (!m_spReportsGoods_movementGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsGoods_movementGenerateResource>());
    }
    if (!m_spReportsGoods_realizationGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsGoods_realizationGenerateResource>());
    }
    if (!m_spReportsGoods_turnoverGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsGoods_turnoverGenerateResource>());
    }
    if (!m_spReportsDocumentsLabelsGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsDocumentsLabelsGenerateResource>());
    }
    if (!m_spReportsPricesGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsPricesGenerateResource>());
    }
    if (!m_spReportsShelf_statisticsGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsShelf_statisticsGenerateResource>());
    }
    if (!m_spReportsDocumentsShipment_listGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsDocumentsShipment_listGenerateResource>());
    }
    if (!m_spReportsShows_salesGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsShows_salesGenerateResource>());
    }
    if (!m_spReportsStocks_on_warehousesGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsStocks_on_warehousesGenerateResource>());
    }
    if (!m_spReportsUnited_marketplace_servicesGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsUnited_marketplace_servicesGenerateResource>());
    }
    if (!m_spReportsUnited_nettingGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsUnited_nettingGenerateResource>());
    }
    if (!m_spReportsUnited_ordersGenerateResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsUnited_ordersGenerateResource>());
    }
    if (!m_spReportsInfoReportIdResource) {
        setResource(std::make_shared<ReportsApiResources::ReportsInfoReportIdResource>());
    }
}

std::shared_ptr<restbed::Service> ReportsApi::service() {
    return m_service;
}


}
}
}
}

