/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include <corvusoft/restbed/byte.hpp>
#include <corvusoft/restbed/string.hpp>
#include <corvusoft/restbed/settings.hpp>
#include <corvusoft/restbed/request.hpp>
#include <corvusoft/restbed/uri.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>

#include "FbyApi.h"

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

FbyApiException::FbyApiException(int status_code, std::string what)
  : m_status(status_code),
    m_what(what)
{

}
int FbyApiException::getStatus() const
{
    return m_status;
}
const char* FbyApiException::what() const noexcept
{
    return m_what.c_str();
}


template<class MODEL_T>
std::shared_ptr<MODEL_T> extractJsonModelBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto model = std::make_shared<MODEL_T>(pt);
    return model;
}

template<class MODEL_T>
std::vector<std::shared_ptr<MODEL_T>> extractJsonArrayBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto arrayRet = std::vector<std::shared_ptr<MODEL_T>>();
    for (const auto& child: pt) {
        arrayRet.emplace_back(std::make_shared<MODEL_T>(child.second));
    }
    return arrayRet;
}

template <class KEY_T, class VAL_T>
std::string convertMapResponse(const std::map<KEY_T, VAL_T>& map)
{
    boost::property_tree::ptree pt;
    for(const auto &kv: map) {
    pt.push_back(boost::property_tree::ptree::value_type(
        boost::lexical_cast<std::string>(kv.first),
        boost::property_tree::ptree(
        boost::lexical_cast<std::string>(kv.second))));
    }
    std::stringstream sstream;
    write_json(sstream, pt);
    std::string result = sstream.str();
    return result;
}

FbyApiCampaignsCampaignIdHidden-offersResource::FbyApiCampaignsCampaignIdHidden-offersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/hidden-offers/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdHidden-offersResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdHidden-offersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdHidden-offersResource::~FbyApiCampaignsCampaignIdHidden-offersResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdHidden-offersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdHidden-offersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdHidden-offersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdHidden-offersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdHidden-offersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdHidden-offersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdHidden-offersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto addHiddenOffersRequest = extractJsonModelBodyParam<AddHiddenOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, addHiddenOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Настройки скрытия получены и скоро вступят в силу." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

// x-extension
void FbyApiCampaignsCampaignIdHidden-offersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {

    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId_x_extension(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken_x_extension(request);

    const int32_t limit = getQueryParam_limit_x_extension(request);

    const int32_t offset = getQueryParam_offset_x_extension(request);

    const int32_t page = getQueryParam_page_x_extension(request);

    const int32_t pageSize = getQueryParam_pageSize_x_extension(request);


    int status_code = 500;
    std::shared_ptr<GetHiddenOffersResponse> resultObject = std::make_shared<GetHiddenOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, offerId, pageToken, limit, offset, page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о скрытых вами товарах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiCampaignsCampaignIdHidden-offersResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<AddHiddenOffersRequest> const & addHiddenOffersRequest)
{
    throw FbyApiException(501, "Not implemented");
}

std::pair<int, std::shared_ptr<GetHiddenOffersResponse>> FbyApiCampaignsCampaignIdHidden-offersResource::handler_GET(
    int64_t const & campaignId, std::vector<std::shared_ptr<std::string>> const & offerId, std::string const & pageToken, int32_t const & limit, int32_t const & offset, int32_t const & page, int32_t const & pageSize)
{
    throw FbyApiException(501, "Not implemented");
}

std::string FbyApiCampaignsCampaignIdHidden-offersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/archive/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::~FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto addOffersToArchiveRequest = extractJsonModelBodyParam<AddOffersToArchiveRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<AddOffersToArchiveResponse> resultObject = std::make_shared<AddOffersToArchiveResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, addOffersToArchiveRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Если некоторые товары добавить в архив не удалось, в ответе 200 будет их список.  Список успешно добавленных товаров не возвращается. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<AddOffersToArchiveResponse>> FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<AddOffersToArchiveRequest> const & addOffersToArchiveRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiTariffsCalculateResource::FbyApiTariffsCalculateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/tariffs/calculate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiTariffsCalculateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiTariffsCalculateResource::~FbyApiTariffsCalculateResource()
{
}

std::pair<int, std::string> FbyApiTariffsCalculateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiTariffsCalculateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiTariffsCalculateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiTariffsCalculateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiTariffsCalculateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiTariffsCalculateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiTariffsCalculateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto calculateTariffsRequest = extractJsonModelBodyParam<CalculateTariffsRequest>(bodyContent);




    int status_code = 500;
    std::shared_ptr<CalculateTariffsResponse> resultObject = std::make_shared<CalculateTariffsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(calculateTariffsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Стоимость услуг." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<CalculateTariffsResponse>> FbyApiTariffsCalculateResource::handler_POST(
        std::shared_ptr<CalculateTariffsRequest> const & calculateTariffsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiTariffsCalculateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/price-quarantine/confirm/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::~FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto confirmPricesRequest = extractJsonModelBodyParam<ConfirmPricesRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, confirmPricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Ответ 200 обозначает, что цены подтверждены." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<ConfirmPricesRequest> const & confirmPricesRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/price-quarantine/confirm/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::~FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto confirmPricesRequest = extractJsonModelBodyParam<ConfirmPricesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, confirmPricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Ответ 200 обозначает, что цены подтверждены." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<ConfirmPricesRequest> const & confirmPricesRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdChatsNewResource::FbyApiBusinessesBusinessIdChatsNewResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/new/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdChatsNewResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdChatsNewResource::~FbyApiBusinessesBusinessIdChatsNewResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsNewResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsNewResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsNewResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdChatsNewResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdChatsNewResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdChatsNewResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdChatsNewResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto createChatRequest = extractJsonModelBodyParam<CreateChatRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<CreateChatResponse> resultObject = std::make_shared<CreateChatResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, createChatRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Все получилось: чат создан. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<CreateChatResponse>> FbyApiBusinessesBusinessIdChatsNewResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<CreateChatRequest> const & createChatRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdChatsNewResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffersDeleteResource::FbyApiCampaignsCampaignIdOffersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/delete/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOffersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffersDeleteResource::~FbyApiCampaignsCampaignIdOffersDeleteResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteCampaignOffersRequest = extractJsonModelBodyParam<DeleteCampaignOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<DeleteCampaignOffersResponse> resultObject = std::make_shared<DeleteCampaignOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, deleteCampaignOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Если удалось удалить не все товары, с ответом 200 вернется список тех, что были в запросе, но остались в магазине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<DeleteCampaignOffersResponse>> FbyApiCampaignsCampaignIdOffersDeleteResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<DeleteCampaignOffersRequest> const & deleteCampaignOffersRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOffersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/delete/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::~FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteGoodsFeedbackCommentRequest = extractJsonModelBodyParam<DeleteGoodsFeedbackCommentRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, deleteGoodsFeedbackCommentRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<DeleteGoodsFeedbackCommentRequest> const & deleteGoodsFeedbackCommentRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdHidden-offersDeleteResource::FbyApiCampaignsCampaignIdHidden-offersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/hidden-offers/delete/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdHidden-offersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdHidden-offersDeleteResource::~FbyApiCampaignsCampaignIdHidden-offersDeleteResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdHidden-offersDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdHidden-offersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdHidden-offersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdHidden-offersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdHidden-offersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdHidden-offersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdHidden-offersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteHiddenOffersRequest = extractJsonModelBodyParam<DeleteHiddenOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, deleteHiddenOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Показ товаров возобновлен." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiCampaignsCampaignIdHidden-offersDeleteResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<DeleteHiddenOffersRequest> const & deleteHiddenOffersRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdHidden-offersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/delete/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::~FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteOffersRequest = extractJsonModelBodyParam<DeleteOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<DeleteOffersResponse> resultObject = std::make_shared<DeleteOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, deleteOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Если удалось удалить не все товары, с ответом 200 вернется список тех, что были в запросе, но остались в магазине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<DeleteOffersResponse>> FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<DeleteOffersRequest> const & deleteOffersRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/unarchive/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::~FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteOffersFromArchiveRequest = extractJsonModelBodyParam<DeleteOffersFromArchiveRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<DeleteOffersFromArchiveResponse> resultObject = std::make_shared<DeleteOffersFromArchiveResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, deleteOffersFromArchiveRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Если некоторые товары восстановить из архива не удалось, в ответе 200 будет их список.  Список успешно восстановленных товаров не возвращается. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<DeleteOffersFromArchiveResponse>> FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<DeleteOffersFromArchiveRequest> const & deleteOffersFromArchiveRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdPromosOffersDeleteResource::FbyApiBusinessesBusinessIdPromosOffersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/delete/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdPromosOffersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdPromosOffersDeleteResource::~FbyApiBusinessesBusinessIdPromosOffersDeleteResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosOffersDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosOffersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosOffersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdPromosOffersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdPromosOffersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdPromosOffersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdPromosOffersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deletePromoOffersRequest = extractJsonModelBodyParam<DeletePromoOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<DeletePromoOffersResponse> resultObject = std::make_shared<DeletePromoOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, deletePromoOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Результат удаления товаров из акции." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<DeletePromoOffersResponse>> FbyApiBusinessesBusinessIdPromosOffersDeleteResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<DeletePromoOffersRequest> const & deletePromoOffersRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdPromosOffersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsBoost-consolidatedGenerateResource::FbyApiReportsBoost-consolidatedGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/boost-consolidated/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsBoost-consolidatedGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsBoost-consolidatedGenerateResource::~FbyApiReportsBoost-consolidatedGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsBoost-consolidatedGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsBoost-consolidatedGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsBoost-consolidatedGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsBoost-consolidatedGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsBoost-consolidatedGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsBoost-consolidatedGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsBoost-consolidatedGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateBoostConsolidatedRequest = extractJsonModelBodyParam<GenerateBoostConsolidatedRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateBoostConsolidatedRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsBoost-consolidatedGenerateResource::handler_POST(
        std::shared_ptr<GenerateBoostConsolidatedRequest> const & generateBoostConsolidatedRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsBoost-consolidatedGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsCompetitors-positionGenerateResource::FbyApiReportsCompetitors-positionGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/competitors-position/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsCompetitors-positionGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsCompetitors-positionGenerateResource::~FbyApiReportsCompetitors-positionGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsCompetitors-positionGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsCompetitors-positionGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsCompetitors-positionGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsCompetitors-positionGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsCompetitors-positionGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsCompetitors-positionGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsCompetitors-positionGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateCompetitorsPositionReportRequest = extractJsonModelBodyParam<GenerateCompetitorsPositionReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateCompetitorsPositionReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsCompetitors-positionGenerateResource::handler_POST(
        std::shared_ptr<GenerateCompetitorsPositionReportRequest> const & generateCompetitorsPositionReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsCompetitors-positionGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsGoods-feedbackGenerateResource::FbyApiReportsGoods-feedbackGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-feedback/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsGoods-feedbackGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsGoods-feedbackGenerateResource::~FbyApiReportsGoods-feedbackGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsGoods-feedbackGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsGoods-feedbackGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsGoods-feedbackGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsGoods-feedbackGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsGoods-feedbackGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsGoods-feedbackGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsGoods-feedbackGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateGoodsFeedbackRequest = extractJsonModelBodyParam<GenerateGoodsFeedbackRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateGoodsFeedbackRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsGoods-feedbackGenerateResource::handler_POST(
        std::shared_ptr<GenerateGoodsFeedbackRequest> const & generateGoodsFeedbackRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsGoods-feedbackGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsGoods-movementGenerateResource::FbyApiReportsGoods-movementGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-movement/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsGoods-movementGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsGoods-movementGenerateResource::~FbyApiReportsGoods-movementGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsGoods-movementGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsGoods-movementGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsGoods-movementGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsGoods-movementGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsGoods-movementGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsGoods-movementGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsGoods-movementGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateGoodsMovementReportRequest = extractJsonModelBodyParam<GenerateGoodsMovementReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateGoodsMovementReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsGoods-movementGenerateResource::handler_POST(
        std::shared_ptr<GenerateGoodsMovementReportRequest> const & generateGoodsMovementReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsGoods-movementGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsGoods-realizationGenerateResource::FbyApiReportsGoods-realizationGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-realization/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsGoods-realizationGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsGoods-realizationGenerateResource::~FbyApiReportsGoods-realizationGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsGoods-realizationGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsGoods-realizationGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsGoods-realizationGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsGoods-realizationGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsGoods-realizationGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsGoods-realizationGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsGoods-realizationGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateGoodsRealizationReportRequest = extractJsonModelBodyParam<GenerateGoodsRealizationReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateGoodsRealizationReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsGoods-realizationGenerateResource::handler_POST(
        std::shared_ptr<GenerateGoodsRealizationReportRequest> const & generateGoodsRealizationReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsGoods-realizationGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsGoods-turnoverGenerateResource::FbyApiReportsGoods-turnoverGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-turnover/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsGoods-turnoverGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsGoods-turnoverGenerateResource::~FbyApiReportsGoods-turnoverGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsGoods-turnoverGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsGoods-turnoverGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsGoods-turnoverGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsGoods-turnoverGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsGoods-turnoverGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsGoods-turnoverGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsGoods-turnoverGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateGoodsTurnoverRequest = extractJsonModelBodyParam<GenerateGoodsTurnoverRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateGoodsTurnoverRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsGoods-turnoverGenerateResource::handler_POST(
        std::shared_ptr<GenerateGoodsTurnoverRequest> const & generateGoodsTurnoverRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsGoods-turnoverGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsPricesGenerateResource::FbyApiReportsPricesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/prices/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsPricesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsPricesGenerateResource::~FbyApiReportsPricesGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsPricesGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsPricesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsPricesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsPricesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsPricesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsPricesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsPricesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generatePricesReportRequest = extractJsonModelBodyParam<GeneratePricesReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generatePricesReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsPricesGenerateResource::handler_POST(
        std::shared_ptr<GeneratePricesReportRequest> const & generatePricesReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsPricesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsShelf-statisticsGenerateResource::FbyApiReportsShelf-statisticsGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shelf-statistics/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsShelf-statisticsGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsShelf-statisticsGenerateResource::~FbyApiReportsShelf-statisticsGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsShelf-statisticsGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsShelf-statisticsGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsShelf-statisticsGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsShelf-statisticsGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsShelf-statisticsGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsShelf-statisticsGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsShelf-statisticsGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateShelfsStatisticsRequest = extractJsonModelBodyParam<GenerateShelfsStatisticsRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateShelfsStatisticsRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsShelf-statisticsGenerateResource::handler_POST(
        std::shared_ptr<GenerateShelfsStatisticsRequest> const & generateShelfsStatisticsRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsShelf-statisticsGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsShows-salesGenerateResource::FbyApiReportsShows-salesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shows-sales/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsShows-salesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsShows-salesGenerateResource::~FbyApiReportsShows-salesGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsShows-salesGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsShows-salesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsShows-salesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsShows-salesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsShows-salesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsShows-salesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsShows-salesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateShowsSalesReportRequest = extractJsonModelBodyParam<GenerateShowsSalesReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateShowsSalesReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsShows-salesGenerateResource::handler_POST(
        std::shared_ptr<GenerateShowsSalesReportRequest> const & generateShowsSalesReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsShows-salesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsStocks-on-warehousesGenerateResource::FbyApiReportsStocks-on-warehousesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/stocks-on-warehouses/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsStocks-on-warehousesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsStocks-on-warehousesGenerateResource::~FbyApiReportsStocks-on-warehousesGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsStocks-on-warehousesGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsStocks-on-warehousesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsStocks-on-warehousesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsStocks-on-warehousesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsStocks-on-warehousesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsStocks-on-warehousesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsStocks-on-warehousesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateStocksOnWarehousesReportRequest = extractJsonModelBodyParam<GenerateStocksOnWarehousesReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateStocksOnWarehousesReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsStocks-on-warehousesGenerateResource::handler_POST(
        std::shared_ptr<GenerateStocksOnWarehousesReportRequest> const & generateStocksOnWarehousesReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsStocks-on-warehousesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsUnited-marketplace-servicesGenerateResource::FbyApiReportsUnited-marketplace-servicesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-marketplace-services/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsUnited-marketplace-servicesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsUnited-marketplace-servicesGenerateResource::~FbyApiReportsUnited-marketplace-servicesGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsUnited-marketplace-servicesGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsUnited-marketplace-servicesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsUnited-marketplace-servicesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsUnited-marketplace-servicesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsUnited-marketplace-servicesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsUnited-marketplace-servicesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsUnited-marketplace-servicesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateUnitedMarketplaceServicesReportRequest = extractJsonModelBodyParam<GenerateUnitedMarketplaceServicesReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateUnitedMarketplaceServicesReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsUnited-marketplace-servicesGenerateResource::handler_POST(
        std::shared_ptr<GenerateUnitedMarketplaceServicesReportRequest> const & generateUnitedMarketplaceServicesReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsUnited-marketplace-servicesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsUnited-nettingGenerateResource::FbyApiReportsUnited-nettingGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-netting/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsUnited-nettingGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsUnited-nettingGenerateResource::~FbyApiReportsUnited-nettingGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsUnited-nettingGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsUnited-nettingGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsUnited-nettingGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsUnited-nettingGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsUnited-nettingGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsUnited-nettingGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsUnited-nettingGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateUnitedNettingReportRequest = extractJsonModelBodyParam<GenerateUnitedNettingReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateUnitedNettingReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsUnited-nettingGenerateResource::handler_POST(
        std::shared_ptr<GenerateUnitedNettingReportRequest> const & generateUnitedNettingReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsUnited-nettingGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsUnited-ordersGenerateResource::FbyApiReportsUnited-ordersGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-orders/generate/");
	this->set_method_handler("POST",
		std::bind(&FbyApiReportsUnited-ordersGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiReportsUnited-ordersGenerateResource::~FbyApiReportsUnited-ordersGenerateResource()
{
}

std::pair<int, std::string> FbyApiReportsUnited-ordersGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsUnited-ordersGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsUnited-ordersGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsUnited-ordersGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsUnited-ordersGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsUnited-ordersGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsUnited-ordersGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateUnitedOrdersRequest = extractJsonModelBodyParam<GenerateUnitedOrdersRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateUnitedOrdersRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> FbyApiReportsUnited-ordersGenerateResource::handler_POST(
        std::shared_ptr<GenerateUnitedOrdersRequest> const & generateUnitedOrdersRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsUnited-ordersGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffersAllResource::FbyApiCampaignsCampaignIdOffersAllResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/all/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdOffersAllResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffersAllResource::~FbyApiCampaignsCampaignIdOffersAllResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersAllResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersAllResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersAllResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffersAllResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffersAllResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffersAllResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffersAllResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const int64_t feedId = getQueryParam_feedId(request);
    const int32_t chunk = getQueryParam_chunk(request);


    int status_code = 500;
    std::shared_ptr<GetAllOffersResponse> resultObject = std::make_shared<GetAllOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, feedId, chunk);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Предложения магазина." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetAllOffersResponse>> FbyApiCampaignsCampaignIdOffersAllResource::handler_GET(
        int64_t const & campaignId, int64_t const & feedId, int32_t const & chunk)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOffersAllResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdBidsInfoResource::FbyApiBusinessesBusinessIdBidsInfoResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/info/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdBidsInfoResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdBidsInfoResource::~FbyApiBusinessesBusinessIdBidsInfoResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdBidsInfoResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdBidsInfoResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdBidsInfoResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdBidsInfoResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdBidsInfoResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdBidsInfoResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdBidsInfoResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getBidsInfoRequest = extractJsonModelBodyParam<GetBidsInfoRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetBidsInfoResponse> resultObject = std::make_shared<GetBidsInfoResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, pageToken, limit, getBidsInfoRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Значения ставок для заданных товаров. В ответ попадают только товары, на которые установлены ставки." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBidsInfoResponse>> FbyApiBusinessesBusinessIdBidsInfoResource::handler_POST(
        int64_t const & businessId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetBidsInfoRequest> const & getBidsInfoRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdBidsInfoResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdBidsRecommendationsResource::FbyApiBusinessesBusinessIdBidsRecommendationsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/recommendations/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdBidsRecommendationsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdBidsRecommendationsResource::~FbyApiBusinessesBusinessIdBidsRecommendationsResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdBidsRecommendationsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdBidsRecommendationsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdBidsRecommendationsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdBidsRecommendationsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdBidsRecommendationsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdBidsRecommendationsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdBidsRecommendationsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getBidsRecommendationsRequest = extractJsonModelBodyParam<GetBidsRecommendationsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetBidsRecommendationsResponse> resultObject = std::make_shared<GetBidsRecommendationsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getBidsRecommendationsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Рекомендованные ставки для заданных товаров." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBidsRecommendationsResponse>> FbyApiBusinessesBusinessIdBidsRecommendationsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetBidsRecommendationsRequest> const & getBidsRecommendationsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdBidsRecommendationsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdPrice-quarantineResource::FbyApiBusinessesBusinessIdPrice-quarantineResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/price-quarantine/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdPrice-quarantineResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdPrice-quarantineResource::~FbyApiBusinessesBusinessIdPrice-quarantineResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPrice-quarantineResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPrice-quarantineResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPrice-quarantineResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdPrice-quarantineResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdPrice-quarantineResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdPrice-quarantineResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdPrice-quarantineResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getQuarantineOffersRequest = extractJsonModelBodyParam<GetQuarantineOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetQuarantineOffersResponse> resultObject = std::make_shared<GetQuarantineOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getQuarantineOffersRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров в карантине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetQuarantineOffersResponse>> FbyApiBusinessesBusinessIdPrice-quarantineResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetQuarantineOffersRequest> const & getQuarantineOffersRequest, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdPrice-quarantineResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdSettingsResource::FbyApiBusinessesBusinessIdSettingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/settings/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdSettingsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdSettingsResource::~FbyApiBusinessesBusinessIdSettingsResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdSettingsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdSettingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdSettingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdSettingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdSettingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdSettingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdSettingsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetBusinessSettingsResponse> resultObject = std::make_shared<GetBusinessSettingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Настройки кабинета." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBusinessSettingsResponse>> FbyApiBusinessesBusinessIdSettingsResource::handler_POST(
        int64_t const & businessId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdSettingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdResource::FbyApiCampaignsCampaignIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdResource::~FbyApiCampaignsCampaignIdResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetCampaignResponse> resultObject = std::make_shared<GetCampaignResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о магазине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignResponse>> FbyApiCampaignsCampaignIdResource::handler_GET(
        int64_t const & campaignId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdLoginsResource::FbyApiCampaignsCampaignIdLoginsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/logins/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdLoginsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdLoginsResource::~FbyApiCampaignsCampaignIdLoginsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdLoginsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdLoginsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdLoginsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdLoginsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdLoginsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdLoginsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdLoginsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetCampaignLoginsResponse> resultObject = std::make_shared<GetCampaignLoginsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список логинов, связанных с магазином." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignLoginsResponse>> FbyApiCampaignsCampaignIdLoginsResource::handler_GET(
        int64_t const & campaignId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdLoginsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffersResource::FbyApiCampaignsCampaignIdOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOffersResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdOffersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffersResource::~FbyApiCampaignsCampaignIdOffersResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getCampaignOffersRequest = extractJsonModelBodyParam<GetCampaignOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetCampaignOffersResponse> resultObject = std::make_shared<GetCampaignOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, getCampaignOffersRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров, размещенных в заданном магазине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

// x-extension
void FbyApiCampaignsCampaignIdOffersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {

    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId_x_extension(request);

    // Getting the query params
    const std::string query = getQueryParam_query_x_extension(request);

    const int64_t feedId = getQueryParam_feedId_x_extension(request);

    const std::string shopCategoryId = getQueryParam_shopCategoryId_x_extension(request);

    const bool matched = getQueryParam_matched_x_extension(request);

    const int32_t page = getQueryParam_page_x_extension(request);

    const int32_t pageSize = getQueryParam_pageSize_x_extension(request);


    int status_code = 500;
    std::shared_ptr<GetOffersResponse> resultObject = std::make_shared<GetOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Предложения магазина." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

std::pair<int, std::shared_ptr<GetCampaignOffersResponse>> FbyApiCampaignsCampaignIdOffersResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<GetCampaignOffersRequest> const & getCampaignOffersRequest, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}

std::pair<int, std::shared_ptr<GetOffersResponse>> FbyApiCampaignsCampaignIdOffersResource::handler_GET(
    int64_t const & campaignId, std::string const & query, int64_t const & feedId, std::string const & shopCategoryId, std::shared_ptr<CurrencyType> const & currency, bool const & matched, int32_t const & page, int32_t const & pageSize)
{
    throw FbyApiException(501, "Not implemented");
}

std::string FbyApiCampaignsCampaignIdOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdPrice-quarantineResource::FbyApiCampaignsCampaignIdPrice-quarantineResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/price-quarantine/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdPrice-quarantineResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdPrice-quarantineResource::~FbyApiCampaignsCampaignIdPrice-quarantineResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdPrice-quarantineResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdPrice-quarantineResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdPrice-quarantineResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdPrice-quarantineResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdPrice-quarantineResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdPrice-quarantineResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdPrice-quarantineResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getQuarantineOffersRequest = extractJsonModelBodyParam<GetQuarantineOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetQuarantineOffersResponse> resultObject = std::make_shared<GetQuarantineOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, getQuarantineOffersRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров в карантине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetQuarantineOffersResponse>> FbyApiCampaignsCampaignIdPrice-quarantineResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<GetQuarantineOffersRequest> const & getQuarantineOffersRequest, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdPrice-quarantineResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdRegionResource::FbyApiCampaignsCampaignIdRegionResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/region/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdRegionResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdRegionResource::~FbyApiCampaignsCampaignIdRegionResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdRegionResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdRegionResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdRegionResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdRegionResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdRegionResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdRegionResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdRegionResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetCampaignRegionResponse> resultObject = std::make_shared<GetCampaignRegionResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Возвращает регион, в котором находится магазин.  |**⚙️ Лимит:** 1000 запросов в час| |-| " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignRegionResponse>> FbyApiCampaignsCampaignIdRegionResource::handler_GET(
        int64_t const & campaignId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdRegionResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdSettingsResource::FbyApiCampaignsCampaignIdSettingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/settings/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdSettingsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdSettingsResource::~FbyApiCampaignsCampaignIdSettingsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdSettingsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdSettingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdSettingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdSettingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdSettingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdSettingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdSettingsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetCampaignSettingsResponse> resultObject = std::make_shared<GetCampaignSettingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Настройки магазина." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignSettingsResponse>> FbyApiCampaignsCampaignIdSettingsResource::handler_GET(
        int64_t const & campaignId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdSettingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsResource::FbyApiCampaignsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsResource::~FbyApiCampaignsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();


    // Getting the query params
    const int32_t page = getQueryParam_page(request);
    const int32_t pageSize = getQueryParam_pageSize(request);


    int status_code = 500;
    std::shared_ptr<GetCampaignsResponse> resultObject = std::make_shared<GetCampaignsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Магазины пользователя." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignsResponse>> FbyApiCampaignsResource::handler_GET(
        int32_t const & page, int32_t const & pageSize)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsBy_loginLoginResource::FbyApiCampaignsBy_loginLoginResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/by_login/{login: .*}/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsBy_loginLoginResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsBy_loginLoginResource::~FbyApiCampaignsBy_loginLoginResource()
{
}

std::pair<int, std::string> FbyApiCampaignsBy_loginLoginResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsBy_loginLoginResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsBy_loginLoginResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsBy_loginLoginResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsBy_loginLoginResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsBy_loginLoginResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsBy_loginLoginResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const std::string login = getPathParam_login(request);

    // Getting the query params
    const int32_t page = getQueryParam_page(request);
    const int32_t pageSize = getQueryParam_pageSize(request);


    int status_code = 500;
    std::shared_ptr<GetCampaignsResponse> resultObject = std::make_shared<GetCampaignsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(login, page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о магазинах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignsResponse>> FbyApiCampaignsBy_loginLoginResource::handler_GET(
        std::string const & login, int32_t const & page, int32_t const & pageSize)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsBy_loginLoginResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCategoriesMax-sale-quantumResource::FbyApiCategoriesMax-sale-quantumResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/categories/max-sale-quantum/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCategoriesMax-sale-quantumResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCategoriesMax-sale-quantumResource::~FbyApiCategoriesMax-sale-quantumResource()
{
}

std::pair<int, std::string> FbyApiCategoriesMax-sale-quantumResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCategoriesMax-sale-quantumResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCategoriesMax-sale-quantumResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCategoriesMax-sale-quantumResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCategoriesMax-sale-quantumResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCategoriesMax-sale-quantumResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCategoriesMax-sale-quantumResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getCategoriesMaxSaleQuantumRequest = extractJsonModelBodyParam<GetCategoriesMaxSaleQuantumRequest>(bodyContent);




    int status_code = 500;
    std::shared_ptr<GetCategoriesMaxSaleQuantumResponse> resultObject = std::make_shared<GetCategoriesMaxSaleQuantumResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(getCategoriesMaxSaleQuantumRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Лимит на установку кванта и минимального количества товаров." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCategoriesMaxSaleQuantumResponse>> FbyApiCategoriesMax-sale-quantumResource::handler_POST(
        std::shared_ptr<GetCategoriesMaxSaleQuantumRequest> const & getCategoriesMaxSaleQuantumRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCategoriesMax-sale-quantumResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCategoriesTreeResource::FbyApiCategoriesTreeResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/categories/tree/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCategoriesTreeResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCategoriesTreeResource::~FbyApiCategoriesTreeResource()
{
}

std::pair<int, std::string> FbyApiCategoriesTreeResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCategoriesTreeResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCategoriesTreeResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCategoriesTreeResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCategoriesTreeResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCategoriesTreeResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCategoriesTreeResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getCategoriesRequest = extractJsonModelBodyParam<GetCategoriesRequest>(bodyContent);




    int status_code = 500;
    std::shared_ptr<GetCategoriesResponse> resultObject = std::make_shared<GetCategoriesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(getCategoriesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Категории Маркета." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCategoriesResponse>> FbyApiCategoriesTreeResource::handler_POST(
        std::shared_ptr<GetCategoriesRequest> const & getCategoriesRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCategoriesTreeResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCategoryCategoryIdParametersResource::FbyApiCategoryCategoryIdParametersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/category/{categoryId: .*}/parameters/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCategoryCategoryIdParametersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCategoryCategoryIdParametersResource::~FbyApiCategoryCategoryIdParametersResource()
{
}

std::pair<int, std::string> FbyApiCategoryCategoryIdParametersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCategoryCategoryIdParametersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCategoryCategoryIdParametersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCategoryCategoryIdParametersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCategoryCategoryIdParametersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCategoryCategoryIdParametersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCategoryCategoryIdParametersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t categoryId = getPathParam_categoryId(request);



    int status_code = 500;
    std::shared_ptr<GetCategoryContentParametersResponse> resultObject = std::make_shared<GetCategoryContentParametersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(categoryId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список характеристик товаров из заданной категории." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCategoryContentParametersResponse>> FbyApiCategoryCategoryIdParametersResource::handler_POST(
        int64_t const & categoryId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCategoryCategoryIdParametersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdChatsHistoryResource::FbyApiBusinessesBusinessIdChatsHistoryResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/history/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdChatsHistoryResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdChatsHistoryResource::~FbyApiBusinessesBusinessIdChatsHistoryResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsHistoryResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsHistoryResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsHistoryResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdChatsHistoryResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdChatsHistoryResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdChatsHistoryResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdChatsHistoryResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getChatHistoryRequest = extractJsonModelBodyParam<GetChatHistoryRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const int64_t chatId = getQueryParam_chatId(request);
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetChatHistoryResponse> resultObject = std::make_shared<GetChatHistoryResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, chatId, getChatHistoryRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "История сообщений успешно получена. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetChatHistoryResponse>> FbyApiBusinessesBusinessIdChatsHistoryResource::handler_POST(
        int64_t const & businessId, int64_t const & chatId, std::shared_ptr<GetChatHistoryRequest> const & getChatHistoryRequest, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdChatsHistoryResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdChatsResource::FbyApiBusinessesBusinessIdChatsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdChatsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdChatsResource::~FbyApiBusinessesBusinessIdChatsResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdChatsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdChatsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdChatsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdChatsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getChatsRequest = extractJsonModelBodyParam<GetChatsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetChatsResponse> resultObject = std::make_shared<GetChatsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getChatsRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список чатов. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetChatsResponse>> FbyApiBusinessesBusinessIdChatsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetChatsRequest> const & getChatsRequest, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdChatsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdFeedsFeedIdResource::FbyApiCampaignsCampaignIdFeedsFeedIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdFeedsFeedIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdFeedsFeedIdResource::~FbyApiCampaignsCampaignIdFeedsFeedIdResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdFeedsFeedIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdFeedsFeedIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdFeedsFeedIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdFeedsFeedIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t feedId = getPathParam_feedId(request);



    int status_code = 500;
    std::shared_ptr<GetFeedResponse> resultObject = std::make_shared<GetFeedResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, feedId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о прайс-листе." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetFeedResponse>> FbyApiCampaignsCampaignIdFeedsFeedIdResource::handler_GET(
        int64_t const & campaignId, int64_t const & feedId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdFeedsFeedIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/index-logs/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::~FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t feedId = getPathParam_feedId(request);

    // Getting the query params
    const int32_t limit = getQueryParam_limit(request);
    const std::string publishedTimeFrom = getQueryParam_publishedTimeFrom(request);
    const std::string publishedTimeTo = getQueryParam_publishedTimeTo(request);


    int status_code = 500;
    std::shared_ptr<GetFeedIndexLogsResponse> resultObject = std::make_shared<GetFeedIndexLogsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Отчет по индексации прайс-листа." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetFeedIndexLogsResponse>> FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handler_GET(
        int64_t const & campaignId, int64_t const & feedId, int32_t const & limit, std::string const & publishedTimeFrom, std::string const & publishedTimeTo, std::shared_ptr<FeedIndexLogsStatusType> const & status)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdFeedbackUpdatesResource::FbyApiCampaignsCampaignIdFeedbackUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feedback/updates/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdFeedbackUpdatesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdFeedbackUpdatesResource::~FbyApiCampaignsCampaignIdFeedbackUpdatesResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedbackUpdatesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedbackUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedbackUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdFeedbackUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdFeedbackUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdFeedbackUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdFeedbackUpdatesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);
    const std::string fromDate = getQueryParam_fromDate(request);


    int status_code = 500;
    std::shared_ptr<GetFeedbackListResponse> resultObject = std::make_shared<GetFeedbackListResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, pageToken, limit, fromDate);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список отзывов для магазина." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetFeedbackListResponse>> FbyApiCampaignsCampaignIdFeedbackUpdatesResource::handler_GET(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::string const & fromDate)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdFeedbackUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdFeedsResource::FbyApiCampaignsCampaignIdFeedsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdFeedsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdFeedsResource::~FbyApiCampaignsCampaignIdFeedsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdFeedsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdFeedsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdFeedsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdFeedsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetFeedsResponse> resultObject = std::make_shared<GetFeedsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список прайс-листов." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetFeedsResponse>> FbyApiCampaignsCampaignIdFeedsResource::handler_GET(
        int64_t const & campaignId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdFeedsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiWarehousesResource::FbyApiWarehousesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/warehouses/");
	this->set_method_handler("GET",
		std::bind(&FbyApiWarehousesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiWarehousesResource::~FbyApiWarehousesResource()
{
}

std::pair<int, std::string> FbyApiWarehousesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiWarehousesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiWarehousesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiWarehousesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiWarehousesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiWarehousesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiWarehousesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();




    int status_code = 500;
    std::shared_ptr<GetFulfillmentWarehousesResponse> resultObject = std::make_shared<GetFulfillmentWarehousesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET();
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список складов." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetFulfillmentWarehousesResponse>> FbyApiWarehousesResource::handler_GET(
        )
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiWarehousesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::~FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getGoodsFeedbackCommentsRequest = extractJsonModelBodyParam<GetGoodsFeedbackCommentsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetGoodsFeedbackCommentsResponse> resultObject = std::make_shared<GetGoodsFeedbackCommentsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Дерево комментариев к отзыву." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetGoodsFeedbackCommentsResponse>> FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetGoodsFeedbackCommentsRequest> const & getGoodsFeedbackCommentsRequest, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdGoods-feedbackResource::FbyApiBusinessesBusinessIdGoods-feedbackResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdGoods-feedbackResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdGoods-feedbackResource::~FbyApiBusinessesBusinessIdGoods-feedbackResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdGoods-feedbackResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdGoods-feedbackResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getGoodsFeedbackRequest = extractJsonModelBodyParam<GetGoodsFeedbackRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetGoodsFeedbackResponse> resultObject = std::make_shared<GetGoodsFeedbackResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, pageToken, limit, getGoodsFeedbackRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список отзывов." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetGoodsFeedbackResponse>> FbyApiBusinessesBusinessIdGoods-feedbackResource::handler_POST(
        int64_t const & businessId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetGoodsFeedbackRequest> const & getGoodsFeedbackRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdGoods-feedbackResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdStatsSkusResource::FbyApiCampaignsCampaignIdStatsSkusResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/stats/skus/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdStatsSkusResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdStatsSkusResource::~FbyApiCampaignsCampaignIdStatsSkusResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdStatsSkusResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdStatsSkusResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdStatsSkusResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdStatsSkusResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdStatsSkusResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdStatsSkusResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdStatsSkusResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getGoodsStatsRequest = extractJsonModelBodyParam<GetGoodsStatsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetGoodsStatsResponse> resultObject = std::make_shared<GetGoodsStatsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, getGoodsStatsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Отчет по товарам." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetGoodsStatsResponse>> FbyApiCampaignsCampaignIdStatsSkusResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<GetGoodsStatsRequest> const & getGoodsStatsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdStatsSkusResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffer-cardsResource::FbyApiBusinessesBusinessIdOffer-cardsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-cards/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffer-cardsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffer-cardsResource::~FbyApiBusinessesBusinessIdOffer-cardsResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-cardsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-cardsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-cardsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffer-cardsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffer-cardsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffer-cardsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffer-cardsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getOfferCardsContentStatusRequest = extractJsonModelBodyParam<GetOfferCardsContentStatusRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOfferCardsContentStatusResponse> resultObject = std::make_shared<GetOfferCardsContentStatusResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, pageToken, limit, getOfferCardsContentStatusRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о карточках указанных товаров." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOfferCardsContentStatusResponse>> FbyApiBusinessesBusinessIdOffer-cardsResource::handler_POST(
        int64_t const & businessId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetOfferCardsContentStatusRequest> const & getOfferCardsContentStatusRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffer-cardsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::FbyApiCampaignsCampaignIdOffer-mapping-entriesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::~FbyApiCampaignsCampaignIdOffer-mapping-entriesResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOfferMappingEntriesResponse> resultObject = std::make_shared<GetOfferMappingEntriesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о товарах в каталоге." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOfferMappingEntriesResponse>> FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::handler_GET(
        int64_t const & campaignId, std::vector<std::string> const & offerId, std::vector<std::shared_ptr<std::string>> const & shopSku, std::shared_ptr<OfferMappingKindType> const & mappingKind, std::vector<std::shared_ptr<OfferProcessingStatusType>> const & status, std::vector<std::shared_ptr<OfferAvailabilityStatusType>> const & availability, std::vector<int32_t> const & categoryId, std::vector<std::string> const & vendor, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOffer-mapping-entriesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffer-mappingsResource::FbyApiBusinessesBusinessIdOffer-mappingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffer-mappingsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffer-mappingsResource::~FbyApiBusinessesBusinessIdOffer-mappingsResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffer-mappingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffer-mappingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getOfferMappingsRequest = extractJsonModelBodyParam<GetOfferMappingsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOfferMappingsResponse> resultObject = std::make_shared<GetOfferMappingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, pageToken, limit, getOfferMappingsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о товарах в каталоге." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOfferMappingsResponse>> FbyApiBusinessesBusinessIdOffer-mappingsResource::handler_POST(
        int64_t const & businessId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetOfferMappingsRequest> const & getOfferMappingsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffer-mappingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffersRecommendationsResource::FbyApiBusinessesBusinessIdOffersRecommendationsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offers/recommendations/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffersRecommendationsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffersRecommendationsResource::~FbyApiBusinessesBusinessIdOffersRecommendationsResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffersRecommendationsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffersRecommendationsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffersRecommendationsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffersRecommendationsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffersRecommendationsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffersRecommendationsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffersRecommendationsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getOfferRecommendationsRequest = extractJsonModelBodyParam<GetOfferRecommendationsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOfferRecommendationsResponse> resultObject = std::make_shared<GetOfferRecommendationsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getOfferRecommendationsRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров с рекомендациями." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOfferRecommendationsResponse>> FbyApiBusinessesBusinessIdOffersRecommendationsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetOfferRecommendationsRequest> const & getOfferRecommendationsRequest, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffersRecommendationsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOrdersOrderIdResource::FbyApiCampaignsCampaignIdOrdersOrderIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdOrdersOrderIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOrdersOrderIdResource::~FbyApiCampaignsCampaignIdOrdersOrderIdResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<GetOrderResponse> resultObject = std::make_shared<GetOrderResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о заказе." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOrderResponse>> FbyApiCampaignsCampaignIdOrdersOrderIdResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOrdersOrderIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/business-buyer/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::~FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<GetBusinessBuyerInfoResponse> resultObject = std::make_shared<GetBusinessBuyerInfoResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, orderId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о покупателе." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBusinessBuyerInfoResponse>> FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handler_POST(
        int64_t const & campaignId, int64_t const & orderId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/documents/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::~FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<GetBusinessDocumentsInfoResponse> resultObject = std::make_shared<GetBusinessDocumentsInfoResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, orderId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о документах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBusinessDocumentsInfoResponse>> FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST(
        int64_t const & campaignId, int64_t const & orderId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOrdersResource::FbyApiCampaignsCampaignIdOrdersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdOrdersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOrdersResource::~FbyApiCampaignsCampaignIdOrdersResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOrdersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOrdersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOrdersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOrdersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string fromDate = getQueryParam_fromDate(request);
    const std::string toDate = getQueryParam_toDate(request);
    const std::string supplierShipmentDateFrom = getQueryParam_supplierShipmentDateFrom(request);
    const std::string supplierShipmentDateTo = getQueryParam_supplierShipmentDateTo(request);
    const std::string updatedAtFrom = getQueryParam_updatedAtFrom(request);
    const std::string updatedAtTo = getQueryParam_updatedAtTo(request);
    const bool fake = getQueryParam_fake(request);
    const bool hasCis = getQueryParam_hasCis(request);
    const bool onlyWaitingForCancellationApprove = getQueryParam_onlyWaitingForCancellationApprove(request);
    const bool onlyEstimatedDelivery = getQueryParam_onlyEstimatedDelivery(request);
    const int32_t page = getQueryParam_page(request);
    const int32_t pageSize = getQueryParam_pageSize(request);
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOrdersResponse> resultObject = std::make_shared<GetOrdersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о заказах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOrdersResponse>> FbyApiCampaignsCampaignIdOrdersResource::handler_GET(
        int64_t const & campaignId, std::vector<int64_t> const & orderIds, Set<std::shared_ptr<OrderStatusType>> const & status, Set<std::shared_ptr<OrderSubstatusType>> const & substatus, std::string const & fromDate, std::string const & toDate, std::string const & supplierShipmentDateFrom, std::string const & supplierShipmentDateTo, std::string const & updatedAtFrom, std::string const & updatedAtTo, std::shared_ptr<OrderDeliveryDispatchType> const & dispatchType, bool const & fake, bool const & hasCis, bool const & onlyWaitingForCancellationApprove, bool const & onlyEstimatedDelivery, std::shared_ptr<OrderBuyerType> const & buyerType, int32_t const & page, int32_t const & pageSize, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOrdersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdStatsOrdersResource::FbyApiCampaignsCampaignIdStatsOrdersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/stats/orders/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdStatsOrdersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdStatsOrdersResource::~FbyApiCampaignsCampaignIdStatsOrdersResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdStatsOrdersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdStatsOrdersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdStatsOrdersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdStatsOrdersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdStatsOrdersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdStatsOrdersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdStatsOrdersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getOrdersStatsRequest = extractJsonModelBodyParam<GetOrdersStatsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOrdersStatsResponse> resultObject = std::make_shared<GetOrdersStatsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, pageToken, limit, getOrdersStatsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация по заказам." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOrdersStatsResponse>> FbyApiCampaignsCampaignIdStatsOrdersResource::handler_POST(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetOrdersStatsRequest> const & getOrdersStatsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdStatsOrdersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffer-pricesResource::FbyApiCampaignsCampaignIdOffer-pricesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdOffer-pricesResource::handler_GET_internal, this,
			std::placeholders::_1));
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOffer-pricesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffer-pricesResource::~FbyApiCampaignsCampaignIdOffer-pricesResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-pricesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-pricesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-pricesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffer-pricesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffer-pricesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffer-pricesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffer-pricesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);
    const bool archived = getQueryParam_archived(request);


    int status_code = 500;
    std::shared_ptr<GetPricesResponse> resultObject = std::make_shared<GetPricesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, pageToken, limit, archived);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список всех товаров с установленными ценами." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

// x-extension
void FbyApiCampaignsCampaignIdOffer-pricesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session) {

    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // body params or form params here from the body content string
    auto campaignId = std::make_shared<>(bodyContent);
    auto pageToken = std::make_shared<>(bodyContent);
    auto limit = std::make_shared<>(bodyContent);
    auto getPricesByOfferIdsRequest = extractJsonModelBodyParam<GetPricesByOfferIdsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId_x_extension(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken_x_extension(request);

    const int32_t limit = getQueryParam_limit_x_extension(request);


    int status_code = 500;
    std::shared_ptr<GetPricesByOfferIdsResponse> resultObject = std::make_shared<GetPricesByOfferIdsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, pageToken, limit, getPricesByOfferIdsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров с установленными для заданного магазина ценами." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

std::pair<int, std::shared_ptr<GetPricesResponse>> FbyApiCampaignsCampaignIdOffer-pricesResource::handler_GET(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, bool const & archived)
{
    throw FbyApiException(501, "Not implemented");
}

std::pair<int, std::shared_ptr<GetPricesByOfferIdsResponse>> FbyApiCampaignsCampaignIdOffer-pricesResource::handler_POST(
    int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetPricesByOfferIdsRequest> const & getPricesByOfferIdsRequest)
{
    throw FbyApiException(501, "Not implemented");
}

std::string FbyApiCampaignsCampaignIdOffer-pricesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdPromosOffersResource::FbyApiBusinessesBusinessIdPromosOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdPromosOffersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdPromosOffersResource::~FbyApiBusinessesBusinessIdPromosOffersResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosOffersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdPromosOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdPromosOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdPromosOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdPromosOffersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getPromoOffersRequest = extractJsonModelBodyParam<GetPromoOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetPromoOffersResponse> resultObject = std::make_shared<GetPromoOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getPromoOffersRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров, которые участвуют или могут участвовать в акции." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetPromoOffersResponse>> FbyApiBusinessesBusinessIdPromosOffersResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetPromoOffersRequest> const & getPromoOffersRequest, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdPromosOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdPromosResource::FbyApiBusinessesBusinessIdPromosResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdPromosResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdPromosResource::~FbyApiBusinessesBusinessIdPromosResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdPromosResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdPromosResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdPromosResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdPromosResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getPromosRequest = extractJsonModelBodyParam<GetPromosRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetPromosResponse> resultObject = std::make_shared<GetPromosResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getPromosRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список акций Маркета." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetPromosResponse>> FbyApiBusinessesBusinessIdPromosResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetPromosRequest> const & getPromosRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdPromosResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdRatingsQualityResource::FbyApiBusinessesBusinessIdRatingsQualityResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/ratings/quality/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdRatingsQualityResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdRatingsQualityResource::~FbyApiBusinessesBusinessIdRatingsQualityResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdRatingsQualityResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdRatingsQualityResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdRatingsQualityResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdRatingsQualityResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdRatingsQualityResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdRatingsQualityResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdRatingsQualityResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getQualityRatingRequest = extractJsonModelBodyParam<GetQualityRatingRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetQualityRatingResponse> resultObject = std::make_shared<GetQualityRatingResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getQualityRatingRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Значение индекса качества магазинов и его составляющие." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetQualityRatingResponse>> FbyApiBusinessesBusinessIdRatingsQualityResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetQualityRatingRequest> const & getQualityRatingRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdRatingsQualityResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiReportsInfoReportIdResource::FbyApiReportsInfoReportIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/info/{reportId: .*}/");
	this->set_method_handler("GET",
		std::bind(&FbyApiReportsInfoReportIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiReportsInfoReportIdResource::~FbyApiReportsInfoReportIdResource()
{
}

std::pair<int, std::string> FbyApiReportsInfoReportIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiReportsInfoReportIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiReportsInfoReportIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiReportsInfoReportIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiReportsInfoReportIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiReportsInfoReportIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiReportsInfoReportIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const std::string reportId = getPathParam_reportId(request);



    int status_code = 500;
    std::shared_ptr<GetReportInfoResponse> resultObject = std::make_shared<GetReportInfoResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(reportId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Статус генерации отчета и ссылка, если она уже есть.  {% note tip %}  Если статус генерации отчета — &#x60;FAILED&#x60; или &#x60;NO_DATA&#x60;, проверьте корректность запроса на генерацию. Например, верно ли указан идентификатор магазина, период или номер платежного поручения.  {% endnote %}    " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetReportInfoResponse>> FbyApiReportsInfoReportIdResource::handler_GET(
        std::string const & reportId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiReportsInfoReportIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::~FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);
    const int64_t returnId = getPathParam_returnId(request);



    int status_code = 500;
    std::shared_ptr<GetReturnResponse> resultObject = std::make_shared<GetReturnResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId, returnId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Детали возврата." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetReturnResponse>> FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId, int64_t const & returnId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/decision/{itemId: .*}/image/{imageHash: .*}/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::~FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);
    const int64_t returnId = getPathParam_returnId(request);
    const int64_t itemId = getPathParam_itemId(request);
    const std::string imageHash = getPathParam_imageHash(request);



    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId, returnId, itemId, imageHash);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Фотография возврата." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::string> FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId, int64_t const & returnId, int64_t const & itemId, std::string const & imageHash)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdReturnsResource::FbyApiCampaignsCampaignIdReturnsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/returns/");
	this->set_method_handler("GET",
		std::bind(&FbyApiCampaignsCampaignIdReturnsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdReturnsResource::~FbyApiCampaignsCampaignIdReturnsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdReturnsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdReturnsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdReturnsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdReturnsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdReturnsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdReturnsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdReturnsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);
    const std::string fromDate = getQueryParam_fromDate(request);
    const std::string toDate = getQueryParam_toDate(request);
    const std::string fromDate2 = getQueryParam_fromDate2(request);
    const std::string toDate2 = getQueryParam_toDate2(request);


    int status_code = 500;
    std::shared_ptr<GetReturnsResponse> resultObject = std::make_shared<GetReturnsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Постраничные возвраты партнера." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetReturnsResponse>> FbyApiCampaignsCampaignIdReturnsResource::handler_GET(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::vector<int64_t> const & orderIds, std::vector<std::shared_ptr<RefundStatusType>> const & statuses, std::shared_ptr<ReturnType> const & type, std::string const & fromDate, std::string const & toDate, std::string const & fromDate2, std::string const & toDate2)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdReturnsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffersStocksResource::FbyApiCampaignsCampaignIdOffersStocksResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/stocks/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOffersStocksResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffersStocksResource::~FbyApiCampaignsCampaignIdOffersStocksResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersStocksResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersStocksResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersStocksResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffersStocksResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffersStocksResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffersStocksResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffersStocksResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getWarehouseStocksRequest = extractJsonModelBodyParam<GetWarehouseStocksRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetWarehouseStocksResponse> resultObject = std::make_shared<GetWarehouseStocksResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, pageToken, limit, getWarehouseStocksRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Остатки товаров на складах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetWarehouseStocksResponse>> FbyApiCampaignsCampaignIdOffersStocksResource::handler_POST(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetWarehouseStocksRequest> const & getWarehouseStocksRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOffersStocksResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/suggestions/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::~FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getSuggestedOfferMappingEntriesRequest = extractJsonModelBodyParam<GetSuggestedOfferMappingEntriesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetSuggestedOfferMappingEntriesResponse> resultObject = std::make_shared<GetSuggestedOfferMappingEntriesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, getSuggestedOfferMappingEntriesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о товарах в каталоге." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetSuggestedOfferMappingEntriesResponse>> FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<GetSuggestedOfferMappingEntriesRequest> const & getSuggestedOfferMappingEntriesRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/suggestions/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::~FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getSuggestedOfferMappingsRequest = extractJsonModelBodyParam<GetSuggestedOfferMappingsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetSuggestedOfferMappingsResponse> resultObject = std::make_shared<GetSuggestedOfferMappingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getSuggestedOfferMappingsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Подобранные карточки на Маркете.  По результатам проверки товара полученная через этот запрос карточка может быть заменена на другую. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetSuggestedOfferMappingsResponse>> FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetSuggestedOfferMappingsRequest> const & getSuggestedOfferMappingsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/suggestions/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::~FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto suggestPricesRequest = extractJsonModelBodyParam<SuggestPricesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<SuggestPricesResponse> resultObject = std::make_shared<SuggestPricesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, suggestPricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список цен для продвижения на Маркете." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<SuggestPricesResponse>> FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<SuggestPricesRequest> const & suggestPricesRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdBidsResource::FbyApiBusinessesBusinessIdBidsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/");
	this->set_method_handler("PUT",
		std::bind(&FbyApiBusinessesBusinessIdBidsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdBidsResource::~FbyApiBusinessesBusinessIdBidsResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdBidsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdBidsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdBidsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdBidsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdBidsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdBidsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdBidsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto putSkuBidsRequest = extractJsonModelBodyParam<PutSkuBidsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_PUT(businessId, putSkuBidsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Все получилось: ставки установлены или обновлены. Если нужно, добавлены новые товары и запущена кампания. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiBusinessesBusinessIdBidsResource::handler_PUT(
        int64_t const & businessId, std::shared_ptr<PutSkuBidsRequest> const & putSkuBidsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdBidsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdBidsResource::FbyApiCampaignsCampaignIdBidsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/bids/");
	this->set_method_handler("PUT",
		std::bind(&FbyApiCampaignsCampaignIdBidsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdBidsResource::~FbyApiCampaignsCampaignIdBidsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdBidsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdBidsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdBidsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdBidsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdBidsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdBidsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdBidsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto putSkuBidsRequest = extractJsonModelBodyParam<PutSkuBidsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_PUT(campaignId, putSkuBidsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiCampaignsCampaignIdBidsResource::handler_PUT(
        int64_t const & campaignId, std::shared_ptr<PutSkuBidsRequest> const & putSkuBidsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdBidsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/refresh/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::~FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t feedId = getPathParam_feedId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, feedId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST(
        int64_t const & campaignId, int64_t const & feedId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiRegionsRegionIdChildrenResource::FbyApiRegionsRegionIdChildrenResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/{regionId: .*}/children/");
	this->set_method_handler("GET",
		std::bind(&FbyApiRegionsRegionIdChildrenResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiRegionsRegionIdChildrenResource::~FbyApiRegionsRegionIdChildrenResource()
{
}

std::pair<int, std::string> FbyApiRegionsRegionIdChildrenResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiRegionsRegionIdChildrenResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiRegionsRegionIdChildrenResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiRegionsRegionIdChildrenResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiRegionsRegionIdChildrenResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiRegionsRegionIdChildrenResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiRegionsRegionIdChildrenResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t regionId = getPathParam_regionId(request);

    // Getting the query params
    const int32_t page = getQueryParam_page(request);
    const int32_t pageSize = getQueryParam_pageSize(request);


    int status_code = 500;
    std::shared_ptr<GetRegionWithChildrenResponse> resultObject = std::make_shared<GetRegionWithChildrenResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(regionId, page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Регионы, являющиеся дочерними к указанному в запросе." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetRegionWithChildrenResponse>> FbyApiRegionsRegionIdChildrenResource::handler_GET(
        int64_t const & regionId, int32_t const & page, int32_t const & pageSize)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiRegionsRegionIdChildrenResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiRegionsRegionIdResource::FbyApiRegionsRegionIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/{regionId: .*}/");
	this->set_method_handler("GET",
		std::bind(&FbyApiRegionsRegionIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiRegionsRegionIdResource::~FbyApiRegionsRegionIdResource()
{
}

std::pair<int, std::string> FbyApiRegionsRegionIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiRegionsRegionIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiRegionsRegionIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiRegionsRegionIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiRegionsRegionIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiRegionsRegionIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiRegionsRegionIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t regionId = getPathParam_regionId(request);



    int status_code = 500;
    std::shared_ptr<GetRegionsResponse> resultObject = std::make_shared<GetRegionsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(regionId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Найденный регион." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetRegionsResponse>> FbyApiRegionsRegionIdResource::handler_GET(
        int64_t const & regionId)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiRegionsRegionIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiRegionsResource::FbyApiRegionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/");
	this->set_method_handler("GET",
		std::bind(&FbyApiRegionsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

FbyApiRegionsResource::~FbyApiRegionsResource()
{
}

std::pair<int, std::string> FbyApiRegionsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiRegionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiRegionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiRegionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiRegionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiRegionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiRegionsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();


    // Getting the query params
    const std::string name = getQueryParam_name(request);
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetRegionsResponse> resultObject = std::make_shared<GetRegionsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(name, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список найденных регионов." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetRegionsResponse>> FbyApiRegionsResource::handler_GET(
        std::string const & name, std::string const & pageToken, int32_t const & limit)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiRegionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdChatsFileSendResource::FbyApiBusinessesBusinessIdChatsFileSendResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/file/send/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdChatsFileSendResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdChatsFileSendResource::~FbyApiBusinessesBusinessIdChatsFileSendResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsFileSendResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsFileSendResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsFileSendResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdChatsFileSendResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdChatsFileSendResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdChatsFileSendResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdChatsFileSendResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const int64_t chatId = getQueryParam_chatId(request);


    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, chatId, file);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ. Означает, что файл отправлен." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiBusinessesBusinessIdChatsFileSendResource::handler_POST(
        int64_t const & businessId, int64_t const & chatId, std::string const & file)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdChatsFileSendResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdChatsMessageResource::FbyApiBusinessesBusinessIdChatsMessageResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/message/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdChatsMessageResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdChatsMessageResource::~FbyApiBusinessesBusinessIdChatsMessageResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsMessageResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsMessageResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdChatsMessageResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdChatsMessageResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdChatsMessageResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdChatsMessageResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdChatsMessageResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto sendMessageToChatRequest = extractJsonModelBodyParam<SendMessageToChatRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const int64_t chatId = getQueryParam_chatId(request);


    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, chatId, sendMessageToChatRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ. Означает, что сообщение отправлено." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiBusinessesBusinessIdChatsMessageResource::handler_POST(
        int64_t const & businessId, int64_t const & chatId, std::shared_ptr<SendMessageToChatRequest> const & sendMessageToChatRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdChatsMessageResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/params/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::~FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto setFeedParamsRequest = extractJsonModelBodyParam<SetFeedParamsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t feedId = getPathParam_feedId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, feedId, setFeedParamsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Статус выполнения операции." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST(
        int64_t const & campaignId, int64_t const & feedId, std::shared_ptr<SetFeedParamsRequest> const & setFeedParamsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/skip-reaction/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::~FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto skipGoodsFeedbackReactionRequest = extractJsonModelBodyParam<SkipGoodsFeedbackReactionRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, skipGoodsFeedbackReactionRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<SkipGoodsFeedbackReactionRequest> const & skipGoodsFeedbackReactionRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-prices/updates/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::~FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateBusinessPricesRequest = extractJsonModelBodyParam<UpdateBusinessPricesRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updateBusinessPricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Маркет принял информацию о новых ценах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdateBusinessPricesRequest> const & updateBusinessPricesRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffersUpdateResource::FbyApiCampaignsCampaignIdOffersUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/update/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOffersUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffersUpdateResource::~FbyApiCampaignsCampaignIdOffersUpdateResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffersUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffersUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffersUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffersUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffersUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateCampaignOffersRequest = extractJsonModelBodyParam<UpdateCampaignOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, updateCampaignOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Ответ 200 обозначает, что новые параметры получены Маркетом и скоро вступят в силу." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiCampaignsCampaignIdOffersUpdateResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<UpdateCampaignOffersRequest> const & updateCampaignOffersRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOffersUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/update/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::~FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateGoodsFeedbackCommentRequest = extractJsonModelBodyParam<UpdateGoodsFeedbackCommentRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<UpdateGoodsFeedbackCommentResponse> resultObject = std::make_shared<UpdateGoodsFeedbackCommentResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updateGoodsFeedbackCommentRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о добавленном или измененном комментарии." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdateGoodsFeedbackCommentResponse>> FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdateGoodsFeedbackCommentRequest> const & updateGoodsFeedbackCommentRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::FbyApiBusinessesBusinessIdOffer-cardsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-cards/update/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::~FbyApiBusinessesBusinessIdOffer-cardsUpdateResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateOfferContentRequest = extractJsonModelBodyParam<UpdateOfferContentRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<UpdateOfferContentResponse> resultObject = std::make_shared<UpdateOfferContentResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updateOfferContentRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Запрос выполнен корректно, данные обработаны.  {% note warning \&quot;Ответ 200 сам по себе не значит, что переданные значения корректны\&quot; %}  Обязательно посмотрите детали ответа: &#x60;status&#x60; и перечень ошибок, если он есть.  Даже если ошибка допущена в характеристиках всего одного товара, никакие изменения из запроса в каталог не попадут.  {% endnote %}  Если в &#x60;status&#x60; вернулось &#x60;ERROR&#x60;, убедитесь, что:  * все обязательные характеристики заполнены; * характеристики действительно существуют в указанных категориях; * значения соответствуют характеристикам; * ваши собственные значения имеют нужный тип данных.  Найти проблемы помогут поля &#x60;errors&#x60; и &#x60;warnings&#x60;. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdateOfferContentResponse>> FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdateOfferContentRequest> const & updateOfferContentRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffer-cardsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/updates/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::~FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateOfferMappingEntryRequest = extractJsonModelBodyParam<UpdateOfferMappingEntryRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, updateOfferMappingEntryRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Статус выполнения операции." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<UpdateOfferMappingEntryRequest> const & updateOfferMappingEntryRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/update/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::~FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateOfferMappingsRequest = extractJsonModelBodyParam<UpdateOfferMappingsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<UpdateOfferMappingsResponse> resultObject = std::make_shared<UpdateOfferMappingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updateOfferMappingsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Все обязательные поля товаров заполнены, поэтому новые товары и внесенные изменения сохранены в каталоге. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdateOfferMappingsResponse>> FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdateOfferMappingsRequest> const & updateOfferMappingsRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/updates/");
	this->set_method_handler("POST",
		std::bind(&FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::~FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource()
{
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updatePricesRequest = extractJsonModelBodyParam<UpdatePricesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, updatePricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Маркет принял информацию о новых ценах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<UpdatePricesRequest> const & updatePricesRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
FbyApiBusinessesBusinessIdPromosOffersUpdateResource::FbyApiBusinessesBusinessIdPromosOffersUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/update/");
	this->set_method_handler("POST",
		std::bind(&FbyApiBusinessesBusinessIdPromosOffersUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

FbyApiBusinessesBusinessIdPromosOffersUpdateResource::~FbyApiBusinessesBusinessIdPromosOffersUpdateResource()
{
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosOffersUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosOffersUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> FbyApiBusinessesBusinessIdPromosOffersUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void FbyApiBusinessesBusinessIdPromosOffersUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void FbyApiBusinessesBusinessIdPromosOffersUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void FbyApiBusinessesBusinessIdPromosOffersUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void FbyApiBusinessesBusinessIdPromosOffersUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updatePromoOffersRequest = extractJsonModelBodyParam<UpdatePromoOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<UpdatePromoOffersResponse> resultObject = std::make_shared<UpdatePromoOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updatePromoOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Результат добавления товаров в акцию или обновления их цен." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdatePromoOffersResponse>> FbyApiBusinessesBusinessIdPromosOffersUpdateResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdatePromoOffersRequest> const & updatePromoOffersRequest)
{
    throw FbyApiException(501, "Not implemented");
}


std::string FbyApiBusinessesBusinessIdPromosOffersUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

FbyApi::FbyApi(std::shared_ptr<restbed::Service> const& restbedService)
: m_service(restbedService)
{
}

FbyApi::~FbyApi() {}

void FbyApi::setFbyApiCampaignsCampaignIdHidden-offersResource(std::shared_ptr<FbyApiCampaignsCampaignIdHidden-offersResource> spFbyApiCampaignsCampaignIdHidden-offersResource) {
    m_spFbyApiCampaignsCampaignIdHidden-offersResource = spFbyApiCampaignsCampaignIdHidden-offersResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdHidden-offersResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer-mappingsArchiveResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource> spFbyApiBusinessesBusinessIdOffer-mappingsArchiveResource) {
    m_spFbyApiBusinessesBusinessIdOffer-mappingsArchiveResource = spFbyApiBusinessesBusinessIdOffer-mappingsArchiveResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffer-mappingsArchiveResource);
}
void FbyApi::setFbyApiTariffsCalculateResource(std::shared_ptr<FbyApiTariffsCalculateResource> spFbyApiTariffsCalculateResource) {
    m_spFbyApiTariffsCalculateResource = spFbyApiTariffsCalculateResource;
    m_service->publish(m_spFbyApiTariffsCalculateResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPrice-quarantineConfirmResource(std::shared_ptr<FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource> spFbyApiBusinessesBusinessIdPrice-quarantineConfirmResource) {
    m_spFbyApiBusinessesBusinessIdPrice-quarantineConfirmResource = spFbyApiBusinessesBusinessIdPrice-quarantineConfirmResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdPrice-quarantineConfirmResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdPrice-quarantineConfirmResource(std::shared_ptr<FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource> spFbyApiCampaignsCampaignIdPrice-quarantineConfirmResource) {
    m_spFbyApiCampaignsCampaignIdPrice-quarantineConfirmResource = spFbyApiCampaignsCampaignIdPrice-quarantineConfirmResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdPrice-quarantineConfirmResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsNewResource(std::shared_ptr<FbyApiBusinessesBusinessIdChatsNewResource> spFbyApiBusinessesBusinessIdChatsNewResource) {
    m_spFbyApiBusinessesBusinessIdChatsNewResource = spFbyApiBusinessesBusinessIdChatsNewResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdChatsNewResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersDeleteResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffersDeleteResource> spFbyApiCampaignsCampaignIdOffersDeleteResource) {
    m_spFbyApiCampaignsCampaignIdOffersDeleteResource = spFbyApiCampaignsCampaignIdOffersDeleteResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffersDeleteResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource(std::shared_ptr<FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource> spFbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource) {
    m_spFbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource = spFbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdHidden-offersDeleteResource(std::shared_ptr<FbyApiCampaignsCampaignIdHidden-offersDeleteResource> spFbyApiCampaignsCampaignIdHidden-offersDeleteResource) {
    m_spFbyApiCampaignsCampaignIdHidden-offersDeleteResource = spFbyApiCampaignsCampaignIdHidden-offersDeleteResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdHidden-offersDeleteResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer-mappingsDeleteResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource> spFbyApiBusinessesBusinessIdOffer-mappingsDeleteResource) {
    m_spFbyApiBusinessesBusinessIdOffer-mappingsDeleteResource = spFbyApiBusinessesBusinessIdOffer-mappingsDeleteResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffer-mappingsDeleteResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource> spFbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource) {
    m_spFbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource = spFbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPromosOffersDeleteResource(std::shared_ptr<FbyApiBusinessesBusinessIdPromosOffersDeleteResource> spFbyApiBusinessesBusinessIdPromosOffersDeleteResource) {
    m_spFbyApiBusinessesBusinessIdPromosOffersDeleteResource = spFbyApiBusinessesBusinessIdPromosOffersDeleteResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdPromosOffersDeleteResource);
}
void FbyApi::setFbyApiReportsBoost-consolidatedGenerateResource(std::shared_ptr<FbyApiReportsBoost-consolidatedGenerateResource> spFbyApiReportsBoost-consolidatedGenerateResource) {
    m_spFbyApiReportsBoost-consolidatedGenerateResource = spFbyApiReportsBoost-consolidatedGenerateResource;
    m_service->publish(m_spFbyApiReportsBoost-consolidatedGenerateResource);
}
void FbyApi::setFbyApiReportsCompetitors-positionGenerateResource(std::shared_ptr<FbyApiReportsCompetitors-positionGenerateResource> spFbyApiReportsCompetitors-positionGenerateResource) {
    m_spFbyApiReportsCompetitors-positionGenerateResource = spFbyApiReportsCompetitors-positionGenerateResource;
    m_service->publish(m_spFbyApiReportsCompetitors-positionGenerateResource);
}
void FbyApi::setFbyApiReportsGoods-feedbackGenerateResource(std::shared_ptr<FbyApiReportsGoods-feedbackGenerateResource> spFbyApiReportsGoods-feedbackGenerateResource) {
    m_spFbyApiReportsGoods-feedbackGenerateResource = spFbyApiReportsGoods-feedbackGenerateResource;
    m_service->publish(m_spFbyApiReportsGoods-feedbackGenerateResource);
}
void FbyApi::setFbyApiReportsGoods-movementGenerateResource(std::shared_ptr<FbyApiReportsGoods-movementGenerateResource> spFbyApiReportsGoods-movementGenerateResource) {
    m_spFbyApiReportsGoods-movementGenerateResource = spFbyApiReportsGoods-movementGenerateResource;
    m_service->publish(m_spFbyApiReportsGoods-movementGenerateResource);
}
void FbyApi::setFbyApiReportsGoods-realizationGenerateResource(std::shared_ptr<FbyApiReportsGoods-realizationGenerateResource> spFbyApiReportsGoods-realizationGenerateResource) {
    m_spFbyApiReportsGoods-realizationGenerateResource = spFbyApiReportsGoods-realizationGenerateResource;
    m_service->publish(m_spFbyApiReportsGoods-realizationGenerateResource);
}
void FbyApi::setFbyApiReportsGoods-turnoverGenerateResource(std::shared_ptr<FbyApiReportsGoods-turnoverGenerateResource> spFbyApiReportsGoods-turnoverGenerateResource) {
    m_spFbyApiReportsGoods-turnoverGenerateResource = spFbyApiReportsGoods-turnoverGenerateResource;
    m_service->publish(m_spFbyApiReportsGoods-turnoverGenerateResource);
}
void FbyApi::setFbyApiReportsPricesGenerateResource(std::shared_ptr<FbyApiReportsPricesGenerateResource> spFbyApiReportsPricesGenerateResource) {
    m_spFbyApiReportsPricesGenerateResource = spFbyApiReportsPricesGenerateResource;
    m_service->publish(m_spFbyApiReportsPricesGenerateResource);
}
void FbyApi::setFbyApiReportsShelf-statisticsGenerateResource(std::shared_ptr<FbyApiReportsShelf-statisticsGenerateResource> spFbyApiReportsShelf-statisticsGenerateResource) {
    m_spFbyApiReportsShelf-statisticsGenerateResource = spFbyApiReportsShelf-statisticsGenerateResource;
    m_service->publish(m_spFbyApiReportsShelf-statisticsGenerateResource);
}
void FbyApi::setFbyApiReportsShows-salesGenerateResource(std::shared_ptr<FbyApiReportsShows-salesGenerateResource> spFbyApiReportsShows-salesGenerateResource) {
    m_spFbyApiReportsShows-salesGenerateResource = spFbyApiReportsShows-salesGenerateResource;
    m_service->publish(m_spFbyApiReportsShows-salesGenerateResource);
}
void FbyApi::setFbyApiReportsStocks-on-warehousesGenerateResource(std::shared_ptr<FbyApiReportsStocks-on-warehousesGenerateResource> spFbyApiReportsStocks-on-warehousesGenerateResource) {
    m_spFbyApiReportsStocks-on-warehousesGenerateResource = spFbyApiReportsStocks-on-warehousesGenerateResource;
    m_service->publish(m_spFbyApiReportsStocks-on-warehousesGenerateResource);
}
void FbyApi::setFbyApiReportsUnited-marketplace-servicesGenerateResource(std::shared_ptr<FbyApiReportsUnited-marketplace-servicesGenerateResource> spFbyApiReportsUnited-marketplace-servicesGenerateResource) {
    m_spFbyApiReportsUnited-marketplace-servicesGenerateResource = spFbyApiReportsUnited-marketplace-servicesGenerateResource;
    m_service->publish(m_spFbyApiReportsUnited-marketplace-servicesGenerateResource);
}
void FbyApi::setFbyApiReportsUnited-nettingGenerateResource(std::shared_ptr<FbyApiReportsUnited-nettingGenerateResource> spFbyApiReportsUnited-nettingGenerateResource) {
    m_spFbyApiReportsUnited-nettingGenerateResource = spFbyApiReportsUnited-nettingGenerateResource;
    m_service->publish(m_spFbyApiReportsUnited-nettingGenerateResource);
}
void FbyApi::setFbyApiReportsUnited-ordersGenerateResource(std::shared_ptr<FbyApiReportsUnited-ordersGenerateResource> spFbyApiReportsUnited-ordersGenerateResource) {
    m_spFbyApiReportsUnited-ordersGenerateResource = spFbyApiReportsUnited-ordersGenerateResource;
    m_service->publish(m_spFbyApiReportsUnited-ordersGenerateResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersAllResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffersAllResource> spFbyApiCampaignsCampaignIdOffersAllResource) {
    m_spFbyApiCampaignsCampaignIdOffersAllResource = spFbyApiCampaignsCampaignIdOffersAllResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffersAllResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdBidsInfoResource(std::shared_ptr<FbyApiBusinessesBusinessIdBidsInfoResource> spFbyApiBusinessesBusinessIdBidsInfoResource) {
    m_spFbyApiBusinessesBusinessIdBidsInfoResource = spFbyApiBusinessesBusinessIdBidsInfoResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdBidsInfoResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdBidsRecommendationsResource(std::shared_ptr<FbyApiBusinessesBusinessIdBidsRecommendationsResource> spFbyApiBusinessesBusinessIdBidsRecommendationsResource) {
    m_spFbyApiBusinessesBusinessIdBidsRecommendationsResource = spFbyApiBusinessesBusinessIdBidsRecommendationsResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdBidsRecommendationsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPrice-quarantineResource(std::shared_ptr<FbyApiBusinessesBusinessIdPrice-quarantineResource> spFbyApiBusinessesBusinessIdPrice-quarantineResource) {
    m_spFbyApiBusinessesBusinessIdPrice-quarantineResource = spFbyApiBusinessesBusinessIdPrice-quarantineResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdPrice-quarantineResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdSettingsResource(std::shared_ptr<FbyApiBusinessesBusinessIdSettingsResource> spFbyApiBusinessesBusinessIdSettingsResource) {
    m_spFbyApiBusinessesBusinessIdSettingsResource = spFbyApiBusinessesBusinessIdSettingsResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdSettingsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdResource(std::shared_ptr<FbyApiCampaignsCampaignIdResource> spFbyApiCampaignsCampaignIdResource) {
    m_spFbyApiCampaignsCampaignIdResource = spFbyApiCampaignsCampaignIdResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdLoginsResource(std::shared_ptr<FbyApiCampaignsCampaignIdLoginsResource> spFbyApiCampaignsCampaignIdLoginsResource) {
    m_spFbyApiCampaignsCampaignIdLoginsResource = spFbyApiCampaignsCampaignIdLoginsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdLoginsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffersResource> spFbyApiCampaignsCampaignIdOffersResource) {
    m_spFbyApiCampaignsCampaignIdOffersResource = spFbyApiCampaignsCampaignIdOffersResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffersResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdPrice-quarantineResource(std::shared_ptr<FbyApiCampaignsCampaignIdPrice-quarantineResource> spFbyApiCampaignsCampaignIdPrice-quarantineResource) {
    m_spFbyApiCampaignsCampaignIdPrice-quarantineResource = spFbyApiCampaignsCampaignIdPrice-quarantineResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdPrice-quarantineResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdRegionResource(std::shared_ptr<FbyApiCampaignsCampaignIdRegionResource> spFbyApiCampaignsCampaignIdRegionResource) {
    m_spFbyApiCampaignsCampaignIdRegionResource = spFbyApiCampaignsCampaignIdRegionResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdRegionResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdSettingsResource(std::shared_ptr<FbyApiCampaignsCampaignIdSettingsResource> spFbyApiCampaignsCampaignIdSettingsResource) {
    m_spFbyApiCampaignsCampaignIdSettingsResource = spFbyApiCampaignsCampaignIdSettingsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdSettingsResource);
}
void FbyApi::setFbyApiCampaignsResource(std::shared_ptr<FbyApiCampaignsResource> spFbyApiCampaignsResource) {
    m_spFbyApiCampaignsResource = spFbyApiCampaignsResource;
    m_service->publish(m_spFbyApiCampaignsResource);
}
void FbyApi::setFbyApiCampaignsBy_loginLoginResource(std::shared_ptr<FbyApiCampaignsBy_loginLoginResource> spFbyApiCampaignsBy_loginLoginResource) {
    m_spFbyApiCampaignsBy_loginLoginResource = spFbyApiCampaignsBy_loginLoginResource;
    m_service->publish(m_spFbyApiCampaignsBy_loginLoginResource);
}
void FbyApi::setFbyApiCategoriesMax-sale-quantumResource(std::shared_ptr<FbyApiCategoriesMax-sale-quantumResource> spFbyApiCategoriesMax-sale-quantumResource) {
    m_spFbyApiCategoriesMax-sale-quantumResource = spFbyApiCategoriesMax-sale-quantumResource;
    m_service->publish(m_spFbyApiCategoriesMax-sale-quantumResource);
}
void FbyApi::setFbyApiCategoriesTreeResource(std::shared_ptr<FbyApiCategoriesTreeResource> spFbyApiCategoriesTreeResource) {
    m_spFbyApiCategoriesTreeResource = spFbyApiCategoriesTreeResource;
    m_service->publish(m_spFbyApiCategoriesTreeResource);
}
void FbyApi::setFbyApiCategoryCategoryIdParametersResource(std::shared_ptr<FbyApiCategoryCategoryIdParametersResource> spFbyApiCategoryCategoryIdParametersResource) {
    m_spFbyApiCategoryCategoryIdParametersResource = spFbyApiCategoryCategoryIdParametersResource;
    m_service->publish(m_spFbyApiCategoryCategoryIdParametersResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsHistoryResource(std::shared_ptr<FbyApiBusinessesBusinessIdChatsHistoryResource> spFbyApiBusinessesBusinessIdChatsHistoryResource) {
    m_spFbyApiBusinessesBusinessIdChatsHistoryResource = spFbyApiBusinessesBusinessIdChatsHistoryResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdChatsHistoryResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsResource(std::shared_ptr<FbyApiBusinessesBusinessIdChatsResource> spFbyApiBusinessesBusinessIdChatsResource) {
    m_spFbyApiBusinessesBusinessIdChatsResource = spFbyApiBusinessesBusinessIdChatsResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdChatsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsFeedIdResource(std::shared_ptr<FbyApiCampaignsCampaignIdFeedsFeedIdResource> spFbyApiCampaignsCampaignIdFeedsFeedIdResource) {
    m_spFbyApiCampaignsCampaignIdFeedsFeedIdResource = spFbyApiCampaignsCampaignIdFeedsFeedIdResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdFeedsFeedIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource(std::shared_ptr<FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource> spFbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource) {
    m_spFbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource = spFbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedbackUpdatesResource(std::shared_ptr<FbyApiCampaignsCampaignIdFeedbackUpdatesResource> spFbyApiCampaignsCampaignIdFeedbackUpdatesResource) {
    m_spFbyApiCampaignsCampaignIdFeedbackUpdatesResource = spFbyApiCampaignsCampaignIdFeedbackUpdatesResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdFeedbackUpdatesResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsResource(std::shared_ptr<FbyApiCampaignsCampaignIdFeedsResource> spFbyApiCampaignsCampaignIdFeedsResource) {
    m_spFbyApiCampaignsCampaignIdFeedsResource = spFbyApiCampaignsCampaignIdFeedsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdFeedsResource);
}
void FbyApi::setFbyApiWarehousesResource(std::shared_ptr<FbyApiWarehousesResource> spFbyApiWarehousesResource) {
    m_spFbyApiWarehousesResource = spFbyApiWarehousesResource;
    m_service->publish(m_spFbyApiWarehousesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods-feedbackCommentsResource(std::shared_ptr<FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource> spFbyApiBusinessesBusinessIdGoods-feedbackCommentsResource) {
    m_spFbyApiBusinessesBusinessIdGoods-feedbackCommentsResource = spFbyApiBusinessesBusinessIdGoods-feedbackCommentsResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdGoods-feedbackCommentsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods-feedbackResource(std::shared_ptr<FbyApiBusinessesBusinessIdGoods-feedbackResource> spFbyApiBusinessesBusinessIdGoods-feedbackResource) {
    m_spFbyApiBusinessesBusinessIdGoods-feedbackResource = spFbyApiBusinessesBusinessIdGoods-feedbackResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdGoods-feedbackResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdStatsSkusResource(std::shared_ptr<FbyApiCampaignsCampaignIdStatsSkusResource> spFbyApiCampaignsCampaignIdStatsSkusResource) {
    m_spFbyApiCampaignsCampaignIdStatsSkusResource = spFbyApiCampaignsCampaignIdStatsSkusResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdStatsSkusResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer-cardsResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffer-cardsResource> spFbyApiBusinessesBusinessIdOffer-cardsResource) {
    m_spFbyApiBusinessesBusinessIdOffer-cardsResource = spFbyApiBusinessesBusinessIdOffer-cardsResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffer-cardsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer-mapping-entriesResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffer-mapping-entriesResource> spFbyApiCampaignsCampaignIdOffer-mapping-entriesResource) {
    m_spFbyApiCampaignsCampaignIdOffer-mapping-entriesResource = spFbyApiCampaignsCampaignIdOffer-mapping-entriesResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffer-mapping-entriesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer-mappingsResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffer-mappingsResource> spFbyApiBusinessesBusinessIdOffer-mappingsResource) {
    m_spFbyApiBusinessesBusinessIdOffer-mappingsResource = spFbyApiBusinessesBusinessIdOffer-mappingsResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffer-mappingsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffersRecommendationsResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffersRecommendationsResource> spFbyApiBusinessesBusinessIdOffersRecommendationsResource) {
    m_spFbyApiBusinessesBusinessIdOffersRecommendationsResource = spFbyApiBusinessesBusinessIdOffersRecommendationsResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffersRecommendationsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdResource(std::shared_ptr<FbyApiCampaignsCampaignIdOrdersOrderIdResource> spFbyApiCampaignsCampaignIdOrdersOrderIdResource) {
    m_spFbyApiCampaignsCampaignIdOrdersOrderIdResource = spFbyApiCampaignsCampaignIdOrdersOrderIdResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOrdersOrderIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource(std::shared_ptr<FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource> spFbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource) {
    m_spFbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource = spFbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource(std::shared_ptr<FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource> spFbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
    m_spFbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource = spFbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersResource(std::shared_ptr<FbyApiCampaignsCampaignIdOrdersResource> spFbyApiCampaignsCampaignIdOrdersResource) {
    m_spFbyApiCampaignsCampaignIdOrdersResource = spFbyApiCampaignsCampaignIdOrdersResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOrdersResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdStatsOrdersResource(std::shared_ptr<FbyApiCampaignsCampaignIdStatsOrdersResource> spFbyApiCampaignsCampaignIdStatsOrdersResource) {
    m_spFbyApiCampaignsCampaignIdStatsOrdersResource = spFbyApiCampaignsCampaignIdStatsOrdersResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdStatsOrdersResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer-pricesResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffer-pricesResource> spFbyApiCampaignsCampaignIdOffer-pricesResource) {
    m_spFbyApiCampaignsCampaignIdOffer-pricesResource = spFbyApiCampaignsCampaignIdOffer-pricesResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffer-pricesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPromosOffersResource(std::shared_ptr<FbyApiBusinessesBusinessIdPromosOffersResource> spFbyApiBusinessesBusinessIdPromosOffersResource) {
    m_spFbyApiBusinessesBusinessIdPromosOffersResource = spFbyApiBusinessesBusinessIdPromosOffersResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdPromosOffersResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPromosResource(std::shared_ptr<FbyApiBusinessesBusinessIdPromosResource> spFbyApiBusinessesBusinessIdPromosResource) {
    m_spFbyApiBusinessesBusinessIdPromosResource = spFbyApiBusinessesBusinessIdPromosResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdPromosResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdRatingsQualityResource(std::shared_ptr<FbyApiBusinessesBusinessIdRatingsQualityResource> spFbyApiBusinessesBusinessIdRatingsQualityResource) {
    m_spFbyApiBusinessesBusinessIdRatingsQualityResource = spFbyApiBusinessesBusinessIdRatingsQualityResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdRatingsQualityResource);
}
void FbyApi::setFbyApiReportsInfoReportIdResource(std::shared_ptr<FbyApiReportsInfoReportIdResource> spFbyApiReportsInfoReportIdResource) {
    m_spFbyApiReportsInfoReportIdResource = spFbyApiReportsInfoReportIdResource;
    m_service->publish(m_spFbyApiReportsInfoReportIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(std::shared_ptr<FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource> spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
    m_spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource = spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(std::shared_ptr<FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource> spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
    m_spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource = spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdReturnsResource(std::shared_ptr<FbyApiCampaignsCampaignIdReturnsResource> spFbyApiCampaignsCampaignIdReturnsResource) {
    m_spFbyApiCampaignsCampaignIdReturnsResource = spFbyApiCampaignsCampaignIdReturnsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdReturnsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersStocksResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffersStocksResource> spFbyApiCampaignsCampaignIdOffersStocksResource) {
    m_spFbyApiCampaignsCampaignIdOffersStocksResource = spFbyApiCampaignsCampaignIdOffersStocksResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffersStocksResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource> spFbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource) {
    m_spFbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource = spFbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource> spFbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource) {
    m_spFbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource = spFbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource> spFbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource) {
    m_spFbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource = spFbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdBidsResource(std::shared_ptr<FbyApiBusinessesBusinessIdBidsResource> spFbyApiBusinessesBusinessIdBidsResource) {
    m_spFbyApiBusinessesBusinessIdBidsResource = spFbyApiBusinessesBusinessIdBidsResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdBidsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdBidsResource(std::shared_ptr<FbyApiCampaignsCampaignIdBidsResource> spFbyApiCampaignsCampaignIdBidsResource) {
    m_spFbyApiCampaignsCampaignIdBidsResource = spFbyApiCampaignsCampaignIdBidsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdBidsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource(std::shared_ptr<FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource> spFbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource) {
    m_spFbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource = spFbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource);
}
void FbyApi::setFbyApiRegionsRegionIdChildrenResource(std::shared_ptr<FbyApiRegionsRegionIdChildrenResource> spFbyApiRegionsRegionIdChildrenResource) {
    m_spFbyApiRegionsRegionIdChildrenResource = spFbyApiRegionsRegionIdChildrenResource;
    m_service->publish(m_spFbyApiRegionsRegionIdChildrenResource);
}
void FbyApi::setFbyApiRegionsRegionIdResource(std::shared_ptr<FbyApiRegionsRegionIdResource> spFbyApiRegionsRegionIdResource) {
    m_spFbyApiRegionsRegionIdResource = spFbyApiRegionsRegionIdResource;
    m_service->publish(m_spFbyApiRegionsRegionIdResource);
}
void FbyApi::setFbyApiRegionsResource(std::shared_ptr<FbyApiRegionsResource> spFbyApiRegionsResource) {
    m_spFbyApiRegionsResource = spFbyApiRegionsResource;
    m_service->publish(m_spFbyApiRegionsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsFileSendResource(std::shared_ptr<FbyApiBusinessesBusinessIdChatsFileSendResource> spFbyApiBusinessesBusinessIdChatsFileSendResource) {
    m_spFbyApiBusinessesBusinessIdChatsFileSendResource = spFbyApiBusinessesBusinessIdChatsFileSendResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdChatsFileSendResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsMessageResource(std::shared_ptr<FbyApiBusinessesBusinessIdChatsMessageResource> spFbyApiBusinessesBusinessIdChatsMessageResource) {
    m_spFbyApiBusinessesBusinessIdChatsMessageResource = spFbyApiBusinessesBusinessIdChatsMessageResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdChatsMessageResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsFeedIdParamsResource(std::shared_ptr<FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource> spFbyApiCampaignsCampaignIdFeedsFeedIdParamsResource) {
    m_spFbyApiCampaignsCampaignIdFeedsFeedIdParamsResource = spFbyApiCampaignsCampaignIdFeedsFeedIdParamsResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdFeedsFeedIdParamsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource(std::shared_ptr<FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource> spFbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource) {
    m_spFbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource = spFbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer-pricesUpdatesResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource> spFbyApiBusinessesBusinessIdOffer-pricesUpdatesResource) {
    m_spFbyApiBusinessesBusinessIdOffer-pricesUpdatesResource = spFbyApiBusinessesBusinessIdOffer-pricesUpdatesResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffer-pricesUpdatesResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersUpdateResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffersUpdateResource> spFbyApiCampaignsCampaignIdOffersUpdateResource) {
    m_spFbyApiCampaignsCampaignIdOffersUpdateResource = spFbyApiCampaignsCampaignIdOffersUpdateResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffersUpdateResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource(std::shared_ptr<FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource> spFbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource) {
    m_spFbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource = spFbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer-cardsUpdateResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffer-cardsUpdateResource> spFbyApiBusinessesBusinessIdOffer-cardsUpdateResource) {
    m_spFbyApiBusinessesBusinessIdOffer-cardsUpdateResource = spFbyApiBusinessesBusinessIdOffer-cardsUpdateResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffer-cardsUpdateResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource> spFbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource) {
    m_spFbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource = spFbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer-mappingsUpdateResource(std::shared_ptr<FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource> spFbyApiBusinessesBusinessIdOffer-mappingsUpdateResource) {
    m_spFbyApiBusinessesBusinessIdOffer-mappingsUpdateResource = spFbyApiBusinessesBusinessIdOffer-mappingsUpdateResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdOffer-mappingsUpdateResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer-pricesUpdatesResource(std::shared_ptr<FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource> spFbyApiCampaignsCampaignIdOffer-pricesUpdatesResource) {
    m_spFbyApiCampaignsCampaignIdOffer-pricesUpdatesResource = spFbyApiCampaignsCampaignIdOffer-pricesUpdatesResource;
    m_service->publish(m_spFbyApiCampaignsCampaignIdOffer-pricesUpdatesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPromosOffersUpdateResource(std::shared_ptr<FbyApiBusinessesBusinessIdPromosOffersUpdateResource> spFbyApiBusinessesBusinessIdPromosOffersUpdateResource) {
    m_spFbyApiBusinessesBusinessIdPromosOffersUpdateResource = spFbyApiBusinessesBusinessIdPromosOffersUpdateResource;
    m_service->publish(m_spFbyApiBusinessesBusinessIdPromosOffersUpdateResource);
}


void FbyApi::publishDefaultResources() {
    if (!m_spFbyApiCampaignsCampaignIdHidden-offersResource) {
        setFbyApiCampaignsCampaignIdHidden-offersResource(std::make_shared<FbyApiCampaignsCampaignIdHidden-offersResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffer-mappingsArchiveResource) {
        setFbyApiBusinessesBusinessIdOffer-mappingsArchiveResource(std::make_shared<FbyApiBusinessesBusinessIdOffer-mappingsArchiveResource>());
    }
    if (!m_spFbyApiTariffsCalculateResource) {
        setFbyApiTariffsCalculateResource(std::make_shared<FbyApiTariffsCalculateResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdPrice-quarantineConfirmResource) {
        setFbyApiBusinessesBusinessIdPrice-quarantineConfirmResource(std::make_shared<FbyApiBusinessesBusinessIdPrice-quarantineConfirmResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdPrice-quarantineConfirmResource) {
        setFbyApiCampaignsCampaignIdPrice-quarantineConfirmResource(std::make_shared<FbyApiCampaignsCampaignIdPrice-quarantineConfirmResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdChatsNewResource) {
        setFbyApiBusinessesBusinessIdChatsNewResource(std::make_shared<FbyApiBusinessesBusinessIdChatsNewResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffersDeleteResource) {
        setFbyApiCampaignsCampaignIdOffersDeleteResource(std::make_shared<FbyApiCampaignsCampaignIdOffersDeleteResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource) {
        setFbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource(std::make_shared<FbyApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdHidden-offersDeleteResource) {
        setFbyApiCampaignsCampaignIdHidden-offersDeleteResource(std::make_shared<FbyApiCampaignsCampaignIdHidden-offersDeleteResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffer-mappingsDeleteResource) {
        setFbyApiBusinessesBusinessIdOffer-mappingsDeleteResource(std::make_shared<FbyApiBusinessesBusinessIdOffer-mappingsDeleteResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource) {
        setFbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource(std::make_shared<FbyApiBusinessesBusinessIdOffer-mappingsUnarchiveResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdPromosOffersDeleteResource) {
        setFbyApiBusinessesBusinessIdPromosOffersDeleteResource(std::make_shared<FbyApiBusinessesBusinessIdPromosOffersDeleteResource>());
    }
    if (!m_spFbyApiReportsBoost-consolidatedGenerateResource) {
        setFbyApiReportsBoost-consolidatedGenerateResource(std::make_shared<FbyApiReportsBoost-consolidatedGenerateResource>());
    }
    if (!m_spFbyApiReportsCompetitors-positionGenerateResource) {
        setFbyApiReportsCompetitors-positionGenerateResource(std::make_shared<FbyApiReportsCompetitors-positionGenerateResource>());
    }
    if (!m_spFbyApiReportsGoods-feedbackGenerateResource) {
        setFbyApiReportsGoods-feedbackGenerateResource(std::make_shared<FbyApiReportsGoods-feedbackGenerateResource>());
    }
    if (!m_spFbyApiReportsGoods-movementGenerateResource) {
        setFbyApiReportsGoods-movementGenerateResource(std::make_shared<FbyApiReportsGoods-movementGenerateResource>());
    }
    if (!m_spFbyApiReportsGoods-realizationGenerateResource) {
        setFbyApiReportsGoods-realizationGenerateResource(std::make_shared<FbyApiReportsGoods-realizationGenerateResource>());
    }
    if (!m_spFbyApiReportsGoods-turnoverGenerateResource) {
        setFbyApiReportsGoods-turnoverGenerateResource(std::make_shared<FbyApiReportsGoods-turnoverGenerateResource>());
    }
    if (!m_spFbyApiReportsPricesGenerateResource) {
        setFbyApiReportsPricesGenerateResource(std::make_shared<FbyApiReportsPricesGenerateResource>());
    }
    if (!m_spFbyApiReportsShelf-statisticsGenerateResource) {
        setFbyApiReportsShelf-statisticsGenerateResource(std::make_shared<FbyApiReportsShelf-statisticsGenerateResource>());
    }
    if (!m_spFbyApiReportsShows-salesGenerateResource) {
        setFbyApiReportsShows-salesGenerateResource(std::make_shared<FbyApiReportsShows-salesGenerateResource>());
    }
    if (!m_spFbyApiReportsStocks-on-warehousesGenerateResource) {
        setFbyApiReportsStocks-on-warehousesGenerateResource(std::make_shared<FbyApiReportsStocks-on-warehousesGenerateResource>());
    }
    if (!m_spFbyApiReportsUnited-marketplace-servicesGenerateResource) {
        setFbyApiReportsUnited-marketplace-servicesGenerateResource(std::make_shared<FbyApiReportsUnited-marketplace-servicesGenerateResource>());
    }
    if (!m_spFbyApiReportsUnited-nettingGenerateResource) {
        setFbyApiReportsUnited-nettingGenerateResource(std::make_shared<FbyApiReportsUnited-nettingGenerateResource>());
    }
    if (!m_spFbyApiReportsUnited-ordersGenerateResource) {
        setFbyApiReportsUnited-ordersGenerateResource(std::make_shared<FbyApiReportsUnited-ordersGenerateResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffersAllResource) {
        setFbyApiCampaignsCampaignIdOffersAllResource(std::make_shared<FbyApiCampaignsCampaignIdOffersAllResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdBidsInfoResource) {
        setFbyApiBusinessesBusinessIdBidsInfoResource(std::make_shared<FbyApiBusinessesBusinessIdBidsInfoResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdBidsRecommendationsResource) {
        setFbyApiBusinessesBusinessIdBidsRecommendationsResource(std::make_shared<FbyApiBusinessesBusinessIdBidsRecommendationsResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdPrice-quarantineResource) {
        setFbyApiBusinessesBusinessIdPrice-quarantineResource(std::make_shared<FbyApiBusinessesBusinessIdPrice-quarantineResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdSettingsResource) {
        setFbyApiBusinessesBusinessIdSettingsResource(std::make_shared<FbyApiBusinessesBusinessIdSettingsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdResource) {
        setFbyApiCampaignsCampaignIdResource(std::make_shared<FbyApiCampaignsCampaignIdResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdLoginsResource) {
        setFbyApiCampaignsCampaignIdLoginsResource(std::make_shared<FbyApiCampaignsCampaignIdLoginsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffersResource) {
        setFbyApiCampaignsCampaignIdOffersResource(std::make_shared<FbyApiCampaignsCampaignIdOffersResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdPrice-quarantineResource) {
        setFbyApiCampaignsCampaignIdPrice-quarantineResource(std::make_shared<FbyApiCampaignsCampaignIdPrice-quarantineResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdRegionResource) {
        setFbyApiCampaignsCampaignIdRegionResource(std::make_shared<FbyApiCampaignsCampaignIdRegionResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdSettingsResource) {
        setFbyApiCampaignsCampaignIdSettingsResource(std::make_shared<FbyApiCampaignsCampaignIdSettingsResource>());
    }
    if (!m_spFbyApiCampaignsResource) {
        setFbyApiCampaignsResource(std::make_shared<FbyApiCampaignsResource>());
    }
    if (!m_spFbyApiCampaignsBy_loginLoginResource) {
        setFbyApiCampaignsBy_loginLoginResource(std::make_shared<FbyApiCampaignsBy_loginLoginResource>());
    }
    if (!m_spFbyApiCategoriesMax-sale-quantumResource) {
        setFbyApiCategoriesMax-sale-quantumResource(std::make_shared<FbyApiCategoriesMax-sale-quantumResource>());
    }
    if (!m_spFbyApiCategoriesTreeResource) {
        setFbyApiCategoriesTreeResource(std::make_shared<FbyApiCategoriesTreeResource>());
    }
    if (!m_spFbyApiCategoryCategoryIdParametersResource) {
        setFbyApiCategoryCategoryIdParametersResource(std::make_shared<FbyApiCategoryCategoryIdParametersResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdChatsHistoryResource) {
        setFbyApiBusinessesBusinessIdChatsHistoryResource(std::make_shared<FbyApiBusinessesBusinessIdChatsHistoryResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdChatsResource) {
        setFbyApiBusinessesBusinessIdChatsResource(std::make_shared<FbyApiBusinessesBusinessIdChatsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdFeedsFeedIdResource) {
        setFbyApiCampaignsCampaignIdFeedsFeedIdResource(std::make_shared<FbyApiCampaignsCampaignIdFeedsFeedIdResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource) {
        setFbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource(std::make_shared<FbyApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdFeedbackUpdatesResource) {
        setFbyApiCampaignsCampaignIdFeedbackUpdatesResource(std::make_shared<FbyApiCampaignsCampaignIdFeedbackUpdatesResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdFeedsResource) {
        setFbyApiCampaignsCampaignIdFeedsResource(std::make_shared<FbyApiCampaignsCampaignIdFeedsResource>());
    }
    if (!m_spFbyApiWarehousesResource) {
        setFbyApiWarehousesResource(std::make_shared<FbyApiWarehousesResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdGoods-feedbackCommentsResource) {
        setFbyApiBusinessesBusinessIdGoods-feedbackCommentsResource(std::make_shared<FbyApiBusinessesBusinessIdGoods-feedbackCommentsResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdGoods-feedbackResource) {
        setFbyApiBusinessesBusinessIdGoods-feedbackResource(std::make_shared<FbyApiBusinessesBusinessIdGoods-feedbackResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdStatsSkusResource) {
        setFbyApiCampaignsCampaignIdStatsSkusResource(std::make_shared<FbyApiCampaignsCampaignIdStatsSkusResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffer-cardsResource) {
        setFbyApiBusinessesBusinessIdOffer-cardsResource(std::make_shared<FbyApiBusinessesBusinessIdOffer-cardsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffer-mapping-entriesResource) {
        setFbyApiCampaignsCampaignIdOffer-mapping-entriesResource(std::make_shared<FbyApiCampaignsCampaignIdOffer-mapping-entriesResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffer-mappingsResource) {
        setFbyApiBusinessesBusinessIdOffer-mappingsResource(std::make_shared<FbyApiBusinessesBusinessIdOffer-mappingsResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffersRecommendationsResource) {
        setFbyApiBusinessesBusinessIdOffersRecommendationsResource(std::make_shared<FbyApiBusinessesBusinessIdOffersRecommendationsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOrdersOrderIdResource) {
        setFbyApiCampaignsCampaignIdOrdersOrderIdResource(std::make_shared<FbyApiCampaignsCampaignIdOrdersOrderIdResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource) {
        setFbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource(std::make_shared<FbyApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
        setFbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource(std::make_shared<FbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOrdersResource) {
        setFbyApiCampaignsCampaignIdOrdersResource(std::make_shared<FbyApiCampaignsCampaignIdOrdersResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdStatsOrdersResource) {
        setFbyApiCampaignsCampaignIdStatsOrdersResource(std::make_shared<FbyApiCampaignsCampaignIdStatsOrdersResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffer-pricesResource) {
        setFbyApiCampaignsCampaignIdOffer-pricesResource(std::make_shared<FbyApiCampaignsCampaignIdOffer-pricesResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdPromosOffersResource) {
        setFbyApiBusinessesBusinessIdPromosOffersResource(std::make_shared<FbyApiBusinessesBusinessIdPromosOffersResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdPromosResource) {
        setFbyApiBusinessesBusinessIdPromosResource(std::make_shared<FbyApiBusinessesBusinessIdPromosResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdRatingsQualityResource) {
        setFbyApiBusinessesBusinessIdRatingsQualityResource(std::make_shared<FbyApiBusinessesBusinessIdRatingsQualityResource>());
    }
    if (!m_spFbyApiReportsInfoReportIdResource) {
        setFbyApiReportsInfoReportIdResource(std::make_shared<FbyApiReportsInfoReportIdResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
        setFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(std::make_shared<FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
        setFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(std::make_shared<FbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdReturnsResource) {
        setFbyApiCampaignsCampaignIdReturnsResource(std::make_shared<FbyApiCampaignsCampaignIdReturnsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffersStocksResource) {
        setFbyApiCampaignsCampaignIdOffersStocksResource(std::make_shared<FbyApiCampaignsCampaignIdOffersStocksResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource) {
        setFbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource(std::make_shared<FbyApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource) {
        setFbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource(std::make_shared<FbyApiBusinessesBusinessIdOffer-mappingsSuggestionsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource) {
        setFbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource(std::make_shared<FbyApiCampaignsCampaignIdOffer-pricesSuggestionsResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdBidsResource) {
        setFbyApiBusinessesBusinessIdBidsResource(std::make_shared<FbyApiBusinessesBusinessIdBidsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdBidsResource) {
        setFbyApiCampaignsCampaignIdBidsResource(std::make_shared<FbyApiCampaignsCampaignIdBidsResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource) {
        setFbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource(std::make_shared<FbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource>());
    }
    if (!m_spFbyApiRegionsRegionIdChildrenResource) {
        setFbyApiRegionsRegionIdChildrenResource(std::make_shared<FbyApiRegionsRegionIdChildrenResource>());
    }
    if (!m_spFbyApiRegionsRegionIdResource) {
        setFbyApiRegionsRegionIdResource(std::make_shared<FbyApiRegionsRegionIdResource>());
    }
    if (!m_spFbyApiRegionsResource) {
        setFbyApiRegionsResource(std::make_shared<FbyApiRegionsResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdChatsFileSendResource) {
        setFbyApiBusinessesBusinessIdChatsFileSendResource(std::make_shared<FbyApiBusinessesBusinessIdChatsFileSendResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdChatsMessageResource) {
        setFbyApiBusinessesBusinessIdChatsMessageResource(std::make_shared<FbyApiBusinessesBusinessIdChatsMessageResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdFeedsFeedIdParamsResource) {
        setFbyApiCampaignsCampaignIdFeedsFeedIdParamsResource(std::make_shared<FbyApiCampaignsCampaignIdFeedsFeedIdParamsResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource) {
        setFbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource(std::make_shared<FbyApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffer-pricesUpdatesResource) {
        setFbyApiBusinessesBusinessIdOffer-pricesUpdatesResource(std::make_shared<FbyApiBusinessesBusinessIdOffer-pricesUpdatesResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffersUpdateResource) {
        setFbyApiCampaignsCampaignIdOffersUpdateResource(std::make_shared<FbyApiCampaignsCampaignIdOffersUpdateResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource) {
        setFbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource(std::make_shared<FbyApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffer-cardsUpdateResource) {
        setFbyApiBusinessesBusinessIdOffer-cardsUpdateResource(std::make_shared<FbyApiBusinessesBusinessIdOffer-cardsUpdateResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource) {
        setFbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource(std::make_shared<FbyApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdOffer-mappingsUpdateResource) {
        setFbyApiBusinessesBusinessIdOffer-mappingsUpdateResource(std::make_shared<FbyApiBusinessesBusinessIdOffer-mappingsUpdateResource>());
    }
    if (!m_spFbyApiCampaignsCampaignIdOffer-pricesUpdatesResource) {
        setFbyApiCampaignsCampaignIdOffer-pricesUpdatesResource(std::make_shared<FbyApiCampaignsCampaignIdOffer-pricesUpdatesResource>());
    }
    if (!m_spFbyApiBusinessesBusinessIdPromosOffersUpdateResource) {
        setFbyApiBusinessesBusinessIdPromosOffersUpdateResource(std::make_shared<FbyApiBusinessesBusinessIdPromosOffersUpdateResource>());
    }
}

std::shared_ptr<restbed::Service> FbyApi::service() {
    return m_service;
}


}
}
}
}

