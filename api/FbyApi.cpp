/**
* Партнерский API Маркета
* API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
*
* The version of the OpenAPI document: LATEST
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "FbyApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string FbyApi::base = "";

FbyApi::FbyApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{
}

void FbyApi::init() {
    setupRoutes();
}

void FbyApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/campaigns/:campaignId/hidden-offers", Routes::bind(&FbyApi::add_hidden_offers_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offer-mappings/archive", Routes::bind(&FbyApi::add_offers_to_archive_handler, this));
    Routes::Post(*router, base + "/tariffs/calculate", Routes::bind(&FbyApi::calculate_tariffs_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/price-quarantine/confirm", Routes::bind(&FbyApi::confirm_business_prices_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/price-quarantine/confirm", Routes::bind(&FbyApi::confirm_campaign_prices_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/chats/new", Routes::bind(&FbyApi::create_chat_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/offers/delete", Routes::bind(&FbyApi::delete_campaign_offers_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/goods-feedback/comments/delete", Routes::bind(&FbyApi::delete_goods_feedback_comment_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/hidden-offers/delete", Routes::bind(&FbyApi::delete_hidden_offers_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offer-mappings/delete", Routes::bind(&FbyApi::delete_offers_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offer-mappings/unarchive", Routes::bind(&FbyApi::delete_offers_from_archive_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/promos/offers/delete", Routes::bind(&FbyApi::delete_promo_offers_handler, this));
    Routes::Post(*router, base + "/reports/boost-consolidated/generate", Routes::bind(&FbyApi::generate_boost_consolidated_report_handler, this));
    Routes::Post(*router, base + "/reports/competitors-position/generate", Routes::bind(&FbyApi::generate_competitors_position_report_handler, this));
    Routes::Post(*router, base + "/reports/goods-feedback/generate", Routes::bind(&FbyApi::generate_goods_feedback_report_handler, this));
    Routes::Post(*router, base + "/reports/goods-movement/generate", Routes::bind(&FbyApi::generate_goods_movement_report_handler, this));
    Routes::Post(*router, base + "/reports/goods-realization/generate", Routes::bind(&FbyApi::generate_goods_realization_report_handler, this));
    Routes::Post(*router, base + "/reports/goods-turnover/generate", Routes::bind(&FbyApi::generate_goods_turnover_report_handler, this));
    Routes::Post(*router, base + "/reports/prices/generate", Routes::bind(&FbyApi::generate_prices_report_handler, this));
    Routes::Post(*router, base + "/reports/shelf-statistics/generate", Routes::bind(&FbyApi::generate_shelfs_statistics_report_handler, this));
    Routes::Post(*router, base + "/reports/shows-sales/generate", Routes::bind(&FbyApi::generate_shows_sales_report_handler, this));
    Routes::Post(*router, base + "/reports/stocks-on-warehouses/generate", Routes::bind(&FbyApi::generate_stocks_on_warehouses_report_handler, this));
    Routes::Post(*router, base + "/reports/united-marketplace-services/generate", Routes::bind(&FbyApi::generate_united_marketplace_services_report_handler, this));
    Routes::Post(*router, base + "/reports/united-netting/generate", Routes::bind(&FbyApi::generate_united_netting_report_handler, this));
    Routes::Post(*router, base + "/reports/united-orders/generate", Routes::bind(&FbyApi::generate_united_orders_report_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/offers/all", Routes::bind(&FbyApi::get_all_offers_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/bids/info", Routes::bind(&FbyApi::get_bids_info_for_business_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/bids/recommendations", Routes::bind(&FbyApi::get_bids_recommendations_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/price-quarantine", Routes::bind(&FbyApi::get_business_quarantine_offers_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/settings", Routes::bind(&FbyApi::get_business_settings_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId", Routes::bind(&FbyApi::get_campaign_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/logins", Routes::bind(&FbyApi::get_campaign_logins_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/offers", Routes::bind(&FbyApi::get_campaign_offers_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/price-quarantine", Routes::bind(&FbyApi::get_campaign_quarantine_offers_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/region", Routes::bind(&FbyApi::get_campaign_region_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/settings", Routes::bind(&FbyApi::get_campaign_settings_handler, this));
    Routes::Get(*router, base + "/campaigns", Routes::bind(&FbyApi::get_campaigns_handler, this));
    Routes::Get(*router, base + "/campaigns/by_login/:login", Routes::bind(&FbyApi::get_campaigns_by_login_handler, this));
    Routes::Post(*router, base + "/categories/max-sale-quantum", Routes::bind(&FbyApi::get_categories_max_sale_quantum_handler, this));
    Routes::Post(*router, base + "/categories/tree", Routes::bind(&FbyApi::get_categories_tree_handler, this));
    Routes::Post(*router, base + "/category/:categoryId/parameters", Routes::bind(&FbyApi::get_category_content_parameters_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/chats/history", Routes::bind(&FbyApi::get_chat_history_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/chats", Routes::bind(&FbyApi::get_chats_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/feeds/:feedId", Routes::bind(&FbyApi::get_feed_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/feeds/:feedId/index-logs", Routes::bind(&FbyApi::get_feed_index_logs_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/feedback/updates", Routes::bind(&FbyApi::get_feedback_and_comment_updates_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/feeds", Routes::bind(&FbyApi::get_feeds_handler, this));
    Routes::Get(*router, base + "/warehouses", Routes::bind(&FbyApi::get_fulfillment_warehouses_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/goods-feedback/comments", Routes::bind(&FbyApi::get_goods_feedback_comments_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/goods-feedback", Routes::bind(&FbyApi::get_goods_feedbacks_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/stats/skus", Routes::bind(&FbyApi::get_goods_stats_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/hidden-offers", Routes::bind(&FbyApi::get_hidden_offers_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offer-cards", Routes::bind(&FbyApi::get_offer_cards_content_status_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/offer-mapping-entries", Routes::bind(&FbyApi::get_offer_mapping_entries_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offer-mappings", Routes::bind(&FbyApi::get_offer_mappings_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offers/recommendations", Routes::bind(&FbyApi::get_offer_recommendations_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/offers", Routes::bind(&FbyApi::get_offers_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/orders/:orderId", Routes::bind(&FbyApi::get_order_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/orders/:orderId/business-buyer", Routes::bind(&FbyApi::get_order_business_buyer_info_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/orders/:orderId/documents", Routes::bind(&FbyApi::get_order_business_documents_info_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/orders", Routes::bind(&FbyApi::get_orders_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/stats/orders", Routes::bind(&FbyApi::get_orders_stats_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/offer-prices", Routes::bind(&FbyApi::get_prices_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/offer-prices", Routes::bind(&FbyApi::get_prices_by_offer_ids_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/promos/offers", Routes::bind(&FbyApi::get_promo_offers_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/promos", Routes::bind(&FbyApi::get_promos_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/ratings/quality", Routes::bind(&FbyApi::get_quality_ratings_handler, this));
    Routes::Get(*router, base + "/reports/info/:reportId", Routes::bind(&FbyApi::get_report_info_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/orders/:orderId/returns/:returnId", Routes::bind(&FbyApi::get_return_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/orders/:orderId/returns/:returnId/decision/:itemId/image/:imageHash", Routes::bind(&FbyApi::get_return_photo_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/returns", Routes::bind(&FbyApi::get_returns_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/offers/stocks", Routes::bind(&FbyApi::get_stocks_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/offer-mapping-entries/suggestions", Routes::bind(&FbyApi::get_suggested_offer_mapping_entries_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offer-mappings/suggestions", Routes::bind(&FbyApi::get_suggested_offer_mappings_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/offer-prices/suggestions", Routes::bind(&FbyApi::get_suggested_prices_handler, this));
    Routes::Put(*router, base + "/businesses/:businessId/bids", Routes::bind(&FbyApi::put_bids_for_business_handler, this));
    Routes::Put(*router, base + "/campaigns/:campaignId/bids", Routes::bind(&FbyApi::put_bids_for_campaign_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/feeds/:feedId/refresh", Routes::bind(&FbyApi::refresh_feed_handler, this));
    Routes::Get(*router, base + "/regions/:regionId/children", Routes::bind(&FbyApi::search_region_children_handler, this));
    Routes::Get(*router, base + "/regions/:regionId", Routes::bind(&FbyApi::search_regions_by_id_handler, this));
    Routes::Get(*router, base + "/regions", Routes::bind(&FbyApi::search_regions_by_name_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/chats/file/send", Routes::bind(&FbyApi::send_file_to_chat_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/chats/message", Routes::bind(&FbyApi::send_message_to_chat_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/feeds/:feedId/params", Routes::bind(&FbyApi::set_feed_params_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/goods-feedback/skip-reaction", Routes::bind(&FbyApi::skip_goods_feedbacks_reaction_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offer-prices/updates", Routes::bind(&FbyApi::update_business_prices_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/offers/update", Routes::bind(&FbyApi::update_campaign_offers_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/goods-feedback/comments/update", Routes::bind(&FbyApi::update_goods_feedback_comment_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offer-cards/update", Routes::bind(&FbyApi::update_offer_content_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/offer-mapping-entries/updates", Routes::bind(&FbyApi::update_offer_mapping_entries_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/offer-mappings/update", Routes::bind(&FbyApi::update_offer_mappings_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/offer-prices/updates", Routes::bind(&FbyApi::update_prices_handler, this));
    Routes::Post(*router, base + "/businesses/:businessId/promos/offers/update", Routes::bind(&FbyApi::update_promo_offers_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&FbyApi::fby_api_default_handler, this));
}

void FbyApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept
{
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> FbyApi::handleParsingException(const std::exception& ex) const noexcept
{
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void FbyApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept
{
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> FbyApi::handleOperationException(const std::exception& ex) const noexcept
{
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void FbyApi::add_hidden_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    AddHiddenOffersRequest addHiddenOffersRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(addHiddenOffersRequest);
        addHiddenOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->add_hidden_offers(campaignId, addHiddenOffersRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::add_offers_to_archive_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    AddOffersToArchiveRequest addOffersToArchiveRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(addOffersToArchiveRequest);
        addOffersToArchiveRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->add_offers_to_archive(businessId, addOffersToArchiveRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::calculate_tariffs_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    CalculateTariffsRequest calculateTariffsRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(calculateTariffsRequest);
        calculateTariffsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->calculate_tariffs(calculateTariffsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::confirm_business_prices_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    ConfirmPricesRequest confirmPricesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(confirmPricesRequest);
        confirmPricesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->confirm_business_prices(businessId, confirmPricesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::confirm_campaign_prices_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    ConfirmPricesRequest confirmPricesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(confirmPricesRequest);
        confirmPricesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->confirm_campaign_prices(campaignId, confirmPricesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::create_chat_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    CreateChatRequest createChatRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(createChatRequest);
        createChatRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->create_chat(businessId, createChatRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::delete_campaign_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    DeleteCampaignOffersRequest deleteCampaignOffersRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(deleteCampaignOffersRequest);
        deleteCampaignOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->delete_campaign_offers(campaignId, deleteCampaignOffersRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::delete_goods_feedback_comment_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    DeleteGoodsFeedbackCommentRequest deleteGoodsFeedbackCommentRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(deleteGoodsFeedbackCommentRequest);
        deleteGoodsFeedbackCommentRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->delete_goods_feedback_comment(businessId, deleteGoodsFeedbackCommentRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::delete_hidden_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    DeleteHiddenOffersRequest deleteHiddenOffersRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(deleteHiddenOffersRequest);
        deleteHiddenOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->delete_hidden_offers(campaignId, deleteHiddenOffersRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::delete_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    DeleteOffersRequest deleteOffersRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(deleteOffersRequest);
        deleteOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->delete_offers(businessId, deleteOffersRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::delete_offers_from_archive_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    DeleteOffersFromArchiveRequest deleteOffersFromArchiveRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(deleteOffersFromArchiveRequest);
        deleteOffersFromArchiveRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->delete_offers_from_archive(businessId, deleteOffersFromArchiveRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::delete_promo_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    DeletePromoOffersRequest deletePromoOffersRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(deletePromoOffersRequest);
        deletePromoOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->delete_promo_offers(businessId, deletePromoOffersRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_boost_consolidated_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateBoostConsolidatedRequest generateBoostConsolidatedRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateBoostConsolidatedRequest);
        generateBoostConsolidatedRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_boost_consolidated_report(generateBoostConsolidatedRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_competitors_position_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateCompetitorsPositionReportRequest generateCompetitorsPositionReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateCompetitorsPositionReportRequest);
        generateCompetitorsPositionReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_competitors_position_report(generateCompetitorsPositionReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_goods_feedback_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateGoodsFeedbackRequest generateGoodsFeedbackRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateGoodsFeedbackRequest);
        generateGoodsFeedbackRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_goods_feedback_report(generateGoodsFeedbackRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_goods_movement_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateGoodsMovementReportRequest generateGoodsMovementReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateGoodsMovementReportRequest);
        generateGoodsMovementReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_goods_movement_report(generateGoodsMovementReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_goods_realization_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateGoodsRealizationReportRequest generateGoodsRealizationReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateGoodsRealizationReportRequest);
        generateGoodsRealizationReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_goods_realization_report(generateGoodsRealizationReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_goods_turnover_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateGoodsTurnoverRequest generateGoodsTurnoverRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateGoodsTurnoverRequest);
        generateGoodsTurnoverRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_goods_turnover_report(generateGoodsTurnoverRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_prices_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GeneratePricesReportRequest generatePricesReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generatePricesReportRequest);
        generatePricesReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_prices_report(generatePricesReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_shelfs_statistics_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateShelfsStatisticsRequest generateShelfsStatisticsRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateShelfsStatisticsRequest);
        generateShelfsStatisticsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_shelfs_statistics_report(generateShelfsStatisticsRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_shows_sales_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateShowsSalesReportRequest generateShowsSalesReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateShowsSalesReportRequest);
        generateShowsSalesReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_shows_sales_report(generateShowsSalesReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_stocks_on_warehouses_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateStocksOnWarehousesReportRequest generateStocksOnWarehousesReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateStocksOnWarehousesReportRequest);
        generateStocksOnWarehousesReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_stocks_on_warehouses_report(generateStocksOnWarehousesReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_united_marketplace_services_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateUnitedMarketplaceServicesReportRequest generateUnitedMarketplaceServicesReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateUnitedMarketplaceServicesReportRequest);
        generateUnitedMarketplaceServicesReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_united_marketplace_services_report(generateUnitedMarketplaceServicesReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_united_netting_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateUnitedNettingReportRequest generateUnitedNettingReportRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateUnitedNettingReportRequest);
        generateUnitedNettingReportRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_united_netting_report(generateUnitedNettingReportRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::generate_united_orders_report_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GenerateUnitedOrdersRequest generateUnitedOrdersRequest;
    
    // Getting the query params
    auto formatQuery = request.query().get("format");
    std::optional<ReportFormatType> format;
    if(formatQuery.has_value()){
        ReportFormatType valueQuery_instance;
        if(fromStringValue(formatQuery.value(), valueQuery_instance)){
            format = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(generateUnitedOrdersRequest);
        generateUnitedOrdersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->generate_united_orders_report(generateUnitedOrdersRequest, format, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_all_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the query params
    auto feedIdQuery = request.query().get("feedId");
    std::optional<int64_t> feedId;
    if(feedIdQuery.has_value()){
        int64_t valueQuery_instance;
        if(fromStringValue(feedIdQuery.value(), valueQuery_instance)){
            feedId = valueQuery_instance;
        }
    }
    auto chunkQuery = request.query().get("chunk");
    std::optional<int32_t> chunk;
    if(chunkQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(chunkQuery.value(), valueQuery_instance)){
            chunk = valueQuery_instance;
        }
    }
    
    try {
        this->get_all_offers(campaignId, feedId, chunk, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_bids_info_for_business_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetBidsInfoRequest getBidsInfoRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getBidsInfoRequest);
        getBidsInfoRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_bids_info_for_business(businessId, pageToken, limit, getBidsInfoRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_bids_recommendations_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetBidsRecommendationsRequest getBidsRecommendationsRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(getBidsRecommendationsRequest);
        getBidsRecommendationsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_bids_recommendations(businessId, getBidsRecommendationsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_business_quarantine_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetQuarantineOffersRequest getQuarantineOffersRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getQuarantineOffersRequest);
        getQuarantineOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_business_quarantine_offers(businessId, getQuarantineOffersRequest, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_business_settings_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    try {
        this->get_business_settings(businessId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_campaign_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    try {
        this->get_campaign(campaignId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_campaign_logins_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    try {
        this->get_campaign_logins(campaignId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_campaign_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    GetCampaignOffersRequest getCampaignOffersRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getCampaignOffersRequest);
        getCampaignOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_campaign_offers(campaignId, getCampaignOffersRequest, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_campaign_quarantine_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    GetQuarantineOffersRequest getQuarantineOffersRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getQuarantineOffersRequest);
        getQuarantineOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_campaign_quarantine_offers(campaignId, getQuarantineOffersRequest, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_campaign_region_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    try {
        this->get_campaign_region(campaignId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_campaign_settings_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    try {
        this->get_campaign_settings(campaignId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_campaigns_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto pageQuery = request.query().get("page");
    std::optional<int32_t> page;
    if(pageQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageQuery.value(), valueQuery_instance)){
            page = valueQuery_instance;
        }
    }
    auto pageSizeQuery = request.query().get("pageSize");
    std::optional<int32_t> pageSize;
    if(pageSizeQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageSizeQuery.value(), valueQuery_instance)){
            pageSize = valueQuery_instance;
        }
    }
    
    try {
        this->get_campaigns(page, pageSize, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_campaigns_by_login_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto login = request.param(":login").as<std::string>();
    
    // Getting the query params
    auto pageQuery = request.query().get("page");
    std::optional<int32_t> page;
    if(pageQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageQuery.value(), valueQuery_instance)){
            page = valueQuery_instance;
        }
    }
    auto pageSizeQuery = request.query().get("pageSize");
    std::optional<int32_t> pageSize;
    if(pageSizeQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageSizeQuery.value(), valueQuery_instance)){
            pageSize = valueQuery_instance;
        }
    }
    
    try {
        this->get_campaigns_by_login(login, page, pageSize, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_categories_max_sale_quantum_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GetCategoriesMaxSaleQuantumRequest getCategoriesMaxSaleQuantumRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(getCategoriesMaxSaleQuantumRequest);
        getCategoriesMaxSaleQuantumRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_categories_max_sale_quantum(getCategoriesMaxSaleQuantumRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_categories_tree_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the body param
    
    GetCategoriesRequest getCategoriesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(getCategoriesRequest);
        getCategoriesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_categories_tree(getCategoriesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_category_content_parameters_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto categoryId = request.param(":categoryId").as<int64_t>();
    
    try {
        this->get_category_content_parameters(categoryId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_chat_history_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetChatHistoryRequest getChatHistoryRequest;
    
    // Getting the query params
    auto chatIdQuery = request.query().get("chatId");
    std::optional<int64_t> chatId;
    if(chatIdQuery.has_value()){
        int64_t valueQuery_instance;
        if(fromStringValue(chatIdQuery.value(), valueQuery_instance)){
            chatId = valueQuery_instance;
        }
    }
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getChatHistoryRequest);
        getChatHistoryRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_chat_history(businessId, chatId, getChatHistoryRequest, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_chats_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetChatsRequest getChatsRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getChatsRequest);
        getChatsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_chats(businessId, getChatsRequest, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_feed_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto feedId = request.param(":feedId").as<int64_t>();
    
    try {
        this->get_feed(campaignId, feedId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_feed_index_logs_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto feedId = request.param(":feedId").as<int64_t>();
    
    // Getting the query params
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    auto publishedTimeFromQuery = request.query().get("published_time_from");
    std::optional<std::string> publishedTimeFrom;
    if(publishedTimeFromQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(publishedTimeFromQuery.value(), valueQuery_instance)){
            publishedTimeFrom = valueQuery_instance;
        }
    }
    auto publishedTimeToQuery = request.query().get("published_time_to");
    std::optional<std::string> publishedTimeTo;
    if(publishedTimeToQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(publishedTimeToQuery.value(), valueQuery_instance)){
            publishedTimeTo = valueQuery_instance;
        }
    }
    auto statusQuery = request.query().get("status");
    std::optional<FeedIndexLogsStatusType> status;
    if(statusQuery.has_value()){
        FeedIndexLogsStatusType valueQuery_instance;
        if(fromStringValue(statusQuery.value(), valueQuery_instance)){
            status = valueQuery_instance;
        }
    }
    
    try {
        this->get_feed_index_logs(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_feedback_and_comment_updates_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    auto fromDateQuery = request.query().get("from_date");
    std::optional<std::string> fromDate;
    if(fromDateQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(fromDateQuery.value(), valueQuery_instance)){
            fromDate = valueQuery_instance;
        }
    }
    
    try {
        this->get_feedback_and_comment_updates(campaignId, pageToken, limit, fromDate, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_feeds_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    try {
        this->get_feeds(campaignId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_fulfillment_warehouses_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    try {


    try {
        this->get_fulfillment_warehouses(response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_goods_feedback_comments_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetGoodsFeedbackCommentsRequest getGoodsFeedbackCommentsRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getGoodsFeedbackCommentsRequest);
        getGoodsFeedbackCommentsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_goods_feedback_comments(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_goods_feedbacks_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetGoodsFeedbackRequest getGoodsFeedbackRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getGoodsFeedbackRequest);
        getGoodsFeedbackRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_goods_feedbacks(businessId, pageToken, limit, getGoodsFeedbackRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_goods_stats_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    GetGoodsStatsRequest getGoodsStatsRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(getGoodsStatsRequest);
        getGoodsStatsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_goods_stats(campaignId, getGoodsStatsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_hidden_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the query params
    auto offerIdQuery = request.query().get("offer_id");
    std::optional<std::vector<std::string>> offerId;
    if(offerIdQuery.has_value()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(offerIdQuery.value(), valueQuery_instance)){
            offerId = valueQuery_instance;
        }
    }
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    auto offsetQuery = request.query().get("offset");
    std::optional<int32_t> offset;
    if(offsetQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(offsetQuery.value(), valueQuery_instance)){
            offset = valueQuery_instance;
        }
    }
    auto pageQuery = request.query().get("page");
    std::optional<int32_t> page;
    if(pageQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageQuery.value(), valueQuery_instance)){
            page = valueQuery_instance;
        }
    }
    auto pageSizeQuery = request.query().get("pageSize");
    std::optional<int32_t> pageSize;
    if(pageSizeQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageSizeQuery.value(), valueQuery_instance)){
            pageSize = valueQuery_instance;
        }
    }
    
    try {
        this->get_hidden_offers(campaignId, offerId, pageToken, limit, offset, page, pageSize, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_offer_cards_content_status_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetOfferCardsContentStatusRequest getOfferCardsContentStatusRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getOfferCardsContentStatusRequest);
        getOfferCardsContentStatusRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_offer_cards_content_status(businessId, pageToken, limit, getOfferCardsContentStatusRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_offer_mapping_entries_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the query params
    auto offerIdQuery = request.query().get("offer_id");
    std::optional<std::vector<std::string>> offerId;
    if(offerIdQuery.has_value()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(offerIdQuery.value(), valueQuery_instance)){
            offerId = valueQuery_instance;
        }
    }
    auto shopSkuQuery = request.query().get("shop_sku");
    std::optional<std::vector<std::string>> shopSku;
    if(shopSkuQuery.has_value()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(shopSkuQuery.value(), valueQuery_instance)){
            shopSku = valueQuery_instance;
        }
    }
    auto mappingKindQuery = request.query().get("mapping_kind");
    std::optional<OfferMappingKindType> mappingKind;
    if(mappingKindQuery.has_value()){
        OfferMappingKindType valueQuery_instance;
        if(fromStringValue(mappingKindQuery.value(), valueQuery_instance)){
            mappingKind = valueQuery_instance;
        }
    }
    auto statusQuery = request.query().get("status");
    std::optional<std::vector<OfferProcessingStatusType>> status;
    if(statusQuery.has_value()){
        std::vector<OfferProcessingStatusType> valueQuery_instance;
        if(fromStringValue(statusQuery.value(), valueQuery_instance)){
            status = valueQuery_instance;
        }
    }
    auto availabilityQuery = request.query().get("availability");
    std::optional<std::vector<OfferAvailabilityStatusType>> availability;
    if(availabilityQuery.has_value()){
        std::vector<OfferAvailabilityStatusType> valueQuery_instance;
        if(fromStringValue(availabilityQuery.value(), valueQuery_instance)){
            availability = valueQuery_instance;
        }
    }
    auto categoryIdQuery = request.query().get("category_id");
    std::optional<std::vector<int32_t>> categoryId;
    if(categoryIdQuery.has_value()){
        std::vector<int32_t> valueQuery_instance;
        if(fromStringValue(categoryIdQuery.value(), valueQuery_instance)){
            categoryId = valueQuery_instance;
        }
    }
    auto vendorQuery = request.query().get("vendor");
    std::optional<std::vector<std::string>> vendor;
    if(vendorQuery.has_value()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(vendorQuery.value(), valueQuery_instance)){
            vendor = valueQuery_instance;
        }
    }
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        this->get_offer_mapping_entries(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_offer_mappings_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetOfferMappingsRequest getOfferMappingsRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getOfferMappingsRequest);
        getOfferMappingsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_offer_mappings(businessId, pageToken, limit, getOfferMappingsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_offer_recommendations_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetOfferRecommendationsRequest getOfferRecommendationsRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getOfferRecommendationsRequest);
        getOfferRecommendationsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_offer_recommendations(businessId, getOfferRecommendationsRequest, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the query params
    auto queryQuery = request.query().get("query");
    std::optional<std::string> query;
    if(queryQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(queryQuery.value(), valueQuery_instance)){
            query = valueQuery_instance;
        }
    }
    auto feedIdQuery = request.query().get("feedId");
    std::optional<int64_t> feedId;
    if(feedIdQuery.has_value()){
        int64_t valueQuery_instance;
        if(fromStringValue(feedIdQuery.value(), valueQuery_instance)){
            feedId = valueQuery_instance;
        }
    }
    auto shopCategoryIdQuery = request.query().get("shopCategoryId");
    std::optional<std::string> shopCategoryId;
    if(shopCategoryIdQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(shopCategoryIdQuery.value(), valueQuery_instance)){
            shopCategoryId = valueQuery_instance;
        }
    }
    auto currencyQuery = request.query().get("currency");
    std::optional<CurrencyType> currency;
    if(currencyQuery.has_value()){
        CurrencyType valueQuery_instance;
        if(fromStringValue(currencyQuery.value(), valueQuery_instance)){
            currency = valueQuery_instance;
        }
    }
    auto matchedQuery = request.query().get("matched");
    std::optional<bool> matched;
    if(matchedQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(matchedQuery.value(), valueQuery_instance)){
            matched = valueQuery_instance;
        }
    }
    auto pageQuery = request.query().get("page");
    std::optional<int32_t> page;
    if(pageQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageQuery.value(), valueQuery_instance)){
            page = valueQuery_instance;
        }
    }
    auto pageSizeQuery = request.query().get("pageSize");
    std::optional<int32_t> pageSize;
    if(pageSizeQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageSizeQuery.value(), valueQuery_instance)){
            pageSize = valueQuery_instance;
        }
    }
    
    try {
        this->get_offers(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_order_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    try {
        this->get_order(campaignId, orderId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_order_business_buyer_info_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    try {
        this->get_order_business_buyer_info(campaignId, orderId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_order_business_documents_info_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    try {
        this->get_order_business_documents_info(campaignId, orderId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_orders_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the query params
    auto orderIdsQuery = request.query().get("orderIds");
    std::optional<std::vector<int64_t>> orderIds;
    if(orderIdsQuery.has_value()){
        std::vector<int64_t> valueQuery_instance;
        if(fromStringValue(orderIdsQuery.value(), valueQuery_instance)){
            orderIds = valueQuery_instance;
        }
    }
    auto statusQuery = request.query().get("status");
    std::optional<std::vector<OrderStatusType>> status;
    if(statusQuery.has_value()){
        std::vector<OrderStatusType> valueQuery_instance;
        if(fromStringValue(statusQuery.value(), valueQuery_instance)){
            status = valueQuery_instance;
        }
    }
    auto substatusQuery = request.query().get("substatus");
    std::optional<std::vector<OrderSubstatusType>> substatus;
    if(substatusQuery.has_value()){
        std::vector<OrderSubstatusType> valueQuery_instance;
        if(fromStringValue(substatusQuery.value(), valueQuery_instance)){
            substatus = valueQuery_instance;
        }
    }
    auto fromDateQuery = request.query().get("fromDate");
    std::optional<std::string> fromDate;
    if(fromDateQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(fromDateQuery.value(), valueQuery_instance)){
            fromDate = valueQuery_instance;
        }
    }
    auto toDateQuery = request.query().get("toDate");
    std::optional<std::string> toDate;
    if(toDateQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(toDateQuery.value(), valueQuery_instance)){
            toDate = valueQuery_instance;
        }
    }
    auto supplierShipmentDateFromQuery = request.query().get("supplierShipmentDateFrom");
    std::optional<std::string> supplierShipmentDateFrom;
    if(supplierShipmentDateFromQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(supplierShipmentDateFromQuery.value(), valueQuery_instance)){
            supplierShipmentDateFrom = valueQuery_instance;
        }
    }
    auto supplierShipmentDateToQuery = request.query().get("supplierShipmentDateTo");
    std::optional<std::string> supplierShipmentDateTo;
    if(supplierShipmentDateToQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(supplierShipmentDateToQuery.value(), valueQuery_instance)){
            supplierShipmentDateTo = valueQuery_instance;
        }
    }
    auto updatedAtFromQuery = request.query().get("updatedAtFrom");
    std::optional<std::string> updatedAtFrom;
    if(updatedAtFromQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(updatedAtFromQuery.value(), valueQuery_instance)){
            updatedAtFrom = valueQuery_instance;
        }
    }
    auto updatedAtToQuery = request.query().get("updatedAtTo");
    std::optional<std::string> updatedAtTo;
    if(updatedAtToQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(updatedAtToQuery.value(), valueQuery_instance)){
            updatedAtTo = valueQuery_instance;
        }
    }
    auto dispatchTypeQuery = request.query().get("dispatchType");
    std::optional<OrderDeliveryDispatchType> dispatchType;
    if(dispatchTypeQuery.has_value()){
        OrderDeliveryDispatchType valueQuery_instance;
        if(fromStringValue(dispatchTypeQuery.value(), valueQuery_instance)){
            dispatchType = valueQuery_instance;
        }
    }
    auto fakeQuery = request.query().get("fake");
    std::optional<bool> fake;
    if(fakeQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(fakeQuery.value(), valueQuery_instance)){
            fake = valueQuery_instance;
        }
    }
    auto hasCisQuery = request.query().get("hasCis");
    std::optional<bool> hasCis;
    if(hasCisQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(hasCisQuery.value(), valueQuery_instance)){
            hasCis = valueQuery_instance;
        }
    }
    auto onlyWaitingForCancellationApproveQuery = request.query().get("onlyWaitingForCancellationApprove");
    std::optional<bool> onlyWaitingForCancellationApprove;
    if(onlyWaitingForCancellationApproveQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(onlyWaitingForCancellationApproveQuery.value(), valueQuery_instance)){
            onlyWaitingForCancellationApprove = valueQuery_instance;
        }
    }
    auto onlyEstimatedDeliveryQuery = request.query().get("onlyEstimatedDelivery");
    std::optional<bool> onlyEstimatedDelivery;
    if(onlyEstimatedDeliveryQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(onlyEstimatedDeliveryQuery.value(), valueQuery_instance)){
            onlyEstimatedDelivery = valueQuery_instance;
        }
    }
    auto buyerTypeQuery = request.query().get("buyerType");
    std::optional<OrderBuyerType> buyerType;
    if(buyerTypeQuery.has_value()){
        OrderBuyerType valueQuery_instance;
        if(fromStringValue(buyerTypeQuery.value(), valueQuery_instance)){
            buyerType = valueQuery_instance;
        }
    }
    auto pageQuery = request.query().get("page");
    std::optional<int32_t> page;
    if(pageQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageQuery.value(), valueQuery_instance)){
            page = valueQuery_instance;
        }
    }
    auto pageSizeQuery = request.query().get("pageSize");
    std::optional<int32_t> pageSize;
    if(pageSizeQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageSizeQuery.value(), valueQuery_instance)){
            pageSize = valueQuery_instance;
        }
    }
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        this->get_orders(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_orders_stats_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    GetOrdersStatsRequest getOrdersStatsRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getOrdersStatsRequest);
        getOrdersStatsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_orders_stats(campaignId, pageToken, limit, getOrdersStatsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_prices_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    auto archivedQuery = request.query().get("archived");
    std::optional<bool> archived;
    if(archivedQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(archivedQuery.value(), valueQuery_instance)){
            archived = valueQuery_instance;
        }
    }
    
    try {
        this->get_prices(campaignId, pageToken, limit, archived, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_prices_by_offer_ids_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    GetPricesByOfferIdsRequest getPricesByOfferIdsRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getPricesByOfferIdsRequest);
        getPricesByOfferIdsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_prices_by_offer_ids(campaignId, pageToken, limit, getPricesByOfferIdsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_promo_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetPromoOffersRequest getPromoOffersRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getPromoOffersRequest);
        getPromoOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_promo_offers(businessId, getPromoOffersRequest, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_promos_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetPromosRequest getPromosRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(getPromosRequest);
        getPromosRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_promos(businessId, getPromosRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_quality_ratings_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetQualityRatingRequest getQualityRatingRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(getQualityRatingRequest);
        getQualityRatingRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_quality_ratings(businessId, getQualityRatingRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_report_info_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto reportId = request.param(":reportId").as<std::string>();
    
    try {
        this->get_report_info(reportId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_return_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    auto returnId = request.param(":returnId").as<int64_t>();
    
    try {
        this->get_return(campaignId, orderId, returnId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_return_photo_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    auto returnId = request.param(":returnId").as<int64_t>();
    auto itemId = request.param(":itemId").as<int64_t>();
    auto imageHash = request.param(":imageHash").as<std::string>();
    
    try {
        this->get_return_photo(campaignId, orderId, returnId, itemId, imageHash, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_returns_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    auto orderIdsQuery = request.query().get("orderIds");
    std::optional<std::vector<int64_t>> orderIds;
    if(orderIdsQuery.has_value()){
        std::vector<int64_t> valueQuery_instance;
        if(fromStringValue(orderIdsQuery.value(), valueQuery_instance)){
            orderIds = valueQuery_instance;
        }
    }
    auto statusesQuery = request.query().get("statuses");
    std::optional<std::vector<RefundStatusType>> statuses;
    if(statusesQuery.has_value()){
        std::vector<RefundStatusType> valueQuery_instance;
        if(fromStringValue(statusesQuery.value(), valueQuery_instance)){
            statuses = valueQuery_instance;
        }
    }
    auto typeQuery = request.query().get("type");
    std::optional<ReturnType> type;
    if(typeQuery.has_value()){
        ReturnType valueQuery_instance;
        if(fromStringValue(typeQuery.value(), valueQuery_instance)){
            type = valueQuery_instance;
        }
    }
    auto fromDateQuery = request.query().get("fromDate");
    std::optional<std::string> fromDate;
    if(fromDateQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(fromDateQuery.value(), valueQuery_instance)){
            fromDate = valueQuery_instance;
        }
    }
    auto toDateQuery = request.query().get("toDate");
    std::optional<std::string> toDate;
    if(toDateQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(toDateQuery.value(), valueQuery_instance)){
            toDate = valueQuery_instance;
        }
    }
    auto fromDate2Query = request.query().get("from_date");
    std::optional<std::string> fromDate2;
    if(fromDate2Query.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(fromDate2Query.value(), valueQuery_instance)){
            fromDate2 = valueQuery_instance;
        }
    }
    auto toDate2Query = request.query().get("to_date");
    std::optional<std::string> toDate2;
    if(toDate2Query.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(toDate2Query.value(), valueQuery_instance)){
            toDate2 = valueQuery_instance;
        }
    }
    
    try {
        this->get_returns(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_stocks_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    GetWarehouseStocksRequest getWarehouseStocksRequest;
    
    // Getting the query params
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(getWarehouseStocksRequest);
        getWarehouseStocksRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_stocks(campaignId, pageToken, limit, getWarehouseStocksRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_suggested_offer_mapping_entries_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    GetSuggestedOfferMappingEntriesRequest getSuggestedOfferMappingEntriesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(getSuggestedOfferMappingEntriesRequest);
        getSuggestedOfferMappingEntriesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_suggested_offer_mapping_entries(campaignId, getSuggestedOfferMappingEntriesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_suggested_offer_mappings_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    GetSuggestedOfferMappingsRequest getSuggestedOfferMappingsRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(getSuggestedOfferMappingsRequest);
        getSuggestedOfferMappingsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_suggested_offer_mappings(businessId, getSuggestedOfferMappingsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::get_suggested_prices_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    SuggestPricesRequest suggestPricesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(suggestPricesRequest);
        suggestPricesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->get_suggested_prices(campaignId, suggestPricesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::put_bids_for_business_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    PutSkuBidsRequest putSkuBidsRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(putSkuBidsRequest);
        putSkuBidsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->put_bids_for_business(businessId, putSkuBidsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::put_bids_for_campaign_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    PutSkuBidsRequest putSkuBidsRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(putSkuBidsRequest);
        putSkuBidsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->put_bids_for_campaign(campaignId, putSkuBidsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::refresh_feed_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto feedId = request.param(":feedId").as<int64_t>();
    
    try {
        this->refresh_feed(campaignId, feedId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::search_region_children_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto regionId = request.param(":regionId").as<int64_t>();
    
    // Getting the query params
    auto pageQuery = request.query().get("page");
    std::optional<int32_t> page;
    if(pageQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageQuery.value(), valueQuery_instance)){
            page = valueQuery_instance;
        }
    }
    auto pageSizeQuery = request.query().get("pageSize");
    std::optional<int32_t> pageSize;
    if(pageSizeQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageSizeQuery.value(), valueQuery_instance)){
            pageSize = valueQuery_instance;
        }
    }
    
    try {
        this->search_region_children(regionId, page, pageSize, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::search_regions_by_id_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto regionId = request.param(":regionId").as<int64_t>();
    
    try {
        this->search_regions_by_id(regionId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::search_regions_by_name_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto nameQuery = request.query().get("name");
    std::optional<std::string> name;
    if(nameQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(nameQuery.value(), valueQuery_instance)){
            name = valueQuery_instance;
        }
    }
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        this->search_regions_by_name(name, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::send_file_to_chat_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    try {
      this->send_file_to_chat(request, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::send_message_to_chat_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    SendMessageToChatRequest sendMessageToChatRequest;
    
    // Getting the query params
    auto chatIdQuery = request.query().get("chatId");
    std::optional<int64_t> chatId;
    if(chatIdQuery.has_value()){
        int64_t valueQuery_instance;
        if(fromStringValue(chatIdQuery.value(), valueQuery_instance)){
            chatId = valueQuery_instance;
        }
    }
    
    try {
        nlohmann::json::parse(request.body()).get_to(sendMessageToChatRequest);
        sendMessageToChatRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->send_message_to_chat(businessId, chatId, sendMessageToChatRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::set_feed_params_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto feedId = request.param(":feedId").as<int64_t>();
    
    // Getting the body param
    
    SetFeedParamsRequest setFeedParamsRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(setFeedParamsRequest);
        setFeedParamsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->set_feed_params(campaignId, feedId, setFeedParamsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::skip_goods_feedbacks_reaction_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    SkipGoodsFeedbackReactionRequest skipGoodsFeedbackReactionRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(skipGoodsFeedbackReactionRequest);
        skipGoodsFeedbackReactionRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->skip_goods_feedbacks_reaction(businessId, skipGoodsFeedbackReactionRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::update_business_prices_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    UpdateBusinessPricesRequest updateBusinessPricesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updateBusinessPricesRequest);
        updateBusinessPricesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_business_prices(businessId, updateBusinessPricesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::update_campaign_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    UpdateCampaignOffersRequest updateCampaignOffersRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updateCampaignOffersRequest);
        updateCampaignOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_campaign_offers(campaignId, updateCampaignOffersRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::update_goods_feedback_comment_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    UpdateGoodsFeedbackCommentRequest updateGoodsFeedbackCommentRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updateGoodsFeedbackCommentRequest);
        updateGoodsFeedbackCommentRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_goods_feedback_comment(businessId, updateGoodsFeedbackCommentRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::update_offer_content_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    UpdateOfferContentRequest updateOfferContentRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updateOfferContentRequest);
        updateOfferContentRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_offer_content(businessId, updateOfferContentRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::update_offer_mapping_entries_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    UpdateOfferMappingEntryRequest updateOfferMappingEntryRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updateOfferMappingEntryRequest);
        updateOfferMappingEntryRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_offer_mapping_entries(campaignId, updateOfferMappingEntryRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::update_offer_mappings_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    UpdateOfferMappingsRequest updateOfferMappingsRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updateOfferMappingsRequest);
        updateOfferMappingsRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_offer_mappings(businessId, updateOfferMappingsRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::update_prices_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    UpdatePricesRequest updatePricesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updatePricesRequest);
        updatePricesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_prices(campaignId, updatePricesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void FbyApi::update_promo_offers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto businessId = request.param(":businessId").as<int64_t>();
    
    // Getting the body param
    
    UpdatePromoOffersRequest updatePromoOffersRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updatePromoOffersRequest);
        updatePromoOffersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_promo_offers(businessId, updatePromoOffersRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}

void FbyApi::fby_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

