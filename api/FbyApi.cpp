/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include <corvusoft/restbed/byte.hpp>
#include <corvusoft/restbed/string.hpp>
#include <corvusoft/restbed/settings.hpp>
#include <corvusoft/restbed/request.hpp>
#include <corvusoft/restbed/uri.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>

#include "FbyApi.h"

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

namespace {
[[maybe_unused]]
std::string selectPreferredContentType(const std::vector<std::string>& contentTypes) {
    if (contentTypes.size() == 0) {
        return "application/json";
    }

    if (contentTypes.size() == 1) {
        return contentTypes.at(0);
    }

    static const std::array<std::string, 2> preferredTypes = {"json", "xml"};
    for (const auto& preferredType: preferredTypes) {
        const auto ret = std::find_if(contentTypes.cbegin(),
        contentTypes.cend(),
        [preferredType](const std::string& str) {
            return str.find(preferredType) != std::string::npos;});
        if (ret != contentTypes.cend()) {
            return *ret;
        }
    }

    return contentTypes.at(0);
}
}

FbyApiException::FbyApiException(int status_code, std::string what)
  : m_status(status_code),
    m_what(what)
{

}
int FbyApiException::getStatus() const
{
    return m_status;
}
const char* FbyApiException::what() const noexcept
{
    return m_what.c_str();
}


template<class MODEL_T>
MODEL_T extractJsonModelBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto model = MODEL_T(pt);
    return model;
}

template<class MODEL_T>
std::vector<MODEL_T> extractJsonArrayBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto arrayRet = std::vector<MODEL_T>();
    for (const auto& child: pt) {
        arrayRet.emplace_back(MODEL_T(child.second));
    }
    return arrayRet;
}

template <class KEY_T, class VAL_T>
std::string convertMapResponse(const std::map<KEY_T, VAL_T>& map)
{
    boost::property_tree::ptree pt;
    for(const auto &kv: map) {
    pt.push_back(boost::property_tree::ptree::value_type(
        boost::lexical_cast<std::string>(kv.first),
        boost::property_tree::ptree(
        boost::lexical_cast<std::string>(kv.second))));
    }
    std::stringstream sstream;
    write_json(sstream, pt);
    std::string result = sstream.str();
    return result;
}

namespace FbyApiResources {
CampaignsCampaignIdHidden_offersResource::CampaignsCampaignIdHidden_offersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/hidden-offers");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdHidden_offersResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdHidden_offersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdHidden_offersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdHidden_offersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdHidden_offersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdHidden_offersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto addHiddenOffersRequest = extractJsonModelBodyParam<AddHiddenOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, addHiddenOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdHidden_offersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string offerId_raw = request->get_query_parameter("offerId");
    std::vector<std::string> offerId;
    std::vector<std::string> offerId_temp;
    boost::split(offerId_temp, offerId_raw, boost::is_any_of(","));
    std::copy(offerId_temp.begin(), offerId_temp.end(), std::inserter(offerId, std::next(offerId.begin())));
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    int32_t offset = request->get_query_parameter("offset", 0);
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetHiddenOffersResponse resultObject = GetHiddenOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, offerId, pageToken, limit, offset, page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, EmptyApiResponse> CampaignsCampaignIdHidden_offersResource::handler_POST(
        int64_t & campaignId, AddHiddenOffersRequest & addHiddenOffersRequest)
{
    return handler_POST_func(campaignId, addHiddenOffersRequest);
}

std::pair<int, GetHiddenOffersResponse> CampaignsCampaignIdHidden_offersResource::handler_GET(
    int64_t & campaignId, std::vector<std::string> & offerId, std::string & pageToken, int32_t & limit, int32_t & offset, int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(campaignId, offerId, pageToken, limit, offset, page, pageSize);
}

std::string CampaignsCampaignIdHidden_offersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdHidden_offersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsArchiveResource::BusinessesBusinessIdOffer_mappingsArchiveResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/archive");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsArchiveResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsArchiveResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsArchiveResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsArchiveResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsArchiveResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsArchiveResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsArchiveResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsArchiveResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto addOffersToArchiveRequest = extractJsonModelBodyParam<AddOffersToArchiveRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    AddOffersToArchiveResponse resultObject = AddOffersToArchiveResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, addOffersToArchiveRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, AddOffersToArchiveResponse> BusinessesBusinessIdOffer_mappingsArchiveResource::handler_POST(
        int64_t & businessId, AddOffersToArchiveRequest & addOffersToArchiveRequest)
{
    return handler_POST_func(businessId, addOffersToArchiveRequest);
}


std::string BusinessesBusinessIdOffer_mappingsArchiveResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsArchiveResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
TariffsCalculateResource::TariffsCalculateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/tariffs/calculate");
	this->set_method_handler("POST",
		std::bind(&TariffsCalculateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> TariffsCalculateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> TariffsCalculateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> TariffsCalculateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void TariffsCalculateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void TariffsCalculateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void TariffsCalculateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void TariffsCalculateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto calculateTariffsRequest = extractJsonModelBodyParam<CalculateTariffsRequest>(bodyContent);
    
    int status_code = 500;
    CalculateTariffsResponse resultObject = CalculateTariffsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(calculateTariffsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, CalculateTariffsResponse> TariffsCalculateResource::handler_POST(
        CalculateTariffsRequest & calculateTariffsRequest)
{
    return handler_POST_func(calculateTariffsRequest);
}


std::string TariffsCalculateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string TariffsCalculateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPrice_quarantineConfirmResource::BusinessesBusinessIdPrice_quarantineConfirmResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/price-quarantine/confirm");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPrice_quarantineConfirmResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineConfirmResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineConfirmResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineConfirmResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPrice_quarantineConfirmResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPrice_quarantineConfirmResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPrice_quarantineConfirmResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPrice_quarantineConfirmResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto confirmPricesRequest = extractJsonModelBodyParam<ConfirmPricesRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, confirmPricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdPrice_quarantineConfirmResource::handler_POST(
        int64_t & businessId, ConfirmPricesRequest & confirmPricesRequest)
{
    return handler_POST_func(businessId, confirmPricesRequest);
}


std::string BusinessesBusinessIdPrice_quarantineConfirmResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPrice_quarantineConfirmResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdPrice_quarantineConfirmResource::CampaignsCampaignIdPrice_quarantineConfirmResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/price-quarantine/confirm");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdPrice_quarantineConfirmResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineConfirmResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineConfirmResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineConfirmResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdPrice_quarantineConfirmResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdPrice_quarantineConfirmResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdPrice_quarantineConfirmResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdPrice_quarantineConfirmResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto confirmPricesRequest = extractJsonModelBodyParam<ConfirmPricesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, confirmPricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdPrice_quarantineConfirmResource::handler_POST(
        int64_t & campaignId, ConfirmPricesRequest & confirmPricesRequest)
{
    return handler_POST_func(campaignId, confirmPricesRequest);
}


std::string CampaignsCampaignIdPrice_quarantineConfirmResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdPrice_quarantineConfirmResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsNewResource::BusinessesBusinessIdChatsNewResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/new");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsNewResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsNewResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsNewResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsNewResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsNewResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsNewResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsNewResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsNewResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto createChatRequest = extractJsonModelBodyParam<CreateChatRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    CreateChatResponse resultObject = CreateChatResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, createChatRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, CreateChatResponse> BusinessesBusinessIdChatsNewResource::handler_POST(
        int64_t & businessId, CreateChatRequest & createChatRequest)
{
    return handler_POST_func(businessId, createChatRequest);
}


std::string BusinessesBusinessIdChatsNewResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsNewResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersDeleteResource::CampaignsCampaignIdOffersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/delete");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteCampaignOffersRequest = extractJsonModelBodyParam<DeleteCampaignOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    DeleteCampaignOffersResponse resultObject = DeleteCampaignOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, deleteCampaignOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, DeleteCampaignOffersResponse> CampaignsCampaignIdOffersDeleteResource::handler_POST(
        int64_t & campaignId, DeleteCampaignOffersRequest & deleteCampaignOffersRequest)
{
    return handler_POST_func(campaignId, deleteCampaignOffersRequest);
}


std::string CampaignsCampaignIdOffersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/delete");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteGoodsFeedbackCommentRequest = extractJsonModelBodyParam<DeleteGoodsFeedbackCommentRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, deleteGoodsFeedbackCommentRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::handler_POST(
        int64_t & businessId, DeleteGoodsFeedbackCommentRequest & deleteGoodsFeedbackCommentRequest)
{
    return handler_POST_func(businessId, deleteGoodsFeedbackCommentRequest);
}


std::string BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackCommentsDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdHidden_offersDeleteResource::CampaignsCampaignIdHidden_offersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/hidden-offers/delete");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdHidden_offersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdHidden_offersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdHidden_offersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdHidden_offersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdHidden_offersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdHidden_offersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteHiddenOffersRequest = extractJsonModelBodyParam<DeleteHiddenOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, deleteHiddenOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdHidden_offersDeleteResource::handler_POST(
        int64_t & campaignId, DeleteHiddenOffersRequest & deleteHiddenOffersRequest)
{
    return handler_POST_func(campaignId, deleteHiddenOffersRequest);
}


std::string CampaignsCampaignIdHidden_offersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdHidden_offersDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsDeleteResource::BusinessesBusinessIdOffer_mappingsDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/delete");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteOffersRequest = extractJsonModelBodyParam<DeleteOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    DeleteOffersResponse resultObject = DeleteOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, deleteOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, DeleteOffersResponse> BusinessesBusinessIdOffer_mappingsDeleteResource::handler_POST(
        int64_t & businessId, DeleteOffersRequest & deleteOffersRequest)
{
    return handler_POST_func(businessId, deleteOffersRequest);
}


std::string BusinessesBusinessIdOffer_mappingsDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsUnarchiveResource::BusinessesBusinessIdOffer_mappingsUnarchiveResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/unarchive");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsUnarchiveResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUnarchiveResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUnarchiveResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUnarchiveResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsUnarchiveResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsUnarchiveResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsUnarchiveResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsUnarchiveResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deleteOffersFromArchiveRequest = extractJsonModelBodyParam<DeleteOffersFromArchiveRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    DeleteOffersFromArchiveResponse resultObject = DeleteOffersFromArchiveResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, deleteOffersFromArchiveRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, DeleteOffersFromArchiveResponse> BusinessesBusinessIdOffer_mappingsUnarchiveResource::handler_POST(
        int64_t & businessId, DeleteOffersFromArchiveRequest & deleteOffersFromArchiveRequest)
{
    return handler_POST_func(businessId, deleteOffersFromArchiveRequest);
}


std::string BusinessesBusinessIdOffer_mappingsUnarchiveResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsUnarchiveResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPromosOffersDeleteResource::BusinessesBusinessIdPromosOffersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/delete");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPromosOffersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersDeleteResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPromosOffersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPromosOffersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPromosOffersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPromosOffersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto deletePromoOffersRequest = extractJsonModelBodyParam<DeletePromoOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    DeletePromoOffersResponse resultObject = DeletePromoOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, deletePromoOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, DeletePromoOffersResponse> BusinessesBusinessIdPromosOffersDeleteResource::handler_POST(
        int64_t & businessId, DeletePromoOffersRequest & deletePromoOffersRequest)
{
    return handler_POST_func(businessId, deletePromoOffersRequest);
}


std::string BusinessesBusinessIdPromosOffersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPromosOffersDeleteResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsBoost_consolidatedGenerateResource::ReportsBoost_consolidatedGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/boost-consolidated/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsBoost_consolidatedGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsBoost_consolidatedGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsBoost_consolidatedGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsBoost_consolidatedGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsBoost_consolidatedGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsBoost_consolidatedGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsBoost_consolidatedGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsBoost_consolidatedGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateBoostConsolidatedRequest = extractJsonModelBodyParam<GenerateBoostConsolidatedRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateBoostConsolidatedRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsBoost_consolidatedGenerateResource::handler_POST(
        GenerateBoostConsolidatedRequest & generateBoostConsolidatedRequest, ReportFormatType & format)
{
    return handler_POST_func(generateBoostConsolidatedRequest, format);
}


std::string ReportsBoost_consolidatedGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsBoost_consolidatedGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsCompetitors_positionGenerateResource::ReportsCompetitors_positionGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/competitors-position/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsCompetitors_positionGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsCompetitors_positionGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsCompetitors_positionGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsCompetitors_positionGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsCompetitors_positionGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsCompetitors_positionGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsCompetitors_positionGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsCompetitors_positionGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateCompetitorsPositionReportRequest = extractJsonModelBodyParam<GenerateCompetitorsPositionReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateCompetitorsPositionReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsCompetitors_positionGenerateResource::handler_POST(
        GenerateCompetitorsPositionReportRequest & generateCompetitorsPositionReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateCompetitorsPositionReportRequest, format);
}


std::string ReportsCompetitors_positionGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsCompetitors_positionGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsGoods_feedbackGenerateResource::ReportsGoods_feedbackGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-feedback/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsGoods_feedbackGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsGoods_feedbackGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsGoods_feedbackGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsGoods_feedbackGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsGoods_feedbackGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsGoods_feedbackGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsGoods_feedbackGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsGoods_feedbackGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateGoodsFeedbackRequest = extractJsonModelBodyParam<GenerateGoodsFeedbackRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateGoodsFeedbackRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsGoods_feedbackGenerateResource::handler_POST(
        GenerateGoodsFeedbackRequest & generateGoodsFeedbackRequest, ReportFormatType & format)
{
    return handler_POST_func(generateGoodsFeedbackRequest, format);
}


std::string ReportsGoods_feedbackGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsGoods_feedbackGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsGoods_movementGenerateResource::ReportsGoods_movementGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-movement/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsGoods_movementGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsGoods_movementGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsGoods_movementGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsGoods_movementGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsGoods_movementGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsGoods_movementGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsGoods_movementGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsGoods_movementGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateGoodsMovementReportRequest = extractJsonModelBodyParam<GenerateGoodsMovementReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateGoodsMovementReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsGoods_movementGenerateResource::handler_POST(
        GenerateGoodsMovementReportRequest & generateGoodsMovementReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateGoodsMovementReportRequest, format);
}


std::string ReportsGoods_movementGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsGoods_movementGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsGoods_realizationGenerateResource::ReportsGoods_realizationGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-realization/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsGoods_realizationGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsGoods_realizationGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsGoods_realizationGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsGoods_realizationGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsGoods_realizationGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsGoods_realizationGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsGoods_realizationGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsGoods_realizationGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateGoodsRealizationReportRequest = extractJsonModelBodyParam<GenerateGoodsRealizationReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateGoodsRealizationReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsGoods_realizationGenerateResource::handler_POST(
        GenerateGoodsRealizationReportRequest & generateGoodsRealizationReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateGoodsRealizationReportRequest, format);
}


std::string ReportsGoods_realizationGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsGoods_realizationGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsGoods_turnoverGenerateResource::ReportsGoods_turnoverGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-turnover/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsGoods_turnoverGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsGoods_turnoverGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsGoods_turnoverGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsGoods_turnoverGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsGoods_turnoverGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsGoods_turnoverGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsGoods_turnoverGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsGoods_turnoverGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateGoodsTurnoverRequest = extractJsonModelBodyParam<GenerateGoodsTurnoverRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateGoodsTurnoverRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsGoods_turnoverGenerateResource::handler_POST(
        GenerateGoodsTurnoverRequest & generateGoodsTurnoverRequest, ReportFormatType & format)
{
    return handler_POST_func(generateGoodsTurnoverRequest, format);
}


std::string ReportsGoods_turnoverGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsGoods_turnoverGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsPricesGenerateResource::ReportsPricesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/prices/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsPricesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsPricesGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsPricesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsPricesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsPricesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsPricesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsPricesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsPricesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generatePricesReportRequest = extractJsonModelBodyParam<GeneratePricesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generatePricesReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsPricesGenerateResource::handler_POST(
        GeneratePricesReportRequest & generatePricesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generatePricesReportRequest, format);
}


std::string ReportsPricesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsPricesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsShelf_statisticsGenerateResource::ReportsShelf_statisticsGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shelf-statistics/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsShelf_statisticsGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsShelf_statisticsGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsShelf_statisticsGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsShelf_statisticsGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsShelf_statisticsGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsShelf_statisticsGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsShelf_statisticsGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsShelf_statisticsGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateShelfsStatisticsRequest = extractJsonModelBodyParam<GenerateShelfsStatisticsRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateShelfsStatisticsRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsShelf_statisticsGenerateResource::handler_POST(
        GenerateShelfsStatisticsRequest & generateShelfsStatisticsRequest, ReportFormatType & format)
{
    return handler_POST_func(generateShelfsStatisticsRequest, format);
}


std::string ReportsShelf_statisticsGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsShelf_statisticsGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsShows_salesGenerateResource::ReportsShows_salesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shows-sales/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsShows_salesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsShows_salesGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsShows_salesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsShows_salesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsShows_salesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsShows_salesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsShows_salesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsShows_salesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateShowsSalesReportRequest = extractJsonModelBodyParam<GenerateShowsSalesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateShowsSalesReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsShows_salesGenerateResource::handler_POST(
        GenerateShowsSalesReportRequest & generateShowsSalesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateShowsSalesReportRequest, format);
}


std::string ReportsShows_salesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsShows_salesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsStocks_on_warehousesGenerateResource::ReportsStocks_on_warehousesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/stocks-on-warehouses/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsStocks_on_warehousesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsStocks_on_warehousesGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsStocks_on_warehousesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsStocks_on_warehousesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsStocks_on_warehousesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsStocks_on_warehousesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsStocks_on_warehousesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsStocks_on_warehousesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateStocksOnWarehousesReportRequest = extractJsonModelBodyParam<GenerateStocksOnWarehousesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateStocksOnWarehousesReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsStocks_on_warehousesGenerateResource::handler_POST(
        GenerateStocksOnWarehousesReportRequest & generateStocksOnWarehousesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateStocksOnWarehousesReportRequest, format);
}


std::string ReportsStocks_on_warehousesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsStocks_on_warehousesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsUnited_marketplace_servicesGenerateResource::ReportsUnited_marketplace_servicesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-marketplace-services/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsUnited_marketplace_servicesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsUnited_marketplace_servicesGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsUnited_marketplace_servicesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsUnited_marketplace_servicesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsUnited_marketplace_servicesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsUnited_marketplace_servicesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsUnited_marketplace_servicesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsUnited_marketplace_servicesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateUnitedMarketplaceServicesReportRequest = extractJsonModelBodyParam<GenerateUnitedMarketplaceServicesReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateUnitedMarketplaceServicesReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsUnited_marketplace_servicesGenerateResource::handler_POST(
        GenerateUnitedMarketplaceServicesReportRequest & generateUnitedMarketplaceServicesReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateUnitedMarketplaceServicesReportRequest, format);
}


std::string ReportsUnited_marketplace_servicesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsUnited_marketplace_servicesGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsUnited_nettingGenerateResource::ReportsUnited_nettingGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-netting/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsUnited_nettingGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsUnited_nettingGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsUnited_nettingGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsUnited_nettingGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsUnited_nettingGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsUnited_nettingGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsUnited_nettingGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsUnited_nettingGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateUnitedNettingReportRequest = extractJsonModelBodyParam<GenerateUnitedNettingReportRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateUnitedNettingReportRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsUnited_nettingGenerateResource::handler_POST(
        GenerateUnitedNettingReportRequest & generateUnitedNettingReportRequest, ReportFormatType & format)
{
    return handler_POST_func(generateUnitedNettingReportRequest, format);
}


std::string ReportsUnited_nettingGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsUnited_nettingGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsUnited_ordersGenerateResource::ReportsUnited_ordersGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-orders/generate");
	this->set_method_handler("POST",
		std::bind(&ReportsUnited_ordersGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsUnited_ordersGenerateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsUnited_ordersGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsUnited_ordersGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsUnited_ordersGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsUnited_ordersGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsUnited_ordersGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsUnited_ordersGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto generateUnitedOrdersRequest = extractJsonModelBodyParam<GenerateUnitedOrdersRequest>(bodyContent);
    // Getting the query params
    
    int status_code = 500;
    GenerateReportResponse resultObject = GenerateReportResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(generateUnitedOrdersRequest, format);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GenerateReportResponse> ReportsUnited_ordersGenerateResource::handler_POST(
        GenerateUnitedOrdersRequest & generateUnitedOrdersRequest, ReportFormatType & format)
{
    return handler_POST_func(generateUnitedOrdersRequest, format);
}


std::string ReportsUnited_ordersGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsUnited_ordersGenerateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersAllResource::CampaignsCampaignIdOffersAllResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/all");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOffersAllResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersAllResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersAllResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersAllResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersAllResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersAllResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersAllResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersAllResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    int64_t feedId = request->get_query_parameter("feedId", 0L);
    int32_t chunk = request->get_query_parameter("chunk", 0);
    
    int status_code = 500;
    GetAllOffersResponse resultObject = GetAllOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, feedId, chunk);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetAllOffersResponse> CampaignsCampaignIdOffersAllResource::handler_GET(
        int64_t & campaignId, int64_t & feedId, int32_t & chunk)
{
    return handler_GET_func(campaignId, feedId, chunk);
}


std::string CampaignsCampaignIdOffersAllResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersAllResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdBidsInfoResource::BusinessesBusinessIdBidsInfoResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/info");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdBidsInfoResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdBidsInfoResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsInfoResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsInfoResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdBidsInfoResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdBidsInfoResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdBidsInfoResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdBidsInfoResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getBidsInfoRequest = extractJsonModelBodyParam<GetBidsInfoRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetBidsInfoResponse resultObject = GetBidsInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, pageToken, limit, getBidsInfoRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBidsInfoResponse> BusinessesBusinessIdBidsInfoResource::handler_POST(
        int64_t & businessId, std::string & pageToken, int32_t & limit, GetBidsInfoRequest & getBidsInfoRequest)
{
    return handler_POST_func(businessId, pageToken, limit, getBidsInfoRequest);
}


std::string BusinessesBusinessIdBidsInfoResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdBidsInfoResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdBidsRecommendationsResource::BusinessesBusinessIdBidsRecommendationsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/recommendations");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdBidsRecommendationsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdBidsRecommendationsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsRecommendationsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsRecommendationsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdBidsRecommendationsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdBidsRecommendationsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdBidsRecommendationsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdBidsRecommendationsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getBidsRecommendationsRequest = extractJsonModelBodyParam<GetBidsRecommendationsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetBidsRecommendationsResponse resultObject = GetBidsRecommendationsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getBidsRecommendationsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBidsRecommendationsResponse> BusinessesBusinessIdBidsRecommendationsResource::handler_POST(
        int64_t & businessId, GetBidsRecommendationsRequest & getBidsRecommendationsRequest)
{
    return handler_POST_func(businessId, getBidsRecommendationsRequest);
}


std::string BusinessesBusinessIdBidsRecommendationsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdBidsRecommendationsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPrice_quarantineResource::BusinessesBusinessIdPrice_quarantineResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/price-quarantine");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPrice_quarantineResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPrice_quarantineResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPrice_quarantineResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPrice_quarantineResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPrice_quarantineResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPrice_quarantineResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getQuarantineOffersRequest = extractJsonModelBodyParam<GetQuarantineOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetQuarantineOffersResponse resultObject = GetQuarantineOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getQuarantineOffersRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetQuarantineOffersResponse> BusinessesBusinessIdPrice_quarantineResource::handler_POST(
        int64_t & businessId, GetQuarantineOffersRequest & getQuarantineOffersRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getQuarantineOffersRequest, pageToken, limit);
}


std::string BusinessesBusinessIdPrice_quarantineResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPrice_quarantineResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdSettingsResource::BusinessesBusinessIdSettingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/settings");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdSettingsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdSettingsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdSettingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdSettingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdSettingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdSettingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdSettingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdSettingsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetBusinessSettingsResponse resultObject = GetBusinessSettingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBusinessSettingsResponse> BusinessesBusinessIdSettingsResource::handler_POST(
        int64_t & businessId)
{
    return handler_POST_func(businessId);
}


std::string BusinessesBusinessIdSettingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdSettingsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdResource::CampaignsCampaignIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetCampaignResponse resultObject = GetCampaignResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignResponse> CampaignsCampaignIdResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdLoginsResource::CampaignsCampaignIdLoginsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/logins");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdLoginsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdLoginsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdLoginsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdLoginsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdLoginsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdLoginsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdLoginsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdLoginsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetCampaignLoginsResponse resultObject = GetCampaignLoginsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignLoginsResponse> CampaignsCampaignIdLoginsResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdLoginsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdLoginsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersResource::CampaignsCampaignIdOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffersResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOffersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getCampaignOffersRequest = extractJsonModelBodyParam<GetCampaignOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetCampaignOffersResponse resultObject = GetCampaignOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, getCampaignOffersRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdOffersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string query = request->get_query_parameter("query", "");
    int64_t feedId = request->get_query_parameter("feedId", 0L);
    std::string shopCategoryId = request->get_query_parameter("shopCategoryId", "");
    bool matched = request->get_query_parameter("matched", false);
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetOffersResponse resultObject = GetOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, GetCampaignOffersResponse> CampaignsCampaignIdOffersResource::handler_POST(
        int64_t & campaignId, GetCampaignOffersRequest & getCampaignOffersRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(campaignId, getCampaignOffersRequest, pageToken, limit);
}

std::pair<int, GetOffersResponse> CampaignsCampaignIdOffersResource::handler_GET(
    int64_t & campaignId, std::string & query, int64_t & feedId, std::string & shopCategoryId, CurrencyType & currency, bool & matched, int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize);
}

std::string CampaignsCampaignIdOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdPrice_quarantineResource::CampaignsCampaignIdPrice_quarantineResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/price-quarantine");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdPrice_quarantineResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdPrice_quarantineResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdPrice_quarantineResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdPrice_quarantineResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdPrice_quarantineResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdPrice_quarantineResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getQuarantineOffersRequest = extractJsonModelBodyParam<GetQuarantineOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetQuarantineOffersResponse resultObject = GetQuarantineOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, getQuarantineOffersRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetQuarantineOffersResponse> CampaignsCampaignIdPrice_quarantineResource::handler_POST(
        int64_t & campaignId, GetQuarantineOffersRequest & getQuarantineOffersRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(campaignId, getQuarantineOffersRequest, pageToken, limit);
}


std::string CampaignsCampaignIdPrice_quarantineResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdPrice_quarantineResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdRegionResource::CampaignsCampaignIdRegionResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/region");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdRegionResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdRegionResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdRegionResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdRegionResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdRegionResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdRegionResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdRegionResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdRegionResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetCampaignRegionResponse resultObject = GetCampaignRegionResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignRegionResponse> CampaignsCampaignIdRegionResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdRegionResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdRegionResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdSettingsResource::CampaignsCampaignIdSettingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/settings");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdSettingsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdSettingsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdSettingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdSettingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdSettingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdSettingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdSettingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdSettingsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetCampaignSettingsResponse resultObject = GetCampaignSettingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignSettingsResponse> CampaignsCampaignIdSettingsResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdSettingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdSettingsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsResource::CampaignsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns");
	this->set_method_handler("GET",
		std::bind(&CampaignsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the query params
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetCampaignsResponse resultObject = GetCampaignsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignsResponse> CampaignsResource::handler_GET(
        int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(page, pageSize);
}


std::string CampaignsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsBy_loginLoginResource::CampaignsBy_loginLoginResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/by_login/{login: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsBy_loginLoginResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsBy_loginLoginResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsBy_loginLoginResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsBy_loginLoginResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsBy_loginLoginResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsBy_loginLoginResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsBy_loginLoginResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsBy_loginLoginResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    std::string login = request->get_path_parameter("login", "");
    // Getting the query params
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetCampaignsResponse resultObject = GetCampaignsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(login, page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCampaignsResponse> CampaignsBy_loginLoginResource::handler_GET(
        std::string & login, int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(login, page, pageSize);
}


std::string CampaignsBy_loginLoginResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsBy_loginLoginResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CategoriesMax_sale_quantumResource::CategoriesMax_sale_quantumResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/categories/max-sale-quantum");
	this->set_method_handler("POST",
		std::bind(&CategoriesMax_sale_quantumResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CategoriesMax_sale_quantumResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CategoriesMax_sale_quantumResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CategoriesMax_sale_quantumResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CategoriesMax_sale_quantumResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CategoriesMax_sale_quantumResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CategoriesMax_sale_quantumResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CategoriesMax_sale_quantumResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getCategoriesMaxSaleQuantumRequest = extractJsonModelBodyParam<GetCategoriesMaxSaleQuantumRequest>(bodyContent);
    
    int status_code = 500;
    GetCategoriesMaxSaleQuantumResponse resultObject = GetCategoriesMaxSaleQuantumResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(getCategoriesMaxSaleQuantumRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCategoriesMaxSaleQuantumResponse> CategoriesMax_sale_quantumResource::handler_POST(
        GetCategoriesMaxSaleQuantumRequest & getCategoriesMaxSaleQuantumRequest)
{
    return handler_POST_func(getCategoriesMaxSaleQuantumRequest);
}


std::string CategoriesMax_sale_quantumResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CategoriesMax_sale_quantumResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CategoriesTreeResource::CategoriesTreeResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/categories/tree");
	this->set_method_handler("POST",
		std::bind(&CategoriesTreeResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CategoriesTreeResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CategoriesTreeResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CategoriesTreeResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CategoriesTreeResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CategoriesTreeResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CategoriesTreeResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CategoriesTreeResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getCategoriesRequest = extractJsonModelBodyParam<GetCategoriesRequest>(bodyContent);
    
    int status_code = 500;
    GetCategoriesResponse resultObject = GetCategoriesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(getCategoriesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCategoriesResponse> CategoriesTreeResource::handler_POST(
        GetCategoriesRequest & getCategoriesRequest)
{
    return handler_POST_func(getCategoriesRequest);
}


std::string CategoriesTreeResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CategoriesTreeResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CategoryCategoryIdParametersResource::CategoryCategoryIdParametersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/category/{categoryId: .*}/parameters");
	this->set_method_handler("POST",
		std::bind(&CategoryCategoryIdParametersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CategoryCategoryIdParametersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CategoryCategoryIdParametersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CategoryCategoryIdParametersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CategoryCategoryIdParametersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CategoryCategoryIdParametersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CategoryCategoryIdParametersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CategoryCategoryIdParametersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t categoryId = request->get_path_parameter("categoryId", 0L);
    
    int status_code = 500;
    GetCategoryContentParametersResponse resultObject = GetCategoryContentParametersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(categoryId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetCategoryContentParametersResponse> CategoryCategoryIdParametersResource::handler_POST(
        int64_t & categoryId)
{
    return handler_POST_func(categoryId);
}


std::string CategoryCategoryIdParametersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CategoryCategoryIdParametersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsHistoryResource::BusinessesBusinessIdChatsHistoryResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/history");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsHistoryResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsHistoryResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsHistoryResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsHistoryResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsHistoryResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsHistoryResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsHistoryResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsHistoryResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getChatHistoryRequest = extractJsonModelBodyParam<GetChatHistoryRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    int64_t chatId = request->get_query_parameter("chatId", 0L);
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetChatHistoryResponse resultObject = GetChatHistoryResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, chatId, getChatHistoryRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetChatHistoryResponse> BusinessesBusinessIdChatsHistoryResource::handler_POST(
        int64_t & businessId, int64_t & chatId, GetChatHistoryRequest & getChatHistoryRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, chatId, getChatHistoryRequest, pageToken, limit);
}


std::string BusinessesBusinessIdChatsHistoryResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsHistoryResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsResource::BusinessesBusinessIdChatsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getChatsRequest = extractJsonModelBodyParam<GetChatsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetChatsResponse resultObject = GetChatsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getChatsRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetChatsResponse> BusinessesBusinessIdChatsResource::handler_POST(
        int64_t & businessId, GetChatsRequest & getChatsRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getChatsRequest, pageToken, limit);
}


std::string BusinessesBusinessIdChatsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsFeedIdResource::CampaignsCampaignIdFeedsFeedIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdFeedsFeedIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsFeedIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsFeedIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsFeedIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsFeedIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t feedId = request->get_path_parameter("feedId", 0L);
    
    int status_code = 500;
    GetFeedResponse resultObject = GetFeedResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, feedId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetFeedResponse> CampaignsCampaignIdFeedsFeedIdResource::handler_GET(
        int64_t & campaignId, int64_t & feedId)
{
    return handler_GET_func(campaignId, feedId);
}


std::string CampaignsCampaignIdFeedsFeedIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsFeedIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsFeedIdIndex_logsResource::CampaignsCampaignIdFeedsFeedIdIndex_logsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/index-logs");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsFeedIdIndex_logsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsFeedIdIndex_logsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsFeedIdIndex_logsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t feedId = request->get_path_parameter("feedId", 0L);
    // Getting the query params
    int32_t limit = request->get_query_parameter("limit", 0);
    std::string publishedTimeFrom = request->get_query_parameter("publishedTimeFrom", "");
    std::string publishedTimeTo = request->get_query_parameter("publishedTimeTo", "");
    
    int status_code = 500;
    GetFeedIndexLogsResponse resultObject = GetFeedIndexLogsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetFeedIndexLogsResponse> CampaignsCampaignIdFeedsFeedIdIndex_logsResource::handler_GET(
        int64_t & campaignId, int64_t & feedId, int32_t & limit, std::string & publishedTimeFrom, std::string & publishedTimeTo, FeedIndexLogsStatusType & status)
{
    return handler_GET_func(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status);
}


std::string CampaignsCampaignIdFeedsFeedIdIndex_logsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsFeedIdIndex_logsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedbackUpdatesResource::CampaignsCampaignIdFeedbackUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feedback/updates");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdFeedbackUpdatesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedbackUpdatesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedbackUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedbackUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedbackUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedbackUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedbackUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedbackUpdatesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    std::string fromDate = request->get_query_parameter("fromDate", "");
    
    int status_code = 500;
    GetFeedbackListResponse resultObject = GetFeedbackListResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, pageToken, limit, fromDate);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetFeedbackListResponse> CampaignsCampaignIdFeedbackUpdatesResource::handler_GET(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, std::string & fromDate)
{
    return handler_GET_func(campaignId, pageToken, limit, fromDate);
}


std::string CampaignsCampaignIdFeedbackUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedbackUpdatesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsResource::CampaignsCampaignIdFeedsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdFeedsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetFeedsResponse resultObject = GetFeedsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetFeedsResponse> CampaignsCampaignIdFeedsResource::handler_GET(
        int64_t & campaignId)
{
    return handler_GET_func(campaignId);
}


std::string CampaignsCampaignIdFeedsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
WarehousesResource::WarehousesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/warehouses");
	this->set_method_handler("GET",
		std::bind(&WarehousesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> WarehousesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> WarehousesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> WarehousesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void WarehousesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void WarehousesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void WarehousesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void WarehousesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    
    int status_code = 500;
    GetFulfillmentWarehousesResponse resultObject = GetFulfillmentWarehousesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET();
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetFulfillmentWarehousesResponse> WarehousesResource::handler_GET(
        )
{
    return handler_GET_func();
}


std::string WarehousesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string WarehousesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackCommentsResource::BusinessesBusinessIdGoods_feedbackCommentsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackCommentsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackCommentsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackCommentsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackCommentsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackCommentsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getGoodsFeedbackCommentsRequest = extractJsonModelBodyParam<GetGoodsFeedbackCommentsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetGoodsFeedbackCommentsResponse resultObject = GetGoodsFeedbackCommentsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetGoodsFeedbackCommentsResponse> BusinessesBusinessIdGoods_feedbackCommentsResource::handler_POST(
        int64_t & businessId, GetGoodsFeedbackCommentsRequest & getGoodsFeedbackCommentsRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit);
}


std::string BusinessesBusinessIdGoods_feedbackCommentsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackCommentsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackResource::BusinessesBusinessIdGoods_feedbackResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getGoodsFeedbackRequest = extractJsonModelBodyParam<GetGoodsFeedbackRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetGoodsFeedbackResponse resultObject = GetGoodsFeedbackResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, pageToken, limit, getGoodsFeedbackRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetGoodsFeedbackResponse> BusinessesBusinessIdGoods_feedbackResource::handler_POST(
        int64_t & businessId, std::string & pageToken, int32_t & limit, GetGoodsFeedbackRequest & getGoodsFeedbackRequest)
{
    return handler_POST_func(businessId, pageToken, limit, getGoodsFeedbackRequest);
}


std::string BusinessesBusinessIdGoods_feedbackResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdStatsSkusResource::CampaignsCampaignIdStatsSkusResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/stats/skus");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdStatsSkusResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdStatsSkusResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdStatsSkusResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdStatsSkusResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdStatsSkusResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdStatsSkusResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdStatsSkusResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdStatsSkusResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getGoodsStatsRequest = extractJsonModelBodyParam<GetGoodsStatsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetGoodsStatsResponse resultObject = GetGoodsStatsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, getGoodsStatsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetGoodsStatsResponse> CampaignsCampaignIdStatsSkusResource::handler_POST(
        int64_t & campaignId, GetGoodsStatsRequest & getGoodsStatsRequest)
{
    return handler_POST_func(campaignId, getGoodsStatsRequest);
}


std::string CampaignsCampaignIdStatsSkusResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdStatsSkusResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_cardsResource::BusinessesBusinessIdOffer_cardsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-cards");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_cardsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_cardsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_cardsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_cardsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_cardsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getOfferCardsContentStatusRequest = extractJsonModelBodyParam<GetOfferCardsContentStatusRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOfferCardsContentStatusResponse resultObject = GetOfferCardsContentStatusResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, pageToken, limit, getOfferCardsContentStatusRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOfferCardsContentStatusResponse> BusinessesBusinessIdOffer_cardsResource::handler_POST(
        int64_t & businessId, std::string & pageToken, int32_t & limit, GetOfferCardsContentStatusRequest & getOfferCardsContentStatusRequest)
{
    return handler_POST_func(businessId, pageToken, limit, getOfferCardsContentStatusRequest);
}


std::string BusinessesBusinessIdOffer_cardsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_cardsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_mapping_entriesResource::CampaignsCampaignIdOffer_mapping_entriesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOffer_mapping_entriesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_mapping_entriesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_mapping_entriesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_mapping_entriesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_mapping_entriesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string offerId_raw = request->get_query_parameter("offerId");
    std::vector<std::string> offerId;
    std::vector<std::string> offerId_temp;
    boost::split(offerId_temp, offerId_raw, boost::is_any_of(","));
    std::copy(offerId_temp.begin(), offerId_temp.end(), std::inserter(offerId, std::next(offerId.begin())));
    std::string shopSku_raw = request->get_query_parameter("shopSku");
    std::vector<std::string> shopSku;
    std::vector<std::string> shopSku_temp;
    boost::split(shopSku_temp, shopSku_raw, boost::is_any_of(","));
    std::copy(shopSku_temp.begin(), shopSku_temp.end(), std::inserter(shopSku, std::next(shopSku.begin())));
    std::string status_raw = request->get_query_parameter("status");
    std::vector<OfferProcessingStatusType> status;
    std::vector<std::string> status_temp;
    boost::split(status_temp, status_raw, boost::is_any_of(","));
    std::transform(status_temp.begin(), status_temp.end(), std::back_inserter(status), [](const auto& i){ OfferProcessingStatusType ret; ret.fromString(i); return ret;});
    std::string availability_raw = request->get_query_parameter("availability");
    std::vector<OfferAvailabilityStatusType> availability;
    std::vector<std::string> availability_temp;
    boost::split(availability_temp, availability_raw, boost::is_any_of(","));
    std::transform(availability_temp.begin(), availability_temp.end(), std::back_inserter(availability), [](const auto& i){ OfferAvailabilityStatusType ret; ret.fromString(i); return ret;});
    std::string categoryId_raw = request->get_query_parameter("categoryId");
    std::vector<int32_t> categoryId;
    std::vector<std::string> categoryId_temp;
    boost::split(categoryId_temp, categoryId_raw, boost::is_any_of(","));
    std::transform(categoryId_temp.begin(), categoryId_temp.end(), std::back_inserter(categoryId), [](const auto& i){ int32_t ret; ret.fromString(i); return ret;});
    std::string vendor_raw = request->get_query_parameter("vendor");
    std::vector<std::string> vendor;
    std::vector<std::string> vendor_temp;
    boost::split(vendor_temp, vendor_raw, boost::is_any_of(","));
    std::copy(vendor_temp.begin(), vendor_temp.end(), std::inserter(vendor, std::next(vendor.begin())));
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOfferMappingEntriesResponse resultObject = GetOfferMappingEntriesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOfferMappingEntriesResponse> CampaignsCampaignIdOffer_mapping_entriesResource::handler_GET(
        int64_t & campaignId, std::vector<std::string> & offerId, std::vector<std::string> & shopSku, OfferMappingKindType & mappingKind, std::vector<OfferProcessingStatusType> & status, std::vector<OfferAvailabilityStatusType> & availability, std::vector<int32_t> & categoryId, std::vector<std::string> & vendor, std::string & pageToken, int32_t & limit)
{
    return handler_GET_func(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit);
}


std::string CampaignsCampaignIdOffer_mapping_entriesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_mapping_entriesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsResource::BusinessesBusinessIdOffer_mappingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getOfferMappingsRequest = extractJsonModelBodyParam<GetOfferMappingsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOfferMappingsResponse resultObject = GetOfferMappingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, pageToken, limit, getOfferMappingsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOfferMappingsResponse> BusinessesBusinessIdOffer_mappingsResource::handler_POST(
        int64_t & businessId, std::string & pageToken, int32_t & limit, GetOfferMappingsRequest & getOfferMappingsRequest)
{
    return handler_POST_func(businessId, pageToken, limit, getOfferMappingsRequest);
}


std::string BusinessesBusinessIdOffer_mappingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffersRecommendationsResource::BusinessesBusinessIdOffersRecommendationsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offers/recommendations");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffersRecommendationsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffersRecommendationsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffersRecommendationsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffersRecommendationsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffersRecommendationsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffersRecommendationsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffersRecommendationsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffersRecommendationsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getOfferRecommendationsRequest = extractJsonModelBodyParam<GetOfferRecommendationsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOfferRecommendationsResponse resultObject = GetOfferRecommendationsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getOfferRecommendationsRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOfferRecommendationsResponse> BusinessesBusinessIdOffersRecommendationsResource::handler_POST(
        int64_t & businessId, GetOfferRecommendationsRequest & getOfferRecommendationsRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getOfferRecommendationsRequest, pageToken, limit);
}


std::string BusinessesBusinessIdOffersRecommendationsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffersRecommendationsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdResource::CampaignsCampaignIdOrdersOrderIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    GetOrderResponse resultObject = GetOrderResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOrderResponse> CampaignsCampaignIdOrdersOrderIdResource::handler_GET(
        int64_t & campaignId, int64_t & orderId)
{
    return handler_GET_func(campaignId, orderId);
}


std::string CampaignsCampaignIdOrdersOrderIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/business-buyer");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    GetBusinessBuyerInfoResponse resultObject = GetBusinessBuyerInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, orderId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBusinessBuyerInfoResponse> CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::handler_POST(
        int64_t & campaignId, int64_t & orderId)
{
    return handler_POST_func(campaignId, orderId);
}


std::string CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdDocumentsResource::CampaignsCampaignIdOrdersOrderIdDocumentsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/documents");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDocumentsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDocumentsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdDocumentsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdDocumentsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdDocumentsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdDocumentsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    
    int status_code = 500;
    GetBusinessDocumentsInfoResponse resultObject = GetBusinessDocumentsInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, orderId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetBusinessDocumentsInfoResponse> CampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST(
        int64_t & campaignId, int64_t & orderId)
{
    return handler_POST_func(campaignId, orderId);
}


std::string CampaignsCampaignIdOrdersOrderIdDocumentsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdDocumentsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersResource::CampaignsCampaignIdOrdersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string orderIds_raw = request->get_query_parameter("orderIds");
    std::vector<int64_t> orderIds;
    std::vector<std::string> orderIds_temp;
    boost::split(orderIds_temp, orderIds_raw, boost::is_any_of(","));
    std::transform(orderIds_temp.begin(), orderIds_temp.end(), std::back_inserter(orderIds), [](const auto& i){ int64_t ret; ret.fromString(i); return ret;});
    std::string status_raw = request->get_query_parameter("status");
    std::set<OrderStatusType> status;
    std::vector<std::string> status_temp;
    boost::split(status_temp, status_raw, boost::is_any_of(","));
    std::transform(status_temp.begin(), status_temp.end(), std::back_inserter(status), [](const auto& i){ OrderStatusType ret; ret.fromString(i); return ret;});
    std::string substatus_raw = request->get_query_parameter("substatus");
    std::set<OrderSubstatusType> substatus;
    std::vector<std::string> substatus_temp;
    boost::split(substatus_temp, substatus_raw, boost::is_any_of(","));
    std::transform(substatus_temp.begin(), substatus_temp.end(), std::back_inserter(substatus), [](const auto& i){ OrderSubstatusType ret; ret.fromString(i); return ret;});
    std::string fromDate = request->get_query_parameter("fromDate", "");
    std::string toDate = request->get_query_parameter("toDate", "");
    std::string supplierShipmentDateFrom = request->get_query_parameter("supplierShipmentDateFrom", "");
    std::string supplierShipmentDateTo = request->get_query_parameter("supplierShipmentDateTo", "");
    std::string updatedAtFrom = request->get_query_parameter("updatedAtFrom", "");
    std::string updatedAtTo = request->get_query_parameter("updatedAtTo", "");
    bool fake = request->get_query_parameter("fake", false);
    bool hasCis = request->get_query_parameter("hasCis", false);
    bool onlyWaitingForCancellationApprove = request->get_query_parameter("onlyWaitingForCancellationApprove", false);
    bool onlyEstimatedDelivery = request->get_query_parameter("onlyEstimatedDelivery", false);
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOrdersResponse resultObject = GetOrdersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOrdersResponse> CampaignsCampaignIdOrdersResource::handler_GET(
        int64_t & campaignId, std::vector<int64_t> & orderIds, std::set<OrderStatusType> & status, std::set<OrderSubstatusType> & substatus, std::string & fromDate, std::string & toDate, std::string & supplierShipmentDateFrom, std::string & supplierShipmentDateTo, std::string & updatedAtFrom, std::string & updatedAtTo, OrderDeliveryDispatchType & dispatchType, bool & fake, bool & hasCis, bool & onlyWaitingForCancellationApprove, bool & onlyEstimatedDelivery, OrderBuyerType & buyerType, int32_t & page, int32_t & pageSize, std::string & pageToken, int32_t & limit)
{
    return handler_GET_func(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit);
}


std::string CampaignsCampaignIdOrdersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdStatsOrdersResource::CampaignsCampaignIdStatsOrdersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/stats/orders");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdStatsOrdersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdStatsOrdersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdStatsOrdersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdStatsOrdersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdStatsOrdersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdStatsOrdersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdStatsOrdersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdStatsOrdersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getOrdersStatsRequest = extractJsonModelBodyParam<GetOrdersStatsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetOrdersStatsResponse resultObject = GetOrdersStatsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, pageToken, limit, getOrdersStatsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetOrdersStatsResponse> CampaignsCampaignIdStatsOrdersResource::handler_POST(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, GetOrdersStatsRequest & getOrdersStatsRequest)
{
    return handler_POST_func(campaignId, pageToken, limit, getOrdersStatsRequest);
}


std::string CampaignsCampaignIdStatsOrdersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdStatsOrdersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_pricesResource::CampaignsCampaignIdOffer_pricesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOffer_pricesResource::handler_GET_internal, this,
			std::placeholders::_1));
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_pricesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_pricesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_pricesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_pricesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_pricesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    bool archived = request->get_query_parameter("archived", false);
    
    int status_code = 500;
    GetPricesResponse resultObject = GetPricesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, pageToken, limit, archived);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

// x-extension
void CampaignsCampaignIdOffer_pricesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session) {
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getPricesByOfferIdsRequest = extractJsonModelBodyParam<GetPricesByOfferIdsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetPricesByOfferIdsResponse resultObject = GetPricesByOfferIdsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, pageToken, limit, getPricesByOfferIdsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}

std::pair<int, GetPricesResponse> CampaignsCampaignIdOffer_pricesResource::handler_GET(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, bool & archived)
{
    return handler_GET_func(campaignId, pageToken, limit, archived);
}

std::pair<int, GetPricesByOfferIdsResponse> CampaignsCampaignIdOffer_pricesResource::handler_POST(
    int64_t & campaignId, std::string & pageToken, int32_t & limit, GetPricesByOfferIdsRequest & getPricesByOfferIdsRequest)
{
    return handler_POST_func(campaignId, pageToken, limit, getPricesByOfferIdsRequest);
}

std::string CampaignsCampaignIdOffer_pricesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_pricesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPromosOffersResource::BusinessesBusinessIdPromosOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPromosOffersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPromosOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPromosOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPromosOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPromosOffersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getPromoOffersRequest = extractJsonModelBodyParam<GetPromoOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetPromoOffersResponse resultObject = GetPromoOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getPromoOffersRequest, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetPromoOffersResponse> BusinessesBusinessIdPromosOffersResource::handler_POST(
        int64_t & businessId, GetPromoOffersRequest & getPromoOffersRequest, std::string & pageToken, int32_t & limit)
{
    return handler_POST_func(businessId, getPromoOffersRequest, pageToken, limit);
}


std::string BusinessesBusinessIdPromosOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPromosOffersResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPromosResource::BusinessesBusinessIdPromosResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPromosResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPromosResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPromosResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPromosResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPromosResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPromosResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getPromosRequest = extractJsonModelBodyParam<GetPromosRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetPromosResponse resultObject = GetPromosResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getPromosRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetPromosResponse> BusinessesBusinessIdPromosResource::handler_POST(
        int64_t & businessId, GetPromosRequest & getPromosRequest)
{
    return handler_POST_func(businessId, getPromosRequest);
}


std::string BusinessesBusinessIdPromosResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPromosResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdRatingsQualityResource::BusinessesBusinessIdRatingsQualityResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/ratings/quality");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdRatingsQualityResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdRatingsQualityResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdRatingsQualityResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdRatingsQualityResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdRatingsQualityResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdRatingsQualityResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdRatingsQualityResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdRatingsQualityResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getQualityRatingRequest = extractJsonModelBodyParam<GetQualityRatingRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetQualityRatingResponse resultObject = GetQualityRatingResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getQualityRatingRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetQualityRatingResponse> BusinessesBusinessIdRatingsQualityResource::handler_POST(
        int64_t & businessId, GetQualityRatingRequest & getQualityRatingRequest)
{
    return handler_POST_func(businessId, getQualityRatingRequest);
}


std::string BusinessesBusinessIdRatingsQualityResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdRatingsQualityResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
ReportsInfoReportIdResource::ReportsInfoReportIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/info/{reportId: .*}");
	this->set_method_handler("GET",
		std::bind(&ReportsInfoReportIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> ReportsInfoReportIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ReportsInfoReportIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ReportsInfoReportIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ReportsInfoReportIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ReportsInfoReportIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void ReportsInfoReportIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ReportsInfoReportIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    std::string reportId = request->get_path_parameter("reportId", "");
    
    int status_code = 500;
    GetReportInfoResponse resultObject = GetReportInfoResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(reportId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetReportInfoResponse> ReportsInfoReportIdResource::handler_GET(
        std::string & reportId)
{
    return handler_GET_func(reportId);
}


std::string ReportsInfoReportIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string ReportsInfoReportIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    int64_t returnId = request->get_path_parameter("returnId", 0L);
    
    int status_code = 500;
    GetReturnResponse resultObject = GetReturnResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId, returnId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetReturnResponse> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET(
        int64_t & campaignId, int64_t & orderId, int64_t & returnId)
{
    return handler_GET_func(campaignId, orderId, returnId);
}


std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/decision/{itemId: .*}/image/{imageHash: .*}");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t orderId = request->get_path_parameter("orderId", 0L);
    int64_t returnId = request->get_path_parameter("returnId", 0L);
    int64_t itemId = request->get_path_parameter("itemId", 0L);
    std::string imageHash = request->get_path_parameter("imageHash", "");
    
    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, orderId, returnId, itemId, imageHash);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/octet-stream","application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, std::string> CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET(
        int64_t & campaignId, int64_t & orderId, int64_t & returnId, int64_t & itemId, std::string & imageHash)
{
    return handler_GET_func(campaignId, orderId, returnId, itemId, imageHash);
}


std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdReturnsResource::CampaignsCampaignIdReturnsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/returns");
	this->set_method_handler("GET",
		std::bind(&CampaignsCampaignIdReturnsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdReturnsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdReturnsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdReturnsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdReturnsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdReturnsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdReturnsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdReturnsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    std::string orderIds_raw = request->get_query_parameter("orderIds");
    std::vector<int64_t> orderIds;
    std::vector<std::string> orderIds_temp;
    boost::split(orderIds_temp, orderIds_raw, boost::is_any_of(","));
    std::transform(orderIds_temp.begin(), orderIds_temp.end(), std::back_inserter(orderIds), [](const auto& i){ int64_t ret; ret.fromString(i); return ret;});
    std::string statuses_raw = request->get_query_parameter("statuses");
    std::vector<RefundStatusType> statuses;
    std::vector<std::string> statuses_temp;
    boost::split(statuses_temp, statuses_raw, boost::is_any_of(","));
    std::transform(statuses_temp.begin(), statuses_temp.end(), std::back_inserter(statuses), [](const auto& i){ RefundStatusType ret; ret.fromString(i); return ret;});
    std::string fromDate = request->get_query_parameter("fromDate", "");
    std::string toDate = request->get_query_parameter("toDate", "");
    std::string fromDate2 = request->get_query_parameter("fromDate2", "");
    std::string toDate2 = request->get_query_parameter("toDate2", "");
    
    int status_code = 500;
    GetReturnsResponse resultObject = GetReturnsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetReturnsResponse> CampaignsCampaignIdReturnsResource::handler_GET(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, std::vector<int64_t> & orderIds, std::vector<RefundStatusType> & statuses, ReturnType & type, std::string & fromDate, std::string & toDate, std::string & fromDate2, std::string & toDate2)
{
    return handler_GET_func(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2);
}


std::string CampaignsCampaignIdReturnsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdReturnsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersStocksResource::CampaignsCampaignIdOffersStocksResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/stocks");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffersStocksResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersStocksResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersStocksResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersStocksResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersStocksResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersStocksResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersStocksResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersStocksResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getWarehouseStocksRequest = extractJsonModelBodyParam<GetWarehouseStocksRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    // Getting the query params
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetWarehouseStocksResponse resultObject = GetWarehouseStocksResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, pageToken, limit, getWarehouseStocksRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetWarehouseStocksResponse> CampaignsCampaignIdOffersStocksResource::handler_POST(
        int64_t & campaignId, std::string & pageToken, int32_t & limit, GetWarehouseStocksRequest & getWarehouseStocksRequest)
{
    return handler_POST_func(campaignId, pageToken, limit, getWarehouseStocksRequest);
}


std::string CampaignsCampaignIdOffersStocksResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersStocksResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/suggestions");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getSuggestedOfferMappingEntriesRequest = extractJsonModelBodyParam<GetSuggestedOfferMappingEntriesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    GetSuggestedOfferMappingEntriesResponse resultObject = GetSuggestedOfferMappingEntriesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, getSuggestedOfferMappingEntriesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetSuggestedOfferMappingEntriesResponse> CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::handler_POST(
        int64_t & campaignId, GetSuggestedOfferMappingEntriesRequest & getSuggestedOfferMappingEntriesRequest)
{
    return handler_POST_func(campaignId, getSuggestedOfferMappingEntriesRequest);
}


std::string CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsSuggestionsResource::BusinessesBusinessIdOffer_mappingsSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/suggestions");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsSuggestionsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto getSuggestedOfferMappingsRequest = extractJsonModelBodyParam<GetSuggestedOfferMappingsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    GetSuggestedOfferMappingsResponse resultObject = GetSuggestedOfferMappingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, getSuggestedOfferMappingsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetSuggestedOfferMappingsResponse> BusinessesBusinessIdOffer_mappingsSuggestionsResource::handler_POST(
        int64_t & businessId, GetSuggestedOfferMappingsRequest & getSuggestedOfferMappingsRequest)
{
    return handler_POST_func(businessId, getSuggestedOfferMappingsRequest);
}


std::string BusinessesBusinessIdOffer_mappingsSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsSuggestionsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_pricesSuggestionsResource::CampaignsCampaignIdOffer_pricesSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/suggestions");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_pricesSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesSuggestionsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_pricesSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_pricesSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_pricesSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_pricesSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto suggestPricesRequest = extractJsonModelBodyParam<SuggestPricesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    SuggestPricesResponse resultObject = SuggestPricesResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, suggestPricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, SuggestPricesResponse> CampaignsCampaignIdOffer_pricesSuggestionsResource::handler_POST(
        int64_t & campaignId, SuggestPricesRequest & suggestPricesRequest)
{
    return handler_POST_func(campaignId, suggestPricesRequest);
}


std::string CampaignsCampaignIdOffer_pricesSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_pricesSuggestionsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdBidsResource::BusinessesBusinessIdBidsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids");
	this->set_method_handler("PUT",
		std::bind(&BusinessesBusinessIdBidsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdBidsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdBidsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdBidsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdBidsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdBidsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdBidsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto putSkuBidsRequest = extractJsonModelBodyParam<PutSkuBidsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(businessId, putSkuBidsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdBidsResource::handler_PUT(
        int64_t & businessId, PutSkuBidsRequest & putSkuBidsRequest)
{
    return handler_PUT_func(businessId, putSkuBidsRequest);
}


std::string BusinessesBusinessIdBidsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdBidsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdBidsResource::CampaignsCampaignIdBidsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/bids");
	this->set_method_handler("PUT",
		std::bind(&CampaignsCampaignIdBidsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdBidsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdBidsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdBidsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdBidsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdBidsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdBidsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdBidsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto putSkuBidsRequest = extractJsonModelBodyParam<PutSkuBidsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, putSkuBidsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdBidsResource::handler_PUT(
        int64_t & campaignId, PutSkuBidsRequest & putSkuBidsRequest)
{
    return handler_PUT_func(campaignId, putSkuBidsRequest);
}


std::string CampaignsCampaignIdBidsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdBidsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsFeedIdRefreshResource::CampaignsCampaignIdFeedsFeedIdRefreshResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/refresh");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdRefreshResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdRefreshResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdRefreshResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsFeedIdRefreshResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsFeedIdRefreshResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsFeedIdRefreshResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t feedId = request->get_path_parameter("feedId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, feedId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST(
        int64_t & campaignId, int64_t & feedId)
{
    return handler_POST_func(campaignId, feedId);
}


std::string CampaignsCampaignIdFeedsFeedIdRefreshResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsFeedIdRefreshResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
RegionsRegionIdChildrenResource::RegionsRegionIdChildrenResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/{regionId: .*}/children");
	this->set_method_handler("GET",
		std::bind(&RegionsRegionIdChildrenResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> RegionsRegionIdChildrenResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> RegionsRegionIdChildrenResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> RegionsRegionIdChildrenResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void RegionsRegionIdChildrenResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void RegionsRegionIdChildrenResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void RegionsRegionIdChildrenResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void RegionsRegionIdChildrenResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t regionId = request->get_path_parameter("regionId", 0L);
    // Getting the query params
    int32_t page = request->get_query_parameter("page", 1);
    int32_t pageSize = request->get_query_parameter("pageSize", 0);
    
    int status_code = 500;
    GetRegionWithChildrenResponse resultObject = GetRegionWithChildrenResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(regionId, page, pageSize);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetRegionWithChildrenResponse> RegionsRegionIdChildrenResource::handler_GET(
        int64_t & regionId, int32_t & page, int32_t & pageSize)
{
    return handler_GET_func(regionId, page, pageSize);
}


std::string RegionsRegionIdChildrenResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string RegionsRegionIdChildrenResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
RegionsRegionIdResource::RegionsRegionIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/{regionId: .*}");
	this->set_method_handler("GET",
		std::bind(&RegionsRegionIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> RegionsRegionIdResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> RegionsRegionIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> RegionsRegionIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void RegionsRegionIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void RegionsRegionIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void RegionsRegionIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void RegionsRegionIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the path params
    int64_t regionId = request->get_path_parameter("regionId", 0L);
    
    int status_code = 500;
    GetRegionsResponse resultObject = GetRegionsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(regionId);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetRegionsResponse> RegionsRegionIdResource::handler_GET(
        int64_t & regionId)
{
    return handler_GET_func(regionId);
}


std::string RegionsRegionIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string RegionsRegionIdResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
RegionsResource::RegionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions");
	this->set_method_handler("GET",
		std::bind(&RegionsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> RegionsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> RegionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> RegionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void RegionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void RegionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void RegionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void RegionsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // Getting the query params
    std::string name = request->get_query_parameter("name", "");
    std::string pageToken = request->get_query_parameter("pageToken", "");
    int32_t limit = request->get_query_parameter("limit", 0);
    
    int status_code = 500;
    GetRegionsResponse resultObject = GetRegionsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_GET(name, pageToken, limit);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, GetRegionsResponse> RegionsResource::handler_GET(
        std::string & name, std::string & pageToken, int32_t & limit)
{
    return handler_GET_func(name, pageToken, limit);
}


std::string RegionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string RegionsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsFileSendResource::BusinessesBusinessIdChatsFileSendResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/file/send");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsFileSendResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsFileSendResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsFileSendResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsFileSendResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsFileSendResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsFileSendResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsFileSendResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsFileSendResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    auto file = boost::lexical_cast<std::string>(extractFormParamsFromBody("file", extractBodyContent(session)));
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    int64_t chatId = request->get_query_parameter("chatId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, chatId, file);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "multipart/form-data, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdChatsFileSendResource::handler_POST(
        int64_t & businessId, int64_t & chatId, std::string & file)
{
    return handler_POST_func(businessId, chatId, file);
}


std::string BusinessesBusinessIdChatsFileSendResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsFileSendResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdChatsMessageResource::BusinessesBusinessIdChatsMessageResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/message");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdChatsMessageResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdChatsMessageResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsMessageResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdChatsMessageResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdChatsMessageResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdChatsMessageResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdChatsMessageResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdChatsMessageResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto sendMessageToChatRequest = extractJsonModelBodyParam<SendMessageToChatRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    // Getting the query params
    int64_t chatId = request->get_query_parameter("chatId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, chatId, sendMessageToChatRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdChatsMessageResource::handler_POST(
        int64_t & businessId, int64_t & chatId, SendMessageToChatRequest & sendMessageToChatRequest)
{
    return handler_POST_func(businessId, chatId, sendMessageToChatRequest);
}


std::string BusinessesBusinessIdChatsMessageResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdChatsMessageResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdFeedsFeedIdParamsResource::CampaignsCampaignIdFeedsFeedIdParamsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/params");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdParamsResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdParamsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdFeedsFeedIdParamsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdFeedsFeedIdParamsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdFeedsFeedIdParamsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdFeedsFeedIdParamsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto setFeedParamsRequest = extractJsonModelBodyParam<SetFeedParamsRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    int64_t feedId = request->get_path_parameter("feedId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, feedId, setFeedParamsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST(
        int64_t & campaignId, int64_t & feedId, SetFeedParamsRequest & setFeedParamsRequest)
{
    return handler_POST_func(campaignId, feedId, setFeedParamsRequest);
}


std::string CampaignsCampaignIdFeedsFeedIdParamsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdFeedsFeedIdParamsResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackSkip_reactionResource::BusinessesBusinessIdGoods_feedbackSkip_reactionResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/skip-reaction");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackSkip_reactionResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackSkip_reactionResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackSkip_reactionResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto skipGoodsFeedbackReactionRequest = extractJsonModelBodyParam<SkipGoodsFeedbackReactionRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, skipGoodsFeedbackReactionRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdGoods_feedbackSkip_reactionResource::handler_POST(
        int64_t & businessId, SkipGoodsFeedbackReactionRequest & skipGoodsFeedbackReactionRequest)
{
    return handler_POST_func(businessId, skipGoodsFeedbackReactionRequest);
}


std::string BusinessesBusinessIdGoods_feedbackSkip_reactionResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackSkip_reactionResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_pricesUpdatesResource::BusinessesBusinessIdOffer_pricesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-prices/updates");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_pricesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_pricesUpdatesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_pricesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_pricesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_pricesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_pricesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_pricesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_pricesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateBusinessPricesRequest = extractJsonModelBodyParam<UpdateBusinessPricesRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updateBusinessPricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> BusinessesBusinessIdOffer_pricesUpdatesResource::handler_POST(
        int64_t & businessId, UpdateBusinessPricesRequest & updateBusinessPricesRequest)
{
    return handler_POST_func(businessId, updateBusinessPricesRequest);
}


std::string BusinessesBusinessIdOffer_pricesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_pricesUpdatesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffersUpdateResource::CampaignsCampaignIdOffersUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/update");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffersUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffersUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffersUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffersUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffersUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffersUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffersUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateCampaignOffersRequest = extractJsonModelBodyParam<UpdateCampaignOffersRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, updateCampaignOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOffersUpdateResource::handler_POST(
        int64_t & campaignId, UpdateCampaignOffersRequest & updateCampaignOffersRequest)
{
    return handler_POST_func(campaignId, updateCampaignOffersRequest);
}


std::string CampaignsCampaignIdOffersUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffersUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/update");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateGoodsFeedbackCommentRequest = extractJsonModelBodyParam<UpdateGoodsFeedbackCommentRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    UpdateGoodsFeedbackCommentResponse resultObject = UpdateGoodsFeedbackCommentResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updateGoodsFeedbackCommentRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdateGoodsFeedbackCommentResponse> BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::handler_POST(
        int64_t & businessId, UpdateGoodsFeedbackCommentRequest & updateGoodsFeedbackCommentRequest)
{
    return handler_POST_func(businessId, updateGoodsFeedbackCommentRequest);
}


std::string BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdGoods_feedbackCommentsUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_cardsUpdateResource::BusinessesBusinessIdOffer_cardsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-cards/update");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_cardsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_cardsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_cardsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_cardsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_cardsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_cardsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOfferContentRequest = extractJsonModelBodyParam<UpdateOfferContentRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    UpdateOfferContentResponse resultObject = UpdateOfferContentResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updateOfferContentRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdateOfferContentResponse> BusinessesBusinessIdOffer_cardsUpdateResource::handler_POST(
        int64_t & businessId, UpdateOfferContentRequest & updateOfferContentRequest)
{
    return handler_POST_func(businessId, updateOfferContentRequest);
}


std::string BusinessesBusinessIdOffer_cardsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_cardsUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/updates");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOfferMappingEntryRequest = extractJsonModelBodyParam<UpdateOfferMappingEntryRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, updateOfferMappingEntryRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::handler_POST(
        int64_t & campaignId, UpdateOfferMappingEntryRequest & updateOfferMappingEntryRequest)
{
    return handler_POST_func(campaignId, updateOfferMappingEntryRequest);
}


std::string CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_mapping_entriesUpdatesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdOffer_mappingsUpdateResource::BusinessesBusinessIdOffer_mappingsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/update");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdOffer_mappingsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdOffer_mappingsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdOffer_mappingsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdOffer_mappingsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdOffer_mappingsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdOffer_mappingsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updateOfferMappingsRequest = extractJsonModelBodyParam<UpdateOfferMappingsRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    UpdateOfferMappingsResponse resultObject = UpdateOfferMappingsResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updateOfferMappingsRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdateOfferMappingsResponse> BusinessesBusinessIdOffer_mappingsUpdateResource::handler_POST(
        int64_t & businessId, UpdateOfferMappingsRequest & updateOfferMappingsRequest)
{
    return handler_POST_func(businessId, updateOfferMappingsRequest);
}


std::string BusinessesBusinessIdOffer_mappingsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdOffer_mappingsUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
CampaignsCampaignIdOffer_pricesUpdatesResource::CampaignsCampaignIdOffer_pricesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/updates");
	this->set_method_handler("POST",
		std::bind(&CampaignsCampaignIdOffer_pricesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesUpdatesResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> CampaignsCampaignIdOffer_pricesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void CampaignsCampaignIdOffer_pricesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void CampaignsCampaignIdOffer_pricesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void CampaignsCampaignIdOffer_pricesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void CampaignsCampaignIdOffer_pricesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updatePricesRequest = extractJsonModelBodyParam<UpdatePricesRequest>(bodyContent);
    // Getting the path params
    int64_t campaignId = request->get_path_parameter("campaignId", 0L);
    
    int status_code = 500;
    EmptyApiResponse resultObject = EmptyApiResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, updatePricesRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 423) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "К ресурсу нельзя применить указанный метод.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 423, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, EmptyApiResponse> CampaignsCampaignIdOffer_pricesUpdatesResource::handler_POST(
        int64_t & campaignId, UpdatePricesRequest & updatePricesRequest)
{
    return handler_POST_func(campaignId, updatePricesRequest);
}


std::string CampaignsCampaignIdOffer_pricesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string CampaignsCampaignIdOffer_pricesUpdatesResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}
BusinessesBusinessIdPromosOffersUpdateResource::BusinessesBusinessIdPromosOffersUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/update");
	this->set_method_handler("POST",
		std::bind(&BusinessesBusinessIdPromosOffersUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersUpdateResource::handleFbyApiException(const FbyApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> BusinessesBusinessIdPromosOffersUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void BusinessesBusinessIdPromosOffersUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void BusinessesBusinessIdPromosOffersUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, std::multimap<std::string, std::string>& responseHeaders)
{
    responseHeaders.insert(std::make_pair("Connection", "close"));
    session->close(status, result, responseHeaders);
}

void BusinessesBusinessIdPromosOffersUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void BusinessesBusinessIdPromosOffersUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    // body params or form params here from the body content string
    std::string bodyContent = extractBodyContent(session);
    auto updatePromoOffersRequest = extractJsonModelBodyParam<UpdatePromoOffersRequest>(bodyContent);
    // Getting the path params
    int64_t businessId = request->get_path_parameter("businessId", 0L);
    
    int status_code = 500;
    UpdatePromoOffersResponse resultObject = UpdatePromoOffersResponse{};
    std::string result = "";
    
    try {
        std::tie(status_code, resultObject) =
            handler_POST(businessId, updatePromoOffersRequest);
    }
    catch(const FbyApiException& e) {
        std::tie(status_code, result) = handleFbyApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }
    
    std::multimap< std::string, std::string > responseHeaders {};
    static const std::vector<std::string> contentTypes{
        "application/json",
    };
    static const std::string acceptTypes{
        "application/json, "
    };
    
    if (status_code == 200) {
        responseHeaders.insert(std::make_pair("Content-Type", selectPreferredContentType(contentTypes)));
        if (!acceptTypes.empty()) {
            responseHeaders.insert(std::make_pair("Accept", acceptTypes));
        }
    
        result = resultObject.toJsonString();
        returnResponse(session, 200, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 400) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрос содержит неправильные данные.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 400, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 401) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "В запросе не указаны данные для авторизации.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 401, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 403) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Данные для авторизации неверны или доступ к ресурсу запрещен.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 403, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 404) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Запрашиваемый ресурс не найден.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 404, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 420) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Превышено ограничение на доступ к ресурсу.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 420, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    if (status_code == 500) {
        responseHeaders.insert(std::make_pair("Content-Type", "text/plain"));
        result = "Внутренняя ошибка сервера.";
    
        result = resultObject.toJsonString();
        returnResponse(session, 500, result.empty() ? "{}" : result, responseHeaders);
        return;
    }
    defaultSessionClose(session, status_code, result);
    
    
}


std::pair<int, UpdatePromoOffersResponse> BusinessesBusinessIdPromosOffersUpdateResource::handler_POST(
        int64_t & businessId, UpdatePromoOffersRequest & updatePromoOffersRequest)
{
    return handler_POST_func(businessId, updatePromoOffersRequest);
}


std::string BusinessesBusinessIdPromosOffersUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

std::string BusinessesBusinessIdPromosOffersUpdateResource::extractFormParamsFromBody(const std::string& paramName, const std::string& body) {
    const auto uri = restbed::Uri("urlencoded?" + body, true);
    const auto params = uri.get_query_parameters();
    const auto result = params.find(paramName);
    if (result != params.cend()) {
        return result->second;
    }
    return "";
}

} /* namespace FbyApiResources */

FbyApi::FbyApi(std::shared_ptr<restbed::Service> const& restbedService)
: m_service(restbedService)
{
}

FbyApi::~FbyApi() {}

std::shared_ptr<FbyApiResources::CampaignsCampaignIdHidden_offersResource> FbyApi::getCampaignsCampaignIdHidden_offersResource() {
    if (!m_spCampaignsCampaignIdHidden_offersResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdHidden_offersResource>());
    }
    return m_spCampaignsCampaignIdHidden_offersResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource> FbyApi::getBusinessesBusinessIdOffer_mappingsArchiveResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsArchiveResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsArchiveResource;
}
std::shared_ptr<FbyApiResources::TariffsCalculateResource> FbyApi::getTariffsCalculateResource() {
    if (!m_spTariffsCalculateResource) {
        setResource(std::make_shared<FbyApiResources::TariffsCalculateResource>());
    }
    return m_spTariffsCalculateResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource> FbyApi::getBusinessesBusinessIdPrice_quarantineConfirmResource() {
    if (!m_spBusinessesBusinessIdPrice_quarantineConfirmResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource>());
    }
    return m_spBusinessesBusinessIdPrice_quarantineConfirmResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource> FbyApi::getCampaignsCampaignIdPrice_quarantineConfirmResource() {
    if (!m_spCampaignsCampaignIdPrice_quarantineConfirmResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource>());
    }
    return m_spCampaignsCampaignIdPrice_quarantineConfirmResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsNewResource> FbyApi::getBusinessesBusinessIdChatsNewResource() {
    if (!m_spBusinessesBusinessIdChatsNewResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsNewResource>());
    }
    return m_spBusinessesBusinessIdChatsNewResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersDeleteResource> FbyApi::getCampaignsCampaignIdOffersDeleteResource() {
    if (!m_spCampaignsCampaignIdOffersDeleteResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersDeleteResource>());
    }
    return m_spCampaignsCampaignIdOffersDeleteResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource> FbyApi::getBusinessesBusinessIdGoods_feedbackCommentsDeleteResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdHidden_offersDeleteResource> FbyApi::getCampaignsCampaignIdHidden_offersDeleteResource() {
    if (!m_spCampaignsCampaignIdHidden_offersDeleteResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdHidden_offersDeleteResource>());
    }
    return m_spCampaignsCampaignIdHidden_offersDeleteResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource> FbyApi::getBusinessesBusinessIdOffer_mappingsDeleteResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsDeleteResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsDeleteResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource> FbyApi::getBusinessesBusinessIdOffer_mappingsUnarchiveResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosOffersDeleteResource> FbyApi::getBusinessesBusinessIdPromosOffersDeleteResource() {
    if (!m_spBusinessesBusinessIdPromosOffersDeleteResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPromosOffersDeleteResource>());
    }
    return m_spBusinessesBusinessIdPromosOffersDeleteResource;
}
std::shared_ptr<FbyApiResources::ReportsBoost_consolidatedGenerateResource> FbyApi::getReportsBoost_consolidatedGenerateResource() {
    if (!m_spReportsBoost_consolidatedGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsBoost_consolidatedGenerateResource>());
    }
    return m_spReportsBoost_consolidatedGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsCompetitors_positionGenerateResource> FbyApi::getReportsCompetitors_positionGenerateResource() {
    if (!m_spReportsCompetitors_positionGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsCompetitors_positionGenerateResource>());
    }
    return m_spReportsCompetitors_positionGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsGoods_feedbackGenerateResource> FbyApi::getReportsGoods_feedbackGenerateResource() {
    if (!m_spReportsGoods_feedbackGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsGoods_feedbackGenerateResource>());
    }
    return m_spReportsGoods_feedbackGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsGoods_movementGenerateResource> FbyApi::getReportsGoods_movementGenerateResource() {
    if (!m_spReportsGoods_movementGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsGoods_movementGenerateResource>());
    }
    return m_spReportsGoods_movementGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsGoods_realizationGenerateResource> FbyApi::getReportsGoods_realizationGenerateResource() {
    if (!m_spReportsGoods_realizationGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsGoods_realizationGenerateResource>());
    }
    return m_spReportsGoods_realizationGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsGoods_turnoverGenerateResource> FbyApi::getReportsGoods_turnoverGenerateResource() {
    if (!m_spReportsGoods_turnoverGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsGoods_turnoverGenerateResource>());
    }
    return m_spReportsGoods_turnoverGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsPricesGenerateResource> FbyApi::getReportsPricesGenerateResource() {
    if (!m_spReportsPricesGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsPricesGenerateResource>());
    }
    return m_spReportsPricesGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsShelf_statisticsGenerateResource> FbyApi::getReportsShelf_statisticsGenerateResource() {
    if (!m_spReportsShelf_statisticsGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsShelf_statisticsGenerateResource>());
    }
    return m_spReportsShelf_statisticsGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsShows_salesGenerateResource> FbyApi::getReportsShows_salesGenerateResource() {
    if (!m_spReportsShows_salesGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsShows_salesGenerateResource>());
    }
    return m_spReportsShows_salesGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsStocks_on_warehousesGenerateResource> FbyApi::getReportsStocks_on_warehousesGenerateResource() {
    if (!m_spReportsStocks_on_warehousesGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsStocks_on_warehousesGenerateResource>());
    }
    return m_spReportsStocks_on_warehousesGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsUnited_marketplace_servicesGenerateResource> FbyApi::getReportsUnited_marketplace_servicesGenerateResource() {
    if (!m_spReportsUnited_marketplace_servicesGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsUnited_marketplace_servicesGenerateResource>());
    }
    return m_spReportsUnited_marketplace_servicesGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsUnited_nettingGenerateResource> FbyApi::getReportsUnited_nettingGenerateResource() {
    if (!m_spReportsUnited_nettingGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsUnited_nettingGenerateResource>());
    }
    return m_spReportsUnited_nettingGenerateResource;
}
std::shared_ptr<FbyApiResources::ReportsUnited_ordersGenerateResource> FbyApi::getReportsUnited_ordersGenerateResource() {
    if (!m_spReportsUnited_ordersGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsUnited_ordersGenerateResource>());
    }
    return m_spReportsUnited_ordersGenerateResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersAllResource> FbyApi::getCampaignsCampaignIdOffersAllResource() {
    if (!m_spCampaignsCampaignIdOffersAllResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersAllResource>());
    }
    return m_spCampaignsCampaignIdOffersAllResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdBidsInfoResource> FbyApi::getBusinessesBusinessIdBidsInfoResource() {
    if (!m_spBusinessesBusinessIdBidsInfoResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdBidsInfoResource>());
    }
    return m_spBusinessesBusinessIdBidsInfoResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdBidsRecommendationsResource> FbyApi::getBusinessesBusinessIdBidsRecommendationsResource() {
    if (!m_spBusinessesBusinessIdBidsRecommendationsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdBidsRecommendationsResource>());
    }
    return m_spBusinessesBusinessIdBidsRecommendationsResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdPrice_quarantineResource> FbyApi::getBusinessesBusinessIdPrice_quarantineResource() {
    if (!m_spBusinessesBusinessIdPrice_quarantineResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPrice_quarantineResource>());
    }
    return m_spBusinessesBusinessIdPrice_quarantineResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdSettingsResource> FbyApi::getBusinessesBusinessIdSettingsResource() {
    if (!m_spBusinessesBusinessIdSettingsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdSettingsResource>());
    }
    return m_spBusinessesBusinessIdSettingsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdResource> FbyApi::getCampaignsCampaignIdResource() {
    if (!m_spCampaignsCampaignIdResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdResource>());
    }
    return m_spCampaignsCampaignIdResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdLoginsResource> FbyApi::getCampaignsCampaignIdLoginsResource() {
    if (!m_spCampaignsCampaignIdLoginsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdLoginsResource>());
    }
    return m_spCampaignsCampaignIdLoginsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersResource> FbyApi::getCampaignsCampaignIdOffersResource() {
    if (!m_spCampaignsCampaignIdOffersResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersResource>());
    }
    return m_spCampaignsCampaignIdOffersResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdPrice_quarantineResource> FbyApi::getCampaignsCampaignIdPrice_quarantineResource() {
    if (!m_spCampaignsCampaignIdPrice_quarantineResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdPrice_quarantineResource>());
    }
    return m_spCampaignsCampaignIdPrice_quarantineResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdRegionResource> FbyApi::getCampaignsCampaignIdRegionResource() {
    if (!m_spCampaignsCampaignIdRegionResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdRegionResource>());
    }
    return m_spCampaignsCampaignIdRegionResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdSettingsResource> FbyApi::getCampaignsCampaignIdSettingsResource() {
    if (!m_spCampaignsCampaignIdSettingsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdSettingsResource>());
    }
    return m_spCampaignsCampaignIdSettingsResource;
}
std::shared_ptr<FbyApiResources::CampaignsResource> FbyApi::getCampaignsResource() {
    if (!m_spCampaignsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsResource>());
    }
    return m_spCampaignsResource;
}
std::shared_ptr<FbyApiResources::CampaignsBy_loginLoginResource> FbyApi::getCampaignsBy_loginLoginResource() {
    if (!m_spCampaignsBy_loginLoginResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsBy_loginLoginResource>());
    }
    return m_spCampaignsBy_loginLoginResource;
}
std::shared_ptr<FbyApiResources::CategoriesMax_sale_quantumResource> FbyApi::getCategoriesMax_sale_quantumResource() {
    if (!m_spCategoriesMax_sale_quantumResource) {
        setResource(std::make_shared<FbyApiResources::CategoriesMax_sale_quantumResource>());
    }
    return m_spCategoriesMax_sale_quantumResource;
}
std::shared_ptr<FbyApiResources::CategoriesTreeResource> FbyApi::getCategoriesTreeResource() {
    if (!m_spCategoriesTreeResource) {
        setResource(std::make_shared<FbyApiResources::CategoriesTreeResource>());
    }
    return m_spCategoriesTreeResource;
}
std::shared_ptr<FbyApiResources::CategoryCategoryIdParametersResource> FbyApi::getCategoryCategoryIdParametersResource() {
    if (!m_spCategoryCategoryIdParametersResource) {
        setResource(std::make_shared<FbyApiResources::CategoryCategoryIdParametersResource>());
    }
    return m_spCategoryCategoryIdParametersResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsHistoryResource> FbyApi::getBusinessesBusinessIdChatsHistoryResource() {
    if (!m_spBusinessesBusinessIdChatsHistoryResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsHistoryResource>());
    }
    return m_spBusinessesBusinessIdChatsHistoryResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsResource> FbyApi::getBusinessesBusinessIdChatsResource() {
    if (!m_spBusinessesBusinessIdChatsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsResource>());
    }
    return m_spBusinessesBusinessIdChatsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdResource> FbyApi::getCampaignsCampaignIdFeedsFeedIdResource() {
    if (!m_spCampaignsCampaignIdFeedsFeedIdResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsFeedIdResource>());
    }
    return m_spCampaignsCampaignIdFeedsFeedIdResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource> FbyApi::getCampaignsCampaignIdFeedsFeedIdIndex_logsResource() {
    if (!m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource>());
    }
    return m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedbackUpdatesResource> FbyApi::getCampaignsCampaignIdFeedbackUpdatesResource() {
    if (!m_spCampaignsCampaignIdFeedbackUpdatesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedbackUpdatesResource>());
    }
    return m_spCampaignsCampaignIdFeedbackUpdatesResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsResource> FbyApi::getCampaignsCampaignIdFeedsResource() {
    if (!m_spCampaignsCampaignIdFeedsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsResource>());
    }
    return m_spCampaignsCampaignIdFeedsResource;
}
std::shared_ptr<FbyApiResources::WarehousesResource> FbyApi::getWarehousesResource() {
    if (!m_spWarehousesResource) {
        setResource(std::make_shared<FbyApiResources::WarehousesResource>());
    }
    return m_spWarehousesResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource> FbyApi::getBusinessesBusinessIdGoods_feedbackCommentsResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackCommentsResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackResource> FbyApi::getBusinessesBusinessIdGoods_feedbackResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdStatsSkusResource> FbyApi::getCampaignsCampaignIdStatsSkusResource() {
    if (!m_spCampaignsCampaignIdStatsSkusResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdStatsSkusResource>());
    }
    return m_spCampaignsCampaignIdStatsSkusResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_cardsResource> FbyApi::getBusinessesBusinessIdOffer_cardsResource() {
    if (!m_spBusinessesBusinessIdOffer_cardsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_cardsResource>());
    }
    return m_spBusinessesBusinessIdOffer_cardsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesResource> FbyApi::getCampaignsCampaignIdOffer_mapping_entriesResource() {
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesResource>());
    }
    return m_spCampaignsCampaignIdOffer_mapping_entriesResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsResource> FbyApi::getBusinessesBusinessIdOffer_mappingsResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffersRecommendationsResource> FbyApi::getBusinessesBusinessIdOffersRecommendationsResource() {
    if (!m_spBusinessesBusinessIdOffersRecommendationsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffersRecommendationsResource>());
    }
    return m_spBusinessesBusinessIdOffersRecommendationsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdResource> FbyApi::getCampaignsCampaignIdOrdersOrderIdResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource> FbyApi::getCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource> FbyApi::getCampaignsCampaignIdOrdersOrderIdDocumentsResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersResource> FbyApi::getCampaignsCampaignIdOrdersResource() {
    if (!m_spCampaignsCampaignIdOrdersResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersResource>());
    }
    return m_spCampaignsCampaignIdOrdersResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdStatsOrdersResource> FbyApi::getCampaignsCampaignIdStatsOrdersResource() {
    if (!m_spCampaignsCampaignIdStatsOrdersResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdStatsOrdersResource>());
    }
    return m_spCampaignsCampaignIdStatsOrdersResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_pricesResource> FbyApi::getCampaignsCampaignIdOffer_pricesResource() {
    if (!m_spCampaignsCampaignIdOffer_pricesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_pricesResource>());
    }
    return m_spCampaignsCampaignIdOffer_pricesResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosOffersResource> FbyApi::getBusinessesBusinessIdPromosOffersResource() {
    if (!m_spBusinessesBusinessIdPromosOffersResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPromosOffersResource>());
    }
    return m_spBusinessesBusinessIdPromosOffersResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosResource> FbyApi::getBusinessesBusinessIdPromosResource() {
    if (!m_spBusinessesBusinessIdPromosResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPromosResource>());
    }
    return m_spBusinessesBusinessIdPromosResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdRatingsQualityResource> FbyApi::getBusinessesBusinessIdRatingsQualityResource() {
    if (!m_spBusinessesBusinessIdRatingsQualityResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdRatingsQualityResource>());
    }
    return m_spBusinessesBusinessIdRatingsQualityResource;
}
std::shared_ptr<FbyApiResources::ReportsInfoReportIdResource> FbyApi::getReportsInfoReportIdResource() {
    if (!m_spReportsInfoReportIdResource) {
        setResource(std::make_shared<FbyApiResources::ReportsInfoReportIdResource>());
    }
    return m_spReportsInfoReportIdResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource> FbyApi::getCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource> FbyApi::getCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource() {
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource>());
    }
    return m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdReturnsResource> FbyApi::getCampaignsCampaignIdReturnsResource() {
    if (!m_spCampaignsCampaignIdReturnsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdReturnsResource>());
    }
    return m_spCampaignsCampaignIdReturnsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersStocksResource> FbyApi::getCampaignsCampaignIdOffersStocksResource() {
    if (!m_spCampaignsCampaignIdOffersStocksResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersStocksResource>());
    }
    return m_spCampaignsCampaignIdOffersStocksResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource> FbyApi::getCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource() {
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource>());
    }
    return m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource> FbyApi::getBusinessesBusinessIdOffer_mappingsSuggestionsResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource> FbyApi::getCampaignsCampaignIdOffer_pricesSuggestionsResource() {
    if (!m_spCampaignsCampaignIdOffer_pricesSuggestionsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource>());
    }
    return m_spCampaignsCampaignIdOffer_pricesSuggestionsResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdBidsResource> FbyApi::getBusinessesBusinessIdBidsResource() {
    if (!m_spBusinessesBusinessIdBidsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdBidsResource>());
    }
    return m_spBusinessesBusinessIdBidsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdBidsResource> FbyApi::getCampaignsCampaignIdBidsResource() {
    if (!m_spCampaignsCampaignIdBidsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdBidsResource>());
    }
    return m_spCampaignsCampaignIdBidsResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource> FbyApi::getCampaignsCampaignIdFeedsFeedIdRefreshResource() {
    if (!m_spCampaignsCampaignIdFeedsFeedIdRefreshResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource>());
    }
    return m_spCampaignsCampaignIdFeedsFeedIdRefreshResource;
}
std::shared_ptr<FbyApiResources::RegionsRegionIdChildrenResource> FbyApi::getRegionsRegionIdChildrenResource() {
    if (!m_spRegionsRegionIdChildrenResource) {
        setResource(std::make_shared<FbyApiResources::RegionsRegionIdChildrenResource>());
    }
    return m_spRegionsRegionIdChildrenResource;
}
std::shared_ptr<FbyApiResources::RegionsRegionIdResource> FbyApi::getRegionsRegionIdResource() {
    if (!m_spRegionsRegionIdResource) {
        setResource(std::make_shared<FbyApiResources::RegionsRegionIdResource>());
    }
    return m_spRegionsRegionIdResource;
}
std::shared_ptr<FbyApiResources::RegionsResource> FbyApi::getRegionsResource() {
    if (!m_spRegionsResource) {
        setResource(std::make_shared<FbyApiResources::RegionsResource>());
    }
    return m_spRegionsResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsFileSendResource> FbyApi::getBusinessesBusinessIdChatsFileSendResource() {
    if (!m_spBusinessesBusinessIdChatsFileSendResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsFileSendResource>());
    }
    return m_spBusinessesBusinessIdChatsFileSendResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsMessageResource> FbyApi::getBusinessesBusinessIdChatsMessageResource() {
    if (!m_spBusinessesBusinessIdChatsMessageResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsMessageResource>());
    }
    return m_spBusinessesBusinessIdChatsMessageResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource> FbyApi::getCampaignsCampaignIdFeedsFeedIdParamsResource() {
    if (!m_spCampaignsCampaignIdFeedsFeedIdParamsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource>());
    }
    return m_spCampaignsCampaignIdFeedsFeedIdParamsResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource> FbyApi::getBusinessesBusinessIdGoods_feedbackSkip_reactionResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource> FbyApi::getBusinessesBusinessIdOffer_pricesUpdatesResource() {
    if (!m_spBusinessesBusinessIdOffer_pricesUpdatesResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource>());
    }
    return m_spBusinessesBusinessIdOffer_pricesUpdatesResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersUpdateResource> FbyApi::getCampaignsCampaignIdOffersUpdateResource() {
    if (!m_spCampaignsCampaignIdOffersUpdateResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersUpdateResource>());
    }
    return m_spCampaignsCampaignIdOffersUpdateResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource> FbyApi::getBusinessesBusinessIdGoods_feedbackCommentsUpdateResource() {
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource>());
    }
    return m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_cardsUpdateResource> FbyApi::getBusinessesBusinessIdOffer_cardsUpdateResource() {
    if (!m_spBusinessesBusinessIdOffer_cardsUpdateResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_cardsUpdateResource>());
    }
    return m_spBusinessesBusinessIdOffer_cardsUpdateResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource> FbyApi::getCampaignsCampaignIdOffer_mapping_entriesUpdatesResource() {
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource>());
    }
    return m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource> FbyApi::getBusinessesBusinessIdOffer_mappingsUpdateResource() {
    if (!m_spBusinessesBusinessIdOffer_mappingsUpdateResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource>());
    }
    return m_spBusinessesBusinessIdOffer_mappingsUpdateResource;
}
std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource> FbyApi::getCampaignsCampaignIdOffer_pricesUpdatesResource() {
    if (!m_spCampaignsCampaignIdOffer_pricesUpdatesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource>());
    }
    return m_spCampaignsCampaignIdOffer_pricesUpdatesResource;
}
std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosOffersUpdateResource> FbyApi::getBusinessesBusinessIdPromosOffersUpdateResource() {
    if (!m_spBusinessesBusinessIdPromosOffersUpdateResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPromosOffersUpdateResource>());
    }
    return m_spBusinessesBusinessIdPromosOffersUpdateResource;
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdHidden_offersResource> resource) {
    m_spCampaignsCampaignIdHidden_offersResource = resource;
    m_service->publish(m_spCampaignsCampaignIdHidden_offersResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsArchiveResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsArchiveResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::TariffsCalculateResource> resource) {
    m_spTariffsCalculateResource = resource;
    m_service->publish(m_spTariffsCalculateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource> resource) {
    m_spBusinessesBusinessIdPrice_quarantineConfirmResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPrice_quarantineConfirmResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource> resource) {
    m_spCampaignsCampaignIdPrice_quarantineConfirmResource = resource;
    m_service->publish(m_spCampaignsCampaignIdPrice_quarantineConfirmResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsNewResource> resource) {
    m_spBusinessesBusinessIdChatsNewResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsNewResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersDeleteResource> resource) {
    m_spCampaignsCampaignIdOffersDeleteResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersDeleteResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdHidden_offersDeleteResource> resource) {
    m_spCampaignsCampaignIdHidden_offersDeleteResource = resource;
    m_service->publish(m_spCampaignsCampaignIdHidden_offersDeleteResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsDeleteResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsDeleteResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosOffersDeleteResource> resource) {
    m_spBusinessesBusinessIdPromosOffersDeleteResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersDeleteResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsBoost_consolidatedGenerateResource> resource) {
    m_spReportsBoost_consolidatedGenerateResource = resource;
    m_service->publish(m_spReportsBoost_consolidatedGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsCompetitors_positionGenerateResource> resource) {
    m_spReportsCompetitors_positionGenerateResource = resource;
    m_service->publish(m_spReportsCompetitors_positionGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsGoods_feedbackGenerateResource> resource) {
    m_spReportsGoods_feedbackGenerateResource = resource;
    m_service->publish(m_spReportsGoods_feedbackGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsGoods_movementGenerateResource> resource) {
    m_spReportsGoods_movementGenerateResource = resource;
    m_service->publish(m_spReportsGoods_movementGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsGoods_realizationGenerateResource> resource) {
    m_spReportsGoods_realizationGenerateResource = resource;
    m_service->publish(m_spReportsGoods_realizationGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsGoods_turnoverGenerateResource> resource) {
    m_spReportsGoods_turnoverGenerateResource = resource;
    m_service->publish(m_spReportsGoods_turnoverGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsPricesGenerateResource> resource) {
    m_spReportsPricesGenerateResource = resource;
    m_service->publish(m_spReportsPricesGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsShelf_statisticsGenerateResource> resource) {
    m_spReportsShelf_statisticsGenerateResource = resource;
    m_service->publish(m_spReportsShelf_statisticsGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsShows_salesGenerateResource> resource) {
    m_spReportsShows_salesGenerateResource = resource;
    m_service->publish(m_spReportsShows_salesGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsStocks_on_warehousesGenerateResource> resource) {
    m_spReportsStocks_on_warehousesGenerateResource = resource;
    m_service->publish(m_spReportsStocks_on_warehousesGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsUnited_marketplace_servicesGenerateResource> resource) {
    m_spReportsUnited_marketplace_servicesGenerateResource = resource;
    m_service->publish(m_spReportsUnited_marketplace_servicesGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsUnited_nettingGenerateResource> resource) {
    m_spReportsUnited_nettingGenerateResource = resource;
    m_service->publish(m_spReportsUnited_nettingGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsUnited_ordersGenerateResource> resource) {
    m_spReportsUnited_ordersGenerateResource = resource;
    m_service->publish(m_spReportsUnited_ordersGenerateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersAllResource> resource) {
    m_spCampaignsCampaignIdOffersAllResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersAllResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdBidsInfoResource> resource) {
    m_spBusinessesBusinessIdBidsInfoResource = resource;
    m_service->publish(m_spBusinessesBusinessIdBidsInfoResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdBidsRecommendationsResource> resource) {
    m_spBusinessesBusinessIdBidsRecommendationsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdBidsRecommendationsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPrice_quarantineResource> resource) {
    m_spBusinessesBusinessIdPrice_quarantineResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPrice_quarantineResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdSettingsResource> resource) {
    m_spBusinessesBusinessIdSettingsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdSettingsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdResource> resource) {
    m_spCampaignsCampaignIdResource = resource;
    m_service->publish(m_spCampaignsCampaignIdResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdLoginsResource> resource) {
    m_spCampaignsCampaignIdLoginsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdLoginsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersResource> resource) {
    m_spCampaignsCampaignIdOffersResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdPrice_quarantineResource> resource) {
    m_spCampaignsCampaignIdPrice_quarantineResource = resource;
    m_service->publish(m_spCampaignsCampaignIdPrice_quarantineResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdRegionResource> resource) {
    m_spCampaignsCampaignIdRegionResource = resource;
    m_service->publish(m_spCampaignsCampaignIdRegionResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdSettingsResource> resource) {
    m_spCampaignsCampaignIdSettingsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdSettingsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsResource> resource) {
    m_spCampaignsResource = resource;
    m_service->publish(m_spCampaignsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsBy_loginLoginResource> resource) {
    m_spCampaignsBy_loginLoginResource = resource;
    m_service->publish(m_spCampaignsBy_loginLoginResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CategoriesMax_sale_quantumResource> resource) {
    m_spCategoriesMax_sale_quantumResource = resource;
    m_service->publish(m_spCategoriesMax_sale_quantumResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CategoriesTreeResource> resource) {
    m_spCategoriesTreeResource = resource;
    m_service->publish(m_spCategoriesTreeResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CategoryCategoryIdParametersResource> resource) {
    m_spCategoryCategoryIdParametersResource = resource;
    m_service->publish(m_spCategoryCategoryIdParametersResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsHistoryResource> resource) {
    m_spBusinessesBusinessIdChatsHistoryResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsHistoryResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsResource> resource) {
    m_spBusinessesBusinessIdChatsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdResource> resource) {
    m_spCampaignsCampaignIdFeedsFeedIdResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource> resource) {
    m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedbackUpdatesResource> resource) {
    m_spCampaignsCampaignIdFeedbackUpdatesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedbackUpdatesResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsResource> resource) {
    m_spCampaignsCampaignIdFeedsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::WarehousesResource> resource) {
    m_spWarehousesResource = resource;
    m_service->publish(m_spWarehousesResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdStatsSkusResource> resource) {
    m_spCampaignsCampaignIdStatsSkusResource = resource;
    m_service->publish(m_spCampaignsCampaignIdStatsSkusResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_cardsResource> resource) {
    m_spBusinessesBusinessIdOffer_cardsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_cardsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesResource> resource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffersRecommendationsResource> resource) {
    m_spBusinessesBusinessIdOffersRecommendationsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffersRecommendationsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersResource> resource) {
    m_spCampaignsCampaignIdOrdersResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdStatsOrdersResource> resource) {
    m_spCampaignsCampaignIdStatsOrdersResource = resource;
    m_service->publish(m_spCampaignsCampaignIdStatsOrdersResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_pricesResource> resource) {
    m_spCampaignsCampaignIdOffer_pricesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosOffersResource> resource) {
    m_spBusinessesBusinessIdPromosOffersResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosResource> resource) {
    m_spBusinessesBusinessIdPromosResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPromosResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdRatingsQualityResource> resource) {
    m_spBusinessesBusinessIdRatingsQualityResource = resource;
    m_service->publish(m_spBusinessesBusinessIdRatingsQualityResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::ReportsInfoReportIdResource> resource) {
    m_spReportsInfoReportIdResource = resource;
    m_service->publish(m_spReportsInfoReportIdResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource> resource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdReturnsResource> resource) {
    m_spCampaignsCampaignIdReturnsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdReturnsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersStocksResource> resource) {
    m_spCampaignsCampaignIdOffersStocksResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersStocksResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource> resource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource> resource) {
    m_spCampaignsCampaignIdOffer_pricesSuggestionsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesSuggestionsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdBidsResource> resource) {
    m_spBusinessesBusinessIdBidsResource = resource;
    m_service->publish(m_spBusinessesBusinessIdBidsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdBidsResource> resource) {
    m_spCampaignsCampaignIdBidsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdBidsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource> resource) {
    m_spCampaignsCampaignIdFeedsFeedIdRefreshResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdRefreshResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::RegionsRegionIdChildrenResource> resource) {
    m_spRegionsRegionIdChildrenResource = resource;
    m_service->publish(m_spRegionsRegionIdChildrenResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::RegionsRegionIdResource> resource) {
    m_spRegionsRegionIdResource = resource;
    m_service->publish(m_spRegionsRegionIdResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::RegionsResource> resource) {
    m_spRegionsResource = resource;
    m_service->publish(m_spRegionsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsFileSendResource> resource) {
    m_spBusinessesBusinessIdChatsFileSendResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsFileSendResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsMessageResource> resource) {
    m_spBusinessesBusinessIdChatsMessageResource = resource;
    m_service->publish(m_spBusinessesBusinessIdChatsMessageResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource> resource) {
    m_spCampaignsCampaignIdFeedsFeedIdParamsResource = resource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdParamsResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource> resource) {
    m_spBusinessesBusinessIdOffer_pricesUpdatesResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_pricesUpdatesResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersUpdateResource> resource) {
    m_spCampaignsCampaignIdOffersUpdateResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffersUpdateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource> resource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource = resource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_cardsUpdateResource> resource) {
    m_spBusinessesBusinessIdOffer_cardsUpdateResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_cardsUpdateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource> resource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource> resource) {
    m_spBusinessesBusinessIdOffer_mappingsUpdateResource = resource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsUpdateResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource> resource) {
    m_spCampaignsCampaignIdOffer_pricesUpdatesResource = resource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesUpdatesResource);
}
void FbyApi::setResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosOffersUpdateResource> resource) {
    m_spBusinessesBusinessIdPromosOffersUpdateResource = resource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersUpdateResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdHidden_offersResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdHidden_offersResource> spCampaignsCampaignIdHidden_offersResource) {
    m_spCampaignsCampaignIdHidden_offersResource = spCampaignsCampaignIdHidden_offersResource;
    m_service->publish(m_spCampaignsCampaignIdHidden_offersResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer_mappingsArchiveResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource> spBusinessesBusinessIdOffer_mappingsArchiveResource) {
    m_spBusinessesBusinessIdOffer_mappingsArchiveResource = spBusinessesBusinessIdOffer_mappingsArchiveResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsArchiveResource);
}
void FbyApi::setFbyApiTariffsCalculateResource(std::shared_ptr<FbyApiResources::TariffsCalculateResource> spTariffsCalculateResource) {
    m_spTariffsCalculateResource = spTariffsCalculateResource;
    m_service->publish(m_spTariffsCalculateResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPrice_quarantineConfirmResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource> spBusinessesBusinessIdPrice_quarantineConfirmResource) {
    m_spBusinessesBusinessIdPrice_quarantineConfirmResource = spBusinessesBusinessIdPrice_quarantineConfirmResource;
    m_service->publish(m_spBusinessesBusinessIdPrice_quarantineConfirmResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdPrice_quarantineConfirmResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource> spCampaignsCampaignIdPrice_quarantineConfirmResource) {
    m_spCampaignsCampaignIdPrice_quarantineConfirmResource = spCampaignsCampaignIdPrice_quarantineConfirmResource;
    m_service->publish(m_spCampaignsCampaignIdPrice_quarantineConfirmResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsNewResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsNewResource> spBusinessesBusinessIdChatsNewResource) {
    m_spBusinessesBusinessIdChatsNewResource = spBusinessesBusinessIdChatsNewResource;
    m_service->publish(m_spBusinessesBusinessIdChatsNewResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersDeleteResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersDeleteResource> spCampaignsCampaignIdOffersDeleteResource) {
    m_spCampaignsCampaignIdOffersDeleteResource = spCampaignsCampaignIdOffersDeleteResource;
    m_service->publish(m_spCampaignsCampaignIdOffersDeleteResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods_feedbackCommentsDeleteResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource> spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource = spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdHidden_offersDeleteResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdHidden_offersDeleteResource> spCampaignsCampaignIdHidden_offersDeleteResource) {
    m_spCampaignsCampaignIdHidden_offersDeleteResource = spCampaignsCampaignIdHidden_offersDeleteResource;
    m_service->publish(m_spCampaignsCampaignIdHidden_offersDeleteResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer_mappingsDeleteResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource> spBusinessesBusinessIdOffer_mappingsDeleteResource) {
    m_spBusinessesBusinessIdOffer_mappingsDeleteResource = spBusinessesBusinessIdOffer_mappingsDeleteResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsDeleteResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer_mappingsUnarchiveResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource> spBusinessesBusinessIdOffer_mappingsUnarchiveResource) {
    m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource = spBusinessesBusinessIdOffer_mappingsUnarchiveResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPromosOffersDeleteResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosOffersDeleteResource> spBusinessesBusinessIdPromosOffersDeleteResource) {
    m_spBusinessesBusinessIdPromosOffersDeleteResource = spBusinessesBusinessIdPromosOffersDeleteResource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersDeleteResource);
}
void FbyApi::setFbyApiReportsBoost_consolidatedGenerateResource(std::shared_ptr<FbyApiResources::ReportsBoost_consolidatedGenerateResource> spReportsBoost_consolidatedGenerateResource) {
    m_spReportsBoost_consolidatedGenerateResource = spReportsBoost_consolidatedGenerateResource;
    m_service->publish(m_spReportsBoost_consolidatedGenerateResource);
}
void FbyApi::setFbyApiReportsCompetitors_positionGenerateResource(std::shared_ptr<FbyApiResources::ReportsCompetitors_positionGenerateResource> spReportsCompetitors_positionGenerateResource) {
    m_spReportsCompetitors_positionGenerateResource = spReportsCompetitors_positionGenerateResource;
    m_service->publish(m_spReportsCompetitors_positionGenerateResource);
}
void FbyApi::setFbyApiReportsGoods_feedbackGenerateResource(std::shared_ptr<FbyApiResources::ReportsGoods_feedbackGenerateResource> spReportsGoods_feedbackGenerateResource) {
    m_spReportsGoods_feedbackGenerateResource = spReportsGoods_feedbackGenerateResource;
    m_service->publish(m_spReportsGoods_feedbackGenerateResource);
}
void FbyApi::setFbyApiReportsGoods_movementGenerateResource(std::shared_ptr<FbyApiResources::ReportsGoods_movementGenerateResource> spReportsGoods_movementGenerateResource) {
    m_spReportsGoods_movementGenerateResource = spReportsGoods_movementGenerateResource;
    m_service->publish(m_spReportsGoods_movementGenerateResource);
}
void FbyApi::setFbyApiReportsGoods_realizationGenerateResource(std::shared_ptr<FbyApiResources::ReportsGoods_realizationGenerateResource> spReportsGoods_realizationGenerateResource) {
    m_spReportsGoods_realizationGenerateResource = spReportsGoods_realizationGenerateResource;
    m_service->publish(m_spReportsGoods_realizationGenerateResource);
}
void FbyApi::setFbyApiReportsGoods_turnoverGenerateResource(std::shared_ptr<FbyApiResources::ReportsGoods_turnoverGenerateResource> spReportsGoods_turnoverGenerateResource) {
    m_spReportsGoods_turnoverGenerateResource = spReportsGoods_turnoverGenerateResource;
    m_service->publish(m_spReportsGoods_turnoverGenerateResource);
}
void FbyApi::setFbyApiReportsPricesGenerateResource(std::shared_ptr<FbyApiResources::ReportsPricesGenerateResource> spReportsPricesGenerateResource) {
    m_spReportsPricesGenerateResource = spReportsPricesGenerateResource;
    m_service->publish(m_spReportsPricesGenerateResource);
}
void FbyApi::setFbyApiReportsShelf_statisticsGenerateResource(std::shared_ptr<FbyApiResources::ReportsShelf_statisticsGenerateResource> spReportsShelf_statisticsGenerateResource) {
    m_spReportsShelf_statisticsGenerateResource = spReportsShelf_statisticsGenerateResource;
    m_service->publish(m_spReportsShelf_statisticsGenerateResource);
}
void FbyApi::setFbyApiReportsShows_salesGenerateResource(std::shared_ptr<FbyApiResources::ReportsShows_salesGenerateResource> spReportsShows_salesGenerateResource) {
    m_spReportsShows_salesGenerateResource = spReportsShows_salesGenerateResource;
    m_service->publish(m_spReportsShows_salesGenerateResource);
}
void FbyApi::setFbyApiReportsStocks_on_warehousesGenerateResource(std::shared_ptr<FbyApiResources::ReportsStocks_on_warehousesGenerateResource> spReportsStocks_on_warehousesGenerateResource) {
    m_spReportsStocks_on_warehousesGenerateResource = spReportsStocks_on_warehousesGenerateResource;
    m_service->publish(m_spReportsStocks_on_warehousesGenerateResource);
}
void FbyApi::setFbyApiReportsUnited_marketplace_servicesGenerateResource(std::shared_ptr<FbyApiResources::ReportsUnited_marketplace_servicesGenerateResource> spReportsUnited_marketplace_servicesGenerateResource) {
    m_spReportsUnited_marketplace_servicesGenerateResource = spReportsUnited_marketplace_servicesGenerateResource;
    m_service->publish(m_spReportsUnited_marketplace_servicesGenerateResource);
}
void FbyApi::setFbyApiReportsUnited_nettingGenerateResource(std::shared_ptr<FbyApiResources::ReportsUnited_nettingGenerateResource> spReportsUnited_nettingGenerateResource) {
    m_spReportsUnited_nettingGenerateResource = spReportsUnited_nettingGenerateResource;
    m_service->publish(m_spReportsUnited_nettingGenerateResource);
}
void FbyApi::setFbyApiReportsUnited_ordersGenerateResource(std::shared_ptr<FbyApiResources::ReportsUnited_ordersGenerateResource> spReportsUnited_ordersGenerateResource) {
    m_spReportsUnited_ordersGenerateResource = spReportsUnited_ordersGenerateResource;
    m_service->publish(m_spReportsUnited_ordersGenerateResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersAllResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersAllResource> spCampaignsCampaignIdOffersAllResource) {
    m_spCampaignsCampaignIdOffersAllResource = spCampaignsCampaignIdOffersAllResource;
    m_service->publish(m_spCampaignsCampaignIdOffersAllResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdBidsInfoResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdBidsInfoResource> spBusinessesBusinessIdBidsInfoResource) {
    m_spBusinessesBusinessIdBidsInfoResource = spBusinessesBusinessIdBidsInfoResource;
    m_service->publish(m_spBusinessesBusinessIdBidsInfoResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdBidsRecommendationsResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdBidsRecommendationsResource> spBusinessesBusinessIdBidsRecommendationsResource) {
    m_spBusinessesBusinessIdBidsRecommendationsResource = spBusinessesBusinessIdBidsRecommendationsResource;
    m_service->publish(m_spBusinessesBusinessIdBidsRecommendationsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPrice_quarantineResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPrice_quarantineResource> spBusinessesBusinessIdPrice_quarantineResource) {
    m_spBusinessesBusinessIdPrice_quarantineResource = spBusinessesBusinessIdPrice_quarantineResource;
    m_service->publish(m_spBusinessesBusinessIdPrice_quarantineResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdSettingsResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdSettingsResource> spBusinessesBusinessIdSettingsResource) {
    m_spBusinessesBusinessIdSettingsResource = spBusinessesBusinessIdSettingsResource;
    m_service->publish(m_spBusinessesBusinessIdSettingsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdResource> spCampaignsCampaignIdResource) {
    m_spCampaignsCampaignIdResource = spCampaignsCampaignIdResource;
    m_service->publish(m_spCampaignsCampaignIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdLoginsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdLoginsResource> spCampaignsCampaignIdLoginsResource) {
    m_spCampaignsCampaignIdLoginsResource = spCampaignsCampaignIdLoginsResource;
    m_service->publish(m_spCampaignsCampaignIdLoginsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersResource> spCampaignsCampaignIdOffersResource) {
    m_spCampaignsCampaignIdOffersResource = spCampaignsCampaignIdOffersResource;
    m_service->publish(m_spCampaignsCampaignIdOffersResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdPrice_quarantineResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdPrice_quarantineResource> spCampaignsCampaignIdPrice_quarantineResource) {
    m_spCampaignsCampaignIdPrice_quarantineResource = spCampaignsCampaignIdPrice_quarantineResource;
    m_service->publish(m_spCampaignsCampaignIdPrice_quarantineResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdRegionResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdRegionResource> spCampaignsCampaignIdRegionResource) {
    m_spCampaignsCampaignIdRegionResource = spCampaignsCampaignIdRegionResource;
    m_service->publish(m_spCampaignsCampaignIdRegionResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdSettingsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdSettingsResource> spCampaignsCampaignIdSettingsResource) {
    m_spCampaignsCampaignIdSettingsResource = spCampaignsCampaignIdSettingsResource;
    m_service->publish(m_spCampaignsCampaignIdSettingsResource);
}
void FbyApi::setFbyApiCampaignsResource(std::shared_ptr<FbyApiResources::CampaignsResource> spCampaignsResource) {
    m_spCampaignsResource = spCampaignsResource;
    m_service->publish(m_spCampaignsResource);
}
void FbyApi::setFbyApiCampaignsBy_loginLoginResource(std::shared_ptr<FbyApiResources::CampaignsBy_loginLoginResource> spCampaignsBy_loginLoginResource) {
    m_spCampaignsBy_loginLoginResource = spCampaignsBy_loginLoginResource;
    m_service->publish(m_spCampaignsBy_loginLoginResource);
}
void FbyApi::setFbyApiCategoriesMax_sale_quantumResource(std::shared_ptr<FbyApiResources::CategoriesMax_sale_quantumResource> spCategoriesMax_sale_quantumResource) {
    m_spCategoriesMax_sale_quantumResource = spCategoriesMax_sale_quantumResource;
    m_service->publish(m_spCategoriesMax_sale_quantumResource);
}
void FbyApi::setFbyApiCategoriesTreeResource(std::shared_ptr<FbyApiResources::CategoriesTreeResource> spCategoriesTreeResource) {
    m_spCategoriesTreeResource = spCategoriesTreeResource;
    m_service->publish(m_spCategoriesTreeResource);
}
void FbyApi::setFbyApiCategoryCategoryIdParametersResource(std::shared_ptr<FbyApiResources::CategoryCategoryIdParametersResource> spCategoryCategoryIdParametersResource) {
    m_spCategoryCategoryIdParametersResource = spCategoryCategoryIdParametersResource;
    m_service->publish(m_spCategoryCategoryIdParametersResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsHistoryResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsHistoryResource> spBusinessesBusinessIdChatsHistoryResource) {
    m_spBusinessesBusinessIdChatsHistoryResource = spBusinessesBusinessIdChatsHistoryResource;
    m_service->publish(m_spBusinessesBusinessIdChatsHistoryResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsResource> spBusinessesBusinessIdChatsResource) {
    m_spBusinessesBusinessIdChatsResource = spBusinessesBusinessIdChatsResource;
    m_service->publish(m_spBusinessesBusinessIdChatsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsFeedIdResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdResource> spCampaignsCampaignIdFeedsFeedIdResource) {
    m_spCampaignsCampaignIdFeedsFeedIdResource = spCampaignsCampaignIdFeedsFeedIdResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsFeedIdIndex_logsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource> spCampaignsCampaignIdFeedsFeedIdIndex_logsResource) {
    m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource = spCampaignsCampaignIdFeedsFeedIdIndex_logsResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedbackUpdatesResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedbackUpdatesResource> spCampaignsCampaignIdFeedbackUpdatesResource) {
    m_spCampaignsCampaignIdFeedbackUpdatesResource = spCampaignsCampaignIdFeedbackUpdatesResource;
    m_service->publish(m_spCampaignsCampaignIdFeedbackUpdatesResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsResource> spCampaignsCampaignIdFeedsResource) {
    m_spCampaignsCampaignIdFeedsResource = spCampaignsCampaignIdFeedsResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsResource);
}
void FbyApi::setFbyApiWarehousesResource(std::shared_ptr<FbyApiResources::WarehousesResource> spWarehousesResource) {
    m_spWarehousesResource = spWarehousesResource;
    m_service->publish(m_spWarehousesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods_feedbackCommentsResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource> spBusinessesBusinessIdGoods_feedbackCommentsResource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsResource = spBusinessesBusinessIdGoods_feedbackCommentsResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods_feedbackResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackResource> spBusinessesBusinessIdGoods_feedbackResource) {
    m_spBusinessesBusinessIdGoods_feedbackResource = spBusinessesBusinessIdGoods_feedbackResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdStatsSkusResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdStatsSkusResource> spCampaignsCampaignIdStatsSkusResource) {
    m_spCampaignsCampaignIdStatsSkusResource = spCampaignsCampaignIdStatsSkusResource;
    m_service->publish(m_spCampaignsCampaignIdStatsSkusResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer_cardsResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_cardsResource> spBusinessesBusinessIdOffer_cardsResource) {
    m_spBusinessesBusinessIdOffer_cardsResource = spBusinessesBusinessIdOffer_cardsResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_cardsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer_mapping_entriesResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesResource> spCampaignsCampaignIdOffer_mapping_entriesResource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesResource = spCampaignsCampaignIdOffer_mapping_entriesResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer_mappingsResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsResource> spBusinessesBusinessIdOffer_mappingsResource) {
    m_spBusinessesBusinessIdOffer_mappingsResource = spBusinessesBusinessIdOffer_mappingsResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffersRecommendationsResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffersRecommendationsResource> spBusinessesBusinessIdOffersRecommendationsResource) {
    m_spBusinessesBusinessIdOffersRecommendationsResource = spBusinessesBusinessIdOffersRecommendationsResource;
    m_service->publish(m_spBusinessesBusinessIdOffersRecommendationsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdResource> spCampaignsCampaignIdOrdersOrderIdResource) {
    m_spCampaignsCampaignIdOrdersOrderIdResource = spCampaignsCampaignIdOrdersOrderIdResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource> spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource) {
    m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource = spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdDocumentsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource> spCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
    m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource = spCampaignsCampaignIdOrdersOrderIdDocumentsResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersResource> spCampaignsCampaignIdOrdersResource) {
    m_spCampaignsCampaignIdOrdersResource = spCampaignsCampaignIdOrdersResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdStatsOrdersResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdStatsOrdersResource> spCampaignsCampaignIdStatsOrdersResource) {
    m_spCampaignsCampaignIdStatsOrdersResource = spCampaignsCampaignIdStatsOrdersResource;
    m_service->publish(m_spCampaignsCampaignIdStatsOrdersResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer_pricesResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_pricesResource> spCampaignsCampaignIdOffer_pricesResource) {
    m_spCampaignsCampaignIdOffer_pricesResource = spCampaignsCampaignIdOffer_pricesResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPromosOffersResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosOffersResource> spBusinessesBusinessIdPromosOffersResource) {
    m_spBusinessesBusinessIdPromosOffersResource = spBusinessesBusinessIdPromosOffersResource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPromosResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosResource> spBusinessesBusinessIdPromosResource) {
    m_spBusinessesBusinessIdPromosResource = spBusinessesBusinessIdPromosResource;
    m_service->publish(m_spBusinessesBusinessIdPromosResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdRatingsQualityResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdRatingsQualityResource> spBusinessesBusinessIdRatingsQualityResource) {
    m_spBusinessesBusinessIdRatingsQualityResource = spBusinessesBusinessIdRatingsQualityResource;
    m_service->publish(m_spBusinessesBusinessIdRatingsQualityResource);
}
void FbyApi::setFbyApiReportsInfoReportIdResource(std::shared_ptr<FbyApiResources::ReportsInfoReportIdResource> spReportsInfoReportIdResource) {
    m_spReportsInfoReportIdResource = spReportsInfoReportIdResource;
    m_service->publish(m_spReportsInfoReportIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource> spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource = spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource> spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
    m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource = spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource;
    m_service->publish(m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdReturnsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdReturnsResource> spCampaignsCampaignIdReturnsResource) {
    m_spCampaignsCampaignIdReturnsResource = spCampaignsCampaignIdReturnsResource;
    m_service->publish(m_spCampaignsCampaignIdReturnsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersStocksResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersStocksResource> spCampaignsCampaignIdOffersStocksResource) {
    m_spCampaignsCampaignIdOffersStocksResource = spCampaignsCampaignIdOffersStocksResource;
    m_service->publish(m_spCampaignsCampaignIdOffersStocksResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource> spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource = spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer_mappingsSuggestionsResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource> spBusinessesBusinessIdOffer_mappingsSuggestionsResource) {
    m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource = spBusinessesBusinessIdOffer_mappingsSuggestionsResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer_pricesSuggestionsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource> spCampaignsCampaignIdOffer_pricesSuggestionsResource) {
    m_spCampaignsCampaignIdOffer_pricesSuggestionsResource = spCampaignsCampaignIdOffer_pricesSuggestionsResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesSuggestionsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdBidsResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdBidsResource> spBusinessesBusinessIdBidsResource) {
    m_spBusinessesBusinessIdBidsResource = spBusinessesBusinessIdBidsResource;
    m_service->publish(m_spBusinessesBusinessIdBidsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdBidsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdBidsResource> spCampaignsCampaignIdBidsResource) {
    m_spCampaignsCampaignIdBidsResource = spCampaignsCampaignIdBidsResource;
    m_service->publish(m_spCampaignsCampaignIdBidsResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsFeedIdRefreshResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource> spCampaignsCampaignIdFeedsFeedIdRefreshResource) {
    m_spCampaignsCampaignIdFeedsFeedIdRefreshResource = spCampaignsCampaignIdFeedsFeedIdRefreshResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdRefreshResource);
}
void FbyApi::setFbyApiRegionsRegionIdChildrenResource(std::shared_ptr<FbyApiResources::RegionsRegionIdChildrenResource> spRegionsRegionIdChildrenResource) {
    m_spRegionsRegionIdChildrenResource = spRegionsRegionIdChildrenResource;
    m_service->publish(m_spRegionsRegionIdChildrenResource);
}
void FbyApi::setFbyApiRegionsRegionIdResource(std::shared_ptr<FbyApiResources::RegionsRegionIdResource> spRegionsRegionIdResource) {
    m_spRegionsRegionIdResource = spRegionsRegionIdResource;
    m_service->publish(m_spRegionsRegionIdResource);
}
void FbyApi::setFbyApiRegionsResource(std::shared_ptr<FbyApiResources::RegionsResource> spRegionsResource) {
    m_spRegionsResource = spRegionsResource;
    m_service->publish(m_spRegionsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsFileSendResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsFileSendResource> spBusinessesBusinessIdChatsFileSendResource) {
    m_spBusinessesBusinessIdChatsFileSendResource = spBusinessesBusinessIdChatsFileSendResource;
    m_service->publish(m_spBusinessesBusinessIdChatsFileSendResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdChatsMessageResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdChatsMessageResource> spBusinessesBusinessIdChatsMessageResource) {
    m_spBusinessesBusinessIdChatsMessageResource = spBusinessesBusinessIdChatsMessageResource;
    m_service->publish(m_spBusinessesBusinessIdChatsMessageResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdFeedsFeedIdParamsResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource> spCampaignsCampaignIdFeedsFeedIdParamsResource) {
    m_spCampaignsCampaignIdFeedsFeedIdParamsResource = spCampaignsCampaignIdFeedsFeedIdParamsResource;
    m_service->publish(m_spCampaignsCampaignIdFeedsFeedIdParamsResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods_feedbackSkip_reactionResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource> spBusinessesBusinessIdGoods_feedbackSkip_reactionResource) {
    m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource = spBusinessesBusinessIdGoods_feedbackSkip_reactionResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer_pricesUpdatesResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource> spBusinessesBusinessIdOffer_pricesUpdatesResource) {
    m_spBusinessesBusinessIdOffer_pricesUpdatesResource = spBusinessesBusinessIdOffer_pricesUpdatesResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_pricesUpdatesResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffersUpdateResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffersUpdateResource> spCampaignsCampaignIdOffersUpdateResource) {
    m_spCampaignsCampaignIdOffersUpdateResource = spCampaignsCampaignIdOffersUpdateResource;
    m_service->publish(m_spCampaignsCampaignIdOffersUpdateResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdGoods_feedbackCommentsUpdateResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource> spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource) {
    m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource = spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource;
    m_service->publish(m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer_cardsUpdateResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_cardsUpdateResource> spBusinessesBusinessIdOffer_cardsUpdateResource) {
    m_spBusinessesBusinessIdOffer_cardsUpdateResource = spBusinessesBusinessIdOffer_cardsUpdateResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_cardsUpdateResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer_mapping_entriesUpdatesResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource> spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource) {
    m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource = spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdOffer_mappingsUpdateResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource> spBusinessesBusinessIdOffer_mappingsUpdateResource) {
    m_spBusinessesBusinessIdOffer_mappingsUpdateResource = spBusinessesBusinessIdOffer_mappingsUpdateResource;
    m_service->publish(m_spBusinessesBusinessIdOffer_mappingsUpdateResource);
}
void FbyApi::setFbyApiCampaignsCampaignIdOffer_pricesUpdatesResource(std::shared_ptr<FbyApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource> spCampaignsCampaignIdOffer_pricesUpdatesResource) {
    m_spCampaignsCampaignIdOffer_pricesUpdatesResource = spCampaignsCampaignIdOffer_pricesUpdatesResource;
    m_service->publish(m_spCampaignsCampaignIdOffer_pricesUpdatesResource);
}
void FbyApi::setFbyApiBusinessesBusinessIdPromosOffersUpdateResource(std::shared_ptr<FbyApiResources::BusinessesBusinessIdPromosOffersUpdateResource> spBusinessesBusinessIdPromosOffersUpdateResource) {
    m_spBusinessesBusinessIdPromosOffersUpdateResource = spBusinessesBusinessIdPromosOffersUpdateResource;
    m_service->publish(m_spBusinessesBusinessIdPromosOffersUpdateResource);
}


void FbyApi::publishDefaultResources() {
    if (!m_spCampaignsCampaignIdHidden_offersResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdHidden_offersResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsArchiveResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsArchiveResource>());
    }
    if (!m_spTariffsCalculateResource) {
        setResource(std::make_shared<FbyApiResources::TariffsCalculateResource>());
    }
    if (!m_spBusinessesBusinessIdPrice_quarantineConfirmResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPrice_quarantineConfirmResource>());
    }
    if (!m_spCampaignsCampaignIdPrice_quarantineConfirmResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdPrice_quarantineConfirmResource>());
    }
    if (!m_spBusinessesBusinessIdChatsNewResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsNewResource>());
    }
    if (!m_spCampaignsCampaignIdOffersDeleteResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersDeleteResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsDeleteResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsDeleteResource>());
    }
    if (!m_spCampaignsCampaignIdHidden_offersDeleteResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdHidden_offersDeleteResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsDeleteResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsDeleteResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsUnarchiveResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsUnarchiveResource>());
    }
    if (!m_spBusinessesBusinessIdPromosOffersDeleteResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPromosOffersDeleteResource>());
    }
    if (!m_spReportsBoost_consolidatedGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsBoost_consolidatedGenerateResource>());
    }
    if (!m_spReportsCompetitors_positionGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsCompetitors_positionGenerateResource>());
    }
    if (!m_spReportsGoods_feedbackGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsGoods_feedbackGenerateResource>());
    }
    if (!m_spReportsGoods_movementGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsGoods_movementGenerateResource>());
    }
    if (!m_spReportsGoods_realizationGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsGoods_realizationGenerateResource>());
    }
    if (!m_spReportsGoods_turnoverGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsGoods_turnoverGenerateResource>());
    }
    if (!m_spReportsPricesGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsPricesGenerateResource>());
    }
    if (!m_spReportsShelf_statisticsGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsShelf_statisticsGenerateResource>());
    }
    if (!m_spReportsShows_salesGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsShows_salesGenerateResource>());
    }
    if (!m_spReportsStocks_on_warehousesGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsStocks_on_warehousesGenerateResource>());
    }
    if (!m_spReportsUnited_marketplace_servicesGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsUnited_marketplace_servicesGenerateResource>());
    }
    if (!m_spReportsUnited_nettingGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsUnited_nettingGenerateResource>());
    }
    if (!m_spReportsUnited_ordersGenerateResource) {
        setResource(std::make_shared<FbyApiResources::ReportsUnited_ordersGenerateResource>());
    }
    if (!m_spCampaignsCampaignIdOffersAllResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersAllResource>());
    }
    if (!m_spBusinessesBusinessIdBidsInfoResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdBidsInfoResource>());
    }
    if (!m_spBusinessesBusinessIdBidsRecommendationsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdBidsRecommendationsResource>());
    }
    if (!m_spBusinessesBusinessIdPrice_quarantineResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPrice_quarantineResource>());
    }
    if (!m_spBusinessesBusinessIdSettingsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdSettingsResource>());
    }
    if (!m_spCampaignsCampaignIdResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdResource>());
    }
    if (!m_spCampaignsCampaignIdLoginsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdLoginsResource>());
    }
    if (!m_spCampaignsCampaignIdOffersResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersResource>());
    }
    if (!m_spCampaignsCampaignIdPrice_quarantineResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdPrice_quarantineResource>());
    }
    if (!m_spCampaignsCampaignIdRegionResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdRegionResource>());
    }
    if (!m_spCampaignsCampaignIdSettingsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdSettingsResource>());
    }
    if (!m_spCampaignsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsResource>());
    }
    if (!m_spCampaignsBy_loginLoginResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsBy_loginLoginResource>());
    }
    if (!m_spCategoriesMax_sale_quantumResource) {
        setResource(std::make_shared<FbyApiResources::CategoriesMax_sale_quantumResource>());
    }
    if (!m_spCategoriesTreeResource) {
        setResource(std::make_shared<FbyApiResources::CategoriesTreeResource>());
    }
    if (!m_spCategoryCategoryIdParametersResource) {
        setResource(std::make_shared<FbyApiResources::CategoryCategoryIdParametersResource>());
    }
    if (!m_spBusinessesBusinessIdChatsHistoryResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsHistoryResource>());
    }
    if (!m_spBusinessesBusinessIdChatsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsFeedIdResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsFeedIdResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsFeedIdIndex_logsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsFeedIdIndex_logsResource>());
    }
    if (!m_spCampaignsCampaignIdFeedbackUpdatesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedbackUpdatesResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsResource>());
    }
    if (!m_spWarehousesResource) {
        setResource(std::make_shared<FbyApiResources::WarehousesResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackResource>());
    }
    if (!m_spCampaignsCampaignIdStatsSkusResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdStatsSkusResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_cardsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_cardsResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsResource>());
    }
    if (!m_spBusinessesBusinessIdOffersRecommendationsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffersRecommendationsResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdBusiness_buyerResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdBusiness_buyerResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdDocumentsResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersResource>());
    }
    if (!m_spCampaignsCampaignIdStatsOrdersResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdStatsOrdersResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_pricesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_pricesResource>());
    }
    if (!m_spBusinessesBusinessIdPromosOffersResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPromosOffersResource>());
    }
    if (!m_spBusinessesBusinessIdPromosResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPromosResource>());
    }
    if (!m_spBusinessesBusinessIdRatingsQualityResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdRatingsQualityResource>());
    }
    if (!m_spReportsInfoReportIdResource) {
        setResource(std::make_shared<FbyApiResources::ReportsInfoReportIdResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource>());
    }
    if (!m_spCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource>());
    }
    if (!m_spCampaignsCampaignIdReturnsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdReturnsResource>());
    }
    if (!m_spCampaignsCampaignIdOffersStocksResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersStocksResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesSuggestionsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesSuggestionsResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsSuggestionsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsSuggestionsResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_pricesSuggestionsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_pricesSuggestionsResource>());
    }
    if (!m_spBusinessesBusinessIdBidsResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdBidsResource>());
    }
    if (!m_spCampaignsCampaignIdBidsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdBidsResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsFeedIdRefreshResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsFeedIdRefreshResource>());
    }
    if (!m_spRegionsRegionIdChildrenResource) {
        setResource(std::make_shared<FbyApiResources::RegionsRegionIdChildrenResource>());
    }
    if (!m_spRegionsRegionIdResource) {
        setResource(std::make_shared<FbyApiResources::RegionsRegionIdResource>());
    }
    if (!m_spRegionsResource) {
        setResource(std::make_shared<FbyApiResources::RegionsResource>());
    }
    if (!m_spBusinessesBusinessIdChatsFileSendResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsFileSendResource>());
    }
    if (!m_spBusinessesBusinessIdChatsMessageResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdChatsMessageResource>());
    }
    if (!m_spCampaignsCampaignIdFeedsFeedIdParamsResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdFeedsFeedIdParamsResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackSkip_reactionResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackSkip_reactionResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_pricesUpdatesResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_pricesUpdatesResource>());
    }
    if (!m_spCampaignsCampaignIdOffersUpdateResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffersUpdateResource>());
    }
    if (!m_spBusinessesBusinessIdGoods_feedbackCommentsUpdateResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdGoods_feedbackCommentsUpdateResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_cardsUpdateResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_cardsUpdateResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_mapping_entriesUpdatesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_mapping_entriesUpdatesResource>());
    }
    if (!m_spBusinessesBusinessIdOffer_mappingsUpdateResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdOffer_mappingsUpdateResource>());
    }
    if (!m_spCampaignsCampaignIdOffer_pricesUpdatesResource) {
        setResource(std::make_shared<FbyApiResources::CampaignsCampaignIdOffer_pricesUpdatesResource>());
    }
    if (!m_spBusinessesBusinessIdPromosOffersUpdateResource) {
        setResource(std::make_shared<FbyApiResources::BusinessesBusinessIdPromosOffersUpdateResource>());
    }
}

std::shared_ptr<restbed::Service> FbyApi::service() {
    return m_service;
}


}
}
}
}

