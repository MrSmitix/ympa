/**
* Партнерский API Маркета
* API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
*
* The version of the OpenAPI document: LATEST
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "OrdersApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string OrdersApi::base = "";

OrdersApi::OrdersApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{
}

void OrdersApi::init() {
    setupRoutes();
}

void OrdersApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Put(*router, base + "/campaigns/:campaignId/orders/:orderId/cancellation/accept", Routes::bind(&OrdersApi::accept_order_cancellation_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/orders/:orderId", Routes::bind(&OrdersApi::get_order_handler, this));
    Routes::Get(*router, base + "/campaigns/:campaignId/orders", Routes::bind(&OrdersApi::get_orders_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/orders/:orderId/deliverDigitalGoods", Routes::bind(&OrdersApi::provide_order_digital_codes_handler, this));
    Routes::Put(*router, base + "/campaigns/:campaignId/orders/:orderId/identifiers", Routes::bind(&OrdersApi::provide_order_item_identifiers_handler, this));
    Routes::Put(*router, base + "/campaigns/:campaignId/orders/:orderId/boxes", Routes::bind(&OrdersApi::set_order_box_layout_handler, this));
    Routes::Put(*router, base + "/campaigns/:campaignId/orders/:orderId/delivery/shipments/:shipmentId/boxes", Routes::bind(&OrdersApi::set_order_shipment_boxes_handler, this));
    Routes::Put(*router, base + "/campaigns/:campaignId/orders/:orderId/items", Routes::bind(&OrdersApi::update_order_items_handler, this));
    Routes::Put(*router, base + "/campaigns/:campaignId/orders/:orderId/status", Routes::bind(&OrdersApi::update_order_status_handler, this));
    Routes::Post(*router, base + "/campaigns/:campaignId/orders/status-update", Routes::bind(&OrdersApi::update_order_statuses_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&OrdersApi::orders_api_default_handler, this));
}

void OrdersApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept
{
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> OrdersApi::handleParsingException(const std::exception& ex) const noexcept
{
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void OrdersApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept
{
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> OrdersApi::handleOperationException(const std::exception& ex) const noexcept
{
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void OrdersApi::accept_order_cancellation_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    // Getting the body param
    
    AcceptOrderCancellationRequest acceptOrderCancellationRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(acceptOrderCancellationRequest);
        acceptOrderCancellationRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->accept_order_cancellation(campaignId, orderId, acceptOrderCancellationRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void OrdersApi::get_order_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    try {
        this->get_order(campaignId, orderId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void OrdersApi::get_orders_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the query params
    auto orderIdsQuery = request.query().get("orderIds");
    std::optional<std::vector<int64_t>> orderIds;
    if(orderIdsQuery.has_value()){
        std::vector<int64_t> valueQuery_instance;
        if(fromStringValue(orderIdsQuery.value(), valueQuery_instance)){
            orderIds = valueQuery_instance;
        }
    }
    auto statusQuery = request.query().get("status");
    std::optional<std::vector<OrderStatusType>> status;
    if(statusQuery.has_value()){
        std::vector<OrderStatusType> valueQuery_instance;
        if(fromStringValue(statusQuery.value(), valueQuery_instance)){
            status = valueQuery_instance;
        }
    }
    auto substatusQuery = request.query().get("substatus");
    std::optional<std::vector<OrderSubstatusType>> substatus;
    if(substatusQuery.has_value()){
        std::vector<OrderSubstatusType> valueQuery_instance;
        if(fromStringValue(substatusQuery.value(), valueQuery_instance)){
            substatus = valueQuery_instance;
        }
    }
    auto fromDateQuery = request.query().get("fromDate");
    std::optional<std::string> fromDate;
    if(fromDateQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(fromDateQuery.value(), valueQuery_instance)){
            fromDate = valueQuery_instance;
        }
    }
    auto toDateQuery = request.query().get("toDate");
    std::optional<std::string> toDate;
    if(toDateQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(toDateQuery.value(), valueQuery_instance)){
            toDate = valueQuery_instance;
        }
    }
    auto supplierShipmentDateFromQuery = request.query().get("supplierShipmentDateFrom");
    std::optional<std::string> supplierShipmentDateFrom;
    if(supplierShipmentDateFromQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(supplierShipmentDateFromQuery.value(), valueQuery_instance)){
            supplierShipmentDateFrom = valueQuery_instance;
        }
    }
    auto supplierShipmentDateToQuery = request.query().get("supplierShipmentDateTo");
    std::optional<std::string> supplierShipmentDateTo;
    if(supplierShipmentDateToQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(supplierShipmentDateToQuery.value(), valueQuery_instance)){
            supplierShipmentDateTo = valueQuery_instance;
        }
    }
    auto updatedAtFromQuery = request.query().get("updatedAtFrom");
    std::optional<std::string> updatedAtFrom;
    if(updatedAtFromQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(updatedAtFromQuery.value(), valueQuery_instance)){
            updatedAtFrom = valueQuery_instance;
        }
    }
    auto updatedAtToQuery = request.query().get("updatedAtTo");
    std::optional<std::string> updatedAtTo;
    if(updatedAtToQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(updatedAtToQuery.value(), valueQuery_instance)){
            updatedAtTo = valueQuery_instance;
        }
    }
    auto dispatchTypeQuery = request.query().get("dispatchType");
    std::optional<OrderDeliveryDispatchType> dispatchType;
    if(dispatchTypeQuery.has_value()){
        OrderDeliveryDispatchType valueQuery_instance;
        if(fromStringValue(dispatchTypeQuery.value(), valueQuery_instance)){
            dispatchType = valueQuery_instance;
        }
    }
    auto fakeQuery = request.query().get("fake");
    std::optional<bool> fake;
    if(fakeQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(fakeQuery.value(), valueQuery_instance)){
            fake = valueQuery_instance;
        }
    }
    auto hasCisQuery = request.query().get("hasCis");
    std::optional<bool> hasCis;
    if(hasCisQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(hasCisQuery.value(), valueQuery_instance)){
            hasCis = valueQuery_instance;
        }
    }
    auto onlyWaitingForCancellationApproveQuery = request.query().get("onlyWaitingForCancellationApprove");
    std::optional<bool> onlyWaitingForCancellationApprove;
    if(onlyWaitingForCancellationApproveQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(onlyWaitingForCancellationApproveQuery.value(), valueQuery_instance)){
            onlyWaitingForCancellationApprove = valueQuery_instance;
        }
    }
    auto onlyEstimatedDeliveryQuery = request.query().get("onlyEstimatedDelivery");
    std::optional<bool> onlyEstimatedDelivery;
    if(onlyEstimatedDeliveryQuery.has_value()){
        bool valueQuery_instance;
        if(fromStringValue(onlyEstimatedDeliveryQuery.value(), valueQuery_instance)){
            onlyEstimatedDelivery = valueQuery_instance;
        }
    }
    auto buyerTypeQuery = request.query().get("buyerType");
    std::optional<OrderBuyerType> buyerType;
    if(buyerTypeQuery.has_value()){
        OrderBuyerType valueQuery_instance;
        if(fromStringValue(buyerTypeQuery.value(), valueQuery_instance)){
            buyerType = valueQuery_instance;
        }
    }
    auto pageQuery = request.query().get("page");
    std::optional<int32_t> page;
    if(pageQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageQuery.value(), valueQuery_instance)){
            page = valueQuery_instance;
        }
    }
    auto pageSizeQuery = request.query().get("pageSize");
    std::optional<int32_t> pageSize;
    if(pageSizeQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(pageSizeQuery.value(), valueQuery_instance)){
            pageSize = valueQuery_instance;
        }
    }
    auto pageTokenQuery = request.query().get("page_token");
    std::optional<std::string> pageToken;
    if(pageTokenQuery.has_value()){
        std::string valueQuery_instance;
        if(fromStringValue(pageTokenQuery.value(), valueQuery_instance)){
            pageToken = valueQuery_instance;
        }
    }
    auto limitQuery = request.query().get("limit");
    std::optional<int32_t> limit;
    if(limitQuery.has_value()){
        int32_t valueQuery_instance;
        if(fromStringValue(limitQuery.value(), valueQuery_instance)){
            limit = valueQuery_instance;
        }
    }
    
    try {
        this->get_orders(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void OrdersApi::provide_order_digital_codes_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    // Getting the body param
    
    ProvideOrderDigitalCodesRequest provideOrderDigitalCodesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(provideOrderDigitalCodesRequest);
        provideOrderDigitalCodesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->provide_order_digital_codes(campaignId, orderId, provideOrderDigitalCodesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void OrdersApi::provide_order_item_identifiers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    // Getting the body param
    
    ProvideOrderItemIdentifiersRequest provideOrderItemIdentifiersRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(provideOrderItemIdentifiersRequest);
        provideOrderItemIdentifiersRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->provide_order_item_identifiers(campaignId, orderId, provideOrderItemIdentifiersRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void OrdersApi::set_order_box_layout_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    // Getting the body param
    
    SetOrderBoxLayoutRequest setOrderBoxLayoutRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(setOrderBoxLayoutRequest);
        setOrderBoxLayoutRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->set_order_box_layout(campaignId, orderId, setOrderBoxLayoutRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void OrdersApi::set_order_shipment_boxes_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    auto shipmentId = request.param(":shipmentId").as<int64_t>();
    
    // Getting the body param
    
    SetOrderShipmentBoxesRequest setOrderShipmentBoxesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(setOrderShipmentBoxesRequest);
        setOrderShipmentBoxesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->set_order_shipment_boxes(campaignId, orderId, shipmentId, setOrderShipmentBoxesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void OrdersApi::update_order_items_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    // Getting the body param
    
    UpdateOrderItemRequest updateOrderItemRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updateOrderItemRequest);
        updateOrderItemRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_order_items(campaignId, orderId, updateOrderItemRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void OrdersApi::update_order_status_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    auto orderId = request.param(":orderId").as<int64_t>();
    
    // Getting the body param
    
    UpdateOrderStatusRequest updateOrderStatusRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updateOrderStatusRequest);
        updateOrderStatusRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_order_status(campaignId, orderId, updateOrderStatusRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void OrdersApi::update_order_statuses_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto campaignId = request.param(":campaignId").as<int64_t>();
    
    // Getting the body param
    
    UpdateOrderStatusesRequest updateOrderStatusesRequest;
    
    try {
        nlohmann::json::parse(request.body()).get_to(updateOrderStatusesRequest);
        updateOrderStatusesRequest.validate();
    } catch (std::exception &e) {
        this->handleParsingException(e, response);
        return;
    }

    try {
        this->update_order_statuses(campaignId, updateOrderStatusesRequest, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        this->handleOperationException(e, response);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}

void OrdersApi::orders_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

