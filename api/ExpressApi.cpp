/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include <corvusoft/restbed/byte.hpp>
#include <corvusoft/restbed/string.hpp>
#include <corvusoft/restbed/settings.hpp>
#include <corvusoft/restbed/request.hpp>
#include <corvusoft/restbed/uri.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>

#include "ExpressApi.h"

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

ExpressApiException::ExpressApiException(int status_code, std::string what)
  : m_status(status_code),
    m_what(what)
{

}
int ExpressApiException::getStatus() const
{
    return m_status;
}
const char* ExpressApiException::what() const noexcept
{
    return m_what.c_str();
}


template<class MODEL_T>
std::shared_ptr<MODEL_T> extractJsonModelBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto model = std::make_shared<MODEL_T>(pt);
    return model;
}

template<class MODEL_T>
std::vector<std::shared_ptr<MODEL_T>> extractJsonArrayBodyParam(const std::string& bodyContent)
{
    std::stringstream sstream(bodyContent);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream, pt);

    auto arrayRet = std::vector<std::shared_ptr<MODEL_T>>();
    for (const auto& child: pt) {
        arrayRet.emplace_back(std::make_shared<MODEL_T>(child.second));
    }
    return arrayRet;
}

template <class KEY_T, class VAL_T>
std::string convertMapResponse(const std::map<KEY_T, VAL_T>& map)
{
    boost::property_tree::ptree pt;
    for(const auto &kv: map) {
    pt.push_back(boost::property_tree::ptree::value_type(
        boost::lexical_cast<std::string>(kv.first),
        boost::property_tree::ptree(
        boost::lexical_cast<std::string>(kv.second))));
    }
    std::stringstream sstream;
    write_json(sstream, pt);
    std::string result = sstream.str();
    return result;
}

ExpressApiCampaignsCampaignIdHidden-offersResource::ExpressApiCampaignsCampaignIdHidden-offersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/hidden-offers/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdHidden-offersResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdHidden-offersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdHidden-offersResource::~ExpressApiCampaignsCampaignIdHidden-offersResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdHidden-offersResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdHidden-offersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdHidden-offersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdHidden-offersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdHidden-offersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdHidden-offersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdHidden-offersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto addHiddenOffersRequest = extractJsonModelBodyParam<AddHiddenOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, addHiddenOffersRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Настройки скрытия получены и скоро вступят в силу." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

// x-extension
void ExpressApiCampaignsCampaignIdHidden-offersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {

    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId_x_extension(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken_x_extension(request);

    const int32_t limit = getQueryParam_limit_x_extension(request);

    const int32_t offset = getQueryParam_offset_x_extension(request);

    const int32_t page = getQueryParam_page_x_extension(request);

    const int32_t pageSize = getQueryParam_pageSize_x_extension(request);


    int status_code = 500;
    std::shared_ptr<GetHiddenOffersResponse> resultObject = std::make_shared<GetHiddenOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, offerId, pageToken, limit, offset, page, pageSize);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о скрытых вами товарах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdHidden-offersResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<AddHiddenOffersRequest> const & addHiddenOffersRequest)
{
    throw ExpressApiException(501, "Not implemented");
}

std::pair<int, std::shared_ptr<GetHiddenOffersResponse>> ExpressApiCampaignsCampaignIdHidden-offersResource::handler_GET(
    int64_t const & campaignId, std::vector<std::shared_ptr<std::string>> const & offerId, std::string const & pageToken, int32_t const & limit, int32_t const & offset, int32_t const & page, int32_t const & pageSize)
{
    throw ExpressApiException(501, "Not implemented");
}

std::string ExpressApiCampaignsCampaignIdHidden-offersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/archive/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::~ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto addOffersToArchiveRequest = extractJsonModelBodyParam<AddOffersToArchiveRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<AddOffersToArchiveResponse> resultObject = std::make_shared<AddOffersToArchiveResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, addOffersToArchiveRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Если некоторые товары добавить в архив не удалось, в ответе 200 будет их список.  Список успешно добавленных товаров не возвращается. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<AddOffersToArchiveResponse>> ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<AddOffersToArchiveRequest> const & addOffersToArchiveRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiTariffsCalculateResource::ExpressApiTariffsCalculateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/tariffs/calculate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiTariffsCalculateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiTariffsCalculateResource::~ExpressApiTariffsCalculateResource()
{
}

std::pair<int, std::string> ExpressApiTariffsCalculateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiTariffsCalculateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiTariffsCalculateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiTariffsCalculateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiTariffsCalculateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiTariffsCalculateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiTariffsCalculateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto calculateTariffsRequest = extractJsonModelBodyParam<CalculateTariffsRequest>(bodyContent);




    int status_code = 500;
    std::shared_ptr<CalculateTariffsResponse> resultObject = std::make_shared<CalculateTariffsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(calculateTariffsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Стоимость услуг." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<CalculateTariffsResponse>> ExpressApiTariffsCalculateResource::handler_POST(
        std::shared_ptr<CalculateTariffsRequest> const & calculateTariffsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiTariffsCalculateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/price-quarantine/confirm/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::~ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto confirmPricesRequest = extractJsonModelBodyParam<ConfirmPricesRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, confirmPricesRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Ответ 200 обозначает, что цены подтверждены." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<ConfirmPricesRequest> const & confirmPricesRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/price-quarantine/confirm/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::~ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto confirmPricesRequest = extractJsonModelBodyParam<ConfirmPricesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, confirmPricesRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Ответ 200 обозначает, что цены подтверждены." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<ConfirmPricesRequest> const & confirmPricesRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdChatsNewResource::ExpressApiBusinessesBusinessIdChatsNewResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/new/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdChatsNewResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdChatsNewResource::~ExpressApiBusinessesBusinessIdChatsNewResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsNewResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsNewResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsNewResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdChatsNewResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdChatsNewResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdChatsNewResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdChatsNewResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto createChatRequest = extractJsonModelBodyParam<CreateChatRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<CreateChatResponse> resultObject = std::make_shared<CreateChatResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, createChatRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Все получилось: чат создан. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<CreateChatResponse>> ExpressApiBusinessesBusinessIdChatsNewResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<CreateChatRequest> const & createChatRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdChatsNewResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffersDeleteResource::ExpressApiCampaignsCampaignIdOffersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/delete/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOffersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffersDeleteResource::~ExpressApiCampaignsCampaignIdOffersDeleteResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersDeleteResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteCampaignOffersRequest = extractJsonModelBodyParam<DeleteCampaignOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<DeleteCampaignOffersResponse> resultObject = std::make_shared<DeleteCampaignOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, deleteCampaignOffersRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Если удалось удалить не все товары, с ответом 200 вернется список тех, что были в запросе, но остались в магазине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<DeleteCampaignOffersResponse>> ExpressApiCampaignsCampaignIdOffersDeleteResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<DeleteCampaignOffersRequest> const & deleteCampaignOffersRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOffersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/delete/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::~ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteGoodsFeedbackCommentRequest = extractJsonModelBodyParam<DeleteGoodsFeedbackCommentRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, deleteGoodsFeedbackCommentRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<DeleteGoodsFeedbackCommentRequest> const & deleteGoodsFeedbackCommentRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::ExpressApiCampaignsCampaignIdHidden-offersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/hidden-offers/delete/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::~ExpressApiCampaignsCampaignIdHidden-offersDeleteResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteHiddenOffersRequest = extractJsonModelBodyParam<DeleteHiddenOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, deleteHiddenOffersRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Показ товаров возобновлен." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<DeleteHiddenOffersRequest> const & deleteHiddenOffersRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdHidden-offersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/delete/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::~ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteOffersRequest = extractJsonModelBodyParam<DeleteOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<DeleteOffersResponse> resultObject = std::make_shared<DeleteOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, deleteOffersRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Если удалось удалить не все товары, с ответом 200 вернется список тех, что были в запросе, но остались в магазине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<DeleteOffersResponse>> ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<DeleteOffersRequest> const & deleteOffersRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/unarchive/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::~ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deleteOffersFromArchiveRequest = extractJsonModelBodyParam<DeleteOffersFromArchiveRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<DeleteOffersFromArchiveResponse> resultObject = std::make_shared<DeleteOffersFromArchiveResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, deleteOffersFromArchiveRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Если некоторые товары восстановить из архива не удалось, в ответе 200 будет их список.  Список успешно восстановленных товаров не возвращается. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<DeleteOffersFromArchiveResponse>> ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<DeleteOffersFromArchiveRequest> const & deleteOffersFromArchiveRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::ExpressApiBusinessesBusinessIdPromosOffersDeleteResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/delete/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::~ExpressApiBusinessesBusinessIdPromosOffersDeleteResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto deletePromoOffersRequest = extractJsonModelBodyParam<DeletePromoOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<DeletePromoOffersResponse> resultObject = std::make_shared<DeletePromoOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, deletePromoOffersRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Результат удаления товаров из акции." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<DeletePromoOffersResponse>> ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<DeletePromoOffersRequest> const & deletePromoOffersRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdPromosOffersDeleteResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsBoost-consolidatedGenerateResource::ExpressApiReportsBoost-consolidatedGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/boost-consolidated/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsBoost-consolidatedGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsBoost-consolidatedGenerateResource::~ExpressApiReportsBoost-consolidatedGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsBoost-consolidatedGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsBoost-consolidatedGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsBoost-consolidatedGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsBoost-consolidatedGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsBoost-consolidatedGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsBoost-consolidatedGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsBoost-consolidatedGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateBoostConsolidatedRequest = extractJsonModelBodyParam<GenerateBoostConsolidatedRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateBoostConsolidatedRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsBoost-consolidatedGenerateResource::handler_POST(
        std::shared_ptr<GenerateBoostConsolidatedRequest> const & generateBoostConsolidatedRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsBoost-consolidatedGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsCompetitors-positionGenerateResource::ExpressApiReportsCompetitors-positionGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/competitors-position/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsCompetitors-positionGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsCompetitors-positionGenerateResource::~ExpressApiReportsCompetitors-positionGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsCompetitors-positionGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsCompetitors-positionGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsCompetitors-positionGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsCompetitors-positionGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsCompetitors-positionGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsCompetitors-positionGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsCompetitors-positionGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateCompetitorsPositionReportRequest = extractJsonModelBodyParam<GenerateCompetitorsPositionReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateCompetitorsPositionReportRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsCompetitors-positionGenerateResource::handler_POST(
        std::shared_ptr<GenerateCompetitorsPositionReportRequest> const & generateCompetitorsPositionReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsCompetitors-positionGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsGoods-feedbackGenerateResource::ExpressApiReportsGoods-feedbackGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-feedback/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsGoods-feedbackGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsGoods-feedbackGenerateResource::~ExpressApiReportsGoods-feedbackGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsGoods-feedbackGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsGoods-feedbackGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsGoods-feedbackGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsGoods-feedbackGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsGoods-feedbackGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsGoods-feedbackGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsGoods-feedbackGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateGoodsFeedbackRequest = extractJsonModelBodyParam<GenerateGoodsFeedbackRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateGoodsFeedbackRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsGoods-feedbackGenerateResource::handler_POST(
        std::shared_ptr<GenerateGoodsFeedbackRequest> const & generateGoodsFeedbackRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsGoods-feedbackGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsGoods-realizationGenerateResource::ExpressApiReportsGoods-realizationGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/goods-realization/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsGoods-realizationGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsGoods-realizationGenerateResource::~ExpressApiReportsGoods-realizationGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsGoods-realizationGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsGoods-realizationGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsGoods-realizationGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsGoods-realizationGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsGoods-realizationGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsGoods-realizationGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsGoods-realizationGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateGoodsRealizationReportRequest = extractJsonModelBodyParam<GenerateGoodsRealizationReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateGoodsRealizationReportRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsGoods-realizationGenerateResource::handler_POST(
        std::shared_ptr<GenerateGoodsRealizationReportRequest> const & generateGoodsRealizationReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsGoods-realizationGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsDocumentsLabelsGenerateResource::ExpressApiReportsDocumentsLabelsGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/documents/labels/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsDocumentsLabelsGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsDocumentsLabelsGenerateResource::~ExpressApiReportsDocumentsLabelsGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsDocumentsLabelsGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsDocumentsLabelsGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsDocumentsLabelsGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsDocumentsLabelsGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsDocumentsLabelsGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsDocumentsLabelsGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsDocumentsLabelsGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateMassOrderLabelsRequest = extractJsonModelBodyParam<GenerateMassOrderLabelsRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateMassOrderLabelsRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый файл.  Если при генерации не удалось найти часть заказов, в ответе на запрос получения готового файла вернется подстатус &#x60;RESOURCE_NOT_FOUND&#x60;. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsDocumentsLabelsGenerateResource::handler_POST(
        std::shared_ptr<GenerateMassOrderLabelsRequest> const & generateMassOrderLabelsRequest, std::shared_ptr<PageFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsDocumentsLabelsGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/shipments/{shipmentId: .*}/boxes/{boxId: .*}/label/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);
    const int64_t shipmentId = getPathParam_shipmentId(request);
    const int64_t boxId = getPathParam_boxId(request);

    // Getting the query params


    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId, shipmentId, boxId, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "PDF‑файл с ярлыками для коробки. Файл содержит одну страницу с ярлыком." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId, int64_t const & shipmentId, int64_t const & boxId, std::shared_ptr<PageFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/labels/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);

    // Getting the query params


    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "PDF‑файл с ярлыками на все коробки." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId, std::shared_ptr<PageFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsPricesGenerateResource::ExpressApiReportsPricesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/prices/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsPricesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsPricesGenerateResource::~ExpressApiReportsPricesGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsPricesGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsPricesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsPricesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsPricesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsPricesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsPricesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsPricesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generatePricesReportRequest = extractJsonModelBodyParam<GeneratePricesReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generatePricesReportRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsPricesGenerateResource::handler_POST(
        std::shared_ptr<GeneratePricesReportRequest> const & generatePricesReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsPricesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsShelf-statisticsGenerateResource::ExpressApiReportsShelf-statisticsGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shelf-statistics/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsShelf-statisticsGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsShelf-statisticsGenerateResource::~ExpressApiReportsShelf-statisticsGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsShelf-statisticsGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsShelf-statisticsGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsShelf-statisticsGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsShelf-statisticsGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsShelf-statisticsGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsShelf-statisticsGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsShelf-statisticsGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateShelfsStatisticsRequest = extractJsonModelBodyParam<GenerateShelfsStatisticsRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateShelfsStatisticsRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsShelf-statisticsGenerateResource::handler_POST(
        std::shared_ptr<GenerateShelfsStatisticsRequest> const & generateShelfsStatisticsRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsShelf-statisticsGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsShows-salesGenerateResource::ExpressApiReportsShows-salesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/shows-sales/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsShows-salesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsShows-salesGenerateResource::~ExpressApiReportsShows-salesGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsShows-salesGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsShows-salesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsShows-salesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsShows-salesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsShows-salesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsShows-salesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsShows-salesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateShowsSalesReportRequest = extractJsonModelBodyParam<GenerateShowsSalesReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateShowsSalesReportRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsShows-salesGenerateResource::handler_POST(
        std::shared_ptr<GenerateShowsSalesReportRequest> const & generateShowsSalesReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsShows-salesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsStocks-on-warehousesGenerateResource::ExpressApiReportsStocks-on-warehousesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/stocks-on-warehouses/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsStocks-on-warehousesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsStocks-on-warehousesGenerateResource::~ExpressApiReportsStocks-on-warehousesGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsStocks-on-warehousesGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsStocks-on-warehousesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsStocks-on-warehousesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsStocks-on-warehousesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsStocks-on-warehousesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsStocks-on-warehousesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsStocks-on-warehousesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateStocksOnWarehousesReportRequest = extractJsonModelBodyParam<GenerateStocksOnWarehousesReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateStocksOnWarehousesReportRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsStocks-on-warehousesGenerateResource::handler_POST(
        std::shared_ptr<GenerateStocksOnWarehousesReportRequest> const & generateStocksOnWarehousesReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsStocks-on-warehousesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsUnited-marketplace-servicesGenerateResource::ExpressApiReportsUnited-marketplace-servicesGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-marketplace-services/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsUnited-marketplace-servicesGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsUnited-marketplace-servicesGenerateResource::~ExpressApiReportsUnited-marketplace-servicesGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsUnited-marketplace-servicesGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsUnited-marketplace-servicesGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsUnited-marketplace-servicesGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsUnited-marketplace-servicesGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsUnited-marketplace-servicesGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsUnited-marketplace-servicesGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsUnited-marketplace-servicesGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateUnitedMarketplaceServicesReportRequest = extractJsonModelBodyParam<GenerateUnitedMarketplaceServicesReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateUnitedMarketplaceServicesReportRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsUnited-marketplace-servicesGenerateResource::handler_POST(
        std::shared_ptr<GenerateUnitedMarketplaceServicesReportRequest> const & generateUnitedMarketplaceServicesReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsUnited-marketplace-servicesGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsUnited-nettingGenerateResource::ExpressApiReportsUnited-nettingGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-netting/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsUnited-nettingGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsUnited-nettingGenerateResource::~ExpressApiReportsUnited-nettingGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsUnited-nettingGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsUnited-nettingGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsUnited-nettingGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsUnited-nettingGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsUnited-nettingGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsUnited-nettingGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsUnited-nettingGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateUnitedNettingReportRequest = extractJsonModelBodyParam<GenerateUnitedNettingReportRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateUnitedNettingReportRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsUnited-nettingGenerateResource::handler_POST(
        std::shared_ptr<GenerateUnitedNettingReportRequest> const & generateUnitedNettingReportRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsUnited-nettingGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsUnited-ordersGenerateResource::ExpressApiReportsUnited-ordersGenerateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/united-orders/generate/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiReportsUnited-ordersGenerateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsUnited-ordersGenerateResource::~ExpressApiReportsUnited-ordersGenerateResource()
{
}

std::pair<int, std::string> ExpressApiReportsUnited-ordersGenerateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsUnited-ordersGenerateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsUnited-ordersGenerateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsUnited-ordersGenerateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsUnited-ordersGenerateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsUnited-ordersGenerateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsUnited-ordersGenerateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto generateUnitedOrdersRequest = extractJsonModelBodyParam<GenerateUnitedOrdersRequest>(bodyContent);


    // Getting the query params


    int status_code = 500;
    std::shared_ptr<GenerateReportResponse> resultObject = std::make_shared<GenerateReportResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(generateUnitedOrdersRequest, format);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ приходит идентификатор, который позволяет узнавать статус генерации и скачать готовый отчет." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GenerateReportResponse>> ExpressApiReportsUnited-ordersGenerateResource::handler_POST(
        std::shared_ptr<GenerateUnitedOrdersRequest> const & generateUnitedOrdersRequest, std::shared_ptr<ReportFormatType> const & format)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsUnited-ordersGenerateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffersAllResource::ExpressApiCampaignsCampaignIdOffersAllResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/all/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOffersAllResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffersAllResource::~ExpressApiCampaignsCampaignIdOffersAllResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersAllResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersAllResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersAllResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffersAllResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffersAllResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffersAllResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffersAllResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const int64_t feedId = getQueryParam_feedId(request);
    const int32_t chunk = getQueryParam_chunk(request);


    int status_code = 500;
    std::shared_ptr<GetAllOffersResponse> resultObject = std::make_shared<GetAllOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, feedId, chunk);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Предложения магазина." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetAllOffersResponse>> ExpressApiCampaignsCampaignIdOffersAllResource::handler_GET(
        int64_t const & campaignId, int64_t const & feedId, int32_t const & chunk)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOffersAllResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdBidsInfoResource::ExpressApiBusinessesBusinessIdBidsInfoResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/info/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdBidsInfoResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdBidsInfoResource::~ExpressApiBusinessesBusinessIdBidsInfoResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdBidsInfoResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdBidsInfoResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdBidsInfoResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdBidsInfoResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdBidsInfoResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdBidsInfoResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdBidsInfoResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getBidsInfoRequest = extractJsonModelBodyParam<GetBidsInfoRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetBidsInfoResponse> resultObject = std::make_shared<GetBidsInfoResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, pageToken, limit, getBidsInfoRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Значения ставок для заданных товаров. В ответ попадают только товары, на которые установлены ставки." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBidsInfoResponse>> ExpressApiBusinessesBusinessIdBidsInfoResource::handler_POST(
        int64_t const & businessId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetBidsInfoRequest> const & getBidsInfoRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdBidsInfoResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdBidsRecommendationsResource::ExpressApiBusinessesBusinessIdBidsRecommendationsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/recommendations/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdBidsRecommendationsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdBidsRecommendationsResource::~ExpressApiBusinessesBusinessIdBidsRecommendationsResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdBidsRecommendationsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdBidsRecommendationsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdBidsRecommendationsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdBidsRecommendationsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdBidsRecommendationsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdBidsRecommendationsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdBidsRecommendationsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getBidsRecommendationsRequest = extractJsonModelBodyParam<GetBidsRecommendationsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetBidsRecommendationsResponse> resultObject = std::make_shared<GetBidsRecommendationsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getBidsRecommendationsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Рекомендованные ставки для заданных товаров." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBidsRecommendationsResponse>> ExpressApiBusinessesBusinessIdBidsRecommendationsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetBidsRecommendationsRequest> const & getBidsRecommendationsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdBidsRecommendationsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdPrice-quarantineResource::ExpressApiBusinessesBusinessIdPrice-quarantineResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/price-quarantine/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdPrice-quarantineResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdPrice-quarantineResource::~ExpressApiBusinessesBusinessIdPrice-quarantineResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPrice-quarantineResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPrice-quarantineResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPrice-quarantineResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdPrice-quarantineResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdPrice-quarantineResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdPrice-quarantineResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdPrice-quarantineResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getQuarantineOffersRequest = extractJsonModelBodyParam<GetQuarantineOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetQuarantineOffersResponse> resultObject = std::make_shared<GetQuarantineOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getQuarantineOffersRequest, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров в карантине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetQuarantineOffersResponse>> ExpressApiBusinessesBusinessIdPrice-quarantineResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetQuarantineOffersRequest> const & getQuarantineOffersRequest, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdPrice-quarantineResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdSettingsResource::ExpressApiBusinessesBusinessIdSettingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/settings/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdSettingsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdSettingsResource::~ExpressApiBusinessesBusinessIdSettingsResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdSettingsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdSettingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdSettingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdSettingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdSettingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdSettingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdSettingsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetBusinessSettingsResponse> resultObject = std::make_shared<GetBusinessSettingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Настройки кабинета." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBusinessSettingsResponse>> ExpressApiBusinessesBusinessIdSettingsResource::handler_POST(
        int64_t const & businessId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdSettingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdResource::ExpressApiCampaignsCampaignIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdResource::~ExpressApiCampaignsCampaignIdResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetCampaignResponse> resultObject = std::make_shared<GetCampaignResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о магазине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignResponse>> ExpressApiCampaignsCampaignIdResource::handler_GET(
        int64_t const & campaignId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdLoginsResource::ExpressApiCampaignsCampaignIdLoginsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/logins/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdLoginsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdLoginsResource::~ExpressApiCampaignsCampaignIdLoginsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdLoginsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdLoginsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdLoginsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdLoginsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdLoginsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdLoginsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdLoginsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetCampaignLoginsResponse> resultObject = std::make_shared<GetCampaignLoginsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список логинов, связанных с магазином." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignLoginsResponse>> ExpressApiCampaignsCampaignIdLoginsResource::handler_GET(
        int64_t const & campaignId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdLoginsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffersResource::ExpressApiCampaignsCampaignIdOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOffersResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOffersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffersResource::~ExpressApiCampaignsCampaignIdOffersResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getCampaignOffersRequest = extractJsonModelBodyParam<GetCampaignOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetCampaignOffersResponse> resultObject = std::make_shared<GetCampaignOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, getCampaignOffersRequest, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров, размещенных в заданном магазине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

// x-extension
void ExpressApiCampaignsCampaignIdOffersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session) {

    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId_x_extension(request);

    // Getting the query params
    const std::string query = getQueryParam_query_x_extension(request);

    const int64_t feedId = getQueryParam_feedId_x_extension(request);

    const std::string shopCategoryId = getQueryParam_shopCategoryId_x_extension(request);

    const bool matched = getQueryParam_matched_x_extension(request);

    const int32_t page = getQueryParam_page_x_extension(request);

    const int32_t pageSize = getQueryParam_pageSize_x_extension(request);


    int status_code = 500;
    std::shared_ptr<GetOffersResponse> resultObject = std::make_shared<GetOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
            handler_GET(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Предложения магазина." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

std::pair<int, std::shared_ptr<GetCampaignOffersResponse>> ExpressApiCampaignsCampaignIdOffersResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<GetCampaignOffersRequest> const & getCampaignOffersRequest, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}

std::pair<int, std::shared_ptr<GetOffersResponse>> ExpressApiCampaignsCampaignIdOffersResource::handler_GET(
    int64_t const & campaignId, std::string const & query, int64_t const & feedId, std::string const & shopCategoryId, std::shared_ptr<CurrencyType> const & currency, bool const & matched, int32_t const & page, int32_t const & pageSize)
{
    throw ExpressApiException(501, "Not implemented");
}

std::string ExpressApiCampaignsCampaignIdOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdPrice-quarantineResource::ExpressApiCampaignsCampaignIdPrice-quarantineResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/price-quarantine/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdPrice-quarantineResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdPrice-quarantineResource::~ExpressApiCampaignsCampaignIdPrice-quarantineResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdPrice-quarantineResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdPrice-quarantineResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdPrice-quarantineResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdPrice-quarantineResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdPrice-quarantineResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdPrice-quarantineResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdPrice-quarantineResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getQuarantineOffersRequest = extractJsonModelBodyParam<GetQuarantineOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetQuarantineOffersResponse> resultObject = std::make_shared<GetQuarantineOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, getQuarantineOffersRequest, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров в карантине." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetQuarantineOffersResponse>> ExpressApiCampaignsCampaignIdPrice-quarantineResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<GetQuarantineOffersRequest> const & getQuarantineOffersRequest, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdPrice-quarantineResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdRegionResource::ExpressApiCampaignsCampaignIdRegionResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/region/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdRegionResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdRegionResource::~ExpressApiCampaignsCampaignIdRegionResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdRegionResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdRegionResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdRegionResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdRegionResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdRegionResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdRegionResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdRegionResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetCampaignRegionResponse> resultObject = std::make_shared<GetCampaignRegionResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Возвращает регион, в котором находится магазин.  |**⚙️ Лимит:** 1000 запросов в час| |-| " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignRegionResponse>> ExpressApiCampaignsCampaignIdRegionResource::handler_GET(
        int64_t const & campaignId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdRegionResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdSettingsResource::ExpressApiCampaignsCampaignIdSettingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/settings/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdSettingsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdSettingsResource::~ExpressApiCampaignsCampaignIdSettingsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdSettingsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdSettingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdSettingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdSettingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdSettingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdSettingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdSettingsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetCampaignSettingsResponse> resultObject = std::make_shared<GetCampaignSettingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Настройки магазина." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignSettingsResponse>> ExpressApiCampaignsCampaignIdSettingsResource::handler_GET(
        int64_t const & campaignId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdSettingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsResource::ExpressApiCampaignsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsResource::~ExpressApiCampaignsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();


    // Getting the query params
    const int32_t page = getQueryParam_page(request);
    const int32_t pageSize = getQueryParam_pageSize(request);


    int status_code = 500;
    std::shared_ptr<GetCampaignsResponse> resultObject = std::make_shared<GetCampaignsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(page, pageSize);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Магазины пользователя." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignsResponse>> ExpressApiCampaignsResource::handler_GET(
        int32_t const & page, int32_t const & pageSize)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsBy_loginLoginResource::ExpressApiCampaignsBy_loginLoginResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/by_login/{login: .*}/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsBy_loginLoginResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsBy_loginLoginResource::~ExpressApiCampaignsBy_loginLoginResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsBy_loginLoginResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsBy_loginLoginResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsBy_loginLoginResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsBy_loginLoginResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsBy_loginLoginResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsBy_loginLoginResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsBy_loginLoginResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const std::string login = getPathParam_login(request);

    // Getting the query params
    const int32_t page = getQueryParam_page(request);
    const int32_t pageSize = getQueryParam_pageSize(request);


    int status_code = 500;
    std::shared_ptr<GetCampaignsResponse> resultObject = std::make_shared<GetCampaignsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(login, page, pageSize);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о магазинах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCampaignsResponse>> ExpressApiCampaignsBy_loginLoginResource::handler_GET(
        std::string const & login, int32_t const & page, int32_t const & pageSize)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsBy_loginLoginResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCategoriesMax-sale-quantumResource::ExpressApiCategoriesMax-sale-quantumResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/categories/max-sale-quantum/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCategoriesMax-sale-quantumResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCategoriesMax-sale-quantumResource::~ExpressApiCategoriesMax-sale-quantumResource()
{
}

std::pair<int, std::string> ExpressApiCategoriesMax-sale-quantumResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCategoriesMax-sale-quantumResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCategoriesMax-sale-quantumResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCategoriesMax-sale-quantumResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCategoriesMax-sale-quantumResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCategoriesMax-sale-quantumResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCategoriesMax-sale-quantumResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getCategoriesMaxSaleQuantumRequest = extractJsonModelBodyParam<GetCategoriesMaxSaleQuantumRequest>(bodyContent);




    int status_code = 500;
    std::shared_ptr<GetCategoriesMaxSaleQuantumResponse> resultObject = std::make_shared<GetCategoriesMaxSaleQuantumResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(getCategoriesMaxSaleQuantumRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Лимит на установку кванта и минимального количества товаров." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCategoriesMaxSaleQuantumResponse>> ExpressApiCategoriesMax-sale-quantumResource::handler_POST(
        std::shared_ptr<GetCategoriesMaxSaleQuantumRequest> const & getCategoriesMaxSaleQuantumRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCategoriesMax-sale-quantumResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCategoriesTreeResource::ExpressApiCategoriesTreeResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/categories/tree/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCategoriesTreeResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCategoriesTreeResource::~ExpressApiCategoriesTreeResource()
{
}

std::pair<int, std::string> ExpressApiCategoriesTreeResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCategoriesTreeResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCategoriesTreeResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCategoriesTreeResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCategoriesTreeResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCategoriesTreeResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCategoriesTreeResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getCategoriesRequest = extractJsonModelBodyParam<GetCategoriesRequest>(bodyContent);




    int status_code = 500;
    std::shared_ptr<GetCategoriesResponse> resultObject = std::make_shared<GetCategoriesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(getCategoriesRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Категории Маркета." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCategoriesResponse>> ExpressApiCategoriesTreeResource::handler_POST(
        std::shared_ptr<GetCategoriesRequest> const & getCategoriesRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCategoriesTreeResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCategoryCategoryIdParametersResource::ExpressApiCategoryCategoryIdParametersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/category/{categoryId: .*}/parameters/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCategoryCategoryIdParametersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCategoryCategoryIdParametersResource::~ExpressApiCategoryCategoryIdParametersResource()
{
}

std::pair<int, std::string> ExpressApiCategoryCategoryIdParametersResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCategoryCategoryIdParametersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCategoryCategoryIdParametersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCategoryCategoryIdParametersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCategoryCategoryIdParametersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCategoryCategoryIdParametersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCategoryCategoryIdParametersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t categoryId = getPathParam_categoryId(request);



    int status_code = 500;
    std::shared_ptr<GetCategoryContentParametersResponse> resultObject = std::make_shared<GetCategoryContentParametersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(categoryId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список характеристик товаров из заданной категории." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetCategoryContentParametersResponse>> ExpressApiCategoryCategoryIdParametersResource::handler_POST(
        int64_t const & categoryId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCategoryCategoryIdParametersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdChatsHistoryResource::ExpressApiBusinessesBusinessIdChatsHistoryResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/history/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdChatsHistoryResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdChatsHistoryResource::~ExpressApiBusinessesBusinessIdChatsHistoryResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsHistoryResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsHistoryResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsHistoryResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdChatsHistoryResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdChatsHistoryResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdChatsHistoryResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdChatsHistoryResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getChatHistoryRequest = extractJsonModelBodyParam<GetChatHistoryRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const int64_t chatId = getQueryParam_chatId(request);
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetChatHistoryResponse> resultObject = std::make_shared<GetChatHistoryResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, chatId, getChatHistoryRequest, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "История сообщений успешно получена. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetChatHistoryResponse>> ExpressApiBusinessesBusinessIdChatsHistoryResource::handler_POST(
        int64_t const & businessId, int64_t const & chatId, std::shared_ptr<GetChatHistoryRequest> const & getChatHistoryRequest, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdChatsHistoryResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdChatsResource::ExpressApiBusinessesBusinessIdChatsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdChatsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdChatsResource::~ExpressApiBusinessesBusinessIdChatsResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdChatsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdChatsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdChatsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdChatsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getChatsRequest = extractJsonModelBodyParam<GetChatsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetChatsResponse> resultObject = std::make_shared<GetChatsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getChatsRequest, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список чатов. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetChatsResponse>> ExpressApiBusinessesBusinessIdChatsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetChatsRequest> const & getChatsRequest, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdChatsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiDeliveryServicesResource::ExpressApiDeliveryServicesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/delivery/services/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiDeliveryServicesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiDeliveryServicesResource::~ExpressApiDeliveryServicesResource()
{
}

std::pair<int, std::string> ExpressApiDeliveryServicesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiDeliveryServicesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiDeliveryServicesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiDeliveryServicesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiDeliveryServicesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiDeliveryServicesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiDeliveryServicesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();




    int status_code = 500;
    std::shared_ptr<GetDeliveryServicesResponse> resultObject = std::make_shared<GetDeliveryServicesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET();
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о службах доставки." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetDeliveryServicesResponse>> ExpressApiDeliveryServicesResource::handler_GET(
        )
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiDeliveryServicesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdFeedsFeedIdResource::ExpressApiCampaignsCampaignIdFeedsFeedIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdFeedsFeedIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdFeedsFeedIdResource::~ExpressApiCampaignsCampaignIdFeedsFeedIdResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t feedId = getPathParam_feedId(request);



    int status_code = 500;
    std::shared_ptr<GetFeedResponse> resultObject = std::make_shared<GetFeedResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, feedId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о прайс-листе." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetFeedResponse>> ExpressApiCampaignsCampaignIdFeedsFeedIdResource::handler_GET(
        int64_t const & campaignId, int64_t const & feedId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdFeedsFeedIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/index-logs/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::~ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t feedId = getPathParam_feedId(request);

    // Getting the query params
    const int32_t limit = getQueryParam_limit(request);
    const std::string publishedTimeFrom = getQueryParam_publishedTimeFrom(request);
    const std::string publishedTimeTo = getQueryParam_publishedTimeTo(request);


    int status_code = 500;
    std::shared_ptr<GetFeedIndexLogsResponse> resultObject = std::make_shared<GetFeedIndexLogsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Отчет по индексации прайс-листа." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetFeedIndexLogsResponse>> ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::handler_GET(
        int64_t const & campaignId, int64_t const & feedId, int32_t const & limit, std::string const & publishedTimeFrom, std::string const & publishedTimeTo, std::shared_ptr<FeedIndexLogsStatusType> const & status)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::ExpressApiCampaignsCampaignIdFeedbackUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feedback/updates/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::~ExpressApiCampaignsCampaignIdFeedbackUpdatesResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);
    const std::string fromDate = getQueryParam_fromDate(request);


    int status_code = 500;
    std::shared_ptr<GetFeedbackListResponse> resultObject = std::make_shared<GetFeedbackListResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, pageToken, limit, fromDate);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список отзывов для магазина." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetFeedbackListResponse>> ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::handler_GET(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::string const & fromDate)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdFeedbackUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdFeedsResource::ExpressApiCampaignsCampaignIdFeedsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdFeedsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdFeedsResource::~ExpressApiCampaignsCampaignIdFeedsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdFeedsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdFeedsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdFeedsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdFeedsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetFeedsResponse> resultObject = std::make_shared<GetFeedsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список прайс-листов." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetFeedsResponse>> ExpressApiCampaignsCampaignIdFeedsResource::handler_GET(
        int64_t const & campaignId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdFeedsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::~ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getGoodsFeedbackCommentsRequest = extractJsonModelBodyParam<GetGoodsFeedbackCommentsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetGoodsFeedbackCommentsResponse> resultObject = std::make_shared<GetGoodsFeedbackCommentsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Дерево комментариев к отзыву." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetGoodsFeedbackCommentsResponse>> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetGoodsFeedbackCommentsRequest> const & getGoodsFeedbackCommentsRequest, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdGoods-feedbackResource::ExpressApiBusinessesBusinessIdGoods-feedbackResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdGoods-feedbackResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdGoods-feedbackResource::~ExpressApiBusinessesBusinessIdGoods-feedbackResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getGoodsFeedbackRequest = extractJsonModelBodyParam<GetGoodsFeedbackRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetGoodsFeedbackResponse> resultObject = std::make_shared<GetGoodsFeedbackResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, pageToken, limit, getGoodsFeedbackRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список отзывов." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetGoodsFeedbackResponse>> ExpressApiBusinessesBusinessIdGoods-feedbackResource::handler_POST(
        int64_t const & businessId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetGoodsFeedbackRequest> const & getGoodsFeedbackRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdGoods-feedbackResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdStatsSkusResource::ExpressApiCampaignsCampaignIdStatsSkusResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/stats/skus/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdStatsSkusResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdStatsSkusResource::~ExpressApiCampaignsCampaignIdStatsSkusResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdStatsSkusResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdStatsSkusResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdStatsSkusResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdStatsSkusResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdStatsSkusResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdStatsSkusResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdStatsSkusResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getGoodsStatsRequest = extractJsonModelBodyParam<GetGoodsStatsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetGoodsStatsResponse> resultObject = std::make_shared<GetGoodsStatsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, getGoodsStatsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Отчет по товарам." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetGoodsStatsResponse>> ExpressApiCampaignsCampaignIdStatsSkusResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<GetGoodsStatsRequest> const & getGoodsStatsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdStatsSkusResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffer-cardsResource::ExpressApiBusinessesBusinessIdOffer-cardsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-cards/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffer-cardsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffer-cardsResource::~ExpressApiBusinessesBusinessIdOffer-cardsResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-cardsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-cardsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-cardsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffer-cardsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffer-cardsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffer-cardsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffer-cardsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getOfferCardsContentStatusRequest = extractJsonModelBodyParam<GetOfferCardsContentStatusRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOfferCardsContentStatusResponse> resultObject = std::make_shared<GetOfferCardsContentStatusResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, pageToken, limit, getOfferCardsContentStatusRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о карточках указанных товаров." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOfferCardsContentStatusResponse>> ExpressApiBusinessesBusinessIdOffer-cardsResource::handler_POST(
        int64_t const & businessId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetOfferCardsContentStatusRequest> const & getOfferCardsContentStatusRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffer-cardsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::~ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOfferMappingEntriesResponse> resultObject = std::make_shared<GetOfferMappingEntriesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о товарах в каталоге." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOfferMappingEntriesResponse>> ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::handler_GET(
        int64_t const & campaignId, std::vector<std::string> const & offerId, std::vector<std::shared_ptr<std::string>> const & shopSku, std::shared_ptr<OfferMappingKindType> const & mappingKind, std::vector<std::shared_ptr<OfferProcessingStatusType>> const & status, std::vector<std::shared_ptr<OfferAvailabilityStatusType>> const & availability, std::vector<int32_t> const & categoryId, std::vector<std::string> const & vendor, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffer-mappingsResource::ExpressApiBusinessesBusinessIdOffer-mappingsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffer-mappingsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffer-mappingsResource::~ExpressApiBusinessesBusinessIdOffer-mappingsResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getOfferMappingsRequest = extractJsonModelBodyParam<GetOfferMappingsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOfferMappingsResponse> resultObject = std::make_shared<GetOfferMappingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, pageToken, limit, getOfferMappingsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о товарах в каталоге." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOfferMappingsResponse>> ExpressApiBusinessesBusinessIdOffer-mappingsResource::handler_POST(
        int64_t const & businessId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetOfferMappingsRequest> const & getOfferMappingsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffer-mappingsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffersRecommendationsResource::ExpressApiBusinessesBusinessIdOffersRecommendationsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offers/recommendations/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffersRecommendationsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffersRecommendationsResource::~ExpressApiBusinessesBusinessIdOffersRecommendationsResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffersRecommendationsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffersRecommendationsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffersRecommendationsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffersRecommendationsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffersRecommendationsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffersRecommendationsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffersRecommendationsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getOfferRecommendationsRequest = extractJsonModelBodyParam<GetOfferRecommendationsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOfferRecommendationsResponse> resultObject = std::make_shared<GetOfferRecommendationsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getOfferRecommendationsRequest, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров с рекомендациями." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOfferRecommendationsResponse>> ExpressApiBusinessesBusinessIdOffersRecommendationsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetOfferRecommendationsRequest> const & getOfferRecommendationsRequest, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffersRecommendationsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdResource::ExpressApiCampaignsCampaignIdOrdersOrderIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<GetOrderResponse> resultObject = std::make_shared<GetOrderResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о заказе." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOrderResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/business-buyer/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<GetBusinessBuyerInfoResponse> resultObject = std::make_shared<GetBusinessBuyerInfoResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, orderId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о покупателе." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBusinessBuyerInfoResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::handler_POST(
        int64_t const & campaignId, int64_t const & orderId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/documents/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<GetBusinessDocumentsInfoResponse> resultObject = std::make_shared<GetBusinessDocumentsInfoResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, orderId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о документах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetBusinessDocumentsInfoResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::handler_POST(
        int64_t const & campaignId, int64_t const & orderId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/labels/data/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<GetOrderLabelsDataResponse> resultObject = std::make_shared<GetOrderLabelsDataResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация для печати ярлыков." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOrderLabelsDataResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersResource::ExpressApiCampaignsCampaignIdOrdersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersResource::~ExpressApiCampaignsCampaignIdOrdersResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string fromDate = getQueryParam_fromDate(request);
    const std::string toDate = getQueryParam_toDate(request);
    const std::string supplierShipmentDateFrom = getQueryParam_supplierShipmentDateFrom(request);
    const std::string supplierShipmentDateTo = getQueryParam_supplierShipmentDateTo(request);
    const std::string updatedAtFrom = getQueryParam_updatedAtFrom(request);
    const std::string updatedAtTo = getQueryParam_updatedAtTo(request);
    const bool fake = getQueryParam_fake(request);
    const bool hasCis = getQueryParam_hasCis(request);
    const bool onlyWaitingForCancellationApprove = getQueryParam_onlyWaitingForCancellationApprove(request);
    const bool onlyEstimatedDelivery = getQueryParam_onlyEstimatedDelivery(request);
    const int32_t page = getQueryParam_page(request);
    const int32_t pageSize = getQueryParam_pageSize(request);
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOrdersResponse> resultObject = std::make_shared<GetOrdersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о заказах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOrdersResponse>> ExpressApiCampaignsCampaignIdOrdersResource::handler_GET(
        int64_t const & campaignId, std::vector<int64_t> const & orderIds, Set<std::shared_ptr<OrderStatusType>> const & status, Set<std::shared_ptr<OrderSubstatusType>> const & substatus, std::string const & fromDate, std::string const & toDate, std::string const & supplierShipmentDateFrom, std::string const & supplierShipmentDateTo, std::string const & updatedAtFrom, std::string const & updatedAtTo, std::shared_ptr<OrderDeliveryDispatchType> const & dispatchType, bool const & fake, bool const & hasCis, bool const & onlyWaitingForCancellationApprove, bool const & onlyEstimatedDelivery, std::shared_ptr<OrderBuyerType> const & buyerType, int32_t const & page, int32_t const & pageSize, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdStatsOrdersResource::ExpressApiCampaignsCampaignIdStatsOrdersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/stats/orders/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdStatsOrdersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdStatsOrdersResource::~ExpressApiCampaignsCampaignIdStatsOrdersResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdStatsOrdersResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdStatsOrdersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdStatsOrdersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdStatsOrdersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdStatsOrdersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdStatsOrdersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdStatsOrdersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getOrdersStatsRequest = extractJsonModelBodyParam<GetOrdersStatsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetOrdersStatsResponse> resultObject = std::make_shared<GetOrdersStatsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, pageToken, limit, getOrdersStatsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация по заказам." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetOrdersStatsResponse>> ExpressApiCampaignsCampaignIdStatsOrdersResource::handler_POST(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetOrdersStatsRequest> const & getOrdersStatsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdStatsOrdersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffer-pricesResource::ExpressApiCampaignsCampaignIdOffer-pricesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOffer-pricesResource::handler_GET_internal, this,
			std::placeholders::_1));
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOffer-pricesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffer-pricesResource::~ExpressApiCampaignsCampaignIdOffer-pricesResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-pricesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-pricesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-pricesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffer-pricesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffer-pricesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffer-pricesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffer-pricesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);
    const bool archived = getQueryParam_archived(request);


    int status_code = 500;
    std::shared_ptr<GetPricesResponse> resultObject = std::make_shared<GetPricesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, pageToken, limit, archived);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список всех товаров с установленными ценами." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

// x-extension
void ExpressApiCampaignsCampaignIdOffer-pricesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session) {

    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // body params or form params here from the body content string
    auto campaignId = std::make_shared<>(bodyContent);
    auto pageToken = std::make_shared<>(bodyContent);
    auto limit = std::make_shared<>(bodyContent);
    auto getPricesByOfferIdsRequest = extractJsonModelBodyParam<GetPricesByOfferIdsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId_x_extension(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken_x_extension(request);

    const int32_t limit = getQueryParam_limit_x_extension(request);


    int status_code = 500;
    std::shared_ptr<GetPricesByOfferIdsResponse> resultObject = std::make_shared<GetPricesByOfferIdsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
            handler_POST(campaignId, pageToken, limit, getPricesByOfferIdsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров с установленными для заданного магазина ценами." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

std::pair<int, std::shared_ptr<GetPricesResponse>> ExpressApiCampaignsCampaignIdOffer-pricesResource::handler_GET(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, bool const & archived)
{
    throw ExpressApiException(501, "Not implemented");
}

std::pair<int, std::shared_ptr<GetPricesByOfferIdsResponse>> ExpressApiCampaignsCampaignIdOffer-pricesResource::handler_POST(
    int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetPricesByOfferIdsRequest> const & getPricesByOfferIdsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}

std::string ExpressApiCampaignsCampaignIdOffer-pricesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdPromosOffersResource::ExpressApiBusinessesBusinessIdPromosOffersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdPromosOffersResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdPromosOffersResource::~ExpressApiBusinessesBusinessIdPromosOffersResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosOffersResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosOffersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosOffersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdPromosOffersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdPromosOffersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdPromosOffersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdPromosOffersResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getPromoOffersRequest = extractJsonModelBodyParam<GetPromoOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetPromoOffersResponse> resultObject = std::make_shared<GetPromoOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getPromoOffersRequest, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список товаров, которые участвуют или могут участвовать в акции." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetPromoOffersResponse>> ExpressApiBusinessesBusinessIdPromosOffersResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetPromoOffersRequest> const & getPromoOffersRequest, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdPromosOffersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdPromosResource::ExpressApiBusinessesBusinessIdPromosResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdPromosResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdPromosResource::~ExpressApiBusinessesBusinessIdPromosResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdPromosResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdPromosResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdPromosResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdPromosResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getPromosRequest = extractJsonModelBodyParam<GetPromosRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetPromosResponse> resultObject = std::make_shared<GetPromosResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getPromosRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список акций Маркета." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetPromosResponse>> ExpressApiBusinessesBusinessIdPromosResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetPromosRequest> const & getPromosRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdPromosResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/ratings/quality/details/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::~ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetQualityRatingDetailsResponse> resultObject = std::make_shared<GetQualityRatingDetailsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о заказах, которые повлияли на индекс качества." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetQualityRatingDetailsResponse>> ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::handler_POST(
        int64_t const & campaignId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdRatingsQualityResource::ExpressApiBusinessesBusinessIdRatingsQualityResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/ratings/quality/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdRatingsQualityResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdRatingsQualityResource::~ExpressApiBusinessesBusinessIdRatingsQualityResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdRatingsQualityResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdRatingsQualityResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdRatingsQualityResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdRatingsQualityResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdRatingsQualityResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdRatingsQualityResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdRatingsQualityResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getQualityRatingRequest = extractJsonModelBodyParam<GetQualityRatingRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetQualityRatingResponse> resultObject = std::make_shared<GetQualityRatingResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getQualityRatingRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Значение индекса качества магазинов и его составляющие." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetQualityRatingResponse>> ExpressApiBusinessesBusinessIdRatingsQualityResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetQualityRatingRequest> const & getQualityRatingRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdRatingsQualityResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiReportsInfoReportIdResource::ExpressApiReportsInfoReportIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/reports/info/{reportId: .*}/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiReportsInfoReportIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiReportsInfoReportIdResource::~ExpressApiReportsInfoReportIdResource()
{
}

std::pair<int, std::string> ExpressApiReportsInfoReportIdResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiReportsInfoReportIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiReportsInfoReportIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiReportsInfoReportIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiReportsInfoReportIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiReportsInfoReportIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiReportsInfoReportIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const std::string reportId = getPathParam_reportId(request);



    int status_code = 500;
    std::shared_ptr<GetReportInfoResponse> resultObject = std::make_shared<GetReportInfoResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(reportId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Статус генерации отчета и ссылка, если она уже есть.  {% note tip %}  Если статус генерации отчета — &#x60;FAILED&#x60; или &#x60;NO_DATA&#x60;, проверьте корректность запроса на генерацию. Например, верно ли указан идентификатор магазина, период или номер платежного поручения.  {% endnote %}    " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetReportInfoResponse>> ExpressApiReportsInfoReportIdResource::handler_GET(
        std::string const & reportId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiReportsInfoReportIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);
    const int64_t returnId = getPathParam_returnId(request);



    int status_code = 500;
    std::shared_ptr<GetReturnResponse> resultObject = std::make_shared<GetReturnResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId, returnId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Детали возврата." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetReturnResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId, int64_t const & returnId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/application/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);
    const int64_t returnId = getPathParam_returnId(request);



    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId, returnId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Заявление на возврат." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId, int64_t const & returnId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/returns/{returnId: .*}/decision/{itemId: .*}/image/{imageHash: .*}/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);
    const int64_t returnId = getPathParam_returnId(request);
    const int64_t itemId = getPathParam_itemId(request);
    const std::string imageHash = getPathParam_imageHash(request);



    int status_code = 500;
    std::string resultObject = "";
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, orderId, returnId, itemId, imageHash);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Фотография возврата." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::handler_GET(
        int64_t const & campaignId, int64_t const & orderId, int64_t const & returnId, int64_t const & itemId, std::string const & imageHash)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdReturnsResource::ExpressApiCampaignsCampaignIdReturnsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/returns/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiCampaignsCampaignIdReturnsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdReturnsResource::~ExpressApiCampaignsCampaignIdReturnsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdReturnsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdReturnsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdReturnsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdReturnsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdReturnsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdReturnsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdReturnsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);
    const std::string fromDate = getQueryParam_fromDate(request);
    const std::string toDate = getQueryParam_toDate(request);
    const std::string fromDate2 = getQueryParam_fromDate2(request);
    const std::string toDate2 = getQueryParam_toDate2(request);


    int status_code = 500;
    std::shared_ptr<GetReturnsResponse> resultObject = std::make_shared<GetReturnsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Постраничные возвраты партнера." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetReturnsResponse>> ExpressApiCampaignsCampaignIdReturnsResource::handler_GET(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::vector<int64_t> const & orderIds, std::vector<std::shared_ptr<RefundStatusType>> const & statuses, std::shared_ptr<ReturnType> const & type, std::string const & fromDate, std::string const & toDate, std::string const & fromDate2, std::string const & toDate2)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdReturnsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffersStocksResource::ExpressApiCampaignsCampaignIdOffersStocksResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/stocks/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOffersStocksResource::handler_POST_internal, this,
			std::placeholders::_1));
	this->set_method_handler("PUT",
		std::bind(&ExpressApiCampaignsCampaignIdOffersStocksResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffersStocksResource::~ExpressApiCampaignsCampaignIdOffersStocksResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersStocksResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersStocksResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersStocksResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffersStocksResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffersStocksResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffersStocksResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffersStocksResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getWarehouseStocksRequest = extractJsonModelBodyParam<GetWarehouseStocksRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);

    // Getting the query params
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetWarehouseStocksResponse> resultObject = std::make_shared<GetWarehouseStocksResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, pageToken, limit, getWarehouseStocksRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Остатки товаров на складах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

// x-extension
void ExpressApiCampaignsCampaignIdOffersStocksResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session) {

    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // body params or form params here from the body content string
    auto campaignId = std::make_shared<>(bodyContent);
    auto updateStocksRequest = extractJsonModelBodyParam<UpdateStocksRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId_x_extension(request);


    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
            handler_PUT(campaignId, updateStocksRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}

std::pair<int, std::shared_ptr<GetWarehouseStocksResponse>> ExpressApiCampaignsCampaignIdOffersStocksResource::handler_POST(
        int64_t const & campaignId, std::string const & pageToken, int32_t const & limit, std::shared_ptr<GetWarehouseStocksRequest> const & getWarehouseStocksRequest)
{
    throw ExpressApiException(501, "Not implemented");
}

std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdOffersStocksResource::handler_PUT(
    int64_t const & campaignId, std::shared_ptr<UpdateStocksRequest> const & updateStocksRequest)
{
    throw ExpressApiException(501, "Not implemented");
}

std::string ExpressApiCampaignsCampaignIdOffersStocksResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/suggestions/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::~ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getSuggestedOfferMappingEntriesRequest = extractJsonModelBodyParam<GetSuggestedOfferMappingEntriesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<GetSuggestedOfferMappingEntriesResponse> resultObject = std::make_shared<GetSuggestedOfferMappingEntriesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, getSuggestedOfferMappingEntriesRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о товарах в каталоге." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetSuggestedOfferMappingEntriesResponse>> ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<GetSuggestedOfferMappingEntriesRequest> const & getSuggestedOfferMappingEntriesRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/suggestions/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::~ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto getSuggestedOfferMappingsRequest = extractJsonModelBodyParam<GetSuggestedOfferMappingsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetSuggestedOfferMappingsResponse> resultObject = std::make_shared<GetSuggestedOfferMappingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, getSuggestedOfferMappingsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Подобранные карточки на Маркете.  По результатам проверки товара полученная через этот запрос карточка может быть заменена на другую. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetSuggestedOfferMappingsResponse>> ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<GetSuggestedOfferMappingsRequest> const & getSuggestedOfferMappingsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/suggestions/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::~ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto suggestPricesRequest = extractJsonModelBodyParam<SuggestPricesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<SuggestPricesResponse> resultObject = std::make_shared<SuggestPricesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, suggestPricesRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список цен для продвижения на Маркете." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<SuggestPricesResponse>> ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<SuggestPricesRequest> const & suggestPricesRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdWarehousesResource::ExpressApiBusinessesBusinessIdWarehousesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/warehouses/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiBusinessesBusinessIdWarehousesResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdWarehousesResource::~ExpressApiBusinessesBusinessIdWarehousesResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdWarehousesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdWarehousesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdWarehousesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdWarehousesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdWarehousesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdWarehousesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdWarehousesResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<GetWarehousesResponse> resultObject = std::make_shared<GetWarehousesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(businessId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список складов и групп складов." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetWarehousesResponse>> ExpressApiBusinessesBusinessIdWarehousesResource::handler_GET(
        int64_t const & businessId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdWarehousesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/identifiers/");
	this->set_method_handler("PUT",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto provideOrderItemIdentifiersRequest = extractJsonModelBodyParam<ProvideOrderItemIdentifiersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<ProvideOrderItemIdentifiersResponse> resultObject = std::make_shared<ProvideOrderItemIdentifiersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_PUT(campaignId, orderId, provideOrderItemIdentifiersRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Ответ 200 обозначает, что коды успешно записались. Ответ содержит краткие сведения о промаркированных товарах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<ProvideOrderItemIdentifiersResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::handler_PUT(
        int64_t const & campaignId, int64_t const & orderId, std::shared_ptr<ProvideOrderItemIdentifiersRequest> const & provideOrderItemIdentifiersRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdBidsResource::ExpressApiBusinessesBusinessIdBidsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/bids/");
	this->set_method_handler("PUT",
		std::bind(&ExpressApiBusinessesBusinessIdBidsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdBidsResource::~ExpressApiBusinessesBusinessIdBidsResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdBidsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdBidsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdBidsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdBidsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdBidsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdBidsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdBidsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto putSkuBidsRequest = extractJsonModelBodyParam<PutSkuBidsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_PUT(businessId, putSkuBidsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Все получилось: ставки установлены или обновлены. Если нужно, добавлены новые товары и запущена кампания. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiBusinessesBusinessIdBidsResource::handler_PUT(
        int64_t const & businessId, std::shared_ptr<PutSkuBidsRequest> const & putSkuBidsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdBidsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdBidsResource::ExpressApiCampaignsCampaignIdBidsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/bids/");
	this->set_method_handler("PUT",
		std::bind(&ExpressApiCampaignsCampaignIdBidsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdBidsResource::~ExpressApiCampaignsCampaignIdBidsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdBidsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdBidsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdBidsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdBidsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdBidsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdBidsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdBidsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto putSkuBidsRequest = extractJsonModelBodyParam<PutSkuBidsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_PUT(campaignId, putSkuBidsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdBidsResource::handler_PUT(
        int64_t const & campaignId, std::shared_ptr<PutSkuBidsRequest> const & putSkuBidsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdBidsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/refresh/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::~ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t feedId = getPathParam_feedId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, feedId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::handler_POST(
        int64_t const & campaignId, int64_t const & feedId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiRegionsRegionIdChildrenResource::ExpressApiRegionsRegionIdChildrenResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/{regionId: .*}/children/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiRegionsRegionIdChildrenResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiRegionsRegionIdChildrenResource::~ExpressApiRegionsRegionIdChildrenResource()
{
}

std::pair<int, std::string> ExpressApiRegionsRegionIdChildrenResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiRegionsRegionIdChildrenResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiRegionsRegionIdChildrenResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiRegionsRegionIdChildrenResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiRegionsRegionIdChildrenResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiRegionsRegionIdChildrenResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiRegionsRegionIdChildrenResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t regionId = getPathParam_regionId(request);

    // Getting the query params
    const int32_t page = getQueryParam_page(request);
    const int32_t pageSize = getQueryParam_pageSize(request);


    int status_code = 500;
    std::shared_ptr<GetRegionWithChildrenResponse> resultObject = std::make_shared<GetRegionWithChildrenResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(regionId, page, pageSize);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Регионы, являющиеся дочерними к указанному в запросе." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetRegionWithChildrenResponse>> ExpressApiRegionsRegionIdChildrenResource::handler_GET(
        int64_t const & regionId, int32_t const & page, int32_t const & pageSize)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiRegionsRegionIdChildrenResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiRegionsRegionIdResource::ExpressApiRegionsRegionIdResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/{regionId: .*}/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiRegionsRegionIdResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiRegionsRegionIdResource::~ExpressApiRegionsRegionIdResource()
{
}

std::pair<int, std::string> ExpressApiRegionsRegionIdResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiRegionsRegionIdResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiRegionsRegionIdResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiRegionsRegionIdResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiRegionsRegionIdResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiRegionsRegionIdResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiRegionsRegionIdResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t regionId = getPathParam_regionId(request);



    int status_code = 500;
    std::shared_ptr<GetRegionsResponse> resultObject = std::make_shared<GetRegionsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(regionId);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Найденный регион." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetRegionsResponse>> ExpressApiRegionsRegionIdResource::handler_GET(
        int64_t const & regionId)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiRegionsRegionIdResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiRegionsResource::ExpressApiRegionsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/regions/");
	this->set_method_handler("GET",
		std::bind(&ExpressApiRegionsResource::handler_GET_internal, this,
			std::placeholders::_1));
}

ExpressApiRegionsResource::~ExpressApiRegionsResource()
{
}

std::pair<int, std::string> ExpressApiRegionsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiRegionsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiRegionsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiRegionsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiRegionsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiRegionsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiRegionsResource::handler_GET_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();


    // Getting the query params
    const std::string name = getQueryParam_name(request);
    const std::string pageToken = getQueryParam_pageToken(request);
    const int32_t limit = getQueryParam_limit(request);


    int status_code = 500;
    std::shared_ptr<GetRegionsResponse> resultObject = std::make_shared<GetRegionsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_GET(name, pageToken, limit);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Список найденных регионов." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<GetRegionsResponse>> ExpressApiRegionsResource::handler_GET(
        std::string const & name, std::string const & pageToken, int32_t const & limit)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiRegionsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdChatsFileSendResource::ExpressApiBusinessesBusinessIdChatsFileSendResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/file/send/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdChatsFileSendResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdChatsFileSendResource::~ExpressApiBusinessesBusinessIdChatsFileSendResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsFileSendResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsFileSendResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsFileSendResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdChatsFileSendResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdChatsFileSendResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdChatsFileSendResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdChatsFileSendResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const int64_t chatId = getQueryParam_chatId(request);


    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, chatId, file);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ. Означает, что файл отправлен." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiBusinessesBusinessIdChatsFileSendResource::handler_POST(
        int64_t const & businessId, int64_t const & chatId, std::string const & file)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdChatsFileSendResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdChatsMessageResource::ExpressApiBusinessesBusinessIdChatsMessageResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/chats/message/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdChatsMessageResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdChatsMessageResource::~ExpressApiBusinessesBusinessIdChatsMessageResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsMessageResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsMessageResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdChatsMessageResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdChatsMessageResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdChatsMessageResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdChatsMessageResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdChatsMessageResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto sendMessageToChatRequest = extractJsonModelBodyParam<SendMessageToChatRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);

    // Getting the query params
    const int64_t chatId = getQueryParam_chatId(request);


    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, chatId, sendMessageToChatRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ. Означает, что сообщение отправлено." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiBusinessesBusinessIdChatsMessageResource::handler_POST(
        int64_t const & businessId, int64_t const & chatId, std::shared_ptr<SendMessageToChatRequest> const & sendMessageToChatRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdChatsMessageResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/feeds/{feedId: .*}/params/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::~ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto setFeedParamsRequest = extractJsonModelBodyParam<SetFeedParamsRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t feedId = getPathParam_feedId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, feedId, setFeedParamsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Статус выполнения операции." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::handler_POST(
        int64_t const & campaignId, int64_t const & feedId, std::shared_ptr<SetFeedParamsRequest> const & setFeedParamsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/boxes/");
	this->set_method_handler("PUT",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto setOrderBoxLayoutRequest = extractJsonModelBodyParam<SetOrderBoxLayoutRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<SetOrderBoxLayoutResponse> resultObject = std::make_shared<SetOrderBoxLayoutResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_PUT(campaignId, orderId, setOrderBoxLayoutRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В ответ придет переданная раскладка с идентификаторами коробок — они понадобятся для запроса ярлыков. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<SetOrderBoxLayoutResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::handler_PUT(
        int64_t const & campaignId, int64_t const & orderId, std::shared_ptr<SetOrderBoxLayoutRequest> const & setOrderBoxLayoutRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/delivery/shipments/{shipmentId: .*}/boxes/");
	this->set_method_handler("PUT",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto setOrderShipmentBoxesRequest = extractJsonModelBodyParam<SetOrderShipmentBoxesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);
    const int64_t shipmentId = getPathParam_shipmentId(request);



    int status_code = 500;
    std::shared_ptr<SetOrderShipmentBoxesResponse> resultObject = std::make_shared<SetOrderShipmentBoxesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_PUT(campaignId, orderId, shipmentId, setOrderShipmentBoxesRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Имеет значение только тип ответа. Если ответ &#x60;ОК&#x60;, количество грузомест записано." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<SetOrderShipmentBoxesResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::handler_PUT(
        int64_t const & campaignId, int64_t const & orderId, int64_t const & shipmentId, std::shared_ptr<SetOrderShipmentBoxesRequest> const & setOrderShipmentBoxesRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/skip-reaction/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::~ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto skipGoodsFeedbackReactionRequest = extractJsonModelBodyParam<SkipGoodsFeedbackReactionRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, skipGoodsFeedbackReactionRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Пустой ответ." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<SkipGoodsFeedbackReactionRequest> const & skipGoodsFeedbackReactionRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-prices/updates/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::~ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateBusinessPricesRequest = extractJsonModelBodyParam<UpdateBusinessPricesRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updateBusinessPricesRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Маркет принял информацию о новых ценах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdateBusinessPricesRequest> const & updateBusinessPricesRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffersUpdateResource::ExpressApiCampaignsCampaignIdOffersUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offers/update/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOffersUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffersUpdateResource::~ExpressApiCampaignsCampaignIdOffersUpdateResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersUpdateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffersUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffersUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffersUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffersUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffersUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateCampaignOffersRequest = extractJsonModelBodyParam<UpdateCampaignOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, updateCampaignOffersRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Ответ 200 обозначает, что новые параметры получены Маркетом и скоро вступят в силу." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdOffersUpdateResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<UpdateCampaignOffersRequest> const & updateCampaignOffersRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOffersUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/goods-feedback/comments/update/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::~ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateGoodsFeedbackCommentRequest = extractJsonModelBodyParam<UpdateGoodsFeedbackCommentRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<UpdateGoodsFeedbackCommentResponse> resultObject = std::make_shared<UpdateGoodsFeedbackCommentResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updateGoodsFeedbackCommentRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Информация о добавленном или измененном комментарии." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdateGoodsFeedbackCommentResponse>> ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdateGoodsFeedbackCommentRequest> const & updateGoodsFeedbackCommentRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-cards/update/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::~ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateOfferContentRequest = extractJsonModelBodyParam<UpdateOfferContentRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<UpdateOfferContentResponse> resultObject = std::make_shared<UpdateOfferContentResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updateOfferContentRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Запрос выполнен корректно, данные обработаны.  {% note warning \&quot;Ответ 200 сам по себе не значит, что переданные значения корректны\&quot; %}  Обязательно посмотрите детали ответа: &#x60;status&#x60; и перечень ошибок, если он есть.  Даже если ошибка допущена в характеристиках всего одного товара, никакие изменения из запроса в каталог не попадут.  {% endnote %}  Если в &#x60;status&#x60; вернулось &#x60;ERROR&#x60;, убедитесь, что:  * все обязательные характеристики заполнены; * характеристики действительно существуют в указанных категориях; * значения соответствуют характеристикам; * ваши собственные значения имеют нужный тип данных.  Найти проблемы помогут поля &#x60;errors&#x60; и &#x60;warnings&#x60;. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdateOfferContentResponse>> ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdateOfferContentRequest> const & updateOfferContentRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-mapping-entries/updates/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::~ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateOfferMappingEntryRequest = extractJsonModelBodyParam<UpdateOfferMappingEntryRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, updateOfferMappingEntryRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Статус выполнения операции." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<UpdateOfferMappingEntryRequest> const & updateOfferMappingEntryRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/offer-mappings/update/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::~ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateOfferMappingsRequest = extractJsonModelBodyParam<UpdateOfferMappingsRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<UpdateOfferMappingsResponse> resultObject = std::make_shared<UpdateOfferMappingsResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updateOfferMappingsRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Все обязательные поля товаров заполнены, поэтому новые товары и внесенные изменения сохранены в каталоге. " : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdateOfferMappingsResponse>> ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdateOfferMappingsRequest> const & updateOfferMappingsRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/items/");
	this->set_method_handler("PUT",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateOrderItemRequest = extractJsonModelBodyParam<UpdateOrderItemRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::string result = "";

    try {
         status_code =
             handler_PUT(campaignId, orderId, updateOrderItemRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {

        const constexpr auto contentType = "text/plain";
        returnResponse(session, 200, result.empty() ? "Маркет успешно обработал ваш запрос. Выходные данные не ожидаются." : result, contentType);
        return;
    }
    if (status_code == 400) {

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


int ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::handler_PUT(
        int64_t const & campaignId, int64_t const & orderId, std::shared_ptr<UpdateOrderItemRequest> const & updateOrderItemRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/status/");
	this->set_method_handler("PUT",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateOrderStatusRequest = extractJsonModelBodyParam<UpdateOrderStatusRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<UpdateOrderStatusResponse> resultObject = std::make_shared<UpdateOrderStatusResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_PUT(campaignId, orderId, updateOrderStatusRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "В случае успешного изменения статуса заказа возвращается обновленная информация о заказе." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdateOrderStatusResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::handler_PUT(
        int64_t const & campaignId, int64_t const & orderId, std::shared_ptr<UpdateOrderStatusRequest> const & updateOrderStatusRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::ExpressApiCampaignsCampaignIdOrdersStatus-updateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/status-update/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::~ExpressApiCampaignsCampaignIdOrdersStatus-updateResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updateOrderStatusesRequest = extractJsonModelBodyParam<UpdateOrderStatusesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<UpdateOrderStatusesResponse> resultObject = std::make_shared<UpdateOrderStatusesResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, updateOrderStatusesRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Возвращается информация об обновленных статусах заказов." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdateOrderStatusesResponse>> ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<UpdateOrderStatusesRequest> const & updateOrderStatusesRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersStatus-updateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/offer-prices/updates/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::~ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updatePricesRequest = extractJsonModelBodyParam<UpdatePricesRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);



    int status_code = 500;
    std::shared_ptr<EmptyApiResponse> resultObject = std::make_shared<EmptyApiResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(campaignId, updatePricesRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Маркет принял информацию о новых ценах." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 423) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 423, result.empty() ? "К ресурсу нельзя применить указанный метод." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<EmptyApiResponse>> ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::handler_POST(
        int64_t const & campaignId, std::shared_ptr<UpdatePricesRequest> const & updatePricesRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::ExpressApiBusinessesBusinessIdPromosOffersUpdateResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/businesses/{businessId: .*}/promos/offers/update/");
	this->set_method_handler("POST",
		std::bind(&ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::handler_POST_internal, this,
			std::placeholders::_1));
}

ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::~ExpressApiBusinessesBusinessIdPromosOffersUpdateResource()
{
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::handler_POST_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto updatePromoOffersRequest = extractJsonModelBodyParam<UpdatePromoOffersRequest>(bodyContent);

    // Getting the path params
    const int64_t businessId = getPathParam_businessId(request);



    int status_code = 500;
    std::shared_ptr<UpdatePromoOffersResponse> resultObject = std::make_shared<UpdatePromoOffersResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_POST(businessId, updatePromoOffersRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Результат добавления товаров в акцию или обновления их цен." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<UpdatePromoOffersResponse>> ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::handler_POST(
        int64_t const & businessId, std::shared_ptr<UpdatePromoOffersRequest> const & updatePromoOffersRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiBusinessesBusinessIdPromosOffersUpdateResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}
ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource(const std::string& context /* = "" */)
{
	this->set_path(context + "/campaigns/{campaignId: .*}/orders/{orderId: .*}/verifyEac/");
	this->set_method_handler("PUT",
		std::bind(&ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::handler_PUT_internal, this,
			std::placeholders::_1));
}

ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::~ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource()
{
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::handleExpressApiException(const ExpressApiException& e)
{
    return std::make_pair<int, std::string>(e.getStatus(), e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::handleStdException(const std::exception& e)
{
    return std::make_pair<int, std::string>(500, e.what());
}

std::pair<int, std::string> ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::handleUnspecifiedException()
{
    return std::make_pair<int, std::string>(500, "Unknown exception occurred");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::setResponseHeader(const std::shared_ptr<restbed::Session>& session, const std::string& header)
{
    session->set_header(header, "");
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::returnResponse(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result, const std::string& contentType)
{
    session->close(status, result, { {"Connection", "close"}, {"Content-Type", contentType} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::defaultSessionClose(const std::shared_ptr<restbed::Session>& session, const int status, const std::string& result)
{
    session->close(status, result, { {"Connection", "close"} });
}

void ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::handler_PUT_internal(const std::shared_ptr<restbed::Session> session)
{
    const auto request = session->get_request();
    std::string bodyContent = extractBodyContent(session);

    // Get body params or form params here from the body content string
    auto verifyOrderEacRequest = extractJsonModelBodyParam<VerifyOrderEacRequest>(bodyContent);

    // Getting the path params
    const int64_t campaignId = getPathParam_campaignId(request);
    const int64_t orderId = getPathParam_orderId(request);



    int status_code = 500;
    std::shared_ptr<VerifyOrderEacResponse> resultObject = std::make_shared<VerifyOrderEacResponse>();
    std::string result = "";

    try {
        std::tie(status_code, resultObject) =
             handler_PUT(campaignId, orderId, verifyOrderEacRequest);
    }
    catch(const ExpressApiException& e) {
        std::tie(status_code, result) = handleExpressApiException(e);
    }
    catch(const std::exception& e) {
        std::tie(status_code, result) = handleStdException(e);
    }
    catch(...) {
        std::tie(status_code, result) = handleUnspecifiedException();
    }

    if (status_code == 200) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 200, result.empty() ? "Проверка кода выполнена успешно." : result, contentType);
        return;
    }
    if (status_code == 400) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 400, result.empty() ? "Запрос содержит неправильные данные." : result, contentType);
        return;
    }
    if (status_code == 401) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 401, result.empty() ? "В запросе не указаны данные для авторизации." : result, contentType);
        return;
    }
    if (status_code == 403) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 403, result.empty() ? "Данные для авторизации неверны или доступ к ресурсу запрещен." : result, contentType);
        return;
    }
    if (status_code == 404) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 404, result.empty() ? "Запрашиваемый ресурс не найден." : result, contentType);
        return;
    }
    if (status_code == 420) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 420, result.empty() ? "Превышено ограничение на доступ к ресурсу." : result, contentType);
        return;
    }
    if (status_code == 500) {
        result = resultObject->toJsonString();

        const constexpr auto contentType = "application/json";
        returnResponse(session, 500, result.empty() ? "Внутренняя ошибка сервера." : result, contentType);
        return;
    }
    defaultSessionClose(session, status_code, result);
}


std::pair<int, std::shared_ptr<VerifyOrderEacResponse>> ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::handler_PUT(
        int64_t const & campaignId, int64_t const & orderId, std::shared_ptr<VerifyOrderEacRequest> const & verifyOrderEacRequest)
{
    throw ExpressApiException(501, "Not implemented");
}


std::string ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource::extractBodyContent(const std::shared_ptr<restbed::Session>& session) {
  const auto request = session->get_request();
  int content_length = request->get_header("Content-Length", 0);
  std::string bodyContent;
  session->fetch(content_length,
                 [&bodyContent](const std::shared_ptr<restbed::Session> session,
                                const restbed::Bytes &body) {
                   bodyContent = restbed::String::format(
                       "%.*s\n", (int)body.size(), body.data());
                 });
  return bodyContent;
}

ExpressApi::ExpressApi(std::shared_ptr<restbed::Service> const& restbedService)
: m_service(restbedService)
{
}

ExpressApi::~ExpressApi() {}

void ExpressApi::setExpressApiCampaignsCampaignIdHidden-offersResource(std::shared_ptr<ExpressApiCampaignsCampaignIdHidden-offersResource> spExpressApiCampaignsCampaignIdHidden-offersResource) {
    m_spExpressApiCampaignsCampaignIdHidden-offersResource = spExpressApiCampaignsCampaignIdHidden-offersResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdHidden-offersResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource> spExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource) {
    m_spExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource = spExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource);
}
void ExpressApi::setExpressApiTariffsCalculateResource(std::shared_ptr<ExpressApiTariffsCalculateResource> spExpressApiTariffsCalculateResource) {
    m_spExpressApiTariffsCalculateResource = spExpressApiTariffsCalculateResource;
    m_service->publish(m_spExpressApiTariffsCalculateResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource(std::shared_ptr<ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource> spExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource) {
    m_spExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource = spExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource(std::shared_ptr<ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource> spExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource) {
    m_spExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource = spExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdChatsNewResource(std::shared_ptr<ExpressApiBusinessesBusinessIdChatsNewResource> spExpressApiBusinessesBusinessIdChatsNewResource) {
    m_spExpressApiBusinessesBusinessIdChatsNewResource = spExpressApiBusinessesBusinessIdChatsNewResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdChatsNewResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffersDeleteResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffersDeleteResource> spExpressApiCampaignsCampaignIdOffersDeleteResource) {
    m_spExpressApiCampaignsCampaignIdOffersDeleteResource = spExpressApiCampaignsCampaignIdOffersDeleteResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffersDeleteResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource(std::shared_ptr<ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource> spExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource) {
    m_spExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource = spExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdHidden-offersDeleteResource(std::shared_ptr<ExpressApiCampaignsCampaignIdHidden-offersDeleteResource> spExpressApiCampaignsCampaignIdHidden-offersDeleteResource) {
    m_spExpressApiCampaignsCampaignIdHidden-offersDeleteResource = spExpressApiCampaignsCampaignIdHidden-offersDeleteResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdHidden-offersDeleteResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource> spExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource) {
    m_spExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource = spExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource> spExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource) {
    m_spExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource = spExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdPromosOffersDeleteResource(std::shared_ptr<ExpressApiBusinessesBusinessIdPromosOffersDeleteResource> spExpressApiBusinessesBusinessIdPromosOffersDeleteResource) {
    m_spExpressApiBusinessesBusinessIdPromosOffersDeleteResource = spExpressApiBusinessesBusinessIdPromosOffersDeleteResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdPromosOffersDeleteResource);
}
void ExpressApi::setExpressApiReportsBoost-consolidatedGenerateResource(std::shared_ptr<ExpressApiReportsBoost-consolidatedGenerateResource> spExpressApiReportsBoost-consolidatedGenerateResource) {
    m_spExpressApiReportsBoost-consolidatedGenerateResource = spExpressApiReportsBoost-consolidatedGenerateResource;
    m_service->publish(m_spExpressApiReportsBoost-consolidatedGenerateResource);
}
void ExpressApi::setExpressApiReportsCompetitors-positionGenerateResource(std::shared_ptr<ExpressApiReportsCompetitors-positionGenerateResource> spExpressApiReportsCompetitors-positionGenerateResource) {
    m_spExpressApiReportsCompetitors-positionGenerateResource = spExpressApiReportsCompetitors-positionGenerateResource;
    m_service->publish(m_spExpressApiReportsCompetitors-positionGenerateResource);
}
void ExpressApi::setExpressApiReportsGoods-feedbackGenerateResource(std::shared_ptr<ExpressApiReportsGoods-feedbackGenerateResource> spExpressApiReportsGoods-feedbackGenerateResource) {
    m_spExpressApiReportsGoods-feedbackGenerateResource = spExpressApiReportsGoods-feedbackGenerateResource;
    m_service->publish(m_spExpressApiReportsGoods-feedbackGenerateResource);
}
void ExpressApi::setExpressApiReportsGoods-realizationGenerateResource(std::shared_ptr<ExpressApiReportsGoods-realizationGenerateResource> spExpressApiReportsGoods-realizationGenerateResource) {
    m_spExpressApiReportsGoods-realizationGenerateResource = spExpressApiReportsGoods-realizationGenerateResource;
    m_service->publish(m_spExpressApiReportsGoods-realizationGenerateResource);
}
void ExpressApi::setExpressApiReportsDocumentsLabelsGenerateResource(std::shared_ptr<ExpressApiReportsDocumentsLabelsGenerateResource> spExpressApiReportsDocumentsLabelsGenerateResource) {
    m_spExpressApiReportsDocumentsLabelsGenerateResource = spExpressApiReportsDocumentsLabelsGenerateResource;
    m_service->publish(m_spExpressApiReportsDocumentsLabelsGenerateResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource> spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource = spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource> spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource = spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource);
}
void ExpressApi::setExpressApiReportsPricesGenerateResource(std::shared_ptr<ExpressApiReportsPricesGenerateResource> spExpressApiReportsPricesGenerateResource) {
    m_spExpressApiReportsPricesGenerateResource = spExpressApiReportsPricesGenerateResource;
    m_service->publish(m_spExpressApiReportsPricesGenerateResource);
}
void ExpressApi::setExpressApiReportsShelf-statisticsGenerateResource(std::shared_ptr<ExpressApiReportsShelf-statisticsGenerateResource> spExpressApiReportsShelf-statisticsGenerateResource) {
    m_spExpressApiReportsShelf-statisticsGenerateResource = spExpressApiReportsShelf-statisticsGenerateResource;
    m_service->publish(m_spExpressApiReportsShelf-statisticsGenerateResource);
}
void ExpressApi::setExpressApiReportsShows-salesGenerateResource(std::shared_ptr<ExpressApiReportsShows-salesGenerateResource> spExpressApiReportsShows-salesGenerateResource) {
    m_spExpressApiReportsShows-salesGenerateResource = spExpressApiReportsShows-salesGenerateResource;
    m_service->publish(m_spExpressApiReportsShows-salesGenerateResource);
}
void ExpressApi::setExpressApiReportsStocks-on-warehousesGenerateResource(std::shared_ptr<ExpressApiReportsStocks-on-warehousesGenerateResource> spExpressApiReportsStocks-on-warehousesGenerateResource) {
    m_spExpressApiReportsStocks-on-warehousesGenerateResource = spExpressApiReportsStocks-on-warehousesGenerateResource;
    m_service->publish(m_spExpressApiReportsStocks-on-warehousesGenerateResource);
}
void ExpressApi::setExpressApiReportsUnited-marketplace-servicesGenerateResource(std::shared_ptr<ExpressApiReportsUnited-marketplace-servicesGenerateResource> spExpressApiReportsUnited-marketplace-servicesGenerateResource) {
    m_spExpressApiReportsUnited-marketplace-servicesGenerateResource = spExpressApiReportsUnited-marketplace-servicesGenerateResource;
    m_service->publish(m_spExpressApiReportsUnited-marketplace-servicesGenerateResource);
}
void ExpressApi::setExpressApiReportsUnited-nettingGenerateResource(std::shared_ptr<ExpressApiReportsUnited-nettingGenerateResource> spExpressApiReportsUnited-nettingGenerateResource) {
    m_spExpressApiReportsUnited-nettingGenerateResource = spExpressApiReportsUnited-nettingGenerateResource;
    m_service->publish(m_spExpressApiReportsUnited-nettingGenerateResource);
}
void ExpressApi::setExpressApiReportsUnited-ordersGenerateResource(std::shared_ptr<ExpressApiReportsUnited-ordersGenerateResource> spExpressApiReportsUnited-ordersGenerateResource) {
    m_spExpressApiReportsUnited-ordersGenerateResource = spExpressApiReportsUnited-ordersGenerateResource;
    m_service->publish(m_spExpressApiReportsUnited-ordersGenerateResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffersAllResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffersAllResource> spExpressApiCampaignsCampaignIdOffersAllResource) {
    m_spExpressApiCampaignsCampaignIdOffersAllResource = spExpressApiCampaignsCampaignIdOffersAllResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffersAllResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdBidsInfoResource(std::shared_ptr<ExpressApiBusinessesBusinessIdBidsInfoResource> spExpressApiBusinessesBusinessIdBidsInfoResource) {
    m_spExpressApiBusinessesBusinessIdBidsInfoResource = spExpressApiBusinessesBusinessIdBidsInfoResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdBidsInfoResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdBidsRecommendationsResource(std::shared_ptr<ExpressApiBusinessesBusinessIdBidsRecommendationsResource> spExpressApiBusinessesBusinessIdBidsRecommendationsResource) {
    m_spExpressApiBusinessesBusinessIdBidsRecommendationsResource = spExpressApiBusinessesBusinessIdBidsRecommendationsResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdBidsRecommendationsResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdPrice-quarantineResource(std::shared_ptr<ExpressApiBusinessesBusinessIdPrice-quarantineResource> spExpressApiBusinessesBusinessIdPrice-quarantineResource) {
    m_spExpressApiBusinessesBusinessIdPrice-quarantineResource = spExpressApiBusinessesBusinessIdPrice-quarantineResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdPrice-quarantineResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdSettingsResource(std::shared_ptr<ExpressApiBusinessesBusinessIdSettingsResource> spExpressApiBusinessesBusinessIdSettingsResource) {
    m_spExpressApiBusinessesBusinessIdSettingsResource = spExpressApiBusinessesBusinessIdSettingsResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdSettingsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdResource(std::shared_ptr<ExpressApiCampaignsCampaignIdResource> spExpressApiCampaignsCampaignIdResource) {
    m_spExpressApiCampaignsCampaignIdResource = spExpressApiCampaignsCampaignIdResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdLoginsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdLoginsResource> spExpressApiCampaignsCampaignIdLoginsResource) {
    m_spExpressApiCampaignsCampaignIdLoginsResource = spExpressApiCampaignsCampaignIdLoginsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdLoginsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffersResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffersResource> spExpressApiCampaignsCampaignIdOffersResource) {
    m_spExpressApiCampaignsCampaignIdOffersResource = spExpressApiCampaignsCampaignIdOffersResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffersResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdPrice-quarantineResource(std::shared_ptr<ExpressApiCampaignsCampaignIdPrice-quarantineResource> spExpressApiCampaignsCampaignIdPrice-quarantineResource) {
    m_spExpressApiCampaignsCampaignIdPrice-quarantineResource = spExpressApiCampaignsCampaignIdPrice-quarantineResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdPrice-quarantineResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdRegionResource(std::shared_ptr<ExpressApiCampaignsCampaignIdRegionResource> spExpressApiCampaignsCampaignIdRegionResource) {
    m_spExpressApiCampaignsCampaignIdRegionResource = spExpressApiCampaignsCampaignIdRegionResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdRegionResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdSettingsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdSettingsResource> spExpressApiCampaignsCampaignIdSettingsResource) {
    m_spExpressApiCampaignsCampaignIdSettingsResource = spExpressApiCampaignsCampaignIdSettingsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdSettingsResource);
}
void ExpressApi::setExpressApiCampaignsResource(std::shared_ptr<ExpressApiCampaignsResource> spExpressApiCampaignsResource) {
    m_spExpressApiCampaignsResource = spExpressApiCampaignsResource;
    m_service->publish(m_spExpressApiCampaignsResource);
}
void ExpressApi::setExpressApiCampaignsBy_loginLoginResource(std::shared_ptr<ExpressApiCampaignsBy_loginLoginResource> spExpressApiCampaignsBy_loginLoginResource) {
    m_spExpressApiCampaignsBy_loginLoginResource = spExpressApiCampaignsBy_loginLoginResource;
    m_service->publish(m_spExpressApiCampaignsBy_loginLoginResource);
}
void ExpressApi::setExpressApiCategoriesMax-sale-quantumResource(std::shared_ptr<ExpressApiCategoriesMax-sale-quantumResource> spExpressApiCategoriesMax-sale-quantumResource) {
    m_spExpressApiCategoriesMax-sale-quantumResource = spExpressApiCategoriesMax-sale-quantumResource;
    m_service->publish(m_spExpressApiCategoriesMax-sale-quantumResource);
}
void ExpressApi::setExpressApiCategoriesTreeResource(std::shared_ptr<ExpressApiCategoriesTreeResource> spExpressApiCategoriesTreeResource) {
    m_spExpressApiCategoriesTreeResource = spExpressApiCategoriesTreeResource;
    m_service->publish(m_spExpressApiCategoriesTreeResource);
}
void ExpressApi::setExpressApiCategoryCategoryIdParametersResource(std::shared_ptr<ExpressApiCategoryCategoryIdParametersResource> spExpressApiCategoryCategoryIdParametersResource) {
    m_spExpressApiCategoryCategoryIdParametersResource = spExpressApiCategoryCategoryIdParametersResource;
    m_service->publish(m_spExpressApiCategoryCategoryIdParametersResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdChatsHistoryResource(std::shared_ptr<ExpressApiBusinessesBusinessIdChatsHistoryResource> spExpressApiBusinessesBusinessIdChatsHistoryResource) {
    m_spExpressApiBusinessesBusinessIdChatsHistoryResource = spExpressApiBusinessesBusinessIdChatsHistoryResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdChatsHistoryResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdChatsResource(std::shared_ptr<ExpressApiBusinessesBusinessIdChatsResource> spExpressApiBusinessesBusinessIdChatsResource) {
    m_spExpressApiBusinessesBusinessIdChatsResource = spExpressApiBusinessesBusinessIdChatsResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdChatsResource);
}
void ExpressApi::setExpressApiDeliveryServicesResource(std::shared_ptr<ExpressApiDeliveryServicesResource> spExpressApiDeliveryServicesResource) {
    m_spExpressApiDeliveryServicesResource = spExpressApiDeliveryServicesResource;
    m_service->publish(m_spExpressApiDeliveryServicesResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdFeedsFeedIdResource(std::shared_ptr<ExpressApiCampaignsCampaignIdFeedsFeedIdResource> spExpressApiCampaignsCampaignIdFeedsFeedIdResource) {
    m_spExpressApiCampaignsCampaignIdFeedsFeedIdResource = spExpressApiCampaignsCampaignIdFeedsFeedIdResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdFeedsFeedIdResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource> spExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource) {
    m_spExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource = spExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdFeedbackUpdatesResource(std::shared_ptr<ExpressApiCampaignsCampaignIdFeedbackUpdatesResource> spExpressApiCampaignsCampaignIdFeedbackUpdatesResource) {
    m_spExpressApiCampaignsCampaignIdFeedbackUpdatesResource = spExpressApiCampaignsCampaignIdFeedbackUpdatesResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdFeedbackUpdatesResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdFeedsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdFeedsResource> spExpressApiCampaignsCampaignIdFeedsResource) {
    m_spExpressApiCampaignsCampaignIdFeedsResource = spExpressApiCampaignsCampaignIdFeedsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdFeedsResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource(std::shared_ptr<ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource> spExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource) {
    m_spExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource = spExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdGoods-feedbackResource(std::shared_ptr<ExpressApiBusinessesBusinessIdGoods-feedbackResource> spExpressApiBusinessesBusinessIdGoods-feedbackResource) {
    m_spExpressApiBusinessesBusinessIdGoods-feedbackResource = spExpressApiBusinessesBusinessIdGoods-feedbackResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdGoods-feedbackResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdStatsSkusResource(std::shared_ptr<ExpressApiCampaignsCampaignIdStatsSkusResource> spExpressApiCampaignsCampaignIdStatsSkusResource) {
    m_spExpressApiCampaignsCampaignIdStatsSkusResource = spExpressApiCampaignsCampaignIdStatsSkusResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdStatsSkusResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffer-cardsResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffer-cardsResource> spExpressApiBusinessesBusinessIdOffer-cardsResource) {
    m_spExpressApiBusinessesBusinessIdOffer-cardsResource = spExpressApiBusinessesBusinessIdOffer-cardsResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffer-cardsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffer-mapping-entriesResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource> spExpressApiCampaignsCampaignIdOffer-mapping-entriesResource) {
    m_spExpressApiCampaignsCampaignIdOffer-mapping-entriesResource = spExpressApiCampaignsCampaignIdOffer-mapping-entriesResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffer-mapping-entriesResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffer-mappingsResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffer-mappingsResource> spExpressApiBusinessesBusinessIdOffer-mappingsResource) {
    m_spExpressApiBusinessesBusinessIdOffer-mappingsResource = spExpressApiBusinessesBusinessIdOffer-mappingsResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffer-mappingsResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffersRecommendationsResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffersRecommendationsResource> spExpressApiBusinessesBusinessIdOffersRecommendationsResource) {
    m_spExpressApiBusinessesBusinessIdOffersRecommendationsResource = spExpressApiBusinessesBusinessIdOffersRecommendationsResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffersRecommendationsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdResource> spExpressApiCampaignsCampaignIdOrdersOrderIdResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdResource = spExpressApiCampaignsCampaignIdOrdersOrderIdResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource> spExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource = spExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource> spExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource = spExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource> spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource = spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersResource> spExpressApiCampaignsCampaignIdOrdersResource) {
    m_spExpressApiCampaignsCampaignIdOrdersResource = spExpressApiCampaignsCampaignIdOrdersResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdStatsOrdersResource(std::shared_ptr<ExpressApiCampaignsCampaignIdStatsOrdersResource> spExpressApiCampaignsCampaignIdStatsOrdersResource) {
    m_spExpressApiCampaignsCampaignIdStatsOrdersResource = spExpressApiCampaignsCampaignIdStatsOrdersResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdStatsOrdersResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffer-pricesResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffer-pricesResource> spExpressApiCampaignsCampaignIdOffer-pricesResource) {
    m_spExpressApiCampaignsCampaignIdOffer-pricesResource = spExpressApiCampaignsCampaignIdOffer-pricesResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffer-pricesResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdPromosOffersResource(std::shared_ptr<ExpressApiBusinessesBusinessIdPromosOffersResource> spExpressApiBusinessesBusinessIdPromosOffersResource) {
    m_spExpressApiBusinessesBusinessIdPromosOffersResource = spExpressApiBusinessesBusinessIdPromosOffersResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdPromosOffersResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdPromosResource(std::shared_ptr<ExpressApiBusinessesBusinessIdPromosResource> spExpressApiBusinessesBusinessIdPromosResource) {
    m_spExpressApiBusinessesBusinessIdPromosResource = spExpressApiBusinessesBusinessIdPromosResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdPromosResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdRatingsQualityDetailsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource> spExpressApiCampaignsCampaignIdRatingsQualityDetailsResource) {
    m_spExpressApiCampaignsCampaignIdRatingsQualityDetailsResource = spExpressApiCampaignsCampaignIdRatingsQualityDetailsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdRatingsQualityDetailsResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdRatingsQualityResource(std::shared_ptr<ExpressApiBusinessesBusinessIdRatingsQualityResource> spExpressApiBusinessesBusinessIdRatingsQualityResource) {
    m_spExpressApiBusinessesBusinessIdRatingsQualityResource = spExpressApiBusinessesBusinessIdRatingsQualityResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdRatingsQualityResource);
}
void ExpressApi::setExpressApiReportsInfoReportIdResource(std::shared_ptr<ExpressApiReportsInfoReportIdResource> spExpressApiReportsInfoReportIdResource) {
    m_spExpressApiReportsInfoReportIdResource = spExpressApiReportsInfoReportIdResource;
    m_service->publish(m_spExpressApiReportsInfoReportIdResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource> spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource = spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource> spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource = spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource> spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource = spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdReturnsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdReturnsResource> spExpressApiCampaignsCampaignIdReturnsResource) {
    m_spExpressApiCampaignsCampaignIdReturnsResource = spExpressApiCampaignsCampaignIdReturnsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdReturnsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffersStocksResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffersStocksResource> spExpressApiCampaignsCampaignIdOffersStocksResource) {
    m_spExpressApiCampaignsCampaignIdOffersStocksResource = spExpressApiCampaignsCampaignIdOffersStocksResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffersStocksResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource> spExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource) {
    m_spExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource = spExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource> spExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource) {
    m_spExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource = spExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource> spExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource) {
    m_spExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource = spExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdWarehousesResource(std::shared_ptr<ExpressApiBusinessesBusinessIdWarehousesResource> spExpressApiBusinessesBusinessIdWarehousesResource) {
    m_spExpressApiBusinessesBusinessIdWarehousesResource = spExpressApiBusinessesBusinessIdWarehousesResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdWarehousesResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource> spExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource = spExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdBidsResource(std::shared_ptr<ExpressApiBusinessesBusinessIdBidsResource> spExpressApiBusinessesBusinessIdBidsResource) {
    m_spExpressApiBusinessesBusinessIdBidsResource = spExpressApiBusinessesBusinessIdBidsResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdBidsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdBidsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdBidsResource> spExpressApiCampaignsCampaignIdBidsResource) {
    m_spExpressApiCampaignsCampaignIdBidsResource = spExpressApiCampaignsCampaignIdBidsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdBidsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource(std::shared_ptr<ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource> spExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource) {
    m_spExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource = spExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource);
}
void ExpressApi::setExpressApiRegionsRegionIdChildrenResource(std::shared_ptr<ExpressApiRegionsRegionIdChildrenResource> spExpressApiRegionsRegionIdChildrenResource) {
    m_spExpressApiRegionsRegionIdChildrenResource = spExpressApiRegionsRegionIdChildrenResource;
    m_service->publish(m_spExpressApiRegionsRegionIdChildrenResource);
}
void ExpressApi::setExpressApiRegionsRegionIdResource(std::shared_ptr<ExpressApiRegionsRegionIdResource> spExpressApiRegionsRegionIdResource) {
    m_spExpressApiRegionsRegionIdResource = spExpressApiRegionsRegionIdResource;
    m_service->publish(m_spExpressApiRegionsRegionIdResource);
}
void ExpressApi::setExpressApiRegionsResource(std::shared_ptr<ExpressApiRegionsResource> spExpressApiRegionsResource) {
    m_spExpressApiRegionsResource = spExpressApiRegionsResource;
    m_service->publish(m_spExpressApiRegionsResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdChatsFileSendResource(std::shared_ptr<ExpressApiBusinessesBusinessIdChatsFileSendResource> spExpressApiBusinessesBusinessIdChatsFileSendResource) {
    m_spExpressApiBusinessesBusinessIdChatsFileSendResource = spExpressApiBusinessesBusinessIdChatsFileSendResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdChatsFileSendResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdChatsMessageResource(std::shared_ptr<ExpressApiBusinessesBusinessIdChatsMessageResource> spExpressApiBusinessesBusinessIdChatsMessageResource) {
    m_spExpressApiBusinessesBusinessIdChatsMessageResource = spExpressApiBusinessesBusinessIdChatsMessageResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdChatsMessageResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource> spExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource) {
    m_spExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource = spExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource> spExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource = spExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource> spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource = spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource(std::shared_ptr<ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource> spExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource) {
    m_spExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource = spExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource> spExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource) {
    m_spExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource = spExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffersUpdateResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffersUpdateResource> spExpressApiCampaignsCampaignIdOffersUpdateResource) {
    m_spExpressApiCampaignsCampaignIdOffersUpdateResource = spExpressApiCampaignsCampaignIdOffersUpdateResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffersUpdateResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource(std::shared_ptr<ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource> spExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource) {
    m_spExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource = spExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffer-cardsUpdateResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource> spExpressApiBusinessesBusinessIdOffer-cardsUpdateResource) {
    m_spExpressApiBusinessesBusinessIdOffer-cardsUpdateResource = spExpressApiBusinessesBusinessIdOffer-cardsUpdateResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffer-cardsUpdateResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource> spExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource) {
    m_spExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource = spExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource(std::shared_ptr<ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource> spExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource) {
    m_spExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource = spExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource> spExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource = spExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource> spExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource = spExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersStatus-updateResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersStatus-updateResource> spExpressApiCampaignsCampaignIdOrdersStatus-updateResource) {
    m_spExpressApiCampaignsCampaignIdOrdersStatus-updateResource = spExpressApiCampaignsCampaignIdOrdersStatus-updateResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersStatus-updateResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource> spExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource) {
    m_spExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource = spExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource);
}
void ExpressApi::setExpressApiBusinessesBusinessIdPromosOffersUpdateResource(std::shared_ptr<ExpressApiBusinessesBusinessIdPromosOffersUpdateResource> spExpressApiBusinessesBusinessIdPromosOffersUpdateResource) {
    m_spExpressApiBusinessesBusinessIdPromosOffersUpdateResource = spExpressApiBusinessesBusinessIdPromosOffersUpdateResource;
    m_service->publish(m_spExpressApiBusinessesBusinessIdPromosOffersUpdateResource);
}
void ExpressApi::setExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource(std::shared_ptr<ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource> spExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource) {
    m_spExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource = spExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource;
    m_service->publish(m_spExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource);
}


void ExpressApi::publishDefaultResources() {
    if (!m_spExpressApiCampaignsCampaignIdHidden-offersResource) {
        setExpressApiCampaignsCampaignIdHidden-offersResource(std::make_shared<ExpressApiCampaignsCampaignIdHidden-offersResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource) {
        setExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource(std::make_shared<ExpressApiBusinessesBusinessIdOffer-mappingsArchiveResource>());
    }
    if (!m_spExpressApiTariffsCalculateResource) {
        setExpressApiTariffsCalculateResource(std::make_shared<ExpressApiTariffsCalculateResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource) {
        setExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource(std::make_shared<ExpressApiBusinessesBusinessIdPrice-quarantineConfirmResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource) {
        setExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource(std::make_shared<ExpressApiCampaignsCampaignIdPrice-quarantineConfirmResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdChatsNewResource) {
        setExpressApiBusinessesBusinessIdChatsNewResource(std::make_shared<ExpressApiBusinessesBusinessIdChatsNewResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffersDeleteResource) {
        setExpressApiCampaignsCampaignIdOffersDeleteResource(std::make_shared<ExpressApiCampaignsCampaignIdOffersDeleteResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource) {
        setExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource(std::make_shared<ExpressApiBusinessesBusinessIdGoods-feedbackCommentsDeleteResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdHidden-offersDeleteResource) {
        setExpressApiCampaignsCampaignIdHidden-offersDeleteResource(std::make_shared<ExpressApiCampaignsCampaignIdHidden-offersDeleteResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource) {
        setExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource(std::make_shared<ExpressApiBusinessesBusinessIdOffer-mappingsDeleteResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource) {
        setExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource(std::make_shared<ExpressApiBusinessesBusinessIdOffer-mappingsUnarchiveResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdPromosOffersDeleteResource) {
        setExpressApiBusinessesBusinessIdPromosOffersDeleteResource(std::make_shared<ExpressApiBusinessesBusinessIdPromosOffersDeleteResource>());
    }
    if (!m_spExpressApiReportsBoost-consolidatedGenerateResource) {
        setExpressApiReportsBoost-consolidatedGenerateResource(std::make_shared<ExpressApiReportsBoost-consolidatedGenerateResource>());
    }
    if (!m_spExpressApiReportsCompetitors-positionGenerateResource) {
        setExpressApiReportsCompetitors-positionGenerateResource(std::make_shared<ExpressApiReportsCompetitors-positionGenerateResource>());
    }
    if (!m_spExpressApiReportsGoods-feedbackGenerateResource) {
        setExpressApiReportsGoods-feedbackGenerateResource(std::make_shared<ExpressApiReportsGoods-feedbackGenerateResource>());
    }
    if (!m_spExpressApiReportsGoods-realizationGenerateResource) {
        setExpressApiReportsGoods-realizationGenerateResource(std::make_shared<ExpressApiReportsGoods-realizationGenerateResource>());
    }
    if (!m_spExpressApiReportsDocumentsLabelsGenerateResource) {
        setExpressApiReportsDocumentsLabelsGenerateResource(std::make_shared<ExpressApiReportsDocumentsLabelsGenerateResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesBoxIdLabelResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsResource>());
    }
    if (!m_spExpressApiReportsPricesGenerateResource) {
        setExpressApiReportsPricesGenerateResource(std::make_shared<ExpressApiReportsPricesGenerateResource>());
    }
    if (!m_spExpressApiReportsShelf-statisticsGenerateResource) {
        setExpressApiReportsShelf-statisticsGenerateResource(std::make_shared<ExpressApiReportsShelf-statisticsGenerateResource>());
    }
    if (!m_spExpressApiReportsShows-salesGenerateResource) {
        setExpressApiReportsShows-salesGenerateResource(std::make_shared<ExpressApiReportsShows-salesGenerateResource>());
    }
    if (!m_spExpressApiReportsStocks-on-warehousesGenerateResource) {
        setExpressApiReportsStocks-on-warehousesGenerateResource(std::make_shared<ExpressApiReportsStocks-on-warehousesGenerateResource>());
    }
    if (!m_spExpressApiReportsUnited-marketplace-servicesGenerateResource) {
        setExpressApiReportsUnited-marketplace-servicesGenerateResource(std::make_shared<ExpressApiReportsUnited-marketplace-servicesGenerateResource>());
    }
    if (!m_spExpressApiReportsUnited-nettingGenerateResource) {
        setExpressApiReportsUnited-nettingGenerateResource(std::make_shared<ExpressApiReportsUnited-nettingGenerateResource>());
    }
    if (!m_spExpressApiReportsUnited-ordersGenerateResource) {
        setExpressApiReportsUnited-ordersGenerateResource(std::make_shared<ExpressApiReportsUnited-ordersGenerateResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffersAllResource) {
        setExpressApiCampaignsCampaignIdOffersAllResource(std::make_shared<ExpressApiCampaignsCampaignIdOffersAllResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdBidsInfoResource) {
        setExpressApiBusinessesBusinessIdBidsInfoResource(std::make_shared<ExpressApiBusinessesBusinessIdBidsInfoResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdBidsRecommendationsResource) {
        setExpressApiBusinessesBusinessIdBidsRecommendationsResource(std::make_shared<ExpressApiBusinessesBusinessIdBidsRecommendationsResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdPrice-quarantineResource) {
        setExpressApiBusinessesBusinessIdPrice-quarantineResource(std::make_shared<ExpressApiBusinessesBusinessIdPrice-quarantineResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdSettingsResource) {
        setExpressApiBusinessesBusinessIdSettingsResource(std::make_shared<ExpressApiBusinessesBusinessIdSettingsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdResource) {
        setExpressApiCampaignsCampaignIdResource(std::make_shared<ExpressApiCampaignsCampaignIdResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdLoginsResource) {
        setExpressApiCampaignsCampaignIdLoginsResource(std::make_shared<ExpressApiCampaignsCampaignIdLoginsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffersResource) {
        setExpressApiCampaignsCampaignIdOffersResource(std::make_shared<ExpressApiCampaignsCampaignIdOffersResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdPrice-quarantineResource) {
        setExpressApiCampaignsCampaignIdPrice-quarantineResource(std::make_shared<ExpressApiCampaignsCampaignIdPrice-quarantineResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdRegionResource) {
        setExpressApiCampaignsCampaignIdRegionResource(std::make_shared<ExpressApiCampaignsCampaignIdRegionResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdSettingsResource) {
        setExpressApiCampaignsCampaignIdSettingsResource(std::make_shared<ExpressApiCampaignsCampaignIdSettingsResource>());
    }
    if (!m_spExpressApiCampaignsResource) {
        setExpressApiCampaignsResource(std::make_shared<ExpressApiCampaignsResource>());
    }
    if (!m_spExpressApiCampaignsBy_loginLoginResource) {
        setExpressApiCampaignsBy_loginLoginResource(std::make_shared<ExpressApiCampaignsBy_loginLoginResource>());
    }
    if (!m_spExpressApiCategoriesMax-sale-quantumResource) {
        setExpressApiCategoriesMax-sale-quantumResource(std::make_shared<ExpressApiCategoriesMax-sale-quantumResource>());
    }
    if (!m_spExpressApiCategoriesTreeResource) {
        setExpressApiCategoriesTreeResource(std::make_shared<ExpressApiCategoriesTreeResource>());
    }
    if (!m_spExpressApiCategoryCategoryIdParametersResource) {
        setExpressApiCategoryCategoryIdParametersResource(std::make_shared<ExpressApiCategoryCategoryIdParametersResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdChatsHistoryResource) {
        setExpressApiBusinessesBusinessIdChatsHistoryResource(std::make_shared<ExpressApiBusinessesBusinessIdChatsHistoryResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdChatsResource) {
        setExpressApiBusinessesBusinessIdChatsResource(std::make_shared<ExpressApiBusinessesBusinessIdChatsResource>());
    }
    if (!m_spExpressApiDeliveryServicesResource) {
        setExpressApiDeliveryServicesResource(std::make_shared<ExpressApiDeliveryServicesResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdFeedsFeedIdResource) {
        setExpressApiCampaignsCampaignIdFeedsFeedIdResource(std::make_shared<ExpressApiCampaignsCampaignIdFeedsFeedIdResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource) {
        setExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource(std::make_shared<ExpressApiCampaignsCampaignIdFeedsFeedIdIndex-logsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdFeedbackUpdatesResource) {
        setExpressApiCampaignsCampaignIdFeedbackUpdatesResource(std::make_shared<ExpressApiCampaignsCampaignIdFeedbackUpdatesResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdFeedsResource) {
        setExpressApiCampaignsCampaignIdFeedsResource(std::make_shared<ExpressApiCampaignsCampaignIdFeedsResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource) {
        setExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource(std::make_shared<ExpressApiBusinessesBusinessIdGoods-feedbackCommentsResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdGoods-feedbackResource) {
        setExpressApiBusinessesBusinessIdGoods-feedbackResource(std::make_shared<ExpressApiBusinessesBusinessIdGoods-feedbackResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdStatsSkusResource) {
        setExpressApiCampaignsCampaignIdStatsSkusResource(std::make_shared<ExpressApiCampaignsCampaignIdStatsSkusResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffer-cardsResource) {
        setExpressApiBusinessesBusinessIdOffer-cardsResource(std::make_shared<ExpressApiBusinessesBusinessIdOffer-cardsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffer-mapping-entriesResource) {
        setExpressApiCampaignsCampaignIdOffer-mapping-entriesResource(std::make_shared<ExpressApiCampaignsCampaignIdOffer-mapping-entriesResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffer-mappingsResource) {
        setExpressApiBusinessesBusinessIdOffer-mappingsResource(std::make_shared<ExpressApiBusinessesBusinessIdOffer-mappingsResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffersRecommendationsResource) {
        setExpressApiBusinessesBusinessIdOffersRecommendationsResource(std::make_shared<ExpressApiBusinessesBusinessIdOffersRecommendationsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdBusiness-buyerResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdDocumentsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryLabelsDataResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersResource) {
        setExpressApiCampaignsCampaignIdOrdersResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdStatsOrdersResource) {
        setExpressApiCampaignsCampaignIdStatsOrdersResource(std::make_shared<ExpressApiCampaignsCampaignIdStatsOrdersResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffer-pricesResource) {
        setExpressApiCampaignsCampaignIdOffer-pricesResource(std::make_shared<ExpressApiCampaignsCampaignIdOffer-pricesResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdPromosOffersResource) {
        setExpressApiBusinessesBusinessIdPromosOffersResource(std::make_shared<ExpressApiBusinessesBusinessIdPromosOffersResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdPromosResource) {
        setExpressApiBusinessesBusinessIdPromosResource(std::make_shared<ExpressApiBusinessesBusinessIdPromosResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdRatingsQualityDetailsResource) {
        setExpressApiCampaignsCampaignIdRatingsQualityDetailsResource(std::make_shared<ExpressApiCampaignsCampaignIdRatingsQualityDetailsResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdRatingsQualityResource) {
        setExpressApiBusinessesBusinessIdRatingsQualityResource(std::make_shared<ExpressApiBusinessesBusinessIdRatingsQualityResource>());
    }
    if (!m_spExpressApiReportsInfoReportIdResource) {
        setExpressApiReportsInfoReportIdResource(std::make_shared<ExpressApiReportsInfoReportIdResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdApplicationResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdReturnsReturnIdDecisionItemIdImageImageHashResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdReturnsResource) {
        setExpressApiCampaignsCampaignIdReturnsResource(std::make_shared<ExpressApiCampaignsCampaignIdReturnsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffersStocksResource) {
        setExpressApiCampaignsCampaignIdOffersStocksResource(std::make_shared<ExpressApiCampaignsCampaignIdOffersStocksResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource) {
        setExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource(std::make_shared<ExpressApiCampaignsCampaignIdOffer-mapping-entriesSuggestionsResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource) {
        setExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource(std::make_shared<ExpressApiBusinessesBusinessIdOffer-mappingsSuggestionsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource) {
        setExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource(std::make_shared<ExpressApiCampaignsCampaignIdOffer-pricesSuggestionsResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdWarehousesResource) {
        setExpressApiBusinessesBusinessIdWarehousesResource(std::make_shared<ExpressApiBusinessesBusinessIdWarehousesResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdIdentifiersResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdBidsResource) {
        setExpressApiBusinessesBusinessIdBidsResource(std::make_shared<ExpressApiBusinessesBusinessIdBidsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdBidsResource) {
        setExpressApiCampaignsCampaignIdBidsResource(std::make_shared<ExpressApiCampaignsCampaignIdBidsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource) {
        setExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource(std::make_shared<ExpressApiCampaignsCampaignIdFeedsFeedIdRefreshResource>());
    }
    if (!m_spExpressApiRegionsRegionIdChildrenResource) {
        setExpressApiRegionsRegionIdChildrenResource(std::make_shared<ExpressApiRegionsRegionIdChildrenResource>());
    }
    if (!m_spExpressApiRegionsRegionIdResource) {
        setExpressApiRegionsRegionIdResource(std::make_shared<ExpressApiRegionsRegionIdResource>());
    }
    if (!m_spExpressApiRegionsResource) {
        setExpressApiRegionsResource(std::make_shared<ExpressApiRegionsResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdChatsFileSendResource) {
        setExpressApiBusinessesBusinessIdChatsFileSendResource(std::make_shared<ExpressApiBusinessesBusinessIdChatsFileSendResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdChatsMessageResource) {
        setExpressApiBusinessesBusinessIdChatsMessageResource(std::make_shared<ExpressApiBusinessesBusinessIdChatsMessageResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource) {
        setExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource(std::make_shared<ExpressApiCampaignsCampaignIdFeedsFeedIdParamsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdBoxesResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdDeliveryShipmentsShipmentIdBoxesResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource) {
        setExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource(std::make_shared<ExpressApiBusinessesBusinessIdGoods-feedbackSkip-reactionResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource) {
        setExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource(std::make_shared<ExpressApiBusinessesBusinessIdOffer-pricesUpdatesResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffersUpdateResource) {
        setExpressApiCampaignsCampaignIdOffersUpdateResource(std::make_shared<ExpressApiCampaignsCampaignIdOffersUpdateResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource) {
        setExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource(std::make_shared<ExpressApiBusinessesBusinessIdGoods-feedbackCommentsUpdateResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffer-cardsUpdateResource) {
        setExpressApiBusinessesBusinessIdOffer-cardsUpdateResource(std::make_shared<ExpressApiBusinessesBusinessIdOffer-cardsUpdateResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource) {
        setExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource(std::make_shared<ExpressApiCampaignsCampaignIdOffer-mapping-entriesUpdatesResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource) {
        setExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource(std::make_shared<ExpressApiBusinessesBusinessIdOffer-mappingsUpdateResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdItemsResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdStatusResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersStatus-updateResource) {
        setExpressApiCampaignsCampaignIdOrdersStatus-updateResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersStatus-updateResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource) {
        setExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource(std::make_shared<ExpressApiCampaignsCampaignIdOffer-pricesUpdatesResource>());
    }
    if (!m_spExpressApiBusinessesBusinessIdPromosOffersUpdateResource) {
        setExpressApiBusinessesBusinessIdPromosOffersUpdateResource(std::make_shared<ExpressApiBusinessesBusinessIdPromosOffersUpdateResource>());
    }
    if (!m_spExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource) {
        setExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource(std::make_shared<ExpressApiCampaignsCampaignIdOrdersOrderIdVerifyEacResource>());
    }
}

std::shared_ptr<restbed::Service> ExpressApi::service() {
    return m_service;
}


}
}
}
}

