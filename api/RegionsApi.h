/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * RegionsApi.h
 *
 * 
 */

#ifndef RegionsApi_H_
#define RegionsApi_H_


#include <memory>
#include <utility>
#include <exception>
#include <functional>

#include <corvusoft/restbed/session.hpp>
#include <corvusoft/restbed/resource.hpp>
#include <corvusoft/restbed/request.hpp>
#include <corvusoft/restbed/service.hpp>
#include <corvusoft/restbed/settings.hpp>

#include "ApiClientDataErrorResponse.h"
#include "ApiForbiddenErrorResponse.h"
#include "ApiLimitErrorResponse.h"
#include "ApiNotFoundErrorResponse.h"
#include "ApiServerErrorResponse.h"
#include "ApiUnauthorizedErrorResponse.h"
#include "GetRegionWithChildrenResponse.h"
#include "GetRegionsResponse.h"
#include <string>

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

///
/// Exception to flag problems in the handlers
///
class  RegionsApiException: public std::exception
{
public:
    RegionsApiException(int status_code, std::string what);

    int getStatus() const;
    const char* what() const noexcept override;

private:
    int m_status;
    std::string m_what;
};

namespace RegionsApiResources {
/// <summary>
/// Информация о дочерних регионах
/// </summary>
/// <remarks>
/// Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов &#x60;GET regions&#x60;, &#x60;GET regions/{regionId}&#x60; и &#x60;GET regions/{regionId}/children&#x60; действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
/// </remarks>
class  RegionsRegionIdChildrenResource: public restbed::Resource
{
public:
    RegionsRegionIdChildrenResource(const std::string& context = "");
    virtual ~RegionsRegionIdChildrenResource() = default;

    RegionsRegionIdChildrenResource(
        const RegionsRegionIdChildrenResource& other) = default; // copy constructor
    RegionsRegionIdChildrenResource(RegionsRegionIdChildrenResource&& other) noexcept = default; // move constructor

    RegionsRegionIdChildrenResource& operator=(const RegionsRegionIdChildrenResource& other) = default; // copy assignment
    RegionsRegionIdChildrenResource& operator=(RegionsRegionIdChildrenResource&& other) noexcept = default; // move assignment

    /////////////////////////////////////////////////////
    // Set these to implement the server functionality //
    /////////////////////////////////////////////////////
    std::function<std::pair<int, GetRegionWithChildrenResponse>(
        int64_t & regionId, int32_t & page, int32_t & pageSize)> handler_GET_func =
            [](int64_t &, int32_t &, int32_t &) -> std::pair<int, GetRegionWithChildrenResponse>
                { throw RegionsApiException(501, "Not implemented"); };


protected:
    //////////////////////////////////////////////////////////
    // As an alternative to setting the `std::function`s    //
    // override these to implement the server functionality //
    //////////////////////////////////////////////////////////

    virtual std::pair<int, GetRegionWithChildrenResponse> handler_GET(
        int64_t & regionId, int32_t & page, int32_t & pageSize);


protected:
    //////////////////////////////////////
    // Override these for customization //
    //////////////////////////////////////

    virtual std::string extractBodyContent(const std::shared_ptr<restbed::Session>& session);
    virtual std::string extractFormParamsFromBody(const std::string& paramName, const std::string& body);

    virtual std::pair<int, std::string> handleRegionsApiException(const RegionsApiException& e);
    virtual std::pair<int, std::string> handleStdException(const std::exception& e);
    virtual std::pair<int, std::string> handleUnspecifiedException();

    virtual void setResponseHeader(const std::shared_ptr<restbed::Session>& session,
        const std::string& header);

    virtual void returnResponse(const std::shared_ptr<restbed::Session>& session,
        const int status, const std::string& result, std::multimap<std::string, std::string>& contentType);
    virtual void defaultSessionClose(const std::shared_ptr<restbed::Session>& session,
        const int status, const std::string& result);

private:
    void handler_GET_internal(const std::shared_ptr<restbed::Session> session);
};

/// <summary>
/// Информация о регионе
/// </summary>
/// <remarks>
/// Возвращает информацию о регионе.  Для методов &#x60;GET regions&#x60;, &#x60;GET regions/{regionId}&#x60; и &#x60;GET regions/{regionId}/children&#x60; действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
/// </remarks>
class  RegionsRegionIdResource: public restbed::Resource
{
public:
    RegionsRegionIdResource(const std::string& context = "");
    virtual ~RegionsRegionIdResource() = default;

    RegionsRegionIdResource(
        const RegionsRegionIdResource& other) = default; // copy constructor
    RegionsRegionIdResource(RegionsRegionIdResource&& other) noexcept = default; // move constructor

    RegionsRegionIdResource& operator=(const RegionsRegionIdResource& other) = default; // copy assignment
    RegionsRegionIdResource& operator=(RegionsRegionIdResource&& other) noexcept = default; // move assignment

    /////////////////////////////////////////////////////
    // Set these to implement the server functionality //
    /////////////////////////////////////////////////////
    std::function<std::pair<int, GetRegionsResponse>(
        int64_t & regionId)> handler_GET_func =
            [](int64_t &) -> std::pair<int, GetRegionsResponse>
                { throw RegionsApiException(501, "Not implemented"); };


protected:
    //////////////////////////////////////////////////////////
    // As an alternative to setting the `std::function`s    //
    // override these to implement the server functionality //
    //////////////////////////////////////////////////////////

    virtual std::pair<int, GetRegionsResponse> handler_GET(
        int64_t & regionId);


protected:
    //////////////////////////////////////
    // Override these for customization //
    //////////////////////////////////////

    virtual std::string extractBodyContent(const std::shared_ptr<restbed::Session>& session);
    virtual std::string extractFormParamsFromBody(const std::string& paramName, const std::string& body);

    virtual std::pair<int, std::string> handleRegionsApiException(const RegionsApiException& e);
    virtual std::pair<int, std::string> handleStdException(const std::exception& e);
    virtual std::pair<int, std::string> handleUnspecifiedException();

    virtual void setResponseHeader(const std::shared_ptr<restbed::Session>& session,
        const std::string& header);

    virtual void returnResponse(const std::shared_ptr<restbed::Session>& session,
        const int status, const std::string& result, std::multimap<std::string, std::string>& contentType);
    virtual void defaultSessionClose(const std::shared_ptr<restbed::Session>& session,
        const int status, const std::string& result);

private:
    void handler_GET_internal(const std::shared_ptr<restbed::Session> session);
};

/// <summary>
/// Поиск регионов по их имени
/// </summary>
/// <remarks>
/// Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов &#x60;GET regions&#x60;, &#x60;GET regions/{regionId}&#x60; и &#x60;GET regions/{regionId}/children&#x60; действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
/// </remarks>
class  RegionsResource: public restbed::Resource
{
public:
    RegionsResource(const std::string& context = "");
    virtual ~RegionsResource() = default;

    RegionsResource(
        const RegionsResource& other) = default; // copy constructor
    RegionsResource(RegionsResource&& other) noexcept = default; // move constructor

    RegionsResource& operator=(const RegionsResource& other) = default; // copy assignment
    RegionsResource& operator=(RegionsResource&& other) noexcept = default; // move assignment

    /////////////////////////////////////////////////////
    // Set these to implement the server functionality //
    /////////////////////////////////////////////////////
    std::function<std::pair<int, GetRegionsResponse>(
        std::string & name, std::string & pageToken, int32_t & limit)> handler_GET_func =
            [](std::string &, std::string &, int32_t &) -> std::pair<int, GetRegionsResponse>
                { throw RegionsApiException(501, "Not implemented"); };


protected:
    //////////////////////////////////////////////////////////
    // As an alternative to setting the `std::function`s    //
    // override these to implement the server functionality //
    //////////////////////////////////////////////////////////

    virtual std::pair<int, GetRegionsResponse> handler_GET(
        std::string & name, std::string & pageToken, int32_t & limit);


protected:
    //////////////////////////////////////
    // Override these for customization //
    //////////////////////////////////////

    virtual std::string extractBodyContent(const std::shared_ptr<restbed::Session>& session);
    virtual std::string extractFormParamsFromBody(const std::string& paramName, const std::string& body);

    virtual std::pair<int, std::string> handleRegionsApiException(const RegionsApiException& e);
    virtual std::pair<int, std::string> handleStdException(const std::exception& e);
    virtual std::pair<int, std::string> handleUnspecifiedException();

    virtual void setResponseHeader(const std::shared_ptr<restbed::Session>& session,
        const std::string& header);

    virtual void returnResponse(const std::shared_ptr<restbed::Session>& session,
        const int status, const std::string& result, std::multimap<std::string, std::string>& contentType);
    virtual void defaultSessionClose(const std::shared_ptr<restbed::Session>& session,
        const int status, const std::string& result);

private:
    void handler_GET_internal(const std::shared_ptr<restbed::Session> session);
};

} /* namespace RegionsApiResources */

using RegionsApiRegionsRegionIdChildrenResource [[deprecated]] = RegionsApiResources::RegionsRegionIdChildrenResource;
using RegionsApiRegionsRegionIdResource [[deprecated]] = RegionsApiResources::RegionsRegionIdResource;
using RegionsApiRegionsResource [[deprecated]] = RegionsApiResources::RegionsResource;

//
// The restbed service to actually implement the REST server
//
class  RegionsApi
{
public:
    explicit RegionsApi(std::shared_ptr<restbed::Service> const& restbedService);
    virtual ~RegionsApi();

    std::shared_ptr<RegionsApiResources::RegionsRegionIdChildrenResource> getRegionsRegionIdChildrenResource();
    std::shared_ptr<RegionsApiResources::RegionsRegionIdResource> getRegionsRegionIdResource();
    std::shared_ptr<RegionsApiResources::RegionsResource> getRegionsResource();

    void setResource(std::shared_ptr<RegionsApiResources::RegionsRegionIdChildrenResource> resource);
    void setResource(std::shared_ptr<RegionsApiResources::RegionsRegionIdResource> resource);
    void setResource(std::shared_ptr<RegionsApiResources::RegionsResource> resource);
    [[deprecated("use setResource()")]]
    virtual void setRegionsApiRegionsRegionIdChildrenResource(std::shared_ptr<RegionsApiResources::RegionsRegionIdChildrenResource> spRegionsApiRegionsRegionIdChildrenResource);
    [[deprecated("use setResource()")]]
    virtual void setRegionsApiRegionsRegionIdResource(std::shared_ptr<RegionsApiResources::RegionsRegionIdResource> spRegionsApiRegionsRegionIdResource);
    [[deprecated("use setResource()")]]
    virtual void setRegionsApiRegionsResource(std::shared_ptr<RegionsApiResources::RegionsResource> spRegionsApiRegionsResource);

    virtual void publishDefaultResources();

    virtual std::shared_ptr<restbed::Service> service();

protected:
    std::shared_ptr<RegionsApiResources::RegionsRegionIdChildrenResource> m_spRegionsRegionIdChildrenResource;
    std::shared_ptr<RegionsApiResources::RegionsRegionIdResource> m_spRegionsRegionIdResource;
    std::shared_ptr<RegionsApiResources::RegionsResource> m_spRegionsResource;

private:
    std::shared_ptr<restbed::Service> m_service;
};


}
}
}
}

#endif /* RegionsApi_H_ */

