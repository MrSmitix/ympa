/**
* Партнерский API Маркета
* API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
*
* The version of the OpenAPI document: LATEST
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "SuggestedOfferDTO.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

SuggestedOfferDTO::SuggestedOfferDTO()
{
    m_OfferId = "";
    m_OfferIdIsSet = false;
    m_Name = "";
    m_NameIsSet = false;
    m_Category = "";
    m_CategoryIsSet = false;
    m_Vendor = "";
    m_VendorIsSet = false;
    m_BarcodesIsSet = false;
    m_Description = "";
    m_DescriptionIsSet = false;
    m_VendorCode = "";
    m_VendorCodeIsSet = false;
    m_BasicPriceIsSet = false;
    
}

void SuggestedOfferDTO::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool SuggestedOfferDTO::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool SuggestedOfferDTO::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "SuggestedOfferDTO" : pathPrefix;

         
    if (offerIdIsSet())
    {
        const std::string& value = m_OfferId;
        const std::string currentValuePath = _pathPrefix + ".offerId";
                
        
        if (value.length() < 1)
        {
            success = false;
            msg << currentValuePath << ": must be at least 1 characters long;";
        }
        if (value.length() > 255)
        {
            success = false;
            msg << currentValuePath << ": must be at most 255 characters long;";
        }

    }
         
    if (nameIsSet())
    {
        const std::string& value = m_Name;
        const std::string currentValuePath = _pathPrefix + ".name";
                
        
        if (value.length() > 256)
        {
            success = false;
            msg << currentValuePath << ": must be at most 256 characters long;";
        }

    }
                 
    if (barcodesIsSet())
    {
        const std::vector<std::string>& value = m_Barcodes;
        const std::string currentValuePath = _pathPrefix + ".barcodes";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
         
    if (descriptionIsSet())
    {
        const std::string& value = m_Description;
        const std::string currentValuePath = _pathPrefix + ".description";
                
        
        if (value.length() > 6000)
        {
            success = false;
            msg << currentValuePath << ": must be at most 6000 characters long;";
        }

    }
            
    return success;
}

bool SuggestedOfferDTO::operator==(const SuggestedOfferDTO& rhs) const
{
    return
    
    
    
    ((!offerIdIsSet() && !rhs.offerIdIsSet()) || (offerIdIsSet() && rhs.offerIdIsSet() && getOfferId() == rhs.getOfferId())) &&
    
    
    ((!nameIsSet() && !rhs.nameIsSet()) || (nameIsSet() && rhs.nameIsSet() && getName() == rhs.getName())) &&
    
    
    ((!categoryIsSet() && !rhs.categoryIsSet()) || (categoryIsSet() && rhs.categoryIsSet() && getCategory() == rhs.getCategory())) &&
    
    
    ((!vendorIsSet() && !rhs.vendorIsSet()) || (vendorIsSet() && rhs.vendorIsSet() && getVendor() == rhs.getVendor())) &&
    
    
    ((!barcodesIsSet() && !rhs.barcodesIsSet()) || (barcodesIsSet() && rhs.barcodesIsSet() && getBarcodes() == rhs.getBarcodes())) &&
    
    
    ((!descriptionIsSet() && !rhs.descriptionIsSet()) || (descriptionIsSet() && rhs.descriptionIsSet() && getDescription() == rhs.getDescription())) &&
    
    
    ((!vendorCodeIsSet() && !rhs.vendorCodeIsSet()) || (vendorCodeIsSet() && rhs.vendorCodeIsSet() && getVendorCode() == rhs.getVendorCode())) &&
    
    
    ((!basicPriceIsSet() && !rhs.basicPriceIsSet()) || (basicPriceIsSet() && rhs.basicPriceIsSet() && getBasicPrice() == rhs.getBasicPrice()))
    
    ;
}

bool SuggestedOfferDTO::operator!=(const SuggestedOfferDTO& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const SuggestedOfferDTO& o)
{
    j = nlohmann::json::object();
    if(o.offerIdIsSet())
        j["offerId"] = o.m_OfferId;
    if(o.nameIsSet())
        j["name"] = o.m_Name;
    if(o.categoryIsSet())
        j["category"] = o.m_Category;
    if(o.vendorIsSet())
        j["vendor"] = o.m_Vendor;
    if(o.barcodesIsSet() || !o.m_Barcodes.empty())
        j["barcodes"] = o.m_Barcodes;
    if(o.descriptionIsSet())
        j["description"] = o.m_Description;
    if(o.vendorCodeIsSet())
        j["vendorCode"] = o.m_VendorCode;
    if(o.basicPriceIsSet())
        j["basicPrice"] = o.m_BasicPrice;
    
}

void from_json(const nlohmann::json& j, SuggestedOfferDTO& o)
{
    if(j.find("offerId") != j.end())
    {
        j.at("offerId").get_to(o.m_OfferId);
        o.m_OfferIdIsSet = true;
    } 
    if(j.find("name") != j.end())
    {
        j.at("name").get_to(o.m_Name);
        o.m_NameIsSet = true;
    } 
    if(j.find("category") != j.end())
    {
        j.at("category").get_to(o.m_Category);
        o.m_CategoryIsSet = true;
    } 
    if(j.find("vendor") != j.end())
    {
        j.at("vendor").get_to(o.m_Vendor);
        o.m_VendorIsSet = true;
    } 
    if(j.find("barcodes") != j.end())
    {
        j.at("barcodes").get_to(o.m_Barcodes);
        o.m_BarcodesIsSet = true;
    } 
    if(j.find("description") != j.end())
    {
        j.at("description").get_to(o.m_Description);
        o.m_DescriptionIsSet = true;
    } 
    if(j.find("vendorCode") != j.end())
    {
        j.at("vendorCode").get_to(o.m_VendorCode);
        o.m_VendorCodeIsSet = true;
    } 
    if(j.find("basicPrice") != j.end())
    {
        j.at("basicPrice").get_to(o.m_BasicPrice);
        o.m_BasicPriceIsSet = true;
    } 
    
}

std::string SuggestedOfferDTO::getOfferId() const
{
    return m_OfferId;
}
void SuggestedOfferDTO::setOfferId(std::string const& value)
{
    m_OfferId = value;
    m_OfferIdIsSet = true;
}
bool SuggestedOfferDTO::offerIdIsSet() const
{
    return m_OfferIdIsSet;
}
void SuggestedOfferDTO::unsetOfferId()
{
    m_OfferIdIsSet = false;
}
std::string SuggestedOfferDTO::getName() const
{
    return m_Name;
}
void SuggestedOfferDTO::setName(std::string const& value)
{
    m_Name = value;
    m_NameIsSet = true;
}
bool SuggestedOfferDTO::nameIsSet() const
{
    return m_NameIsSet;
}
void SuggestedOfferDTO::unsetName()
{
    m_NameIsSet = false;
}
std::string SuggestedOfferDTO::getCategory() const
{
    return m_Category;
}
void SuggestedOfferDTO::setCategory(std::string const& value)
{
    m_Category = value;
    m_CategoryIsSet = true;
}
bool SuggestedOfferDTO::categoryIsSet() const
{
    return m_CategoryIsSet;
}
void SuggestedOfferDTO::unsetCategory()
{
    m_CategoryIsSet = false;
}
std::string SuggestedOfferDTO::getVendor() const
{
    return m_Vendor;
}
void SuggestedOfferDTO::setVendor(std::string const& value)
{
    m_Vendor = value;
    m_VendorIsSet = true;
}
bool SuggestedOfferDTO::vendorIsSet() const
{
    return m_VendorIsSet;
}
void SuggestedOfferDTO::unsetVendor()
{
    m_VendorIsSet = false;
}
std::vector<std::string> SuggestedOfferDTO::getBarcodes() const
{
    return m_Barcodes;
}
void SuggestedOfferDTO::setBarcodes(std::vector<std::string> const& value)
{
    m_Barcodes = value;
    m_BarcodesIsSet = true;
}
bool SuggestedOfferDTO::barcodesIsSet() const
{
    return m_BarcodesIsSet;
}
void SuggestedOfferDTO::unsetBarcodes()
{
    m_BarcodesIsSet = false;
}
std::string SuggestedOfferDTO::getDescription() const
{
    return m_Description;
}
void SuggestedOfferDTO::setDescription(std::string const& value)
{
    m_Description = value;
    m_DescriptionIsSet = true;
}
bool SuggestedOfferDTO::descriptionIsSet() const
{
    return m_DescriptionIsSet;
}
void SuggestedOfferDTO::unsetDescription()
{
    m_DescriptionIsSet = false;
}
std::string SuggestedOfferDTO::getVendorCode() const
{
    return m_VendorCode;
}
void SuggestedOfferDTO::setVendorCode(std::string const& value)
{
    m_VendorCode = value;
    m_VendorCodeIsSet = true;
}
bool SuggestedOfferDTO::vendorCodeIsSet() const
{
    return m_VendorCodeIsSet;
}
void SuggestedOfferDTO::unsetVendorCode()
{
    m_VendorCodeIsSet = false;
}
org::openapitools::server::model::BasePriceDTO SuggestedOfferDTO::getBasicPrice() const
{
    return m_BasicPrice;
}
void SuggestedOfferDTO::setBasicPrice(org::openapitools::server::model::BasePriceDTO const& value)
{
    m_BasicPrice = value;
    m_BasicPriceIsSet = true;
}
bool SuggestedOfferDTO::basicPriceIsSet() const
{
    return m_BasicPriceIsSet;
}
void SuggestedOfferDTO::unsetBasicPrice()
{
    m_BasicPriceIsSet = false;
}


} // namespace org::openapitools::server::model

