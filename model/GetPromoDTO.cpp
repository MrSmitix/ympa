/**
* Партнерский API Маркета
* API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
*
* The version of the OpenAPI document: LATEST
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "GetPromoDTO.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

GetPromoDTO::GetPromoDTO()
{
    m_Id = "";
    m_Name = "";
    m_Participating = false;
    m_ChannelsIsSet = false;
    m_ConstraintsIsSet = false;
    
}

void GetPromoDTO::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool GetPromoDTO::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool GetPromoDTO::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "GetPromoDTO" : pathPrefix;

                
    if (!m_Period.validate(msg, _pathPrefix + ".period")) {
        msg << _pathPrefix << ": Period is invalid;";
        success = false;
    }        
    if (!m_AssortmentInfo.validate(msg, _pathPrefix + ".assortmentInfo")) {
        msg << _pathPrefix << ": AssortmentInfo is invalid;";
        success = false;
    }    
    if (!m_MechanicsInfo.validate(msg, _pathPrefix + ".mechanicsInfo")) {
        msg << _pathPrefix << ": MechanicsInfo is invalid;";
        success = false;
    }    
    if (!m_BestsellerInfo.validate(msg, _pathPrefix + ".bestsellerInfo")) {
        msg << _pathPrefix << ": BestsellerInfo is invalid;";
        success = false;
    }     
    if (channelsIsSet())
    {
        const std::vector<org::openapitools::server::model::ChannelType>& value = m_Channels;
        const std::string currentValuePath = _pathPrefix + ".channels";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::ChannelType& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath) && success;
        
        success = value.validate(msg, currentValuePath + ".channels") && success;
 
                i++;
            }
        }

    }
        
    return success;
}

bool GetPromoDTO::operator==(const GetPromoDTO& rhs) const
{
    return
    
    
    (getId() == rhs.getId())
     &&
    
    (getName() == rhs.getName())
     &&
    
    (getPeriod() == rhs.getPeriod())
     &&
    
    (isParticipating() == rhs.isParticipating())
     &&
    
    (getAssortmentInfo() == rhs.getAssortmentInfo())
     &&
    
    (getMechanicsInfo() == rhs.getMechanicsInfo())
     &&
    
    (getBestsellerInfo() == rhs.getBestsellerInfo())
     &&
    
    
    ((!channelsIsSet() && !rhs.channelsIsSet()) || (channelsIsSet() && rhs.channelsIsSet() && getChannels() == rhs.getChannels())) &&
    
    
    ((!constraintsIsSet() && !rhs.constraintsIsSet()) || (constraintsIsSet() && rhs.constraintsIsSet() && getConstraints() == rhs.getConstraints()))
    
    ;
}

bool GetPromoDTO::operator!=(const GetPromoDTO& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const GetPromoDTO& o)
{
    j = nlohmann::json::object();
    j["id"] = o.m_Id;
    j["name"] = o.m_Name;
    j["period"] = o.m_Period;
    j["participating"] = o.m_Participating;
    j["assortmentInfo"] = o.m_AssortmentInfo;
    j["mechanicsInfo"] = o.m_MechanicsInfo;
    j["bestsellerInfo"] = o.m_BestsellerInfo;
    if(o.channelsIsSet() || !o.m_Channels.empty())
        j["channels"] = o.m_Channels;
    if(o.constraintsIsSet())
        j["constraints"] = o.m_Constraints;
    
}

void from_json(const nlohmann::json& j, GetPromoDTO& o)
{
    j.at("id").get_to(o.m_Id);
    j.at("name").get_to(o.m_Name);
    j.at("period").get_to(o.m_Period);
    j.at("participating").get_to(o.m_Participating);
    j.at("assortmentInfo").get_to(o.m_AssortmentInfo);
    j.at("mechanicsInfo").get_to(o.m_MechanicsInfo);
    j.at("bestsellerInfo").get_to(o.m_BestsellerInfo);
    if(j.find("channels") != j.end())
    {
        j.at("channels").get_to(o.m_Channels);
        o.m_ChannelsIsSet = true;
    } 
    if(j.find("constraints") != j.end())
    {
        j.at("constraints").get_to(o.m_Constraints);
        o.m_ConstraintsIsSet = true;
    } 
    
}

std::string GetPromoDTO::getId() const
{
    return m_Id;
}
void GetPromoDTO::setId(std::string const& value)
{
    m_Id = value;
}
std::string GetPromoDTO::getName() const
{
    return m_Name;
}
void GetPromoDTO::setName(std::string const& value)
{
    m_Name = value;
}
org::openapitools::server::model::PromoPeriodDTO GetPromoDTO::getPeriod() const
{
    return m_Period;
}
void GetPromoDTO::setPeriod(org::openapitools::server::model::PromoPeriodDTO const& value)
{
    m_Period = value;
}
bool GetPromoDTO::isParticipating() const
{
    return m_Participating;
}
void GetPromoDTO::setParticipating(bool const value)
{
    m_Participating = value;
}
org::openapitools::server::model::GetPromoAssortmentInfoDTO GetPromoDTO::getAssortmentInfo() const
{
    return m_AssortmentInfo;
}
void GetPromoDTO::setAssortmentInfo(org::openapitools::server::model::GetPromoAssortmentInfoDTO const& value)
{
    m_AssortmentInfo = value;
}
org::openapitools::server::model::GetPromoMechanicsInfoDTO GetPromoDTO::getMechanicsInfo() const
{
    return m_MechanicsInfo;
}
void GetPromoDTO::setMechanicsInfo(org::openapitools::server::model::GetPromoMechanicsInfoDTO const& value)
{
    m_MechanicsInfo = value;
}
org::openapitools::server::model::GetPromoBestsellerInfoDTO GetPromoDTO::getBestsellerInfo() const
{
    return m_BestsellerInfo;
}
void GetPromoDTO::setBestsellerInfo(org::openapitools::server::model::GetPromoBestsellerInfoDTO const& value)
{
    m_BestsellerInfo = value;
}
std::vector<org::openapitools::server::model::ChannelType> GetPromoDTO::getChannels() const
{
    return m_Channels;
}
void GetPromoDTO::setChannels(std::vector<org::openapitools::server::model::ChannelType> const& value)
{
    m_Channels = value;
    m_ChannelsIsSet = true;
}
bool GetPromoDTO::channelsIsSet() const
{
    return m_ChannelsIsSet;
}
void GetPromoDTO::unsetChannels()
{
    m_ChannelsIsSet = false;
}
org::openapitools::server::model::GetPromoConstraintsDTO GetPromoDTO::getConstraints() const
{
    return m_Constraints;
}
void GetPromoDTO::setConstraints(org::openapitools::server::model::GetPromoConstraintsDTO const& value)
{
    m_Constraints = value;
    m_ConstraintsIsSet = true;
}
bool GetPromoDTO::constraintsIsSet() const
{
    return m_ConstraintsIsSet;
}
void GetPromoDTO::unsetConstraints()
{
    m_ConstraintsIsSet = false;
}


} // namespace org::openapitools::server::model

