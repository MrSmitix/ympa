/**
* Партнерский API Маркета
* API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
*
* The version of the OpenAPI document: LATEST
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "OutletAddressDTO.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

OutletAddressDTO::OutletAddressDTO()
{
    m_RegionId = 0L;
    m_Street = "";
    m_StreetIsSet = false;
    m_number = "";
    m_numberIsSet = false;
    m_Building = "";
    m_BuildingIsSet = false;
    m_Estate = "";
    m_EstateIsSet = false;
    m_Block = "";
    m_BlockIsSet = false;
    m_Additional = "";
    m_AdditionalIsSet = false;
    m_Km = 0;
    m_KmIsSet = false;
    m_City = "";
    m_CityIsSet = false;
    
}

void OutletAddressDTO::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool OutletAddressDTO::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool OutletAddressDTO::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "OutletAddressDTO" : pathPrefix;

             
    if (streetIsSet())
    {
        const std::string& value = m_Street;
        const std::string currentValuePath = _pathPrefix + ".street";
                
        
        if (value.length() > 512)
        {
            success = false;
            msg << currentValuePath << ": must be at most 512 characters long;";
        }

    }
         
    if (numberIsSet())
    {
        const std::string& value = m_number;
        const std::string currentValuePath = _pathPrefix + ".number";
                
        
        if (value.length() > 256)
        {
            success = false;
            msg << currentValuePath << ": must be at most 256 characters long;";
        }

    }
         
    if (buildingIsSet())
    {
        const std::string& value = m_Building;
        const std::string currentValuePath = _pathPrefix + ".building";
                
        
        if (value.length() > 16)
        {
            success = false;
            msg << currentValuePath << ": must be at most 16 characters long;";
        }

    }
         
    if (estateIsSet())
    {
        const std::string& value = m_Estate;
        const std::string currentValuePath = _pathPrefix + ".estate";
                
        
        if (value.length() > 16)
        {
            success = false;
            msg << currentValuePath << ": must be at most 16 characters long;";
        }

    }
         
    if (blockIsSet())
    {
        const std::string& value = m_Block;
        const std::string currentValuePath = _pathPrefix + ".block";
                
        
        if (value.length() > 16)
        {
            success = false;
            msg << currentValuePath << ": must be at most 16 characters long;";
        }

    }
                 
    if (cityIsSet())
    {
        const std::string& value = m_City;
        const std::string currentValuePath = _pathPrefix + ".city";
                
        
        if (value.length() > 200)
        {
            success = false;
            msg << currentValuePath << ": must be at most 200 characters long;";
        }

    }
    
    return success;
}

bool OutletAddressDTO::operator==(const OutletAddressDTO& rhs) const
{
    return
    
    
    (getRegionId() == rhs.getRegionId())
     &&
    
    
    ((!streetIsSet() && !rhs.streetIsSet()) || (streetIsSet() && rhs.streetIsSet() && getStreet() == rhs.getStreet())) &&
    
    
    ((!numberIsSet() && !rhs.numberIsSet()) || (numberIsSet() && rhs.numberIsSet() && getNumber() == rhs.getNumber())) &&
    
    
    ((!buildingIsSet() && !rhs.buildingIsSet()) || (buildingIsSet() && rhs.buildingIsSet() && getBuilding() == rhs.getBuilding())) &&
    
    
    ((!estateIsSet() && !rhs.estateIsSet()) || (estateIsSet() && rhs.estateIsSet() && getEstate() == rhs.getEstate())) &&
    
    
    ((!blockIsSet() && !rhs.blockIsSet()) || (blockIsSet() && rhs.blockIsSet() && getBlock() == rhs.getBlock())) &&
    
    
    ((!additionalIsSet() && !rhs.additionalIsSet()) || (additionalIsSet() && rhs.additionalIsSet() && getAdditional() == rhs.getAdditional())) &&
    
    
    ((!kmIsSet() && !rhs.kmIsSet()) || (kmIsSet() && rhs.kmIsSet() && getKm() == rhs.getKm())) &&
    
    
    ((!cityIsSet() && !rhs.cityIsSet()) || (cityIsSet() && rhs.cityIsSet() && getCity() == rhs.getCity()))
    
    ;
}

bool OutletAddressDTO::operator!=(const OutletAddressDTO& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const OutletAddressDTO& o)
{
    j = nlohmann::json::object();
    j["regionId"] = o.m_RegionId;
    if(o.streetIsSet())
        j["street"] = o.m_Street;
    if(o.numberIsSet())
        j["number"] = o.m_number;
    if(o.buildingIsSet())
        j["building"] = o.m_Building;
    if(o.estateIsSet())
        j["estate"] = o.m_Estate;
    if(o.blockIsSet())
        j["block"] = o.m_Block;
    if(o.additionalIsSet())
        j["additional"] = o.m_Additional;
    if(o.kmIsSet())
        j["km"] = o.m_Km;
    if(o.cityIsSet())
        j["city"] = o.m_City;
    
}

void from_json(const nlohmann::json& j, OutletAddressDTO& o)
{
    j.at("regionId").get_to(o.m_RegionId);
    if(j.find("street") != j.end())
    {
        j.at("street").get_to(o.m_Street);
        o.m_StreetIsSet = true;
    } 
    if(j.find("number") != j.end())
    {
        j.at("number").get_to(o.m_number);
        o.m_numberIsSet = true;
    } 
    if(j.find("building") != j.end())
    {
        j.at("building").get_to(o.m_Building);
        o.m_BuildingIsSet = true;
    } 
    if(j.find("estate") != j.end())
    {
        j.at("estate").get_to(o.m_Estate);
        o.m_EstateIsSet = true;
    } 
    if(j.find("block") != j.end())
    {
        j.at("block").get_to(o.m_Block);
        o.m_BlockIsSet = true;
    } 
    if(j.find("additional") != j.end())
    {
        j.at("additional").get_to(o.m_Additional);
        o.m_AdditionalIsSet = true;
    } 
    if(j.find("km") != j.end())
    {
        j.at("km").get_to(o.m_Km);
        o.m_KmIsSet = true;
    } 
    if(j.find("city") != j.end())
    {
        j.at("city").get_to(o.m_City);
        o.m_CityIsSet = true;
    } 
    
}

int64_t OutletAddressDTO::getRegionId() const
{
    return m_RegionId;
}
void OutletAddressDTO::setRegionId(int64_t const value)
{
    m_RegionId = value;
}
std::string OutletAddressDTO::getStreet() const
{
    return m_Street;
}
void OutletAddressDTO::setStreet(std::string const& value)
{
    m_Street = value;
    m_StreetIsSet = true;
}
bool OutletAddressDTO::streetIsSet() const
{
    return m_StreetIsSet;
}
void OutletAddressDTO::unsetStreet()
{
    m_StreetIsSet = false;
}
std::string OutletAddressDTO::getNumber() const
{
    return m_number;
}
void OutletAddressDTO::setNumber(std::string const& value)
{
    m_number = value;
    m_numberIsSet = true;
}
bool OutletAddressDTO::numberIsSet() const
{
    return m_numberIsSet;
}
void OutletAddressDTO::unsetnumber()
{
    m_numberIsSet = false;
}
std::string OutletAddressDTO::getBuilding() const
{
    return m_Building;
}
void OutletAddressDTO::setBuilding(std::string const& value)
{
    m_Building = value;
    m_BuildingIsSet = true;
}
bool OutletAddressDTO::buildingIsSet() const
{
    return m_BuildingIsSet;
}
void OutletAddressDTO::unsetBuilding()
{
    m_BuildingIsSet = false;
}
std::string OutletAddressDTO::getEstate() const
{
    return m_Estate;
}
void OutletAddressDTO::setEstate(std::string const& value)
{
    m_Estate = value;
    m_EstateIsSet = true;
}
bool OutletAddressDTO::estateIsSet() const
{
    return m_EstateIsSet;
}
void OutletAddressDTO::unsetEstate()
{
    m_EstateIsSet = false;
}
std::string OutletAddressDTO::getBlock() const
{
    return m_Block;
}
void OutletAddressDTO::setBlock(std::string const& value)
{
    m_Block = value;
    m_BlockIsSet = true;
}
bool OutletAddressDTO::blockIsSet() const
{
    return m_BlockIsSet;
}
void OutletAddressDTO::unsetBlock()
{
    m_BlockIsSet = false;
}
std::string OutletAddressDTO::getAdditional() const
{
    return m_Additional;
}
void OutletAddressDTO::setAdditional(std::string const& value)
{
    m_Additional = value;
    m_AdditionalIsSet = true;
}
bool OutletAddressDTO::additionalIsSet() const
{
    return m_AdditionalIsSet;
}
void OutletAddressDTO::unsetAdditional()
{
    m_AdditionalIsSet = false;
}
int32_t OutletAddressDTO::getKm() const
{
    return m_Km;
}
void OutletAddressDTO::setKm(int32_t const value)
{
    m_Km = value;
    m_KmIsSet = true;
}
bool OutletAddressDTO::kmIsSet() const
{
    return m_KmIsSet;
}
void OutletAddressDTO::unsetKm()
{
    m_KmIsSet = false;
}
std::string OutletAddressDTO::getCity() const
{
    return m_City;
}
void OutletAddressDTO::setCity(std::string const& value)
{
    m_City = value;
    m_CityIsSet = true;
}
bool OutletAddressDTO::cityIsSet() const
{
    return m_CityIsSet;
}
void OutletAddressDTO::unsetCity()
{
    m_CityIsSet = false;
}


} // namespace org::openapitools::server::model

