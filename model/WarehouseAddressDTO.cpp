/**
* Партнерский API Маркета
* API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
*
* The version of the OpenAPI document: LATEST
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "WarehouseAddressDTO.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

WarehouseAddressDTO::WarehouseAddressDTO()
{
    m_City = "";
    m_Street = "";
    m_StreetIsSet = false;
    m_number = "";
    m_numberIsSet = false;
    m_Building = "";
    m_BuildingIsSet = false;
    m_Block = "";
    m_BlockIsSet = false;
    
}

void WarehouseAddressDTO::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool WarehouseAddressDTO::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool WarehouseAddressDTO::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "WarehouseAddressDTO" : pathPrefix;

         
    
    /* City */ {
        const std::string& value = m_City;
        const std::string currentValuePath = _pathPrefix + ".city";
                
        
        if (value.length() > 200)
        {
            success = false;
            msg << currentValuePath << ": must be at most 200 characters long;";
        }

    }
         
    if (streetIsSet())
    {
        const std::string& value = m_Street;
        const std::string currentValuePath = _pathPrefix + ".street";
                
        
        if (value.length() > 512)
        {
            success = false;
            msg << currentValuePath << ": must be at most 512 characters long;";
        }

    }
         
    if (numberIsSet())
    {
        const std::string& value = m_number;
        const std::string currentValuePath = _pathPrefix + ".number";
                
        
        if (value.length() > 256)
        {
            success = false;
            msg << currentValuePath << ": must be at most 256 characters long;";
        }

    }
         
    if (buildingIsSet())
    {
        const std::string& value = m_Building;
        const std::string currentValuePath = _pathPrefix + ".building";
                
        
        if (value.length() > 16)
        {
            success = false;
            msg << currentValuePath << ": must be at most 16 characters long;";
        }

    }
         
    if (blockIsSet())
    {
        const std::string& value = m_Block;
        const std::string currentValuePath = _pathPrefix + ".block";
                
        
        if (value.length() > 16)
        {
            success = false;
            msg << currentValuePath << ": must be at most 16 characters long;";
        }

    }
        
    if (!m_Gps.validate(msg, _pathPrefix + ".gps")) {
        msg << _pathPrefix << ": Gps is invalid;";
        success = false;
    }
    return success;
}

bool WarehouseAddressDTO::operator==(const WarehouseAddressDTO& rhs) const
{
    return
    
    
    (getCity() == rhs.getCity())
     &&
    
    
    ((!streetIsSet() && !rhs.streetIsSet()) || (streetIsSet() && rhs.streetIsSet() && getStreet() == rhs.getStreet())) &&
    
    
    ((!numberIsSet() && !rhs.numberIsSet()) || (numberIsSet() && rhs.numberIsSet() && getNumber() == rhs.getNumber())) &&
    
    
    ((!buildingIsSet() && !rhs.buildingIsSet()) || (buildingIsSet() && rhs.buildingIsSet() && getBuilding() == rhs.getBuilding())) &&
    
    
    ((!blockIsSet() && !rhs.blockIsSet()) || (blockIsSet() && rhs.blockIsSet() && getBlock() == rhs.getBlock())) &&
    
    (getGps() == rhs.getGps())
    
    
    ;
}

bool WarehouseAddressDTO::operator!=(const WarehouseAddressDTO& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const WarehouseAddressDTO& o)
{
    j = nlohmann::json::object();
    j["city"] = o.m_City;
    if(o.streetIsSet())
        j["street"] = o.m_Street;
    if(o.numberIsSet())
        j["number"] = o.m_number;
    if(o.buildingIsSet())
        j["building"] = o.m_Building;
    if(o.blockIsSet())
        j["block"] = o.m_Block;
    j["gps"] = o.m_Gps;
    
}

void from_json(const nlohmann::json& j, WarehouseAddressDTO& o)
{
    j.at("city").get_to(o.m_City);
    if(j.find("street") != j.end())
    {
        j.at("street").get_to(o.m_Street);
        o.m_StreetIsSet = true;
    } 
    if(j.find("number") != j.end())
    {
        j.at("number").get_to(o.m_number);
        o.m_numberIsSet = true;
    } 
    if(j.find("building") != j.end())
    {
        j.at("building").get_to(o.m_Building);
        o.m_BuildingIsSet = true;
    } 
    if(j.find("block") != j.end())
    {
        j.at("block").get_to(o.m_Block);
        o.m_BlockIsSet = true;
    } 
    j.at("gps").get_to(o.m_Gps);
    
}

std::string WarehouseAddressDTO::getCity() const
{
    return m_City;
}
void WarehouseAddressDTO::setCity(std::string const& value)
{
    m_City = value;
}
std::string WarehouseAddressDTO::getStreet() const
{
    return m_Street;
}
void WarehouseAddressDTO::setStreet(std::string const& value)
{
    m_Street = value;
    m_StreetIsSet = true;
}
bool WarehouseAddressDTO::streetIsSet() const
{
    return m_StreetIsSet;
}
void WarehouseAddressDTO::unsetStreet()
{
    m_StreetIsSet = false;
}
std::string WarehouseAddressDTO::getNumber() const
{
    return m_number;
}
void WarehouseAddressDTO::setNumber(std::string const& value)
{
    m_number = value;
    m_numberIsSet = true;
}
bool WarehouseAddressDTO::numberIsSet() const
{
    return m_numberIsSet;
}
void WarehouseAddressDTO::unsetnumber()
{
    m_numberIsSet = false;
}
std::string WarehouseAddressDTO::getBuilding() const
{
    return m_Building;
}
void WarehouseAddressDTO::setBuilding(std::string const& value)
{
    m_Building = value;
    m_BuildingIsSet = true;
}
bool WarehouseAddressDTO::buildingIsSet() const
{
    return m_BuildingIsSet;
}
void WarehouseAddressDTO::unsetBuilding()
{
    m_BuildingIsSet = false;
}
std::string WarehouseAddressDTO::getBlock() const
{
    return m_Block;
}
void WarehouseAddressDTO::setBlock(std::string const& value)
{
    m_Block = value;
    m_BlockIsSet = true;
}
bool WarehouseAddressDTO::blockIsSet() const
{
    return m_BlockIsSet;
}
void WarehouseAddressDTO::unsetBlock()
{
    m_BlockIsSet = false;
}
org::openapitools::server::model::GpsDTO WarehouseAddressDTO::getGps() const
{
    return m_Gps;
}
void WarehouseAddressDTO::setGps(org::openapitools::server::model::GpsDTO const& value)
{
    m_Gps = value;
}


} // namespace org::openapitools::server::model

