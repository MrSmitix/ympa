/**
* Партнерский API Маркета
* API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
*
* The version of the OpenAPI document: LATEST
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "GetGoodsFeedbackRequest.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

GetGoodsFeedbackRequest::GetGoodsFeedbackRequest()
{
    m_DateTimeFrom = "";
    m_DateTimeFromIsSet = false;
    m_DateTimeTo = "";
    m_DateTimeToIsSet = false;
    m_ReactionStatusIsSet = false;
    m_RatingValuesIsSet = false;
    m_ModelIdsIsSet = false;
    m_Paid = false;
    m_PaidIsSet = false;
    
}

void GetGoodsFeedbackRequest::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool GetGoodsFeedbackRequest::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool GetGoodsFeedbackRequest::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "GetGoodsFeedbackRequest" : pathPrefix;

                     
    if (ratingValuesIsSet())
    {
        const std::set<int32_t>& value = m_RatingValues;
        const std::string currentValuePath = _pathPrefix + ".ratingValues";
                
        
        if (value.size() > 5)
        {
            success = false;
            msg << currentValuePath << ": must have at most 5 elements;";
        }
        if (!org::openapitools::server::helpers::hasOnlyUniqueItems(value))
        {
            success = false;
            msg << currentValuePath << ": may not contain the same item more than once;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const int32_t& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
         
    if (modelIdsIsSet())
    {
        const std::set<int64_t>& value = m_ModelIds;
        const std::string currentValuePath = _pathPrefix + ".modelIds";
                
        
        if (value.size() > 20)
        {
            success = false;
            msg << currentValuePath << ": must have at most 20 elements;";
        }
        if (!org::openapitools::server::helpers::hasOnlyUniqueItems(value))
        {
            success = false;
            msg << currentValuePath << ": may not contain the same item more than once;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const int64_t& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
        
    return success;
}

bool GetGoodsFeedbackRequest::operator==(const GetGoodsFeedbackRequest& rhs) const
{
    return
    
    
    
    ((!dateTimeFromIsSet() && !rhs.dateTimeFromIsSet()) || (dateTimeFromIsSet() && rhs.dateTimeFromIsSet() && getDateTimeFrom() == rhs.getDateTimeFrom())) &&
    
    
    ((!dateTimeToIsSet() && !rhs.dateTimeToIsSet()) || (dateTimeToIsSet() && rhs.dateTimeToIsSet() && getDateTimeTo() == rhs.getDateTimeTo())) &&
    
    
    ((!reactionStatusIsSet() && !rhs.reactionStatusIsSet()) || (reactionStatusIsSet() && rhs.reactionStatusIsSet() && getReactionStatus() == rhs.getReactionStatus())) &&
    
    
    ((!ratingValuesIsSet() && !rhs.ratingValuesIsSet()) || (ratingValuesIsSet() && rhs.ratingValuesIsSet() && getRatingValues() == rhs.getRatingValues())) &&
    
    
    ((!modelIdsIsSet() && !rhs.modelIdsIsSet()) || (modelIdsIsSet() && rhs.modelIdsIsSet() && getModelIds() == rhs.getModelIds())) &&
    
    
    ((!paidIsSet() && !rhs.paidIsSet()) || (paidIsSet() && rhs.paidIsSet() && isPaid() == rhs.isPaid()))
    
    ;
}

bool GetGoodsFeedbackRequest::operator!=(const GetGoodsFeedbackRequest& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const GetGoodsFeedbackRequest& o)
{
    j = nlohmann::json::object();
    if(o.dateTimeFromIsSet())
        j["dateTimeFrom"] = o.m_DateTimeFrom;
    if(o.dateTimeToIsSet())
        j["dateTimeTo"] = o.m_DateTimeTo;
    if(o.reactionStatusIsSet())
        j["reactionStatus"] = o.m_ReactionStatus;
    if(o.ratingValuesIsSet() || !o.m_RatingValues.empty())
        j["ratingValues"] = o.m_RatingValues;
    if(o.modelIdsIsSet() || !o.m_ModelIds.empty())
        j["modelIds"] = o.m_ModelIds;
    if(o.paidIsSet())
        j["paid"] = o.m_Paid;
    
}

void from_json(const nlohmann::json& j, GetGoodsFeedbackRequest& o)
{
    if(j.find("dateTimeFrom") != j.end())
    {
        j.at("dateTimeFrom").get_to(o.m_DateTimeFrom);
        o.m_DateTimeFromIsSet = true;
    } 
    if(j.find("dateTimeTo") != j.end())
    {
        j.at("dateTimeTo").get_to(o.m_DateTimeTo);
        o.m_DateTimeToIsSet = true;
    } 
    if(j.find("reactionStatus") != j.end())
    {
        j.at("reactionStatus").get_to(o.m_ReactionStatus);
        o.m_ReactionStatusIsSet = true;
    } 
    if(j.find("ratingValues") != j.end())
    {
        j.at("ratingValues").get_to(o.m_RatingValues);
        o.m_RatingValuesIsSet = true;
    } 
    if(j.find("modelIds") != j.end())
    {
        j.at("modelIds").get_to(o.m_ModelIds);
        o.m_ModelIdsIsSet = true;
    } 
    if(j.find("paid") != j.end())
    {
        j.at("paid").get_to(o.m_Paid);
        o.m_PaidIsSet = true;
    } 
    
}

std::string GetGoodsFeedbackRequest::getDateTimeFrom() const
{
    return m_DateTimeFrom;
}
void GetGoodsFeedbackRequest::setDateTimeFrom(std::string const& value)
{
    m_DateTimeFrom = value;
    m_DateTimeFromIsSet = true;
}
bool GetGoodsFeedbackRequest::dateTimeFromIsSet() const
{
    return m_DateTimeFromIsSet;
}
void GetGoodsFeedbackRequest::unsetDateTimeFrom()
{
    m_DateTimeFromIsSet = false;
}
std::string GetGoodsFeedbackRequest::getDateTimeTo() const
{
    return m_DateTimeTo;
}
void GetGoodsFeedbackRequest::setDateTimeTo(std::string const& value)
{
    m_DateTimeTo = value;
    m_DateTimeToIsSet = true;
}
bool GetGoodsFeedbackRequest::dateTimeToIsSet() const
{
    return m_DateTimeToIsSet;
}
void GetGoodsFeedbackRequest::unsetDateTimeTo()
{
    m_DateTimeToIsSet = false;
}
org::openapitools::server::model::FeedbackReactionStatusType GetGoodsFeedbackRequest::getReactionStatus() const
{
    return m_ReactionStatus;
}
void GetGoodsFeedbackRequest::setReactionStatus(org::openapitools::server::model::FeedbackReactionStatusType const& value)
{
    m_ReactionStatus = value;
    m_ReactionStatusIsSet = true;
}
bool GetGoodsFeedbackRequest::reactionStatusIsSet() const
{
    return m_ReactionStatusIsSet;
}
void GetGoodsFeedbackRequest::unsetReactionStatus()
{
    m_ReactionStatusIsSet = false;
}
std::set<int32_t> GetGoodsFeedbackRequest::getRatingValues() const
{
    return m_RatingValues;
}
void GetGoodsFeedbackRequest::setRatingValues(std::set<int32_t> const value)
{
    m_RatingValues = value;
    m_RatingValuesIsSet = true;
}
bool GetGoodsFeedbackRequest::ratingValuesIsSet() const
{
    return m_RatingValuesIsSet;
}
void GetGoodsFeedbackRequest::unsetRatingValues()
{
    m_RatingValuesIsSet = false;
}
std::set<int64_t> GetGoodsFeedbackRequest::getModelIds() const
{
    return m_ModelIds;
}
void GetGoodsFeedbackRequest::setModelIds(std::set<int64_t> const value)
{
    m_ModelIds = value;
    m_ModelIdsIsSet = true;
}
bool GetGoodsFeedbackRequest::modelIdsIsSet() const
{
    return m_ModelIdsIsSet;
}
void GetGoodsFeedbackRequest::unsetModelIds()
{
    m_ModelIdsIsSet = false;
}
bool GetGoodsFeedbackRequest::isPaid() const
{
    return m_Paid;
}
void GetGoodsFeedbackRequest::setPaid(bool const value)
{
    m_Paid = value;
    m_PaidIsSet = true;
}
bool GetGoodsFeedbackRequest::paidIsSet() const
{
    return m_PaidIsSet;
}
void GetGoodsFeedbackRequest::unsetPaid()
{
    m_PaidIsSet = false;
}


} // namespace org::openapitools::server::model

