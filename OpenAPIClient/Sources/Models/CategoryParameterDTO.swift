//
// CategoryParameterDTO.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/// Характеристика товара. 
public struct CategoryParameterDTO: Codable {
    /// Идентификатор характеристики.
    public var id: Int64
    /// Название характеристики.
    public var name: String?
    public var type: ParameterType
    public var unit: CategoryParameterUnitDTO?
    /// Описание характеристики.
    public var description: String?
    /// Перечень возможных рекомендаций по заполнению карточки, к которым относится данная характеристика.
    public var recommendationTypes: [OfferCardRecommendationType]?
    /// Обязательность характеристики.
    public var _required: Bool
    /// Используется ли характеристика в фильтре.
    public var filtering: Bool
    /// Является ли характеристика особенностью варианта.
    public var distinctive: Bool
    /// Можно ли передать сразу несколько значений.
    public var multivalue: Bool
    /// Можно ли передавать собственное значение, которого нет в списке вариантов Маркета. Только для характеристик типа `ENUM`.
    public var allowCustomValues: Bool
    /// Список допустимых значений параметра. Только для характеристик типа `ENUM`.
    public var values: [ParameterValueOptionDTO]?
    public var constraints: ParameterValueConstraintsDTO?
    /// Ограничения на значения, накладываемые другими характеристиками. Только для характеристик типа `ENUM`.
    public var valueRestrictions: [ValueRestrictionDTO]?

    public init(id: Int64, name: String? = nil, type: ParameterType, unit: CategoryParameterUnitDTO? = nil, description: String? = nil, recommendationTypes: [OfferCardRecommendationType]? = nil, _required: Bool, filtering: Bool, distinctive: Bool, multivalue: Bool, allowCustomValues: Bool, values: [ParameterValueOptionDTO]? = nil, constraints: ParameterValueConstraintsDTO? = nil, valueRestrictions: [ValueRestrictionDTO]? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.unit = unit
        self.description = description
        self.recommendationTypes = recommendationTypes
        self._required = _required
        self.filtering = filtering
        self.distinctive = distinctive
        self.multivalue = multivalue
        self.allowCustomValues = allowCustomValues
        self.values = values
        self.constraints = constraints
        self.valueRestrictions = valueRestrictions
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case name
        case type
        case unit
        case description
        case recommendationTypes
        case _required = "required"
        case filtering
        case distinctive
        case multivalue
        case allowCustomValues
        case values
        case constraints
        case valueRestrictions
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(Int64.self, forKey: .id)
        name = try container.decodeIfPresent(String.self, forKey: .name)
        type = try container.decode(ParameterType.self, forKey: .type)
        unit = try container.decodeIfPresent(CategoryParameterUnitDTO.self, forKey: .unit)
        description = try container.decodeIfPresent(String.self, forKey: .description)
        recommendationTypes = try container.decodeIfPresent([OfferCardRecommendationType].self, forKey: .recommendationTypes)
        _required = try container.decode(Bool.self, forKey: ._required)
        filtering = try container.decode(Bool.self, forKey: .filtering)
        distinctive = try container.decode(Bool.self, forKey: .distinctive)
        multivalue = try container.decode(Bool.self, forKey: .multivalue)
        allowCustomValues = try container.decode(Bool.self, forKey: .allowCustomValues)
        values = try container.decodeIfPresent([ParameterValueOptionDTO].self, forKey: .values)
        constraints = try container.decodeIfPresent(ParameterValueConstraintsDTO.self, forKey: .constraints)
        valueRestrictions = try container.decodeIfPresent([ValueRestrictionDTO].self, forKey: .valueRestrictions)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(unit, forKey: .unit)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(recommendationTypes, forKey: .recommendationTypes)
        try container.encode(_required, forKey: ._required)
        try container.encode(filtering, forKey: .filtering)
        try container.encode(distinctive, forKey: .distinctive)
        try container.encode(multivalue, forKey: .multivalue)
        try container.encode(allowCustomValues, forKey: .allowCustomValues)
        try container.encodeIfPresent(values, forKey: .values)
        try container.encodeIfPresent(constraints, forKey: .constraints)
        try container.encodeIfPresent(valueRestrictions, forKey: .valueRestrictions)
    }
}
