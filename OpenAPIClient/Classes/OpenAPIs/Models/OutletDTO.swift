//
// OutletDTO.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Информация о точке продаж. */
public struct OutletDTO: Codable, JSONEncodable, Hashable {

    static let phonesRule = ArrayRule(minItems: 1, maxItems: nil, uniqueItems: false)
    /** Название точки продаж.  */
    public var name: String
    public var type: OutletType
    /** Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, `20.4522144, 54.7104264`.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в `address`.  */
    public var coords: String?
    /** Признак основной точки продаж.  Возможные значения:  * `false` — неосновная точка продаж. * `true` — основная точка продаж.  */
    public var isMain: Bool?
    /** Идентификатор точки продаж, присвоенный магазином. */
    public var shopOutletCode: String?
    public var visibility: OutletVisibilityType?
    public var address: OutletAddressDTO
    /** Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`.  */
    public var phones: [String]
    public var workingSchedule: OutletWorkingScheduleDTO
    /** Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр `type=DEPOT` или `type=MIXED`.  */
    public var deliveryRules: [OutletDeliveryRuleDTO]?
    /** Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях. */
    public var storagePeriod: Int64?

    public init(name: String, type: OutletType, coords: String? = nil, isMain: Bool? = nil, shopOutletCode: String? = nil, visibility: OutletVisibilityType? = nil, address: OutletAddressDTO, phones: [String], workingSchedule: OutletWorkingScheduleDTO, deliveryRules: [OutletDeliveryRuleDTO]? = nil, storagePeriod: Int64? = nil) {
        self.name = name
        self.type = type
        self.coords = coords
        self.isMain = isMain
        self.shopOutletCode = shopOutletCode
        self.visibility = visibility
        self.address = address
        self.phones = phones
        self.workingSchedule = workingSchedule
        self.deliveryRules = deliveryRules
        self.storagePeriod = storagePeriod
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case type
        case coords
        case isMain
        case shopOutletCode
        case visibility
        case address
        case phones
        case workingSchedule
        case deliveryRules
        case storagePeriod
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(coords, forKey: .coords)
        try container.encodeIfPresent(isMain, forKey: .isMain)
        try container.encodeIfPresent(shopOutletCode, forKey: .shopOutletCode)
        try container.encodeIfPresent(visibility, forKey: .visibility)
        try container.encode(address, forKey: .address)
        try container.encode(phones, forKey: .phones)
        try container.encode(workingSchedule, forKey: .workingSchedule)
        try container.encodeIfPresent(deliveryRules, forKey: .deliveryRules)
        try container.encodeIfPresent(storagePeriod, forKey: .storagePeriod)
    }
}

