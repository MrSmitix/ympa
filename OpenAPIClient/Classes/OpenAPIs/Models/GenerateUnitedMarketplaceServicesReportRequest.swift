//
// GenerateUnitedMarketplaceServicesReportRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Данные, необходимые для генерации отчета: идентификатор магазина, период, за который нужен отчет, а также фильтры.  */
public struct GenerateUnitedMarketplaceServicesReportRequest: Codable, JSONEncodable, Hashable {

    static let monthFromRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: 12, exclusiveMaximum: false, multipleOf: nil)
    static let monthToRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: 12, exclusiveMaximum: false, multipleOf: nil)
    /** Идентификатор бизнеса. */
    public var businessId: Int64
    /** {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Начало периода, включительно.  */
    public var dateTimeFrom: Date?
    /** {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Конец периода, включительно. Максимальный период — 1 год.  */
    public var dateTimeTo: Date?
    /** Начало периода, включительно. */
    public var dateFrom: Date?
    /** Конец периода, включительно. Максимальный период — 1 год. */
    public var dateTo: Date?
    /** Начальный год формирования акта. */
    public var yearFrom: Int?
    /** Начальный номер месяца формирования акта. */
    public var monthFrom: Int?
    /** Конечный год формирования акта. */
    public var yearTo: Int?
    /** Конечный номер месяца формирования акта. */
    public var monthTo: Int?
    /** Список моделей, которые нужны в отчете.  */
    public var placementPrograms: [PlacementType]?
    /** Список ИНН, которые нужны в отчете. */
    public var inns: [String]?
    /** Список магазинов, которые нужны в отчете. */
    public var campaignIds: [Int64]?

    public init(businessId: Int64, dateTimeFrom: Date? = nil, dateTimeTo: Date? = nil, dateFrom: Date? = nil, dateTo: Date? = nil, yearFrom: Int? = nil, monthFrom: Int? = nil, yearTo: Int? = nil, monthTo: Int? = nil, placementPrograms: [PlacementType]? = nil, inns: [String]? = nil, campaignIds: [Int64]? = nil) {
        self.businessId = businessId
        self.dateTimeFrom = dateTimeFrom
        self.dateTimeTo = dateTimeTo
        self.dateFrom = dateFrom
        self.dateTo = dateTo
        self.yearFrom = yearFrom
        self.monthFrom = monthFrom
        self.yearTo = yearTo
        self.monthTo = monthTo
        self.placementPrograms = placementPrograms
        self.inns = inns
        self.campaignIds = campaignIds
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case businessId
        case dateTimeFrom
        case dateTimeTo
        case dateFrom
        case dateTo
        case yearFrom
        case monthFrom
        case yearTo
        case monthTo
        case placementPrograms
        case inns
        case campaignIds
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(businessId, forKey: .businessId)
        try container.encodeIfPresent(dateTimeFrom, forKey: .dateTimeFrom)
        try container.encodeIfPresent(dateTimeTo, forKey: .dateTimeTo)
        try container.encodeIfPresent(dateFrom, forKey: .dateFrom)
        try container.encodeIfPresent(dateTo, forKey: .dateTo)
        try container.encodeIfPresent(yearFrom, forKey: .yearFrom)
        try container.encodeIfPresent(monthFrom, forKey: .monthFrom)
        try container.encodeIfPresent(yearTo, forKey: .yearTo)
        try container.encodeIfPresent(monthTo, forKey: .monthTo)
        try container.encodeIfPresent(placementPrograms, forKey: .placementPrograms)
        try container.encodeIfPresent(inns, forKey: .inns)
        try container.encodeIfPresent(campaignIds, forKey: .campaignIds)
    }
}

