//
// FeedbackDTO.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Отзыв пользователя Яндекс Маркета об указанном магазине. */
public struct FeedbackDTO: Codable, JSONEncodable, Hashable {

    /** Идентификатор отзыва. */
    public var id: Int64?
    /** Дата и время создания отзыва.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`.  */
    public var createdAt: Date?
    /** Комментарий автора отзыва. */
    public var text: String?
    public var state: FeedbackStateType?
    public var author: FeedbackAuthorDTO?
    /** Достоинства магазина, описанные в отзыве. */
    public var pro: String?
    /** Недостатки магазина, описанные в отзыве. */
    public var contra: String?
    /** Переписка автора отзыва с магазином. */
    public var comments: [FeedbackCommentDTO]
    public var shop: FeedbackShopDTO?
    /** Решена ли проблема автора отзыва:  * `true` — да. * `false` — нет.  Если проблема решена, около отзыва на странице магазина появляется соответствующая надпись.  */
    public var resolved: Bool?
    /** {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Является ли отзыв рекомендованным:  * `true` — да. * `false` — нет.  */
    public var verified: Bool?
    /** Купил бы автор отзыва в магазине снова:  * `true` — да. * `false` — нет.  */
    public var recommend: Bool?
    public var grades: FeedbackGradesDTO?
    public var order: FeedbackOrderDTO?

    public init(id: Int64? = nil, createdAt: Date? = nil, text: String? = nil, state: FeedbackStateType? = nil, author: FeedbackAuthorDTO? = nil, pro: String? = nil, contra: String? = nil, comments: [FeedbackCommentDTO], shop: FeedbackShopDTO? = nil, resolved: Bool? = nil, verified: Bool? = nil, recommend: Bool? = nil, grades: FeedbackGradesDTO? = nil, order: FeedbackOrderDTO? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.text = text
        self.state = state
        self.author = author
        self.pro = pro
        self.contra = contra
        self.comments = comments
        self.shop = shop
        self.resolved = resolved
        self.verified = verified
        self.recommend = recommend
        self.grades = grades
        self.order = order
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case createdAt
        case text
        case state
        case author
        case pro
        case contra
        case comments
        case shop
        case resolved
        case verified
        case recommend
        case grades
        case order
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(text, forKey: .text)
        try container.encodeIfPresent(state, forKey: .state)
        try container.encodeIfPresent(author, forKey: .author)
        try container.encodeIfPresent(pro, forKey: .pro)
        try container.encodeIfPresent(contra, forKey: .contra)
        try container.encode(comments, forKey: .comments)
        try container.encodeIfPresent(shop, forKey: .shop)
        try container.encodeIfPresent(resolved, forKey: .resolved)
        try container.encodeIfPresent(verified, forKey: .verified)
        try container.encodeIfPresent(recommend, forKey: .recommend)
        try container.encodeIfPresent(grades, forKey: .grades)
        try container.encodeIfPresent(order, forKey: .order)
    }
}

