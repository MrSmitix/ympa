//
// CategoryParameterDTO.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Характеристика товара. */
public struct CategoryParameterDTO: Codable, JSONEncodable, Hashable {

    /** Идентификатор характеристики. */
    public var id: Int64
    /** Название характеристики. */
    public var name: String?
    public var type: ParameterType
    public var unit: CategoryParameterUnitDTO?
    /** Описание характеристики. */
    public var description: String?
    /** Перечень возможных рекомендаций по заполнению карточки, к которым относится данная характеристика. */
    public var recommendationTypes: [OfferCardRecommendationType]?
    /** Обязательность характеристики. */
    public var _required: Bool
    /** Используется ли характеристика в фильтре. */
    public var filtering: Bool
    /** Является ли характеристика особенностью варианта. */
    public var distinctive: Bool
    /** Можно ли передать сразу несколько значений. */
    public var multivalue: Bool
    /** Можно ли передавать собственное значение, которого нет в списке вариантов Маркета. Только для характеристик типа `ENUM`. */
    public var allowCustomValues: Bool
    /** Список допустимых значений параметра. Только для характеристик типа `ENUM`. */
    public var values: [ParameterValueOptionDTO]?
    public var constraints: ParameterValueConstraintsDTO?
    /** Ограничения на значения, накладываемые другими характеристиками. Только для характеристик типа `ENUM`. */
    public var valueRestrictions: [ValueRestrictionDTO]?

    public init(id: Int64, name: String? = nil, type: ParameterType, unit: CategoryParameterUnitDTO? = nil, description: String? = nil, recommendationTypes: [OfferCardRecommendationType]? = nil, _required: Bool, filtering: Bool, distinctive: Bool, multivalue: Bool, allowCustomValues: Bool, values: [ParameterValueOptionDTO]? = nil, constraints: ParameterValueConstraintsDTO? = nil, valueRestrictions: [ValueRestrictionDTO]? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.unit = unit
        self.description = description
        self.recommendationTypes = recommendationTypes
        self._required = _required
        self.filtering = filtering
        self.distinctive = distinctive
        self.multivalue = multivalue
        self.allowCustomValues = allowCustomValues
        self.values = values
        self.constraints = constraints
        self.valueRestrictions = valueRestrictions
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case name
        case type
        case unit
        case description
        case recommendationTypes
        case _required = "required"
        case filtering
        case distinctive
        case multivalue
        case allowCustomValues
        case values
        case constraints
        case valueRestrictions
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(unit, forKey: .unit)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(recommendationTypes, forKey: .recommendationTypes)
        try container.encode(_required, forKey: ._required)
        try container.encode(filtering, forKey: .filtering)
        try container.encode(distinctive, forKey: .distinctive)
        try container.encode(multivalue, forKey: .multivalue)
        try container.encode(allowCustomValues, forKey: .allowCustomValues)
        try container.encodeIfPresent(values, forKey: .values)
        try container.encodeIfPresent(constraints, forKey: .constraints)
        try container.encodeIfPresent(valueRestrictions, forKey: .valueRestrictions)
    }
}

