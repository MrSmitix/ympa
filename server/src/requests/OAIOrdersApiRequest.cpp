/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "OAIHelpers.h"
#include "OAIOrdersApiRequest.h"

namespace OpenAPI {

OAIOrdersApiRequest::OAIOrdersApiRequest(QHttpEngine::Socket *s, QSharedPointer<OAIOrdersApiHandler> hdl) : QObject(s), socket(s), handler(hdl) {
    auto headers = s->headers();
    for(auto itr = headers.begin(); itr != headers.end(); itr++) {
        requestHeaders.insert(QString(itr.key()), QString(itr.value()));
    }
}

OAIOrdersApiRequest::~OAIOrdersApiRequest(){
    disconnect(this, nullptr, nullptr, nullptr);
    qDebug() << "OAIOrdersApiRequest::~OAIOrdersApiRequest()";
}

QMap<QString, QString>
OAIOrdersApiRequest::getRequestHeaders() const {
    return requestHeaders;
}

void OAIOrdersApiRequest::setResponseHeaders(const QMultiMap<QString, QString>& headers){
    for(auto itr = headers.begin(); itr != headers.end(); ++itr) {
        responseHeaders.insert(itr.key(), itr.value());
    }
}


QHttpEngine::Socket* OAIOrdersApiRequest::getRawSocket(){
    return socket;
}


void OAIOrdersApiRequest::acceptOrderCancellationRequest(const QString& campaign_idstr, const QString& order_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/cancellation/accept";
    connect(this, &OAIOrdersApiRequest::acceptOrderCancellation, handler.data(), &OAIOrdersApiHandler::acceptOrderCancellation);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIAcceptOrderCancellationRequest oai_accept_order_cancellation_request;
    ::OpenAPI::fromJsonValue(oai_accept_order_cancellation_request, obj);
    

    Q_EMIT acceptOrderCancellation(campaign_id, order_id, oai_accept_order_cancellation_request);
}


void OAIOrdersApiRequest::getOrderRequest(const QString& campaign_idstr, const QString& order_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}";
    connect(this, &OAIOrdersApiRequest::getOrder, handler.data(), &OAIOrdersApiHandler::getOrder);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
    

    Q_EMIT getOrder(campaign_id, order_id);
}


void OAIOrdersApiRequest::getOrdersRequest(const QString& campaign_idstr){
    qDebug() << "/campaigns/{campaignId}/orders";
    connect(this, &OAIOrdersApiRequest::getOrders, handler.data(), &OAIOrdersApiHandler::getOrders);

    
    QList<qint64> order_ids;
    if(socket->queryString().keys().contains("order_ids")){
        fromStringValue(socket->queryString().values("order_ids"), order_ids);
    }
    
    QSet<OAIOrderStatusType> status;
    if(socket->queryString().keys().contains("status")){
        fromStringValue(socket->queryString().values("status"), status);
    }
    
    QSet<OAIOrderSubstatusType> substatus;
    if(socket->queryString().keys().contains("substatus")){
        fromStringValue(socket->queryString().values("substatus"), substatus);
    }
    
    QDate from_date;
    if(socket->queryString().keys().contains("from_date")){
        fromStringValue(socket->queryString().value("from_date"), from_date);
    }
    
    QDate to_date;
    if(socket->queryString().keys().contains("to_date")){
        fromStringValue(socket->queryString().value("to_date"), to_date);
    }
    
    QDate supplier_shipment_date_from;
    if(socket->queryString().keys().contains("supplier_shipment_date_from")){
        fromStringValue(socket->queryString().value("supplier_shipment_date_from"), supplier_shipment_date_from);
    }
    
    QDate supplier_shipment_date_to;
    if(socket->queryString().keys().contains("supplier_shipment_date_to")){
        fromStringValue(socket->queryString().value("supplier_shipment_date_to"), supplier_shipment_date_to);
    }
    
    QDateTime updated_at_from;
    if(socket->queryString().keys().contains("updated_at_from")){
        fromStringValue(socket->queryString().value("updated_at_from"), updated_at_from);
    }
    
    QDateTime updated_at_to;
    if(socket->queryString().keys().contains("updated_at_to")){
        fromStringValue(socket->queryString().value("updated_at_to"), updated_at_to);
    }
    
    OAIOrderDeliveryDispatchType dispatch_type;
    if(socket->queryString().keys().contains("dispatch_type")){
        fromStringValue(socket->queryString().value("dispatch_type"), dispatch_type);
    }
    
    bool fake;
    if(socket->queryString().keys().contains("fake")){
        fromStringValue(socket->queryString().value("fake"), fake);
    }
    
    bool has_cis;
    if(socket->queryString().keys().contains("has_cis")){
        fromStringValue(socket->queryString().value("has_cis"), has_cis);
    }
    
    bool only_waiting_for_cancellation_approve;
    if(socket->queryString().keys().contains("only_waiting_for_cancellation_approve")){
        fromStringValue(socket->queryString().value("only_waiting_for_cancellation_approve"), only_waiting_for_cancellation_approve);
    }
    
    bool only_estimated_delivery;
    if(socket->queryString().keys().contains("only_estimated_delivery")){
        fromStringValue(socket->queryString().value("only_estimated_delivery"), only_estimated_delivery);
    }
    
    OAIOrderBuyerType buyer_type;
    if(socket->queryString().keys().contains("buyer_type")){
        fromStringValue(socket->queryString().value("buyer_type"), buyer_type);
    }
    
    qint32 page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    
    qint32 page_size;
    if(socket->queryString().keys().contains("page_size")){
        fromStringValue(socket->queryString().value("page_size"), page_size);
    }
    
    QString page_token;
    if(socket->queryString().keys().contains("page_token")){
        fromStringValue(socket->queryString().value("page_token"), page_token);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
    

    Q_EMIT getOrders(campaign_id, order_ids, status, substatus, from_date, to_date, supplier_shipment_date_from, supplier_shipment_date_to, updated_at_from, updated_at_to, dispatch_type, fake, has_cis, only_waiting_for_cancellation_approve, only_estimated_delivery, buyer_type, page, page_size, page_token, limit);
}


void OAIOrdersApiRequest::provideOrderDigitalCodesRequest(const QString& campaign_idstr, const QString& order_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/deliverDigitalGoods";
    connect(this, &OAIOrdersApiRequest::provideOrderDigitalCodes, handler.data(), &OAIOrdersApiHandler::provideOrderDigitalCodes);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIProvideOrderDigitalCodesRequest oai_provide_order_digital_codes_request;
    ::OpenAPI::fromJsonValue(oai_provide_order_digital_codes_request, obj);
    

    Q_EMIT provideOrderDigitalCodes(campaign_id, order_id, oai_provide_order_digital_codes_request);
}


void OAIOrdersApiRequest::provideOrderItemIdentifiersRequest(const QString& campaign_idstr, const QString& order_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/identifiers";
    connect(this, &OAIOrdersApiRequest::provideOrderItemIdentifiers, handler.data(), &OAIOrdersApiHandler::provideOrderItemIdentifiers);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIProvideOrderItemIdentifiersRequest oai_provide_order_item_identifiers_request;
    ::OpenAPI::fromJsonValue(oai_provide_order_item_identifiers_request, obj);
    

    Q_EMIT provideOrderItemIdentifiers(campaign_id, order_id, oai_provide_order_item_identifiers_request);
}


void OAIOrdersApiRequest::setOrderBoxLayoutRequest(const QString& campaign_idstr, const QString& order_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/boxes";
    connect(this, &OAIOrdersApiRequest::setOrderBoxLayout, handler.data(), &OAIOrdersApiHandler::setOrderBoxLayout);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAISetOrderBoxLayoutRequest oai_set_order_box_layout_request;
    ::OpenAPI::fromJsonValue(oai_set_order_box_layout_request, obj);
    

    Q_EMIT setOrderBoxLayout(campaign_id, order_id, oai_set_order_box_layout_request);
}


void OAIOrdersApiRequest::setOrderShipmentBoxesRequest(const QString& campaign_idstr, const QString& order_idstr, const QString& shipment_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes";
    connect(this, &OAIOrdersApiRequest::setOrderShipmentBoxes, handler.data(), &OAIOrdersApiHandler::setOrderShipmentBoxes);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
        qint64 shipment_id;
    fromStringValue(shipment_idstr, shipment_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAISetOrderShipmentBoxesRequest oai_set_order_shipment_boxes_request;
    ::OpenAPI::fromJsonValue(oai_set_order_shipment_boxes_request, obj);
    

    Q_EMIT setOrderShipmentBoxes(campaign_id, order_id, shipment_id, oai_set_order_shipment_boxes_request);
}


void OAIOrdersApiRequest::updateOrderItemsRequest(const QString& campaign_idstr, const QString& order_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/items";
    connect(this, &OAIOrdersApiRequest::updateOrderItems, handler.data(), &OAIOrdersApiHandler::updateOrderItems);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIUpdateOrderItemRequest oai_update_order_item_request;
    ::OpenAPI::fromJsonValue(oai_update_order_item_request, obj);
    

    Q_EMIT updateOrderItems(campaign_id, order_id, oai_update_order_item_request);
}


void OAIOrdersApiRequest::updateOrderStatusRequest(const QString& campaign_idstr, const QString& order_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/status";
    connect(this, &OAIOrdersApiRequest::updateOrderStatus, handler.data(), &OAIOrdersApiHandler::updateOrderStatus);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIUpdateOrderStatusRequest oai_update_order_status_request;
    ::OpenAPI::fromJsonValue(oai_update_order_status_request, obj);
    

    Q_EMIT updateOrderStatus(campaign_id, order_id, oai_update_order_status_request);
}


void OAIOrdersApiRequest::updateOrderStatusesRequest(const QString& campaign_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/status-update";
    connect(this, &OAIOrdersApiRequest::updateOrderStatuses, handler.data(), &OAIOrdersApiHandler::updateOrderStatuses);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIUpdateOrderStatusesRequest oai_update_order_statuses_request;
    ::OpenAPI::fromJsonValue(oai_update_order_statuses_request, obj);
    

    Q_EMIT updateOrderStatuses(campaign_id, oai_update_order_statuses_request);
}



void OAIOrdersApiRequest::acceptOrderCancellationResponse(const OAIEmptyApiResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::getOrderResponse(const OAIGetOrderResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::getOrdersResponse(const OAIGetOrdersResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::provideOrderDigitalCodesResponse(const OAIEmptyApiResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::provideOrderItemIdentifiersResponse(const OAIProvideOrderItemIdentifiersResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::setOrderBoxLayoutResponse(const OAISetOrderBoxLayoutResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::setOrderShipmentBoxesResponse(const OAISetOrderShipmentBoxesResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::updateOrderItemsResponse(){
    setSocketResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::OK);
    socket->writeHeaders();
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::updateOrderStatusResponse(const OAIUpdateOrderStatusResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::updateOrderStatusesResponse(const OAIUpdateOrderStatusesResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIOrdersApiRequest::acceptOrderCancellationError(const OAIEmptyApiResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::getOrderError(const OAIGetOrderResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::getOrdersError(const OAIGetOrdersResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::provideOrderDigitalCodesError(const OAIEmptyApiResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::provideOrderItemIdentifiersError(const OAIProvideOrderItemIdentifiersResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::setOrderBoxLayoutError(const OAISetOrderBoxLayoutResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::setOrderShipmentBoxesError(const OAISetOrderShipmentBoxesResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::updateOrderItemsError(QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::NotFound);
    socket->write(error_str.toUtf8());
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::updateOrderStatusError(const OAIUpdateOrderStatusResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::updateOrderStatusesError(const OAIUpdateOrderStatusesResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIOrdersApiRequest::sendCustomResponse(QByteArray & res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type); // TODO
    socket->write(res);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIOrdersApiRequest::sendCustomResponse(QIODevice *res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type);  // TODO
    socket->write(res->readAll());
    if(socket->isOpen()){
        socket->close();
    }
}

}
