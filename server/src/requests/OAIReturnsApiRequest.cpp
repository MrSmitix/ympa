/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "OAIHelpers.h"
#include "OAIReturnsApiRequest.h"

namespace OpenAPI {

OAIReturnsApiRequest::OAIReturnsApiRequest(QHttpEngine::Socket *s, QSharedPointer<OAIReturnsApiHandler> hdl) : QObject(s), socket(s), handler(hdl) {
    auto headers = s->headers();
    for(auto itr = headers.begin(); itr != headers.end(); itr++) {
        requestHeaders.insert(QString(itr.key()), QString(itr.value()));
    }
}

OAIReturnsApiRequest::~OAIReturnsApiRequest(){
    disconnect(this, nullptr, nullptr, nullptr);
    qDebug() << "OAIReturnsApiRequest::~OAIReturnsApiRequest()";
}

QMap<QString, QString>
OAIReturnsApiRequest::getRequestHeaders() const {
    return requestHeaders;
}

void OAIReturnsApiRequest::setResponseHeaders(const QMultiMap<QString, QString>& headers){
    for(auto itr = headers.begin(); itr != headers.end(); ++itr) {
        responseHeaders.insert(itr.key(), itr.value());
    }
}


QHttpEngine::Socket* OAIReturnsApiRequest::getRawSocket(){
    return socket;
}


void OAIReturnsApiRequest::getReturnRequest(const QString& campaign_idstr, const QString& order_idstr, const QString& return_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}";
    connect(this, &OAIReturnsApiRequest::getReturn, handler.data(), &OAIReturnsApiHandler::getReturn);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
        qint64 return_id;
    fromStringValue(return_idstr, return_id);
    

    Q_EMIT getReturn(campaign_id, order_id, return_id);
}


void OAIReturnsApiRequest::getReturnApplicationRequest(const QString& campaign_idstr, const QString& order_idstr, const QString& return_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application";
    connect(this, &OAIReturnsApiRequest::getReturnApplication, handler.data(), &OAIReturnsApiHandler::getReturnApplication);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
        qint64 return_id;
    fromStringValue(return_idstr, return_id);
    

    Q_EMIT getReturnApplication(campaign_id, order_id, return_id);
}


void OAIReturnsApiRequest::getReturnPhotoRequest(const QString& campaign_idstr, const QString& order_idstr, const QString& return_idstr, const QString& item_idstr, const QString& image_hashstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}";
    connect(this, &OAIReturnsApiRequest::getReturnPhoto, handler.data(), &OAIReturnsApiHandler::getReturnPhoto);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
        qint64 return_id;
    fromStringValue(return_idstr, return_id);
        qint64 item_id;
    fromStringValue(item_idstr, item_id);
        QString image_hash;
    fromStringValue(image_hashstr, image_hash);
    

    Q_EMIT getReturnPhoto(campaign_id, order_id, return_id, item_id, image_hash);
}


void OAIReturnsApiRequest::getReturnsRequest(const QString& campaign_idstr){
    qDebug() << "/campaigns/{campaignId}/returns";
    connect(this, &OAIReturnsApiRequest::getReturns, handler.data(), &OAIReturnsApiHandler::getReturns);

    
    QString page_token;
    if(socket->queryString().keys().contains("page_token")){
        fromStringValue(socket->queryString().value("page_token"), page_token);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QList<qint64> order_ids;
    if(socket->queryString().keys().contains("order_ids")){
        fromStringValue(socket->queryString().values("order_ids"), order_ids);
    }
    
    QList<OAIRefundStatusType> statuses;
    if(socket->queryString().keys().contains("statuses")){
        fromStringValue(socket->queryString().values("statuses"), statuses);
    }
    
    OAIReturnType type;
    if(socket->queryString().keys().contains("type")){
        fromStringValue(socket->queryString().value("type"), type);
    }
    
    QDate from_date;
    if(socket->queryString().keys().contains("from_date")){
        fromStringValue(socket->queryString().value("from_date"), from_date);
    }
    
    QDate to_date;
    if(socket->queryString().keys().contains("to_date")){
        fromStringValue(socket->queryString().value("to_date"), to_date);
    }
    
    QDate from_date2;
    if(socket->queryString().keys().contains("from_date2")){
        fromStringValue(socket->queryString().value("from_date2"), from_date2);
    }
    
    QDate to_date2;
    if(socket->queryString().keys().contains("to_date2")){
        fromStringValue(socket->queryString().value("to_date2"), to_date2);
    }
    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
    

    Q_EMIT getReturns(campaign_id, page_token, limit, order_ids, statuses, type, from_date, to_date, from_date2, to_date2);
}


void OAIReturnsApiRequest::setReturnDecisionRequest(const QString& campaign_idstr, const QString& order_idstr, const QString& return_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision";
    connect(this, &OAIReturnsApiRequest::setReturnDecision, handler.data(), &OAIReturnsApiHandler::setReturnDecision);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
        qint64 return_id;
    fromStringValue(return_idstr, return_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAISetReturnDecisionRequest oai_set_return_decision_request;
    ::OpenAPI::fromJsonValue(oai_set_return_decision_request, obj);
    

    Q_EMIT setReturnDecision(campaign_id, order_id, return_id, oai_set_return_decision_request);
}


void OAIReturnsApiRequest::submitReturnDecisionRequest(const QString& campaign_idstr, const QString& order_idstr, const QString& return_idstr){
    qDebug() << "/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit";
    connect(this, &OAIReturnsApiRequest::submitReturnDecision, handler.data(), &OAIReturnsApiHandler::submitReturnDecision);

    
    qint64 campaign_id;
    fromStringValue(campaign_idstr, campaign_id);
        qint64 order_id;
    fromStringValue(order_idstr, order_id);
        qint64 return_id;
    fromStringValue(return_idstr, return_id);
    

    Q_EMIT submitReturnDecision(campaign_id, order_id, return_id);
}



void OAIReturnsApiRequest::getReturnResponse(const OAIGetReturnResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::getReturnApplicationResponse(const OAIHttpFileElement& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::getReturnPhotoResponse(const OAIHttpFileElement& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::getReturnsResponse(const OAIGetReturnsResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::setReturnDecisionResponse(const OAIEmptyApiResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::submitReturnDecisionResponse(const OAIEmptyApiResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIReturnsApiRequest::getReturnError(const OAIGetReturnResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::getReturnApplicationError(const OAIHttpFileElement& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::getReturnPhotoError(const OAIHttpFileElement& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::getReturnsError(const OAIGetReturnsResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::setReturnDecisionError(const OAIEmptyApiResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::submitReturnDecisionError(const OAIEmptyApiResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIReturnsApiRequest::sendCustomResponse(QByteArray & res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type); // TODO
    socket->write(res);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIReturnsApiRequest::sendCustomResponse(QIODevice *res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type);  // TODO
    socket->write(res->readAll());
    if(socket->isOpen()){
        socket->close();
    }
}

}
