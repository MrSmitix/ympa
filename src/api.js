// @flow
/* eslint-disable no-use-before-define */
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://api.partner.market.yandex.ru".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type AcceptOrderCancellationRequest = {
    /**
     * Решение об отмене заказа:  * `true` — заказ отменяется, служба доставки узнала об отмене до передачи заказа покупателю. * `false` — заказ не отменяется, так как он уже доставлен покупателю курьером или передан в пункт выдачи заказов. 
     * @type {boolean}
     * @memberof AcceptOrderCancellationRequest
     */
    accepted: boolean;
    /**
     * 
     * @type {OrderCancellationReasonType}
     * @memberof AcceptOrderCancellationRequest
     */
    reason?: OrderCancellationReasonType;
}

/**
 * Запрос на скрытие оферов.
 * @export
 */
export type AddHiddenOffersRequest = {
    /**
     * Список скрытых товаров. 
     * @type {Array<HiddenOfferDTO>}
     * @memberof AddHiddenOffersRequest
     */
    hiddenOffers: Array<HiddenOfferDTO>;
}

/**
 * Товары, которые не удалось поместить в архив.
 * @export
 */
export type AddOffersToArchiveDTO = {
    /**
     * Список товаров, которые не удалось поместить в архив.
     * @type {Array<AddOffersToArchiveErrorDTO>}
     * @memberof AddOffersToArchiveDTO
     */
    notArchivedOffers?: Array<AddOffersToArchiveErrorDTO>;
}

/**
 * Товар, который не удалось поместить в архив.
 * @export
 */
export type AddOffersToArchiveErrorDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof AddOffersToArchiveErrorDTO
     */
    offerId: string;
    /**
     * 
     * @type {AddOffersToArchiveErrorType}
     * @memberof AddOffersToArchiveErrorDTO
     */
    error: AddOffersToArchiveErrorType;
}

/**
 * Причина, по которой товар не удалось поместить в архив:  * `OFFER_HAS_STOCKS` — товар хранится на складе Маркета. 
 * @export
 * @enum {string}
 */
export type AddOffersToArchiveErrorType = 'OFFER_HAS_STOCKS' | 'UNKNOWN';

/**
 * Товары, которые нужно поместить в архив. 
 * @export
 */
export type AddOffersToArchiveRequest = {
    /**
     * Список товаров, которые нужно поместить в архив.
     * @type {Array<string>}
     * @memberof AddOffersToArchiveRequest
     */
    offerIds: Array<string>;
}

/**
 * Результат архивации товаров.
 * @export
 */
export type AddOffersToArchiveResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof AddOffersToArchiveResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {AddOffersToArchiveDTO}
     * @memberof AddOffersToArchiveResponse
     */
    result?: AddOffersToArchiveDTO;
}

/**
 * Составляющие индекса качества.  **Для модели DBS:** * `DBS_CANCELLATION_RATE` — доля отмененных товаров. * `DBS_LATE_DELIVERY_RATE` — доля заказов, доставленных после плановой даты.  **Для моделей FBS и Экспресс:** * `FBS_CANCELLATION_RATE` — доля отмененных товаров. * `FBS_LATE_SHIP_RATE` — доля не вовремя отгруженных заказов. 
 * @export
 * @enum {string}
 */
export type AffectedOrderQualityRatingComponentType = 'DBS_CANCELLATION_RATE' | 'DBS_LATE_DELIVERY_RATE' | 'FBS_CANCELLATION_RATE' | 'FBS_LATE_SHIP_RATE';

/**
 * Возраст в заданных единицах измерения.
 * @export
 */
export type AgeDTO = {
    /**
     * Значение. 
     * @type {number}
     * @memberof AgeDTO
     */
    value: number;
    /**
     * 
     * @type {AgeUnitType}
     * @memberof AgeDTO
     */
    ageUnit: AgeUnitType;
}

/**
 * Единицы измерения возраста:  * `YEAR` — год. * `MONTH` — месяц. 
 * @export
 * @enum {string}
 */
export type AgeUnitType = 'YEAR' | 'MONTH';

/**
 * Ошибка в данных переданных от клиента.
 * @export
 */
export type ApiClientDataErrorResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ApiClientDataErrorResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Список ошибок.
     * @type {Array<ApiErrorDTO>}
     * @memberof ApiClientDataErrorResponse
     */
    errors?: Array<ApiErrorDTO>;
}

/**
 * Общий формат ошибки.
 * @export
 */
export type ApiErrorDTO = {
    /**
     * Код ошибки.
     * @type {string}
     * @memberof ApiErrorDTO
     */
    code: string;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof ApiErrorDTO
     */
    message?: string;
}

/**
 * Стандартная обертка для ошибок сервера.
 * @export
 */
export type ApiErrorResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ApiErrorResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Список ошибок.
     * @type {Array<ApiErrorDTO>}
     * @memberof ApiErrorResponse
     */
    errors?: Array<ApiErrorDTO>;
}

/**
 * Неверны авторизационные данные, указанные в запросе, или запрещен доступ к запрашиваемому ресурсу.
 * @export
 */
export type ApiForbiddenErrorResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ApiForbiddenErrorResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Список ошибок.
     * @type {Array<ApiErrorDTO>}
     * @memberof ApiForbiddenErrorResponse
     */
    errors?: Array<ApiErrorDTO>;
}

/**
 * Превышено ограничение на доступ к ресурсу.
 * @export
 */
export type ApiLimitErrorResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ApiLimitErrorResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Список ошибок.
     * @type {Array<ApiErrorDTO>}
     * @memberof ApiLimitErrorResponse
     */
    errors?: Array<ApiErrorDTO>;
}

/**
 * Ресурс из запроса заблокирован от применения к нему указанного метода.
 * @export
 */
export type ApiLockedErrorResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ApiLockedErrorResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Список ошибок.
     * @type {Array<ApiErrorDTO>}
     * @memberof ApiLockedErrorResponse
     */
    errors?: Array<ApiErrorDTO>;
}

/**
 * Запрашиваемый ресурс не найден.
 * @export
 */
export type ApiNotFoundErrorResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ApiNotFoundErrorResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Список ошибок.
     * @type {Array<ApiErrorDTO>}
     * @memberof ApiNotFoundErrorResponse
     */
    errors?: Array<ApiErrorDTO>;
}

/**
 * Стандартная обертка для ответов сервера.
 * @export
 */
export type ApiResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ApiResponse
     */
    status?: ApiResponseStatusType;
}

/**
 * Тип ответа.
 * @export
 * @enum {string}
 */
export type ApiResponseStatusType = 'OK' | 'ERROR';

/**
 * Внутренняя ошибка сервера.
 * @export
 */
export type ApiServerErrorResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ApiServerErrorResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Список ошибок.
     * @type {Array<ApiErrorDTO>}
     * @memberof ApiServerErrorResponse
     */
    errors?: Array<ApiErrorDTO>;
}

/**
 * В запросе не указаны авторизационные данные.
 * @export
 */
export type ApiUnauthorizedErrorResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ApiUnauthorizedErrorResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Список ошибок.
     * @type {Array<ApiErrorDTO>}
     * @memberof ApiUnauthorizedErrorResponse
     */
    errors?: Array<ApiErrorDTO>;
}

/**
 * Информация о новой цене на товар.
 * @export
 */
export type BaseCampaignOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof BaseCampaignOfferDTO
     */
    offerId: string;
    /**
     * 
     * @type {QuantumDTO}
     * @memberof BaseCampaignOfferDTO
     */
    quantum?: QuantumDTO;
    /**
     * Есть ли товар в продаже. 
     * @type {boolean}
     * @memberof BaseCampaignOfferDTO
     */
    available?: boolean;
}

/**
 * Основные параметры товара.
 * @export
 */
export type BaseOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof BaseOfferDTO
     */
    offerId: string;
    /**
     * Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
     * @type {string}
     * @memberof BaseOfferDTO
     */
    name?: string;
    /**
     * Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать `marketCategoryId`, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
     * @type {number}
     * @memberof BaseOfferDTO
     */
    marketCategoryId?: number;
    /**
     * Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
     * @type {string}
     * @memberof BaseOfferDTO
     */
    category?: string;
    /**
     * Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/images/sku12345.jpg`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/images/sku12345.jpg`  ❌ `https://www.dropbox.com/s/818f/tovar.jpg`  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html) 
     * @type {Array<string>}
     * @memberof BaseOfferDTO
     */
    pictures?: Array<string>;
    /**
     * Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/video/sku12345.avi`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/video/sku12345.avi`  ❌ `https://www.dropbox.com/s/818f/super-tovar.avi`  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html) 
     * @type {Array<string>}
     * @memberof BaseOfferDTO
     */
    videos?: Array<string>;
    /**
     * Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле `manuals`, загруженные ранее инструкции удалятся. 
     * @type {Array<OfferManualDTO>}
     * @memberof BaseOfferDTO
     */
    manuals?: Array<OfferManualDTO>;
    /**
     * Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
     * @type {string}
     * @memberof BaseOfferDTO
     */
    vendor?: string;
    /**
     * Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
     * @type {Array<string>}
     * @memberof BaseOfferDTO
     */
    barcodes?: Array<string>;
    /**
     * Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
     * @type {string}
     * @memberof BaseOfferDTO
     */
    description?: string;
    /**
     * Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx). 
     * @type {Array<string>}
     * @memberof BaseOfferDTO
     */
    manufacturerCountries?: Array<string>;
    /**
     * 
     * @type {OfferWeightDimensionsDTO}
     * @memberof BaseOfferDTO
     */
    weightDimensions?: OfferWeightDimensionsDTO;
    /**
     * Артикул товара от производителя.
     * @type {string}
     * @memberof BaseOfferDTO
     */
    vendorCode?: string;
    /**
     * Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов. 
     * @type {Array<string>}
     * @memberof BaseOfferDTO
     */
    tags?: Array<string>;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof BaseOfferDTO
     */
    shelfLife?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof BaseOfferDTO
     */
    lifeTime?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof BaseOfferDTO
     */
    guaranteePeriod?: TimePeriodDTO;
    /**
     * Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть. 
     * @type {string}
     * @memberof BaseOfferDTO
     */
    customsCommodityCode?: string;
    /**
     * Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html). 
     * @type {Array<string>}
     * @memberof BaseOfferDTO
     */
    certificates?: Array<string>;
    /**
     * Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр. 
     * @type {number}
     * @memberof BaseOfferDTO
     */
    boxCount?: number;
    /**
     * 
     * @type {OfferConditionDTO}
     * @memberof BaseOfferDTO
     */
    condition?: OfferConditionDTO;
    /**
     * 
     * @type {OfferType}
     * @memberof BaseOfferDTO
     */
    type?: OfferType;
    /**
     * Признак цифрового товара. Укажите `true`, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md) 
     * @type {boolean}
     * @memberof BaseOfferDTO
     */
    downloadable?: boolean;
    /**
     * Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей. 
     * @type {boolean}
     * @memberof BaseOfferDTO
     */
    adult?: boolean;
    /**
     * 
     * @type {AgeDTO}
     * @memberof BaseOfferDTO
     */
    age?: AgeDTO;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. При передаче характеристик используйте `parameterValues`.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви. 
     * @type {Array<OfferParamDTO>}
     * @memberof BaseOfferDTO
     */
    params?: Array<OfferParamDTO>;
}

/**
 * Цена на товар.
 * @export
 */
export type BasePriceDTO = {
    /**
     * Значение.
     * @type {number}
     * @memberof BasePriceDTO
     */
    value: number;
    /**
     * 
     * @type {CurrencyType}
     * @memberof BasePriceDTO
     */
    currencyId: CurrencyType;
}

/**
 * Информация об отгрузке.
 * @export
 */
export type BaseShipmentDTO = {
    /**
     * Идентификатор отгрузки.
     * @type {number}
     * @memberof BaseShipmentDTO
     */
    id?: number;
    /**
     * Начало планового интервала отгрузки.
     * @type {Date}
     * @memberof BaseShipmentDTO
     */
    planIntervalFrom?: Date;
    /**
     * Конец планового интервала отгрузки.
     * @type {Date}
     * @memberof BaseShipmentDTO
     */
    planIntervalTo?: Date;
    /**
     * 
     * @type {ShipmentType}
     * @memberof BaseShipmentDTO
     */
    shipmentType?: ShipmentType;
    /**
     * 
     * @type {PartnerShipmentWarehouseDTO}
     * @memberof BaseShipmentDTO
     */
    warehouse?: PartnerShipmentWarehouseDTO;
    /**
     * 
     * @type {PartnerShipmentWarehouseDTO}
     * @memberof BaseShipmentDTO
     */
    warehouseTo?: PartnerShipmentWarehouseDTO;
    /**
     * Идентификатор отгрузки в вашей системе. Если вы еще не передавали идентификатор, вернется идентификатор из параметра `id`.
     * @type {string}
     * @memberof BaseShipmentDTO
     */
    externalId?: string;
    /**
     * 
     * @type {DeliveryServiceDTO}
     * @memberof BaseShipmentDTO
     */
    deliveryService?: DeliveryServiceDTO;
    /**
     * 
     * @type {PalletsCountDTO}
     * @memberof BaseShipmentDTO
     */
    palletsCount?: PalletsCountDTO;
    /**
     * Идентификаторы заказов в отгрузке.
     * @type {Set<number>}
     * @memberof BaseShipmentDTO
     */
    orderIds: Set<number>;
    /**
     * Количество заказов, которое Маркет запланировал к отгрузке.
     * @type {number}
     * @memberof BaseShipmentDTO
     */
    draftCount?: number;
    /**
     * Количество заказов, которое Маркет подтвердил к отгрузке.
     * @type {number}
     * @memberof BaseShipmentDTO
     */
    plannedCount?: number;
    /**
     * Количество заказов, принятых в сортировочном центре или пункте приема.
     * @type {number}
     * @memberof BaseShipmentDTO
     */
    factCount?: number;
}

/**
 * Рекомендованная ставка и возможная доля показов.
 * @export
 */
export type BidRecommendationItemDTO = {
    /**
     * Значение ставки.
     * @type {number}
     * @memberof BidRecommendationItemDTO
     */
    bid: number;
    /**
     * Доля показов. 
     * @type {number}
     * @memberof BidRecommendationItemDTO
     */
    showPercent: number;
}

/**
 * Информация о маркированном товаре.
 * @export
 */
export type BriefOrderItemDTO = {
    /**
     * Идентификатор товара в заказе.  Позволяет идентифицировать товар в рамках данного заказа. 
     * @type {number}
     * @memberof BriefOrderItemDTO
     */
    id?: number;
    /**
     * 
     * @type {OrderVatType}
     * @memberof BriefOrderItemDTO
     */
    vat?: OrderVatType;
    /**
     * Количество единиц товара.
     * @type {number}
     * @memberof BriefOrderItemDTO
     */
    count?: number;
    /**
     * Цена на товар. Указана в той валюте, которая была задана в каталоге. Разделитель целой и дробной части — точка. 
     * @type {number}
     * @memberof BriefOrderItemDTO
     */
    price?: number;
    /**
     * Название товара.
     * @type {string}
     * @memberof BriefOrderItemDTO
     */
    offerName?: string;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof BriefOrderItemDTO
     */
    offerId?: string;
    /**
     * Переданные вами коды маркировки.
     * @type {Array<OrderItemInstanceDTO>}
     * @memberof BriefOrderItemDTO
     */
    instances?: Array<OrderItemInstanceDTO>;
}

/**
 * Идентификатор единицы товара.  Заполните только одно поле в зависимости от того, в какой системе маркирован товар.  Подробно о работе с маркируемыми товарами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/cz.html). 
 * @export
 */
export type BriefOrderItemInstanceDTO = {
    /**
     * Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).  {% note warning %}  Не экранируйте косую черту в коде символа-разделителя `\\u001d`!  ✅ `01030410947874432155Qbag!\\u001d93Zjqw`  ❌ `01030410947874432155Qbag!\\\\u001d93Zjqw`  Косые черты и кавычки в других местах экранируйте по правилам JSON: `\\\\` и `\\\"`  {% endnote %} 
     * @type {string}
     * @memberof BriefOrderItemInstanceDTO
     */
    cis?: string;
    /**
     * Уникальный идентификационный номер ювелирного изделия.  Представляет собой число из 16 цифр. 
     * @type {string}
     * @memberof BriefOrderItemInstanceDTO
     */
    uin?: string;
    /**
     * Регистрационный номер партии товара.  Представляет собой строку из четырех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ/ХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на партию товара. Далее — дата, номер декларации и номер маркированного товара в декларации. 
     * @type {string}
     * @memberof BriefOrderItemInstanceDTO
     */
    rnpt?: string;
    /**
     * Грузовая таможенная декларация.  Представляет собой строку из трех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на ввезенные товары. Далее — дата и номер декларации. 
     * @type {string}
     * @memberof BriefOrderItemInstanceDTO
     */
    gtd?: string;
}

/**
 * Информация о кабинете.
 * @export
 */
export type BusinessDTO = {
    /**
     * Идентификатор кабинета.
     * @type {number}
     * @memberof BusinessDTO
     */
    id?: number;
    /**
     * Название бизнеса.
     * @type {string}
     * @memberof BusinessDTO
     */
    name?: string;
}

/**
 * Настройки кабинета.
 * @export
 */
export type BusinessSettingsDTO = {
    /**
     * Можно ли установить только [базовую цену](*rule): * `false` — можно задать и базовую цену, и цены в конкретных магазинах. * `true` — можно задать только базовую цену. 
     * @type {boolean}
     * @memberof BusinessSettingsDTO
     */
    onlyDefaultPrice?: boolean;
    /**
     * 
     * @type {CurrencyType}
     * @memberof BusinessSettingsDTO
     */
    currency?: CurrencyType;
}

/**
 * Параметры товара, для которого нужно рассчитать стоимость услуг.
 * @export
 */
export type CalculateTariffsOfferDTO = {
    /**
     * Идентификатор категории товара на Маркете.  Для расчета стоимости услуг необходимо указать идентификатор листовой категории товара — той, которая не имеет дочерних категорий.  Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
     * @type {number}
     * @memberof CalculateTariffsOfferDTO
     */
    categoryId: number;
    /**
     * Цена на товар в рублях.
     * @type {number}
     * @memberof CalculateTariffsOfferDTO
     */
    price: number;
    /**
     * Длина товара в сантиметрах.
     * @type {number}
     * @memberof CalculateTariffsOfferDTO
     */
    length: number;
    /**
     * Ширина товара в сантиметрах.
     * @type {number}
     * @memberof CalculateTariffsOfferDTO
     */
    width: number;
    /**
     * Высота товара в сантиметрах.
     * @type {number}
     * @memberof CalculateTariffsOfferDTO
     */
    height: number;
    /**
     * Вес товара в килограммах.
     * @type {number}
     * @memberof CalculateTariffsOfferDTO
     */
    weight: number;
    /**
     * Квант продажи — количество единиц товара в одном товарном предложении.
     * @type {number}
     * @memberof CalculateTariffsOfferDTO
     */
    quantity?: number;
}

/**
 * Стоимость услуг.
 * @export
 */
export type CalculateTariffsOfferInfoDTO = {
    /**
     * 
     * @type {CalculateTariffsOfferDTO}
     * @memberof CalculateTariffsOfferInfoDTO
     */
    offer: CalculateTariffsOfferDTO;
    /**
     * Список услуг и их стоимость.  По некоторым услугам могут возвращаться несколько разных стоимостей. Например, в модели FBS стоимость услуги `SORTING` (обработка заказа) зависит от способа отгрузки и количества заказов в отгрузке. Подробнее о тарифах на услуги читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/introduction/rates/models/). 
     * @type {Array<CalculatedTariffDTO>}
     * @memberof CalculateTariffsOfferInfoDTO
     */
    tariffs: Array<CalculatedTariffDTO>;
}

/**
 * Параметры для расчета стоимости услуг.
 * @export
 */
export type CalculateTariffsParametersDTO = {
    /**
     * Идентификатор кампании. У пользователя, который выполняет запрос, должен быть доступ к этой кампании.  Используйте параметр `campaignId`, если уже завершили подключение магазина на Маркете. Иначе вернется пустой список.  Обязательный параметр, если не указан параметр `sellingProgram`. Совместное использование параметров приведет к ошибке. 
     * @type {number}
     * @memberof CalculateTariffsParametersDTO
     */
    campaignId?: number;
    /**
     * 
     * @type {SellingProgramType}
     * @memberof CalculateTariffsParametersDTO
     */
    sellingProgram?: SellingProgramType;
    /**
     * 
     * @type {PaymentFrequencyType}
     * @memberof CalculateTariffsParametersDTO
     */
    frequency?: PaymentFrequencyType;
}

/**
 * 
 * @export
 */
export type CalculateTariffsRequest = {
    /**
     * 
     * @type {CalculateTariffsParametersDTO}
     * @memberof CalculateTariffsRequest
     */
    parameters: CalculateTariffsParametersDTO;
    /**
     * Товары, для которых нужно рассчитать стоимость услуг.
     * @type {Array<CalculateTariffsOfferDTO>}
     * @memberof CalculateTariffsRequest
     */
    offers: Array<CalculateTariffsOfferDTO>;
}

/**
 * 
 * @export
 */
export type CalculateTariffsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof CalculateTariffsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {CalculateTariffsResponseDTO}
     * @memberof CalculateTariffsResponse
     */
    result?: CalculateTariffsResponseDTO;
}

/**
 * Расчет стоимости услуг.
 * @export
 */
export type CalculateTariffsResponseDTO = {
    /**
     * Стоимость услуг.
     * @type {Array<CalculateTariffsOfferInfoDTO>}
     * @memberof CalculateTariffsResponseDTO
     */
    offers: Array<CalculateTariffsOfferInfoDTO>;
}

/**
 * Информация об услугах Маркета.
 * @export
 */
export type CalculatedTariffDTO = {
    /**
     * 
     * @type {CalculatedTariffType}
     * @memberof CalculatedTariffDTO
     */
    type: CalculatedTariffType;
    /**
     * Стоимость услуги в рублях.
     * @type {number}
     * @memberof CalculatedTariffDTO
     */
    amount?: number;
    /**
     * Параметры расчета тарифа.
     * @type {Array<TariffParameterDTO>}
     * @memberof CalculatedTariffDTO
     */
    parameters: Array<TariffParameterDTO>;
}

/**
 * Услуга Маркета:  * `AGENCY_COMMISSION` — прием платежа покупателя.  * `PAYMENT_TRANSFER` — перевод платежа покупателя.  * `FEE` — размещение товара на Маркете.  * `DELIVERY_TO_CUSTOMER` — доставка покупателю.  * `CROSSREGIONAL_DELIVERY` — доставка в федеральный округ, город или населенный пункт.  * `EXPRESS_DELIVERY` — экспресс-доставка покупателю.  * `SORTING` — обработка заказа.  * `MIDDLE_MILE` — средняя миля.  Подробнее об услугах Маркета читайте [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/introduction/rates/index.html). 
 * @export
 * @enum {string}
 */
export type CalculatedTariffType = 'AGENCY_COMMISSION' | 'PAYMENT_TRANSFER' | 'FEE' | 'DELIVERY_TO_CUSTOMER' | 'CROSSREGIONAL_DELIVERY' | 'EXPRESS_DELIVERY' | 'SORTING' | 'MIDDLE_MILE';

/**
 * Информация о магазине.
 * @export
 */
export type CampaignDTO = {
    /**
     * URL магазина.
     * @type {string}
     * @memberof CampaignDTO
     */
    domain?: string;
    /**
     * Идентификатор кампании.
     * @type {number}
     * @memberof CampaignDTO
     */
    id?: number;
    /**
     * Идентификатор плательщика в Яндекс Балансе.
     * @type {number}
     * @memberof CampaignDTO
     */
    clientId?: number;
    /**
     * 
     * @type {BusinessDTO}
     * @memberof CampaignDTO
     */
    business?: BusinessDTO;
    /**
     * 
     * @type {PlacementType}
     * @memberof CampaignDTO
     */
    placementType?: PlacementType;
}

/**
 * Информация об индексе качества магазина.
 * @export
 */
export type CampaignQualityRatingDTO = {
    /**
     * Идентификатор магазина.
     * @type {number}
     * @memberof CampaignQualityRatingDTO
     */
    campaignId: number;
    /**
     * Список значений индекса качества.
     * @type {Array<QualityRatingDTO>}
     * @memberof CampaignQualityRatingDTO
     */
    ratings: Array<QualityRatingDTO>;
}

/**
 * Настройки магазина.
 * @export
 */
export type CampaignSettingsDTO = {
    /**
     * Идентификатор региона, в котором находится магазин.
     * @type {number}
     * @memberof CampaignSettingsDTO
     */
    countryRegion?: number;
    /**
     * Наименование магазина на Яндекс Маркете. Если наименование отсутствует, значение параметра выводится — `null`. 
     * @type {string}
     * @memberof CampaignSettingsDTO
     */
    shopName?: string;
    /**
     * Признак размещения магазина на сайтах партнеров Яндекс Дистрибуции. Возможные значения: * `false` — магазин не размещен на сайтах партнеров Яндекс Дистрибуции. * `true` — магазин размещен на сайтах партнеров Яндекс Дистрибуции. 
     * @type {boolean}
     * @memberof CampaignSettingsDTO
     */
    showInContext?: boolean;
    /**
     * Признак показа предложений магазина в рекламном блоке над результатами поиска (cпецразмещение). Возможные значения: * `false` — предложения не показываются в блоке cпецразмещения. * `true` — предложения показываются в блоке cпецразмещения. 
     * @type {boolean}
     * @memberof CampaignSettingsDTO
     */
    showInPremium?: boolean;
    /**
     * Признак использования внешней интернет-статистики. Возможные значения: * `false` — внешняя интернет-статистика не используется. * `true` — внешняя интернет-статистика используется. 
     * @type {boolean}
     * @memberof CampaignSettingsDTO
     */
    useOpenStat?: boolean;
    /**
     * 
     * @type {CampaignSettingsLocalRegionDTO}
     * @memberof CampaignSettingsDTO
     */
    localRegion?: CampaignSettingsLocalRegionDTO;
}

/**
 * Информация о доставке в своем регионе магазина.
 * @export
 */
export type CampaignSettingsDeliveryDTO = {
    /**
     * 
     * @type {CampaignSettingsScheduleDTO}
     * @memberof CampaignSettingsDeliveryDTO
     */
    schedule?: CampaignSettingsScheduleDTO;
}

/**
 * Информация о своем регионе магазина.
 * @export
 */
export type CampaignSettingsLocalRegionDTO = {
    /**
     * Идентификатор региона.
     * @type {number}
     * @memberof CampaignSettingsLocalRegionDTO
     */
    id?: number;
    /**
     * Название региона.
     * @type {string}
     * @memberof CampaignSettingsLocalRegionDTO
     */
    name?: string;
    /**
     * 
     * @type {RegionType}
     * @memberof CampaignSettingsLocalRegionDTO
     */
    type?: RegionType;
    /**
     * 
     * @type {CampaignSettingsScheduleSourceType}
     * @memberof CampaignSettingsLocalRegionDTO
     */
    deliveryOptionsSource?: CampaignSettingsScheduleSourceType;
    /**
     * 
     * @type {CampaignSettingsDeliveryDTO}
     * @memberof CampaignSettingsLocalRegionDTO
     */
    delivery?: CampaignSettingsDeliveryDTO;
}

/**
 * Расписание работы службы доставки в своем регионе.
 * @export
 */
export type CampaignSettingsScheduleDTO = {
    /**
     * Признак работы службы доставки в государственные праздники. Возможные значения. * `false` — служба доставки не работает в праздничные дни. * `true` — служба доставки работает в праздничные дни. 
     * @type {boolean}
     * @memberof CampaignSettingsScheduleDTO
     */
    availableOnHolidays?: boolean;
    /**
     * Список дней, в которые служба доставки не работает. Дни магазин указал в кабинете продавца на Маркете.
     * @type {Array<string>}
     * @memberof CampaignSettingsScheduleDTO
     */
    customHolidays: Array<string>;
    /**
     * Список выходных и праздничных дней, в которые служба доставки работает. Дни магазин указал в кабинете продавца на Маркете.
     * @type {Array<string>}
     * @memberof CampaignSettingsScheduleDTO
     */
    customWorkingDays: Array<string>;
    /**
     * 
     * @type {CampaignSettingsTimePeriodDTO}
     * @memberof CampaignSettingsScheduleDTO
     */
    period?: CampaignSettingsTimePeriodDTO;
    /**
     * Итоговый список нерабочих дней службы доставки. Список рассчитывается с учетом выходных, нерабочих дней и государственных праздников. Информацию по ним магазин указывает в кабинете продавца на Маркете.
     * @type {Array<string>}
     * @memberof CampaignSettingsScheduleDTO
     */
    totalHolidays: Array<string>;
    /**
     * Список выходных дней недели и государственных праздников.
     * @type {Array<number>}
     * @memberof CampaignSettingsScheduleDTO
     */
    weeklyHolidays: Array<number>;
}

/**
 * Источник информации о расписании работы службы доставки. Возможные значения: * `WEB` — информация получена из настроек кабинета продавца на Маркете. * `YML` — информация получена из прайс-листа магазина. 
 * @export
 * @enum {string}
 */
export type CampaignSettingsScheduleSourceType = 'WEB' | 'YML';

/**
 * Период, за который рассчитывается итоговый список нерабочих дней службы доставки.
 * @export
 */
export type CampaignSettingsTimePeriodDTO = {
    /**
     * Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {string}
     * @memberof CampaignSettingsTimePeriodDTO
     */
    fromDate?: string;
    /**
     * Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {string}
     * @memberof CampaignSettingsTimePeriodDTO
     */
    toDate?: string;
}

/**
 * Информация об индексе качества магазинов.
 * @export
 */
export type CampaignsQualityRatingDTO = {
    /**
     * Список магазинов c информацией об их индексе качества.
     * @type {Array<CampaignQualityRatingDTO>}
     * @memberof CampaignsQualityRatingDTO
     */
    campaignRatings: Array<CampaignQualityRatingDTO>;
}

/**
 * Информация о параметрах категории.
 * @export
 */
export type CategoryContentParametersDTO = {
    /**
     * Идентификатор категории на Маркете. Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).
     * @type {number}
     * @memberof CategoryContentParametersDTO
     */
    categoryId: number;
    /**
     * Список характеристик.
     * @type {Array<CategoryParameterDTO>}
     * @memberof CategoryContentParametersDTO
     */
    parameters?: Array<CategoryParameterDTO>;
}

/**
 * Информация о категории.  Категория считается листовой, если у нее нет дочерних категорий. 
 * @export
 */
export type CategoryDTO = {
    /**
     * Идентификатор категории.
     * @type {number}
     * @memberof CategoryDTO
     */
    id: number;
    /**
     * Название категории.
     * @type {string}
     * @memberof CategoryDTO
     */
    name: string;
    /**
     * Дочерние категории.
     * @type {Array<CategoryDTO>}
     * @memberof CategoryDTO
     */
    children?: Array<CategoryDTO>;
}

/**
 * Текст ошибки.
 * @export
 */
export type CategoryErrorDTO = {
    /**
     * Идентификатор категории.
     * @type {number}
     * @memberof CategoryErrorDTO
     */
    categoryId?: number;
    /**
     * 
     * @type {CategoryErrorType}
     * @memberof CategoryErrorDTO
     */
    type?: CategoryErrorType;
}

/**
 * Типы ошибок:  * `UNKNOWN_CATEGORY` — указана неизвестная категория. * `CATEGORY_IS_NOT_LEAF` — указана нелистовая категория. Укажите ту, которая не имеет дочерних категорий. 
 * @export
 * @enum {string}
 */
export type CategoryErrorType = 'UNKNOWN_CATEGORY' | 'CATEGORY_IS_NOT_LEAF';

/**
 * Характеристика товара.
 * @export
 */
export type CategoryParameterDTO = {
    /**
     * Идентификатор характеристики.
     * @type {number}
     * @memberof CategoryParameterDTO
     */
    id: number;
    /**
     * Название характеристики.
     * @type {string}
     * @memberof CategoryParameterDTO
     */
    name?: string;
    /**
     * 
     * @type {ParameterType}
     * @memberof CategoryParameterDTO
     */
    type: ParameterType;
    /**
     * 
     * @type {CategoryParameterUnitDTO}
     * @memberof CategoryParameterDTO
     */
    unit?: CategoryParameterUnitDTO;
    /**
     * Описание характеристики.
     * @type {string}
     * @memberof CategoryParameterDTO
     */
    description?: string;
    /**
     * Перечень возможных рекомендаций по заполнению карточки, к которым относится данная характеристика.
     * @type {Array<OfferCardRecommendationType>}
     * @memberof CategoryParameterDTO
     */
    recommendationTypes?: Array<OfferCardRecommendationType>;
    /**
     * Обязательность характеристики.
     * @type {boolean}
     * @memberof CategoryParameterDTO
     */
    required: boolean;
    /**
     * Используется ли характеристика в фильтре.
     * @type {boolean}
     * @memberof CategoryParameterDTO
     */
    filtering: boolean;
    /**
     * Является ли характеристика особенностью варианта.
     * @type {boolean}
     * @memberof CategoryParameterDTO
     */
    distinctive: boolean;
    /**
     * Можно ли передать сразу несколько значений.
     * @type {boolean}
     * @memberof CategoryParameterDTO
     */
    multivalue: boolean;
    /**
     * Можно ли передавать собственное значение, которого нет в списке вариантов Маркета. Только для характеристик типа `ENUM`.
     * @type {boolean}
     * @memberof CategoryParameterDTO
     */
    allowCustomValues: boolean;
    /**
     * Список допустимых значений параметра. Только для характеристик типа `ENUM`.
     * @type {Array<ParameterValueOptionDTO>}
     * @memberof CategoryParameterDTO
     */
    values?: Array<ParameterValueOptionDTO>;
    /**
     * 
     * @type {ParameterValueConstraintsDTO}
     * @memberof CategoryParameterDTO
     */
    constraints?: ParameterValueConstraintsDTO;
    /**
     * Ограничения на значения, накладываемые другими характеристиками. Только для характеристик типа `ENUM`.
     * @type {Array<ValueRestrictionDTO>}
     * @memberof CategoryParameterDTO
     */
    valueRestrictions?: Array<ValueRestrictionDTO>;
}

/**
 * Единицы измерения характеристики товара.
 * @export
 */
export type CategoryParameterUnitDTO = {
    /**
     * Единица измерения по умолчанию.
     * @type {number}
     * @memberof CategoryParameterUnitDTO
     */
    defaultUnitId: number;
    /**
     * Допустимые единицы измерения.
     * @type {Array<UnitDTO>}
     * @memberof CategoryParameterUnitDTO
     */
    units: Array<UnitDTO>;
}

/**
 * 
 * @export
 */
export type ChangeOutletRequest = {
    /**
     * Название точки продаж. 
     * @type {string}
     * @memberof ChangeOutletRequest
     */
    name: string;
    /**
     * 
     * @type {OutletType}
     * @memberof ChangeOutletRequest
     */
    type: OutletType;
    /**
     * Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, `20.4522144, 54.7104264`.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в `address`. 
     * @type {string}
     * @memberof ChangeOutletRequest
     */
    coords?: string;
    /**
     * Признак основной точки продаж.  Возможные значения:  * `false` — неосновная точка продаж. * `true` — основная точка продаж. 
     * @type {boolean}
     * @memberof ChangeOutletRequest
     */
    isMain?: boolean;
    /**
     * Идентификатор точки продаж, присвоенный магазином.
     * @type {string}
     * @memberof ChangeOutletRequest
     */
    shopOutletCode?: string;
    /**
     * 
     * @type {OutletVisibilityType}
     * @memberof ChangeOutletRequest
     */
    visibility?: OutletVisibilityType;
    /**
     * 
     * @type {OutletAddressDTO}
     * @memberof ChangeOutletRequest
     */
    address: OutletAddressDTO;
    /**
     * Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`. 
     * @type {Array<string>}
     * @memberof ChangeOutletRequest
     */
    phones: Array<string>;
    /**
     * 
     * @type {OutletWorkingScheduleDTO}
     * @memberof ChangeOutletRequest
     */
    workingSchedule: OutletWorkingScheduleDTO;
    /**
     * Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр `type=DEPOT` или `type=MIXED`. 
     * @type {Array<OutletDeliveryRuleDTO>}
     * @memberof ChangeOutletRequest
     */
    deliveryRules?: Array<OutletDeliveryRuleDTO>;
    /**
     * Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях.
     * @type {number}
     * @memberof ChangeOutletRequest
     */
    storagePeriod?: number;
}

/**
 * Каналы продвижения товаров:  * `PUSH` — пуш-уведомление из приложения Яндекс Маркет.  * `STRETCH_MAIN` — верхний баннер-растяжка на главной странице Яндекс Маркета.  * `MAIN_PAGE_CAROUSEL` — карусель акций на главной странице Яндекс Маркета.  * `PRODUCT_RETAIL_PAGE` — товар на странице ритейл-повода.  * `MAIN_PAGE_CAROUSEL_WEB` — карусель акций на главной странице веб версии Яндекс Маркета.  * `PRODUCT_SEPARATE_LANDING` — товар на лендинге акции.  * `SUPER_SHELF_CATEGORY` — полка в категориях.  * `CAROUSEL_RETAIL_PAGE` — карусель на лендинге ритейл-повода.  * `POPUP_APPLICATION` — всплывающее окно в приложении Яндекс Маркет.  * `POST_TELEGRAM` — пост в Телеграм-канале Яндекс Маркета.  * `CPA` — реклама в партнерской сети Яндекс Маркета.  * `WEB_PERFORMANCE_DIRECT` — реклама в Яндекс Директе.  * `APP_PERFORMANCE` — реклама в AppStore и Google Play.  * `BANNER_PICKUP_POINT` — баннер в ПВЗ Маркета.  * `BLOGGER_PERFORMANCE` — рекламная интеграция у блогеров.  * `DIGITAL_CHANNEL_BANNER` — баннер в digital-каналах и социальных сетях VK, Одноклассники.  * `YANDEX_ECOSYSTEM_CHANNELS` — реклама в других сервисах Яндекса: GO, Delivery, Еда.  * `PARTNERS_MAIN_BANNER` — баннер на главной странице mail.ru, auto.ru, ya.ru.  * `OTHER` — прочее. 
 * @export
 */
export type ChannelType = {
    [key: string]: NULL_SCHEMA_ERR;

}

/**
 * Информация о сообщениях.
 * @export
 */
export type ChatMessageDTO = {
    /**
     * Идентификатор сообщения.
     * @type {number}
     * @memberof ChatMessageDTO
     */
    messageId: number;
    /**
     * Дата и время создания сообщения.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
     * @type {Date}
     * @memberof ChatMessageDTO
     */
    createdAt: Date;
    /**
     * 
     * @type {ChatMessageSenderType}
     * @memberof ChatMessageDTO
     */
    sender: ChatMessageSenderType;
    /**
     * Текст сообщения.  Необязательный параметр, если возвращается параметр `payload`. 
     * @type {string}
     * @memberof ChatMessageDTO
     */
    message?: string;
    /**
     * Информация о приложенных к сообщению файлах.  Необязательный параметр, если возвращается параметр `message`. 
     * @type {Array<ChatMessagePayloadDTO>}
     * @memberof ChatMessageDTO
     */
    payload?: Array<ChatMessagePayloadDTO>;
}

/**
 * Информация о приложенных к сообщению файлах.
 * @export
 */
export type ChatMessagePayloadDTO = {
    /**
     * Имя файла.
     * @type {string}
     * @memberof ChatMessagePayloadDTO
     */
    name: string;
    /**
     * Ссылка для скачивания файла.
     * @type {string}
     * @memberof ChatMessagePayloadDTO
     */
    url: string;
    /**
     * Размер файла в байтах.
     * @type {number}
     * @memberof ChatMessagePayloadDTO
     */
    size: number;
}

/**
 * Кто отправил сообщение:  * `PARTNER` — магазин. * `CUSTOMER` — покупатель. * `MARKET` — Маркет. * `SUPPORT` — сотрудник службы поддержки Маркета. 
 * @export
 * @enum {string}
 */
export type ChatMessageSenderType = 'PARTNER' | 'CUSTOMER' | 'MARKET' | 'SUPPORT';

/**
 * Информация о сообщениях.
 * @export
 */
export type ChatMessagesResultDTO = {
    /**
     * Идентификатор заказа.
     * @type {number}
     * @memberof ChatMessagesResultDTO
     */
    orderId: number;
    /**
     * Информация о сообщениях.
     * @type {Array<ChatMessageDTO>}
     * @memberof ChatMessagesResultDTO
     */
    messages: Array<ChatMessageDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof ChatMessagesResultDTO
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Статус чата:  * `NEW` — новый чат. * `WAITING_FOR_CUSTOMER` — нужен ответ покупателя. * `WAITING_FOR_PARTNER` — нужен ответ магазина. * `WAITING_FOR_ARBITER` — нужен ответ арбитра. * `WAITING_FOR_MARKET` — нужен ответ Маркета. * `FINISHED` — чат завершен. 
 * @export
 * @enum {string}
 */
export type ChatStatusType = 'NEW' | 'WAITING_FOR_CUSTOMER' | 'WAITING_FOR_PARTNER' | 'WAITING_FOR_ARBITER' | 'WAITING_FOR_MARKET' | 'FINISHED';

/**
 * Тип чата:  * `CHAT` — чат с покупателем. * `ARBITRAGE` — спор. 
 * @export
 * @enum {string}
 */
export type ChatType = 'CHAT' | 'ARBITRAGE';

/**
 * Запрос на подтверждение цены. 
 * @export
 */
export type ConfirmPricesRequest = {
    /**
     * Идентификаторы товаров, у которых подтверждается цена.
     * @type {Array<string>}
     * @memberof ConfirmPricesRequest
     */
    offerIds: Array<string>;
}

/**
 * Запрос для подтверждения отгрузки.
 * @export
 */
export type ConfirmShipmentRequest = {
    /**
     * Идентификатор отгрузки в системе поставщика.
     * @type {string}
     * @memberof ConfirmShipmentRequest
     */
    externalShipmentId?: string;
}

/**
 * Заказ, для которого нужно создать чат. 
 * @export
 */
export type CreateChatRequest = {
    /**
     * Идентификатор заказа на Маркете.
     * @type {number}
     * @memberof CreateChatRequest
     */
    orderId: number;
}

/**
 * Результат создания чата.
 * @export
 */
export type CreateChatResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof CreateChatResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {CreateChatResultDTO}
     * @memberof CreateChatResponse
     */
    result?: CreateChatResultDTO;
}

/**
 * Информация о созданном чате.
 * @export
 */
export type CreateChatResultDTO = {
    /**
     * Идентификатор чата.
     * @type {number}
     * @memberof CreateChatResultDTO
     */
    chatId: number;
}

/**
 * Ответ на запрос о создании точки продаж.
 * @export
 */
export type CreateOutletResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof CreateOutletResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OutletResponseDTO}
     * @memberof CreateOutletResponse
     */
    result?: OutletResponseDTO;
}

/**
 * Коды валют. Возможные значения: * `BYR` — белорусский рубль. * `KZT` — казахстанский тенге. * `RUR` — российский рубль. * `UAH` — украинская гривна. 
 * @export
 * @enum {string}
 */
export type CurrencyType = 'RUR' | 'USD' | 'EUR' | 'UAH' | 'AUD' | 'GBP' | 'BYR' | 'BYN' | 'DKK' | 'ISK' | 'KZT' | 'CAD' | 'CNY' | 'NOK' | 'XDR' | 'SGD' | 'TRY' | 'SEK' | 'CHF' | 'JPY' | 'AZN' | 'ALL' | 'DZD' | 'AOA' | 'ARS' | 'AMD' | 'AFN' | 'BHD' | 'BGN' | 'BOB' | 'BWP' | 'BND' | 'BRL' | 'BIF' | 'HUF' | 'VEF' | 'KPW' | 'VND' | 'GMD' | 'GHS' | 'GNF' | 'HKD' | 'GEL' | 'AED' | 'EGP' | 'ZMK' | 'ILS' | 'INR' | 'IDR' | 'JOD' | 'IQD' | 'IRR' | 'YER' | 'QAR' | 'KES' | 'KGS' | 'COP' | 'CDF' | 'CRC' | 'KWD' | 'CUP' | 'LAK' | 'LVL' | 'SLL' | 'LBP' | 'LYD' | 'SZL' | 'LTL' | 'MUR' | 'MRO' | 'MKD' | 'MWK' | 'MGA' | 'MYR' | 'MAD' | 'MXN' | 'MZN' | 'MDL' | 'MNT' | 'NPR' | 'NGN' | 'NIO' | 'NZD' | 'OMR' | 'PKR' | 'PYG' | 'PEN' | 'PLN' | 'KHR' | 'SAR' | 'RON' | 'SCR' | 'SYP' | 'SKK' | 'SOS' | 'SDG' | 'SRD' | 'TJS' | 'THB' | 'TWD' | 'BDT' | 'TZS' | 'TND' | 'TMM' | 'UGX' | 'UZS' | 'UYU' | 'PHP' | 'DJF' | 'XAF' | 'XOF' | 'HRK' | 'CZK' | 'CLP' | 'LKR' | 'EEK' | 'ETB' | 'RSD' | 'ZAR' | 'KRW' | 'NAD' | 'TL' | 'UE';

/**
 * День недели:  * `MONDAY` — понедельник. * `TUESDAY` — вторник. * `WEDNESDAY` — среда. * `THURSDAY` — четверг. * `FRIDAY` — пятница. * `SATURDAY` — суббота. * `SUNDAY` — воскресенье. 
 * @export
 * @enum {string}
 */
export type DayOfWeekType = 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY' | 'SUNDAY';

/**
 * Список товаров, которые не удалось удалить, потому что они не найдены или хранятся на складе Маркета.
 * @export
 */
export type DeleteCampaignOffersDTO = {
    /**
     * Список SKU.
     * @type {Array<string>}
     * @memberof DeleteCampaignOffersDTO
     */
    notDeletedOfferIds?: Array<string>;
}

/**
 * Фильтрации удаляемых товаров по offerIds. 
 * @export
 */
export type DeleteCampaignOffersRequest = {
    /**
     * Идентификаторы товаров в каталоге.
     * @type {Array<string>}
     * @memberof DeleteCampaignOffersRequest
     */
    offerIds: Array<string>;
}

/**
 * Результат удаления товаров.
 * @export
 */
export type DeleteCampaignOffersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof DeleteCampaignOffersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {DeleteCampaignOffersDTO}
     * @memberof DeleteCampaignOffersResponse
     */
    result?: DeleteCampaignOffersDTO;
}

/**
 * Фильтр запроса отзывов по бизнесу. 
 * @export
 */
export type DeleteGoodsFeedbackCommentRequest = {
    /**
     * Идентификатор комментария к отзыву. 
     * @type {number}
     * @memberof DeleteGoodsFeedbackCommentRequest
     */
    id: number;
}

/**
 * Запрос на возобновление показа оферов.
 * @export
 */
export type DeleteHiddenOffersRequest = {
    /**
     * Список скрытых товаров. 
     * @type {Array<HiddenOfferDTO>}
     * @memberof DeleteHiddenOffersRequest
     */
    hiddenOffers: Array<HiddenOfferDTO>;
}

/**
 * Список товаров, которые не удалось удалить, потому что они хранятся на складе Маркета.
 * @export
 */
export type DeleteOffersDTO = {
    /**
     * Список SKU товаров, которые не удалось удалить.
     * @type {Array<string>}
     * @memberof DeleteOffersDTO
     */
    notDeletedOfferIds?: Array<string>;
}

/**
 * Товары, которые не удалось восстановить из архива.
 * @export
 */
export type DeleteOffersFromArchiveDTO = {
    /**
     * Список товаров, которые не удалось восстановить из архива.
     * @type {Array<string>}
     * @memberof DeleteOffersFromArchiveDTO
     */
    notUnarchivedOfferIds?: Array<string>;
}

/**
 * Товары, которые нужно восстановить из архива. 
 * @export
 */
export type DeleteOffersFromArchiveRequest = {
    /**
     * Список товаров, которые нужно восстановить из архива.
     * @type {Array<string>}
     * @memberof DeleteOffersFromArchiveRequest
     */
    offerIds: Array<string>;
}

/**
 * Результат разархивации товаров.
 * @export
 */
export type DeleteOffersFromArchiveResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof DeleteOffersFromArchiveResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {DeleteOffersFromArchiveDTO}
     * @memberof DeleteOffersFromArchiveResponse
     */
    result?: DeleteOffersFromArchiveDTO;
}

/**
 * Фильтрации удаляемых товаров по offerIds. 
 * @export
 */
export type DeleteOffersRequest = {
    /**
     * Список SKU товаров, которые нужно удалить.
     * @type {Array<string>}
     * @memberof DeleteOffersRequest
     */
    offerIds: Array<string>;
}

/**
 * Результат удаления товаров.
 * @export
 */
export type DeleteOffersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof DeleteOffersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {DeleteOffersDTO}
     * @memberof DeleteOffersResponse
     */
    result?: DeleteOffersDTO;
}

/**
 * Удаление товаров из акции.  Чтобы убрать:  * все товары из акции и больше не участвовать в ней, передайте значение `true` в параметре `deleteAllOffers`;  * часть товаров, передайте их идентификаторы в параметре `offersIds`. 
 * @export
 */
export type DeletePromoOffersRequest = {
    /**
     * Идентификатор акции.
     * @type {string}
     * @memberof DeletePromoOffersRequest
     */
    promoId: string;
    /**
     * Чтобы убрать все товары из акции и больше не участвовать в ней, передайте значение `true` и не передавайте параметр `offerIds`.
     * @type {boolean}
     * @memberof DeletePromoOffersRequest
     */
    deleteAllOffers?: boolean;
    /**
     * Товары, которые нужно убрать из акции.
     * @type {Array<string>}
     * @memberof DeletePromoOffersRequest
     */
    offerIds?: Array<string>;
}

/**
 * Результат удаления товаров из акции.
 * @export
 */
export type DeletePromoOffersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof DeletePromoOffersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {DeletePromoOffersResultDTO}
     * @memberof DeletePromoOffersResponse
     */
    result?: DeletePromoOffersResultDTO;
}

/**
 * Результат удаления товаров из акции.  Возвращается, только если в запросе был передан параметр `offerIds`. 
 * @export
 */
export type DeletePromoOffersResultDTO = {
    /**
     * Товары, при удалении которых появились ошибки.  Возвращается, только если есть такие товары. 
     * @type {Array<RejectedPromoOfferDeleteDTO>}
     * @memberof DeletePromoOffersResultDTO
     */
    rejectedOffers?: Array<RejectedPromoOfferDeleteDTO>;
}

/**
 * Служба доставки.
 * @export
 */
export type DeliveryServiceDTO = {
    /**
     * Идентификатор службы доставки.
     * @type {number}
     * @memberof DeliveryServiceDTO
     */
    id?: number;
    /**
     * Наименование службы доставки.
     * @type {string}
     * @memberof DeliveryServiceDTO
     */
    name?: string;
}

/**
 * Информация о службе доставки.
 * @export
 */
export type DeliveryServiceInfoDTO = {
    /**
     * Идентификатор службы доставки.
     * @type {number}
     * @memberof DeliveryServiceInfoDTO
     */
    id: number;
    /**
     * Наименование службы доставки.
     * @type {string}
     * @memberof DeliveryServiceInfoDTO
     */
    name: string;
}

/**
 * Информация о службах доставки.
 * @export
 */
export type DeliveryServicesDTO = {
    /**
     * Информация о службе доставки.
     * @type {Array<DeliveryServiceInfoDTO>}
     * @memberof DeliveryServicesDTO
     */
    deliveryService: Array<DeliveryServiceInfoDTO>;
}

/**
 * Информация о документе.
 * @export
 */
export type DocumentDTO = {
    /**
     * 
     * @type {OrderDocumentStatusType}
     * @memberof DocumentDTO
     */
    status?: OrderDocumentStatusType;
    /**
     * Номер документа.
     * @type {string}
     * @memberof DocumentDTO
     */
    _number?: string;
    /**
     * Дата создания документа.
     * @type {Date}
     * @memberof DocumentDTO
     */
    _date?: Date;
}

/**
 * Результат выполнения запроса.
 * @export
 */
export type EacVerificationResultDTO = {
    /**
     * 
     * @type {EacVerificationStatusType}
     * @memberof EacVerificationResultDTO
     */
    verificationResult?: EacVerificationStatusType;
    /**
     * Количество оставшихся попыток проверки кода.  Возвращается, если магазин отправил некорректный код.  Когда все попытки будут исчерпаны, код обновится. 
     * @type {number}
     * @memberof EacVerificationResultDTO
     */
    attemptsLeft?: number;
}

/**
 * Статус проверки кода подтверждения:  * `ACCEPTED` — код верный. * `REJECTED` — код неверный. * `NEED_UPDATE` — Маркет отправит новый код. Значение возвращается, если превышено количество попыток отправки кода. 
 * @export
 * @enum {string}
 */
export type EacVerificationStatusType = 'ACCEPTED' | 'REJECTED' | 'NEED_UPDATE';

/**
 * Пустой ответ сервера.
 * @export
 */
export type EmptyApiResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof EmptyApiResponse
     */
    status?: ApiResponseStatusType;
}

/**
 * Информация о рекомендованных карточках товаров.
 * @export
 */
export type EnrichedMappingsOfferDTO = {
    /**
     * Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    name?: string;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    shopSku?: string;
    /**
     * Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    category?: string;
    /**
     * Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    vendor?: string;
    /**
     * Артикул товара от производителя.
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    vendorCode?: string;
    /**
     * Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    description?: string;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    id?: string;
    /**
     * Идентификатор фида.
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    feedId?: number;
    /**
     * Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
     * @type {Array<string>}
     * @memberof EnrichedMappingsOfferDTO
     */
    barcodes?: Array<string>;
    /**
     * URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
     * @type {Array<string>}
     * @memberof EnrichedMappingsOfferDTO
     */
    urls?: Array<string>;
    /**
     * Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр `picture`. 
     * @type {Array<string>}
     * @memberof EnrichedMappingsOfferDTO
     */
    pictures?: Array<string>;
    /**
     * Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    manufacturer?: string;
    /**
     * Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
     * @type {Array<string>}
     * @memberof EnrichedMappingsOfferDTO
     */
    manufacturerCountries?: Array<string>;
    /**
     * Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    minShipment?: number;
    /**
     * Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    transportUnitSize?: number;
    /**
     * Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    quantumOfSupply?: number;
    /**
     * Срок, за который продавец поставляет товары на склад, в днях.
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    deliveryDurationDays?: number;
    /**
     * Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    boxCount?: number;
    /**
     * Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
     * @type {Array<string>}
     * @memberof EnrichedMappingsOfferDTO
     */
    customsCommodityCodes?: Array<string>;
    /**
     * 
     * @type {OfferWeightDimensionsDTO}
     * @memberof EnrichedMappingsOfferDTO
     */
    weightDimensions?: OfferWeightDimensionsDTO;
    /**
     * Дни недели, в которые продавец поставляет товары на склад.
     * @type {Array<DayOfWeekType>}
     * @memberof EnrichedMappingsOfferDTO
     */
    supplyScheduleDays?: Array<DayOfWeekType>;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `shelfLife`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    shelfLifeDays?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `lifeTime`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    lifeTimeDays?: number;
    /**
     * Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    guaranteePeriodDays?: number;
    /**
     * 
     * @type {OfferProcessingStateDTO}
     * @memberof EnrichedMappingsOfferDTO
     */
    processingState?: OfferProcessingStateDTO;
    /**
     * 
     * @type {OfferAvailabilityStatusType}
     * @memberof EnrichedMappingsOfferDTO
     */
    availability?: OfferAvailabilityStatusType;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof EnrichedMappingsOfferDTO
     */
    shelfLife?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof EnrichedMappingsOfferDTO
     */
    lifeTime?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof EnrichedMappingsOfferDTO
     */
    guaranteePeriod?: TimePeriodDTO;
    /**
     * Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    certificate?: string;
    /**
     * Цена на товар в рублях.
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    price?: number;
    /**
     * Идентификатор категории для рекомендованной карточки товара на Маркете.  Возвращается только вместе с параметром ##marketSku##. 
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    marketCategoryId?: number;
    /**
     * Название категории для рекомендованной карточки товара на Маркете.  Может отсутствовать в ответе. 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    marketCategoryName?: string;
    /**
     * Идентификатор модели для рекомендованной карточки товара на Маркете.  Может отсутствовать в ответе. 
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    marketModelId?: number;
    /**
     * Название модели для рекомендованной карточки товара на Маркете.  Возвращается только вместе с параметром ##marketSku##. 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    marketModelName?: string;
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof EnrichedMappingsOfferDTO
     */
    marketSku?: number;
    /**
     * Название товара с рекомендованной карточки на Маркете.  Может отсутствовать в ответе. 
     * @type {string}
     * @memberof EnrichedMappingsOfferDTO
     */
    marketSkuName?: string;
}

/**
 * Модель товара.
 * @export
 */
export type EnrichedModelDTO = {
    /**
     * Идентификатор модели товара.
     * @type {number}
     * @memberof EnrichedModelDTO
     */
    id?: number;
    /**
     * Название модели товара.
     * @type {string}
     * @memberof EnrichedModelDTO
     */
    name?: string;
    /**
     * 
     * @type {ModelPriceDTO}
     * @memberof EnrichedModelDTO
     */
    prices?: ModelPriceDTO;
    /**
     * Список первых десяти предложений, расположенных на карточке модели.  В ответе на запрос возвращаются предложения различных магазинов. Если есть несколько предложений от одного магазина, в ответе отображается только одно, наиболее релевантное из них. 
     * @type {Array<ModelOfferDTO>}
     * @memberof EnrichedModelDTO
     */
    offers?: Array<ModelOfferDTO>;
    /**
     * Суммарное количество предложений в розничных магазинах в регионе. Учитываются все предложения от каждого магазина.
     * @type {number}
     * @memberof EnrichedModelDTO
     */
    offlineOffers?: number;
    /**
     * Суммарное количество предложений в интернет-магазинах в регионе. Учитываются все предложения от каждого магазина.
     * @type {number}
     * @memberof EnrichedModelDTO
     */
    onlineOffers?: number;
}

/**
 * Список моделей товаров.
 * @export
 */
export type EnrichedModelsDTO = {
    /**
     * Список моделей товаров.
     * @type {Array<EnrichedModelDTO>}
     * @memberof EnrichedModelsDTO
     */
    models: Array<EnrichedModelDTO>;
}

/**
 * Информация о коробке.
 * @export
 */
export type EnrichedOrderBoxLayoutDTO = {
    /**
     * Список товаров в коробке.  Если в коробке едет часть большого товара, в списке может быть только один пункт. 
     * @type {Array<OrderBoxLayoutItemDTO>}
     * @memberof EnrichedOrderBoxLayoutDTO
     */
    items: Array<OrderBoxLayoutItemDTO>;
    /**
     * Идентификатор коробки.
     * @type {number}
     * @memberof EnrichedOrderBoxLayoutDTO
     */
    boxId?: number;
}

/**
 * Информация об отгрузке.
 * @export
 */
export type ExtensionShipmentDTO = {
    /**
     * 
     * @type {ShipmentStatusChangeDTO}
     * @memberof ExtensionShipmentDTO
     */
    currentStatus?: ShipmentStatusChangeDTO;
    /**
     * Доступные действия над отгрузкой.
     * @type {Set<ShipmentActionType>}
     * @memberof ExtensionShipmentDTO
     */
    availableActions: Set<ShipmentActionType>;
}

/**
 * Информация о проверке содержимого прайс-листа, загруженного на Маркет.
 * @export
 */
export type FeedContentDTO = {
    /**
     * Количество предложений, в которых найдены ошибки на этапе загрузки прайс-листа. Выводится, если параметр `content status=OK`. 
     * @type {number}
     * @memberof FeedContentDTO
     */
    rejectedOffersCount?: number;
    /**
     * 
     * @type {FeedStatusType}
     * @memberof FeedContentDTO
     */
    status?: FeedStatusType;
    /**
     * Количество предложений в прайс-листе. Выводится, если параметр `content status=OK`. 
     * @type {number}
     * @memberof FeedContentDTO
     */
    totalOffersCount?: number;
    /**
     * 
     * @type {FeedContentErrorDTO}
     * @memberof FeedContentDTO
     */
    error?: FeedContentErrorDTO;
}

/**
 * Информация об ошибке в содержимом прайс-листа. Выводится, если параметр `content status=ERROR`. 
 * @export
 */
export type FeedContentErrorDTO = {
    /**
     * 
     * @type {FeedContentErrorType}
     * @memberof FeedContentErrorDTO
     */
    type?: FeedContentErrorType;
}

/**
 * Тип ошибки в содержимом прайс-листа.  Возможные значения:  * `PARSE_ERROR` — ошибка при проверке прайс-листа, не связанная с форматом YML. Например, прайс-лист пустой или его не удалось разархивировать. * `PARSE_XML_ERROR` — несоответствие техническим требованиям формата YML. Например, элементы и их значения описаны некорректно. * `TOO_MANY_REJECTED_OFFERS` — более чем в половине предложений из прайс-листа найдены ошибки. Все предложения из прайс-листа не будут опубликованы на Маркете. 
 * @export
 * @enum {string}
 */
export type FeedContentErrorType = 'PARSE_ERROR' | 'PARSE_XML_ERROR' | 'TOO_MANY_REJECTED_OFFERS';

/**
 * Информация о прайс-листе.
 * @export
 */
export type FeedDTO = {
    /**
     * Идентификатор прайс-листа.
     * @type {number}
     * @memberof FeedDTO
     */
    id?: number;
    /**
     * Логин для авторизации при скачивании прайс-листа. Параметр выводится при размещении прайс-листа на сайте магазина и в случае ограничения доступа к нему. 
     * @type {string}
     * @memberof FeedDTO
     */
    login?: string;
    /**
     * Имя файла, содержащего прайс-лист. Параметр выводится при размещении прайс-листа на сервере Маркета. 
     * @type {string}
     * @memberof FeedDTO
     */
    name?: string;
    /**
     * Пароль для авторизации при скачивании прайс-листа. Параметр выводится при размещении прайс-листа на сайте магазина и в случае ограничения доступа к нему. 
     * @type {string}
     * @memberof FeedDTO
     */
    password?: string;
    /**
     * Дата загрузки прайс-листа на Маркет.  Формат даты: `ДД-ММ-ГГГГ`.  Параметр выводится при размещении прайс-листа на сервере Маркета. 
     * @type {Date}
     * @memberof FeedDTO
     */
    uploadDate?: Date;
    /**
     * URL прайс-листа. Параметр выводится при размещении прайс-листа на сайте магазина. 
     * @type {string}
     * @memberof FeedDTO
     */
    url?: string;
    /**
     * 
     * @type {FeedContentDTO}
     * @memberof FeedDTO
     */
    content?: FeedContentDTO;
    /**
     * 
     * @type {FeedDownloadDTO}
     * @memberof FeedDTO
     */
    download?: FeedDownloadDTO;
    /**
     * 
     * @type {FeedPlacementDTO}
     * @memberof FeedDTO
     */
    placement?: FeedPlacementDTO;
    /**
     * 
     * @type {FeedPublicationDTO}
     * @memberof FeedDTO
     */
    publication?: FeedPublicationDTO;
}

/**
 * Информация о последней загрузке прайс-листа.
 * @export
 */
export type FeedDownloadDTO = {
    /**
     * 
     * @type {FeedStatusType}
     * @memberof FeedDownloadDTO
     */
    status?: FeedStatusType;
    /**
     * 
     * @type {FeedDownloadErrorDTO}
     * @memberof FeedDownloadDTO
     */
    error?: FeedDownloadErrorDTO;
}

/**
 * Информация об ошибке при загрузке прайс-листа. Выводится, если параметр `download status=ERROR`. 
 * @export
 */
export type FeedDownloadErrorDTO = {
    /**
     * HTTP-код ошибки индексации прайс-листа. Выводится, если `type=DOWNLOAD_HTTP_ERROR`. 
     * @type {number}
     * @memberof FeedDownloadErrorDTO
     */
    httpStatusCode?: number;
    /**
     * 
     * @type {FeedDownloadErrorType}
     * @memberof FeedDownloadErrorDTO
     */
    type?: FeedDownloadErrorType;
    /**
     * Описание ошибки. Выводится, если `type=DOWNLOAD_ERROR`. 
     * @type {string}
     * @memberof FeedDownloadErrorDTO
     */
    description?: string;
}

/**
 * Тип ошибки загрузки прайс-листа.  Возможные значения:  * `DOWNLOAD_ERROR` — ошибка загрузки прайс-листа. Например, проблема с DNS-сервером или обрыв интернет-соединения.   Проблема описана в параметре `description`.  * `DOWNLOAD_HTTP_ERROR` — Яндекс Маркет передал запрос на получение прайс-листа и получил в ответ HTTP-код, отличный от 2xx.  HTTP-код выведен в параметре `httpStatusCode`. 
 * @export
 * @enum {string}
 */
export type FeedDownloadErrorType = 'DOWNLOAD_ERROR' | 'DOWNLOAD_HTTP_ERROR';

/**
 * Информация об ошибке, произошедшей во время индексации прайс-листа.  Выводится, если во время индексации произошли ошибки (`index-log-record status=ERROR`). 
 * @export
 */
export type FeedIndexLogsErrorDTO = {
    /**
     * HTTP-код ошибки индексации прайс-листа.  Выводится, если `type=DOWNLOAD_HTTP_ERROR`. 
     * @type {number}
     * @memberof FeedIndexLogsErrorDTO
     */
    httpStatusCode?: number;
    /**
     * 
     * @type {FeedIndexLogsErrorType}
     * @memberof FeedIndexLogsErrorDTO
     */
    type?: FeedIndexLogsErrorType;
    /**
     * Описание ошибки.  Выводится, если `type=DOWNLOAD_ERROR`. 
     * @type {string}
     * @memberof FeedIndexLogsErrorDTO
     */
    description?: string;
}

/**
 * Тип ошибки индексации прайс-листа.  Возможные значения:  * `DOWNLOAD_ERROR` — ошибка загрузки прайс-листа. Например, проблема с DNS-сервером или обрыв интернет-соединения.    Проблема описана в параметре `description`.  * `DOWNLOAD_HTTP_ERROR` — Маркет передал запрос на получение прайс-листа и получил в ответ HTTP-код, отличный от 2xx.    HTTP-код выведен в параметре `httpStatusCode`.  * `PARSE_ERROR` — ошибка при проверке прайс-листа, не связанная с форматом YML. Например, прайс-лист пустой или его не удалось разархивировать.  * `PARSE_XML_ERROR` — несоответствие техническим требованиям формата YML. Например, элементы и их значения описаны некорректно.  * `TOO_MANY_REJECTED_OFFERS` — более чем в половине предложений из прайс-листа найдены ошибки. Все предложения из прайс-листа не будут опубликованы на Маркете. 
 * @export
 * @enum {string}
 */
export type FeedIndexLogsErrorType = 'DOWNLOAD_ERROR' | 'DOWNLOAD_HTTP_ERROR' | 'PARSE_ERROR' | 'PARSE_XML_ERROR' | 'TOO_MANY_REJECTED_OFFERS' | 'NOT_INDEXED';

/**
 * Информация о прайс-листе.
 * @export
 */
export type FeedIndexLogsFeedDTO = {
    /**
     * Идентификатор прайс-листа.
     * @type {number}
     * @memberof FeedIndexLogsFeedDTO
     */
    id?: number;
}

/**
 * Тип обновления.  Возможные значения:  * `DIFF` — частичное обновление данных на Яндекс Маркете (например, обновление цен ранее опубликованных предложений и публикация новых). * `FAST_PRICE` — только обновление цен ранее опубликованных предложений. * `FULL` — полное обновление данных на Яндекс Маркете. 
 * @export
 * @enum {string}
 */
export type FeedIndexLogsIndexType = 'DIFF' | 'FAST_PRICE' | 'FULL';

/**
 * Информация о предложениях прайс-листа.
 * @export
 */
export type FeedIndexLogsOffersDTO = {
    /**
     * Количество предложений, который не опубликованы на Маркете из-за найденных ошибок.
     * @type {number}
     * @memberof FeedIndexLogsOffersDTO
     */
    rejectedCount?: number;
    /**
     * Количество предложений в прайс-листе.
     * @type {number}
     * @memberof FeedIndexLogsOffersDTO
     */
    totalCount?: number;
}

/**
 * Список отчетов по индексации прайс-листа.
 * @export
 */
export type FeedIndexLogsRecordDTO = {
    /**
     * Дата и время загрузки прайс-листа.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
     * @type {Date}
     * @memberof FeedIndexLogsRecordDTO
     */
    downloadTime?: Date;
    /**
     * Дата и время, которые магазин указал в прайс-листе.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
     * @type {Date}
     * @memberof FeedIndexLogsRecordDTO
     */
    fileTime?: Date;
    /**
     * Идентификатор индексации.
     * @type {number}
     * @memberof FeedIndexLogsRecordDTO
     */
    generationId?: number;
    /**
     * 
     * @type {FeedIndexLogsIndexType}
     * @memberof FeedIndexLogsRecordDTO
     */
    indexType?: FeedIndexLogsIndexType;
    /**
     * Дата и время публикации предложений из прайс-листа на Яндекс Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
     * @type {Date}
     * @memberof FeedIndexLogsRecordDTO
     */
    publishedTime?: Date;
    /**
     * 
     * @type {FeedIndexLogsStatusType}
     * @memberof FeedIndexLogsRecordDTO
     */
    status?: FeedIndexLogsStatusType;
    /**
     * 
     * @type {FeedIndexLogsErrorDTO}
     * @memberof FeedIndexLogsRecordDTO
     */
    error?: FeedIndexLogsErrorDTO;
    /**
     * 
     * @type {FeedIndexLogsOffersDTO}
     * @memberof FeedIndexLogsRecordDTO
     */
    offers?: FeedIndexLogsOffersDTO;
}

/**
 * Результат выполнения запроса отчета по индексации прайс-листа.
 * @export
 */
export type FeedIndexLogsResultDTO = {
    /**
     * 
     * @type {FeedIndexLogsFeedDTO}
     * @memberof FeedIndexLogsResultDTO
     */
    feed?: FeedIndexLogsFeedDTO;
    /**
     * Список отчетов по индексации прайс-листа.
     * @type {Array<FeedIndexLogsRecordDTO>}
     * @memberof FeedIndexLogsResultDTO
     */
    indexLogRecords: Array<FeedIndexLogsRecordDTO>;
    /**
     * Количество отчетов на всех страницах выходных данных.
     * @type {number}
     * @memberof FeedIndexLogsResultDTO
     */
    total?: number;
}

/**
 * Статус индексации прайс-листа и проверки на соответствие техническим требованиям.  Возможные значения:  * `ERROR` — произошли ошибки. * `OK` — обработан без ошибок. * `WARNING` — наблюдались некритичные проблемы. 
 * @export
 * @enum {string}
 */
export type FeedIndexLogsStatusType = 'ERROR' | 'OK' | 'WARNING';

/**
 * Параметр прайс-листа.
 * @export
 */
export type FeedParameterDTO = {
    /**
     * Удалить ли значение параметра.  Возможное значение: * `true` — удалить значение параметра.  Используется вместе с параметром `name`. 
     * @type {boolean}
     * @memberof FeedParameterDTO
     */
    deleted?: boolean;
    /**
     * Название параметра.  Возможное значение: - `reparseIntervalMinutes` — период скачивания прайс-листа. Маркет будет скачивать прайс-лист через количество минут, указанное в параметре `value`. Например, при `value=1440`, Маркет будет скачивать прайс-лист один раз в сутки.  {% note alert %}  Несмотря на установленное значение, Маркет скачает прайс-лист один раз в сутки.  {% endnote %}  Обязательный параметр. 
     * @type {string}
     * @memberof FeedParameterDTO
     */
    name: string;
    /**
     * Значения параметра.  Используется вместе с параметром `name`. 
     * @type {Array<number>}
     * @memberof FeedParameterDTO
     */
    values?: Array<number>;
}

/**
 * Информация о размещении предложений из прайс-листа на Маркете на момент выполнения запроса.
 * @export
 */
export type FeedPlacementDTO = {
    /**
     * 
     * @type {FeedStatusType}
     * @memberof FeedPlacementDTO
     */
    status?: FeedStatusType;
    /**
     * Количество предложений из прайс-листа, которые размещаются на Яндекс Маркете в момент выполнения запроса.
     * @type {number}
     * @memberof FeedPlacementDTO
     */
    totalOffersCount?: number;
}

/**
 * Информация о последней публикации предложений из прайс-листа на Маркете.
 * @export
 */
export type FeedPublicationDTO = {
    /**
     * 
     * @type {FeedStatusType}
     * @memberof FeedPublicationDTO
     */
    status?: FeedStatusType;
    /**
     * 
     * @type {FeedPublicationFullDTO}
     * @memberof FeedPublicationDTO
     */
    full?: FeedPublicationFullDTO;
    /**
     * 
     * @type {FeedPublicationPriceAndStockUpdateDTO}
     * @memberof FeedPublicationDTO
     */
    priceAndStockUpdate?: FeedPublicationPriceAndStockUpdateDTO;
}

/**
 * Информация о последней публикации предложений из прайс-листа на Маркете. 
 * @export
 */
export type FeedPublicationFullDTO = {
    /**
     * Дата и время, которые магазин указал в прайс-листе.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
     * @type {Date}
     * @memberof FeedPublicationFullDTO
     */
    fileTime?: Date;
    /**
     * Дата и время публикации предложений из прайс-листа на Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
     * @type {Date}
     * @memberof FeedPublicationFullDTO
     */
    publishedTime?: Date;
}

/**
 * Последнее обновление цен и наличия товаров на Маркете. Если последнее по времени обновление было полным, в параметре выводятся те же данные, что и в параметре `full`. Выводится, если параметр `publication status=OK`. 
 * @export
 */
export type FeedPublicationPriceAndStockUpdateDTO = {
    /**
     * Дата и время, которые магазин указал в прайс-листе.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
     * @type {Date}
     * @memberof FeedPublicationPriceAndStockUpdateDTO
     */
    fileTime?: Date;
    /**
     * Дата и время публикации предложений из прайс-листа на Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
     * @type {Date}
     * @memberof FeedPublicationPriceAndStockUpdateDTO
     */
    publishedTime?: Date;
}

/**
 * Статус прайс-листа.  Возможные значения:    * `ERROR` — найдены ошибки.   * `NA` — прайс-лист не загружался более семи дней или на этапе загрузки произошла ошибка.   * `OK` — ошибок не найдено. 
 * @export
 * @enum {string}
 */
export type FeedStatusType = 'ERROR' | 'NA' | 'OK';

/**
 * Информация об авторе отзыва.  Если отзыв оставлен анонимно, параметр не возвращается. 
 * @export
 */
export type FeedbackAuthorDTO = {
    /**
     * Имя автора отзыва.
     * @type {string}
     * @memberof FeedbackAuthorDTO
     */
    name?: string;
    /**
     * 
     * @type {RegionDTO}
     * @memberof FeedbackAuthorDTO
     */
    region?: RegionDTO;
}

/**
 * Информация об авторе комментария.
 * @export
 */
export type FeedbackCommentAuthorDTO = {
    /**
     * 
     * @type {FeedbackCommentAuthorType}
     * @memberof FeedbackCommentAuthorDTO
     */
    type?: FeedbackCommentAuthorType;
    /**
     * Имя автора отзыва или название магазина.
     * @type {string}
     * @memberof FeedbackCommentAuthorDTO
     */
    name?: string;
}

/**
 * Тип автора:  * `USER` — пользователь. * `SHOP` — магазин. 
 * @export
 * @enum {string}
 */
export type FeedbackCommentAuthorType = 'USER' | 'SHOP';

/**
 * Комментарий к отзыву на магазин.
 * @export
 */
export type FeedbackCommentDTO = {
    /**
     * Идентификатор ответа.
     * @type {number}
     * @memberof FeedbackCommentDTO
     */
    id?: number;
    /**
     * Идентификатор родительского ответа.
     * @type {number}
     * @memberof FeedbackCommentDTO
     */
    parentId?: number;
    /**
     * Текст ответа.
     * @type {string}
     * @memberof FeedbackCommentDTO
     */
    body?: string;
    /**
     * Дата и время создания ответа.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
     * @type {Date}
     * @memberof FeedbackCommentDTO
     */
    createdAt?: Date;
    /**
     * Дата и время изменения ответа.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
     * @type {Date}
     * @memberof FeedbackCommentDTO
     */
    updatedAt?: Date;
    /**
     * 
     * @type {FeedbackCommentAuthorDTO}
     * @memberof FeedbackCommentDTO
     */
    author?: FeedbackCommentAuthorDTO;
    /**
     * Дочерние ответы.
     * @type {Array<FeedbackCommentDTO>}
     * @memberof FeedbackCommentDTO
     */
    children?: Array<FeedbackCommentDTO>;
}

/**
 * Отзыв пользователя Яндекс Маркета об указанном магазине.
 * @export
 */
export type FeedbackDTO = {
    /**
     * Идентификатор отзыва.
     * @type {number}
     * @memberof FeedbackDTO
     */
    id?: number;
    /**
     * Дата и время создания отзыва.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
     * @type {Date}
     * @memberof FeedbackDTO
     */
    createdAt?: Date;
    /**
     * Комментарий автора отзыва.
     * @type {string}
     * @memberof FeedbackDTO
     */
    text?: string;
    /**
     * 
     * @type {FeedbackStateType}
     * @memberof FeedbackDTO
     */
    state?: FeedbackStateType;
    /**
     * 
     * @type {FeedbackAuthorDTO}
     * @memberof FeedbackDTO
     */
    author?: FeedbackAuthorDTO;
    /**
     * Достоинства магазина, описанные в отзыве.
     * @type {string}
     * @memberof FeedbackDTO
     */
    pro?: string;
    /**
     * Недостатки магазина, описанные в отзыве.
     * @type {string}
     * @memberof FeedbackDTO
     */
    contra?: string;
    /**
     * Переписка автора отзыва с магазином.
     * @type {Array<FeedbackCommentDTO>}
     * @memberof FeedbackDTO
     */
    comments: Array<FeedbackCommentDTO>;
    /**
     * 
     * @type {FeedbackShopDTO}
     * @memberof FeedbackDTO
     */
    shop?: FeedbackShopDTO;
    /**
     * Решена ли проблема автора отзыва:  * `true` — да. * `false` — нет.  Если проблема решена, около отзыва на странице магазина появляется соответствующая надпись. 
     * @type {boolean}
     * @memberof FeedbackDTO
     */
    resolved?: boolean;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Является ли отзыв рекомендованным:  * `true` — да. * `false` — нет. 
     * @type {boolean}
     * @memberof FeedbackDTO
     */
    verified?: boolean;
    /**
     * Купил бы автор отзыва в магазине снова:  * `true` — да. * `false` — нет. 
     * @type {boolean}
     * @memberof FeedbackDTO
     */
    recommend?: boolean;
    /**
     * 
     * @type {FeedbackGradesDTO}
     * @memberof FeedbackDTO
     */
    grades?: FeedbackGradesDTO;
    /**
     * 
     * @type {FeedbackOrderDTO}
     * @memberof FeedbackDTO
     */
    order?: FeedbackOrderDTO;
}

/**
 * Способ покупки, указанный в отзыве:  * `DELIVERY` — доставка. * `PICKUP` — самовывоз. * `INSTORE` — в магазине. 
 * @export
 * @enum {string}
 */
export type FeedbackDeliveryType = 'DELIVERY' | 'PICKUP' | 'INSTORE';

/**
 * Информация об оценках по параметрам, указанных в отзыве.  При создании отзыва автору предлагается поставить оценки магазину по нескольким параметрам: например, за скорость обработки заказа или удобство самовывоза. Набор параметров зависит от того, какой способ покупки (параметр `delivery`) указал автор. 
 * @export
 */
export type FeedbackFactorDTO = {
    /**
     * Идентификатор параметра.
     * @type {number}
     * @memberof FeedbackFactorDTO
     */
    id?: number;
    /**
     * Название параметра. Например, `Скорость обработки заказа`.
     * @type {string}
     * @memberof FeedbackFactorDTO
     */
    title?: string;
    /**
     * Описание параметра. Например, `Как быстро с вами связались для подтверждения заказа?`.
     * @type {string}
     * @memberof FeedbackFactorDTO
     */
    description?: string;
    /**
     * Оценка по параметру, указанная в отзыве: от `1` (низшая оценка) до `5` (высшая оценка). 
     * @type {number}
     * @memberof FeedbackFactorDTO
     */
    value?: number;
}

/**
 * Информация об оценках, которые поставил автор отзыва магазину, и об оценках полезности отзыва от других пользователей Маркета.
 * @export
 */
export type FeedbackGradesDTO = {
    /**
     * Общая оценка, указанная в отзыве: от `1` («Ужасный магазин») до `5` («Отличный магазин»).
     * @type {number}
     * @memberof FeedbackGradesDTO
     */
    average?: number;
    /**
     * Количество пользователей, считающих отзыв полезным.
     * @type {number}
     * @memberof FeedbackGradesDTO
     */
    agreeCount?: number;
    /**
     * Количество пользователей, считающих отзыв бесполезным.
     * @type {number}
     * @memberof FeedbackGradesDTO
     */
    rejectCount?: number;
    /**
     * Информация об оценках по параметрам, указанных в отзыве.  При создании отзыва автору предлагается поставить оценки магазину по нескольким параметрам: например, за скорость обработки заказа или удобство самовывоза. Набор параметров зависит от того, какой способ покупки (параметр `delivery`) указал автор. 
     * @type {Array<FeedbackFactorDTO>}
     * @memberof FeedbackGradesDTO
     */
    factors: Array<FeedbackFactorDTO>;
}

/**
 * Отзывы пользователей Яндекс Маркета об указанном магазине.
 * @export
 */
export type FeedbackListDTO = {
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof FeedbackListDTO
     */
    paging?: ScrollingPagerDTO;
    /**
     * Список отзывов.  Содержит не более 20 отзывов. 
     * @type {Array<FeedbackDTO>}
     * @memberof FeedbackListDTO
     */
    feedbackList: Array<FeedbackDTO>;
}

/**
 * Информация о заказе, указанная в отзыве.
 * @export
 */
export type FeedbackOrderDTO = {
    /**
     * Номер заказа, указанный в отзыве.
     * @type {string}
     * @memberof FeedbackOrderDTO
     */
    shopOrderId?: string;
    /**
     * 
     * @type {FeedbackDeliveryType}
     * @memberof FeedbackOrderDTO
     */
    delivery?: FeedbackDeliveryType;
}

/**
 * Статус реакции на отзыв:  * `ALL` — все отзывы.  * `NEED_REACTION` — отзывы, на которые нужно ответить. 
 * @export
 * @enum {string}
 */
export type FeedbackReactionStatusType = 'ALL' | 'NEED_REACTION';

/**
 * Информация о магазине.
 * @export
 */
export type FeedbackShopDTO = {
    /**
     * Название магазина.
     * @type {string}
     * @memberof FeedbackShopDTO
     */
    name?: string;
}

/**
 * Статус отзыва:  * `LAST` — актуален. * `PREVIOUS` — устарел. * `DELETED` — удален. 
 * @export
 * @enum {string}
 */
export type FeedbackStateType = 'LAST' | 'PREVIOUS' | 'DELETED';

/**
 * Фильтр по заполненности или незаполненности поля:  * `SPECIFIED` — вывести товары, у которых поле заполнено. * `EMPTY` — вывести товары, у которых поле не заполнено. 
 * @export
 * @enum {string}
 */
export type FieldStateType = 'SPECIFIED' | 'EMPTY';

/**
 * Модель для пагинации.
 * @export
 */
export type FlippingPagerDTO = {
    /**
     * Сколько всего найдено элементов.
     * @type {number}
     * @memberof FlippingPagerDTO
     */
    total?: number;
    /**
     * Начальный номер найденного элемента на странице.
     * @type {number}
     * @memberof FlippingPagerDTO
     */
    from?: number;
    /**
     * Конечный номер найденного элемента на странице.
     * @type {number}
     * @memberof FlippingPagerDTO
     */
    to?: number;
    /**
     * Текущая страница.
     * @type {number}
     * @memberof FlippingPagerDTO
     */
    currentPage?: number;
    /**
     * Общее количество страниц.
     * @type {number}
     * @memberof FlippingPagerDTO
     */
    pagesCount?: number;
    /**
     * Размер страницы.
     * @type {number}
     * @memberof FlippingPagerDTO
     */
    pageSize?: number;
}

/**
 * Ссылка на следующую страницу. 
 * @export
 */
export type ForwardScrollingPagerDTO = {
    /**
     * Идентификатор следующей страницы результатов.
     * @type {string}
     * @memberof ForwardScrollingPagerDTO
     */
    nextPageToken?: string;
}

/**
 * Склад Маркета (FBY).
 * @export
 */
export type FulfillmentWarehouseDTO = {
    /**
     * Идентификатор склада.
     * @type {number}
     * @memberof FulfillmentWarehouseDTO
     */
    id: number;
    /**
     * Название склада.
     * @type {string}
     * @memberof FulfillmentWarehouseDTO
     */
    name: string;
    /**
     * 
     * @type {WarehouseAddressDTO}
     * @memberof FulfillmentWarehouseDTO
     */
    address?: WarehouseAddressDTO;
}

/**
 * Список складов Маркета (FBY).
 * @export
 */
export type FulfillmentWarehousesDTO = {
    /**
     * Список складов Маркета (FBY).
     * @type {Array<FulfillmentWarehouseDTO>}
     * @memberof FulfillmentWarehousesDTO
     */
    warehouses: Array<FulfillmentWarehouseDTO>;
}

/**
 * Информация о точке продаж.
 * @export
 */
export type FullOutletDTO = {
    /**
     * Название точки продаж. 
     * @type {string}
     * @memberof FullOutletDTO
     */
    name: string;
    /**
     * 
     * @type {OutletType}
     * @memberof FullOutletDTO
     */
    type: OutletType;
    /**
     * Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, `20.4522144, 54.7104264`.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в `address`. 
     * @type {string}
     * @memberof FullOutletDTO
     */
    coords?: string;
    /**
     * Признак основной точки продаж.  Возможные значения:  * `false` — неосновная точка продаж. * `true` — основная точка продаж. 
     * @type {boolean}
     * @memberof FullOutletDTO
     */
    isMain?: boolean;
    /**
     * Идентификатор точки продаж, присвоенный магазином.
     * @type {string}
     * @memberof FullOutletDTO
     */
    shopOutletCode?: string;
    /**
     * 
     * @type {OutletVisibilityType}
     * @memberof FullOutletDTO
     */
    visibility?: OutletVisibilityType;
    /**
     * 
     * @type {OutletAddressDTO}
     * @memberof FullOutletDTO
     */
    address: OutletAddressDTO;
    /**
     * Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`. 
     * @type {Array<string>}
     * @memberof FullOutletDTO
     */
    phones: Array<string>;
    /**
     * 
     * @type {OutletWorkingScheduleDTO}
     * @memberof FullOutletDTO
     */
    workingSchedule: OutletWorkingScheduleDTO;
    /**
     * Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр `type=DEPOT` или `type=MIXED`. 
     * @type {Array<OutletDeliveryRuleDTO>}
     * @memberof FullOutletDTO
     */
    deliveryRules?: Array<OutletDeliveryRuleDTO>;
    /**
     * Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях.
     * @type {number}
     * @memberof FullOutletDTO
     */
    storagePeriod?: number;
    /**
     * Идентификатор точки продаж, присвоенный Маркетом.
     * @type {number}
     * @memberof FullOutletDTO
     */
    id?: number;
    /**
     * 
     * @type {OutletStatusType}
     * @memberof FullOutletDTO
     */
    status?: OutletStatusType;
    /**
     * 
     * @type {RegionDTO}
     * @memberof FullOutletDTO
     */
    region?: RegionDTO;
    /**
     * Идентификатор точки продаж, заданный магазином.
     * @type {string}
     * @memberof FullOutletDTO
     */
    shopOutletId?: string;
    /**
     * Рабочее время.
     * @type {string}
     * @memberof FullOutletDTO
     */
    workingTime?: string;
    /**
     * Статус модерации.
     * @type {string}
     * @memberof FullOutletDTO
     */
    moderationReason?: string;
}

/**
 * Информация о лицензии.
 * @export
 */
export type FullOutletLicenseDTO = {
    /**
     * Идентификатор лицензии.  Параметр указывается, только если нужно изменить информацию о существующей лицензии. Ее идентификатор можно узнать с помощью запроса [GET campaigns/{campaignId}/outlets/licenses](../../reference/outlets/getOutletLicenses.md). При передаче информации о новой лицензии указывать идентификатор не нужно.  Идентификатор лицензии присваивается Маркетом. Не путайте его с номером, указанным на лицензии: он передается в параметре `number`. 
     * @type {number}
     * @memberof FullOutletLicenseDTO
     */
    id?: number;
    /**
     * Идентификатор точки продаж, для которой действительна лицензия.
     * @type {number}
     * @memberof FullOutletLicenseDTO
     */
    outletId?: number;
    /**
     * 
     * @type {LicenseType}
     * @memberof FullOutletLicenseDTO
     */
    licenseType?: LicenseType;
    /**
     * Номер лицензии.
     * @type {string}
     * @memberof FullOutletLicenseDTO
     */
    _number?: string;
    /**
     * Дата выдачи лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время `00:00:00` и часовой пояс, соответствующий региону точки продаж. Например, если лицензия для точки продаж в Москве выдана 13 ноября 2017 года, то параметр должен иметь значение `2017-11-13T00:00:00+03:00`.  Обязательный параметр.  Не может быть позже даты окончания срока действия, указанной в параметре `dateOfExpiry`. 
     * @type {Date}
     * @memberof FullOutletLicenseDTO
     */
    dateOfIssue?: Date;
    /**
     * Дата окончания действия лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время `00:00:00` и часовой пояс, соответствующий региону точки продаж. Например, если действие лицензии для точки продаж в Москве заканчивается 20 ноября 2022 года, то параметр должен иметь значение `2022-11-20T00:00:00+03:00`.  Обязательный параметр.  Не может быть раньше даты выдачи, указанной в параметре `dateOfIssue`. 
     * @type {Date}
     * @memberof FullOutletLicenseDTO
     */
    dateOfExpiry?: Date;
    /**
     * 
     * @type {LicenseCheckStatusType}
     * @memberof FullOutletLicenseDTO
     */
    checkStatus?: LicenseCheckStatusType;
    /**
     * Причина, по которой лицензия не прошла проверку.  Параметр возвращается, только если параметр `checkStatus` имеет значение `FAIL`. 
     * @type {string}
     * @memberof FullOutletLicenseDTO
     */
    checkComment?: string;
}

/**
 * Данные, необходимые для генерации отчета. 
 * @export
 */
export type GenerateBoostConsolidatedRequest = {
    /**
     * Идентификатор бизнеса.
     * @type {number}
     * @memberof GenerateBoostConsolidatedRequest
     */
    businessId: number;
    /**
     * Начало периода, включительно.
     * @type {Date}
     * @memberof GenerateBoostConsolidatedRequest
     */
    dateFrom: Date;
    /**
     * Конец периода, включительно.
     * @type {Date}
     * @memberof GenerateBoostConsolidatedRequest
     */
    dateTo: Date;
}

/**
 * Данные, необходимые для генерации отчета.
 * @export
 */
export type GenerateCompetitorsPositionReportRequest = {
    /**
     * Идентификатор бизнеса.
     * @type {number}
     * @memberof GenerateCompetitorsPositionReportRequest
     */
    businessId: number;
    /**
     * Идентификатор категории.
     * @type {number}
     * @memberof GenerateCompetitorsPositionReportRequest
     */
    categoryId: number;
    /**
     * Начало периода, включительно.
     * @type {Date}
     * @memberof GenerateCompetitorsPositionReportRequest
     */
    dateFrom: Date;
    /**
     * Конец периода, включительно.
     * @type {Date}
     * @memberof GenerateCompetitorsPositionReportRequest
     */
    dateTo: Date;
}

/**
 * Данные, необходимые для генерации отчета. 
 * @export
 */
export type GenerateGoodsFeedbackRequest = {
    /**
     * Идентификатор бизнеса.
     * @type {number}
     * @memberof GenerateGoodsFeedbackRequest
     */
    businessId: number;
}

/**
 * Данные, необходимые для генерации отчета.
 * @export
 */
export type GenerateGoodsMovementReportRequest = {
    /**
     * Идентификатор кампании.
     * @type {number}
     * @memberof GenerateGoodsMovementReportRequest
     */
    campaignId: number;
    /**
     * Начало периода, включительно.
     * @type {Date}
     * @memberof GenerateGoodsMovementReportRequest
     */
    dateFrom: Date;
    /**
     * Конец периода, включительно.
     * @type {Date}
     * @memberof GenerateGoodsMovementReportRequest
     */
    dateTo: Date;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof GenerateGoodsMovementReportRequest
     */
    shopSku?: string;
}

/**
 * Данные, необходимые для генерации отчета: идентификатор магазина и период, за который нужен отчет. 
 * @export
 */
export type GenerateGoodsRealizationReportRequest = {
    /**
     * Идентификатор кампании.
     * @type {number}
     * @memberof GenerateGoodsRealizationReportRequest
     */
    campaignId: number;
    /**
     * Год.
     * @type {number}
     * @memberof GenerateGoodsRealizationReportRequest
     */
    year: number;
    /**
     * Номер месяца.
     * @type {number}
     * @memberof GenerateGoodsRealizationReportRequest
     */
    month: number;
}

/**
 * Данные, необходимые для генерации отчета. 
 * @export
 */
export type GenerateGoodsTurnoverRequest = {
    /**
     * Идентификатор кампании.
     * @type {number}
     * @memberof GenerateGoodsTurnoverRequest
     */
    campaignId: number;
    /**
     * Дата, за которую нужно рассчитать оборачиваемость. Если параметр не указан, используется текущая дата.
     * @type {Date}
     * @memberof GenerateGoodsTurnoverRequest
     */
    _date?: Date;
}

/**
 * Данные, необходимые для генерации файла. 
 * @export
 */
export type GenerateMassOrderLabelsRequest = {
    /**
     * Идентификатор кабинета.
     * @type {number}
     * @memberof GenerateMassOrderLabelsRequest
     */
    businessId: number;
    /**
     * Список идентификаторов заказов.
     * @type {Set<number>}
     * @memberof GenerateMassOrderLabelsRequest
     */
    orderIds: Set<number>;
}

/**
 * Данные, необходимые для генерации отчета.
 * @export
 */
export type GeneratePricesReportRequest = {
    /**
     * Идентификатор бизнеса.  В большинстве случаев обязателен. Не указывается, если задан `campaignId`. 
     * @type {number}
     * @memberof GeneratePricesReportRequest
     */
    businessId?: number;
    /**
     * Идентификатор кампании.  Как правило, не используется. Передавайте только если в кабинете есть магазины с уникальными ценами и вы хотите получить отчет для них. В этом случае передавать `businessId` не нужно. 
     * @type {number}
     * @memberof GeneratePricesReportRequest
     */
    campaignId?: number;
    /**
     * Фильтр по категориям на Маркете.
     * @type {Array<number>}
     * @memberof GeneratePricesReportRequest
     */
    categoryIds?: Array<number>;
    /**
     * Фильтр по времени появления предложения — начало периода.  Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {Date}
     * @memberof GeneratePricesReportRequest
     */
    creationDateFrom?: Date;
    /**
     * Фильтр по времени появления предложения — окончание периода.  Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {Date}
     * @memberof GeneratePricesReportRequest
     */
    creationDateTo?: Date;
}

/**
 * Идентификатор, который понадобится для отслеживания статуса генерации и получения готового отчета.
 * @export
 */
export type GenerateReportDTO = {
    /**
     * Идентификатор, который понадобится для отслеживания статуса генерации и получения готового отчета.
     * @type {string}
     * @memberof GenerateReportDTO
     */
    reportId: string;
    /**
     * Ожидаемая продолжительность генерации в миллисекундах.
     * @type {number}
     * @memberof GenerateReportDTO
     */
    estimatedGenerationTime: number;
}

/**
 * Ответ на запрос генерации отчета.
 * @export
 */
export type GenerateReportResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GenerateReportResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GenerateReportDTO}
     * @memberof GenerateReportResponse
     */
    result?: GenerateReportDTO;
}

/**
 * Данные, необходимые для генерации отчета. 
 * @export
 */
export type GenerateShelfsStatisticsRequest = {
    /**
     * Идентификатор бизнеса.
     * @type {number}
     * @memberof GenerateShelfsStatisticsRequest
     */
    businessId: number;
    /**
     * Начало периода, включительно.
     * @type {Date}
     * @memberof GenerateShelfsStatisticsRequest
     */
    dateFrom: Date;
    /**
     * Конец периода, включительно.
     * @type {Date}
     * @memberof GenerateShelfsStatisticsRequest
     */
    dateTo: Date;
    /**
     * 
     * @type {ShelfsStatisticsAttributionType}
     * @memberof GenerateShelfsStatisticsRequest
     */
    attributionType: ShelfsStatisticsAttributionType;
}

/**
 * Данные, необходимые для генерации документа. 
 * @export
 */
export type GenerateShipmentListDocumentReportRequest = {
    /**
     * Идентификатор кампании.
     * @type {number}
     * @memberof GenerateShipmentListDocumentReportRequest
     */
    campaignId: number;
    /**
     * Идентификатор отгрузки.
     * @type {number}
     * @memberof GenerateShipmentListDocumentReportRequest
     */
    shipmentId?: number;
    /**
     * Фильтр по идентификаторам заказа в отгрузке.
     * @type {Array<number>}
     * @memberof GenerateShipmentListDocumentReportRequest
     */
    orderIds?: Array<number>;
}

/**
 * Данные, необходимые для генерации отчета.
 * @export
 */
export type GenerateShowsSalesReportRequest = {
    /**
     * Идентификатор бизнеса.  Указывается, если нужно составить отчет по всем магазинам бизнеса. В запросе обязательно должен быть либо `businessID`, либо `campaignId`, но не оба сразу. 
     * @type {number}
     * @memberof GenerateShowsSalesReportRequest
     */
    businessId?: number;
    /**
     * Идентификатор кампании.  Указывается, если нужно составить отчет по конкретному магазину. В запросе обязательно должен быть либо `businessID`, либо `campaignId`, но не оба сразу. 
     * @type {number}
     * @memberof GenerateShowsSalesReportRequest
     */
    campaignId?: number;
    /**
     * Начало периода, включительно.
     * @type {Date}
     * @memberof GenerateShowsSalesReportRequest
     */
    dateFrom: Date;
    /**
     * Конец периода, включительно.
     * @type {Date}
     * @memberof GenerateShowsSalesReportRequest
     */
    dateTo: Date;
    /**
     * 
     * @type {ShowsSalesGroupingType}
     * @memberof GenerateShowsSalesReportRequest
     */
    grouping: ShowsSalesGroupingType;
}

/**
 * Данные, необходимые для генерации отчета. 
 * @export
 */
export type GenerateStocksOnWarehousesReportRequest = {
    /**
     * Идентификатор магазина.
     * @type {number}
     * @memberof GenerateStocksOnWarehousesReportRequest
     */
    campaignId: number;
    /**
     * Фильтр по идентификаторам складов (только модель FBY). Чтобы узнать идентификатор, воспользуйтесь запросом [GET warehouses](../../reference/warehouses/getFulfillmentWarehouses.md).
     * @type {Array<number>}
     * @memberof GenerateStocksOnWarehousesReportRequest
     */
    warehouseIds?: Array<number>;
    /**
     * Фильтр по дате (для модели FBY). В отчет попадут данные за **предшествующий** дате день.
     * @type {Date}
     * @memberof GenerateStocksOnWarehousesReportRequest
     */
    reportDate?: Date;
    /**
     * Фильтр по категориям на Маркете (кроме модели FBY).
     * @type {Array<number>}
     * @memberof GenerateStocksOnWarehousesReportRequest
     */
    categoryIds?: Array<number>;
    /**
     * Фильтр по наличию остатков (кроме модели FBY).
     * @type {boolean}
     * @memberof GenerateStocksOnWarehousesReportRequest
     */
    hasStocks?: boolean;
}

/**
 * Данные, необходимые для генерации отчета: идентификатор магазина, период, за который нужен отчет, а также фильтры. 
 * @export
 */
export type GenerateUnitedMarketplaceServicesReportRequest = {
    /**
     * Идентификатор бизнеса.
     * @type {number}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    businessId: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Начало периода, включительно. 
     * @type {Date}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    dateTimeFrom?: Date;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Конец периода, включительно. Максимальный период — 1 год. 
     * @type {Date}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    dateTimeTo?: Date;
    /**
     * Начало периода, включительно.
     * @type {Date}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    dateFrom?: Date;
    /**
     * Конец периода, включительно. Максимальный период — 1 год.
     * @type {Date}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    dateTo?: Date;
    /**
     * Начальный год формирования акта.
     * @type {number}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    yearFrom?: number;
    /**
     * Начальный номер месяца формирования акта.
     * @type {number}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    monthFrom?: number;
    /**
     * Конечный год формирования акта.
     * @type {number}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    yearTo?: number;
    /**
     * Конечный номер месяца формирования акта.
     * @type {number}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    monthTo?: number;
    /**
     * Список моделей, которые нужны в отчете. 
     * @type {Array<PlacementType>}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    placementPrograms?: Array<PlacementType>;
    /**
     * Список ИНН, которые нужны в отчете.
     * @type {Array<string>}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    inns?: Array<string>;
    /**
     * Список магазинов, которые нужны в отчете.
     * @type {Array<number>}
     * @memberof GenerateUnitedMarketplaceServicesReportRequest
     */
    campaignIds?: Array<number>;
}

/**
 * Данные, необходимые для генерации отчета: идентификатор магазина, период, за который нужен отчет, а также фильтры. 
 * @export
 */
export type GenerateUnitedNettingReportRequest = {
    /**
     * Идентификатор бизнеса.
     * @type {number}
     * @memberof GenerateUnitedNettingReportRequest
     */
    businessId: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Начало периода, включительно. 
     * @type {Date}
     * @memberof GenerateUnitedNettingReportRequest
     */
    dateTimeFrom?: Date;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Конец периода, включительно. Максимальный период — 1 год. 
     * @type {Date}
     * @memberof GenerateUnitedNettingReportRequest
     */
    dateTimeTo?: Date;
    /**
     * Начало периода, включительно.
     * @type {Date}
     * @memberof GenerateUnitedNettingReportRequest
     */
    dateFrom?: Date;
    /**
     * Конец периода, включительно. Максимальный период — 1 год.
     * @type {Date}
     * @memberof GenerateUnitedNettingReportRequest
     */
    dateTo?: Date;
    /**
     * Номер платежного поручения.
     * @type {number}
     * @memberof GenerateUnitedNettingReportRequest
     */
    bankOrderId?: number;
    /**
     * Дата платежного поручения.
     * @type {Date}
     * @memberof GenerateUnitedNettingReportRequest
     */
    bankOrderDateTime?: Date;
    /**
     * Список моделей, которые нужны в отчете. 
     * @type {Array<PlacementType>}
     * @memberof GenerateUnitedNettingReportRequest
     */
    placementPrograms?: Array<PlacementType>;
    /**
     * Список ИНН, которые нужны в отчете.
     * @type {Array<string>}
     * @memberof GenerateUnitedNettingReportRequest
     */
    inns?: Array<string>;
    /**
     * Список магазинов, которые нужны в отчете.
     * @type {Array<number>}
     * @memberof GenerateUnitedNettingReportRequest
     */
    campaignIds?: Array<number>;
}

/**
 * Данные, необходимые для генерации отчета. 
 * @export
 */
export type GenerateUnitedOrdersRequest = {
    /**
     * Идентификатор бизнеса.
     * @type {number}
     * @memberof GenerateUnitedOrdersRequest
     */
    businessId: number;
    /**
     * Начало периода, включительно.
     * @type {Date}
     * @memberof GenerateUnitedOrdersRequest
     */
    dateFrom: Date;
    /**
     * Конец периода, включительно. Максимальный период — 1 год.
     * @type {Date}
     * @memberof GenerateUnitedOrdersRequest
     */
    dateTo: Date;
    /**
     * Список магазинов, которые нужны в отчете.
     * @type {Array<number>}
     * @memberof GenerateUnitedOrdersRequest
     */
    campaignIds?: Array<number>;
    /**
     * Идентификатор акции, товары из которой нужны в отчете.
     * @type {string}
     * @memberof GenerateUnitedOrdersRequest
     */
    promoId?: string;
}

/**
 * Список предложений.
 * @export
 */
export type GetAllOffersResponse = {
    /**
     * Список предложений магазина.
     * @type {Array<OfferDTO>}
     * @memberof GetAllOffersResponse
     */
    offers: Array<OfferDTO>;
}

/**
 * description.
 * @export
 */
export type GetBidsInfoRequest = {
    /**
     * Список товаров, для которых нужно получить значения ставок.  Если список не задан, постранично возвращаются все товары со ставками.  Если список задан, результаты возвращаются одной страницей, а параметры `page_token` и `limit` игнорируются. 
     * @type {Array<string>}
     * @memberof GetBidsInfoRequest
     */
    skus?: Array<string>;
}

/**
 * description.
 * @export
 */
export type GetBidsInfoResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetBidsInfoResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetBidsInfoResponseDTO}
     * @memberof GetBidsInfoResponse
     */
    result?: GetBidsInfoResponseDTO;
}

/**
 * Список товаров с указанными ставками.
 * @export
 */
export type GetBidsInfoResponseDTO = {
    /**
     * Страница списка товаров.
     * @type {Array<SkuBidItemDTO>}
     * @memberof GetBidsInfoResponseDTO
     */
    bids: Array<SkuBidItemDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof GetBidsInfoResponseDTO
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * description.
 * @export
 */
export type GetBidsRecommendationsRequest = {
    /**
     * Список товаров, для которых нужно получить рекомендации по ставкам. 
     * @type {Array<string>}
     * @memberof GetBidsRecommendationsRequest
     */
    skus: Array<string>;
}

/**
 * description.
 * @export
 */
export type GetBidsRecommendationsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetBidsRecommendationsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetBidsRecommendationsResponseDTO}
     * @memberof GetBidsRecommendationsResponse
     */
    result?: GetBidsRecommendationsResponseDTO;
}

/**
 * Список товаров с рекомендованными ставками.
 * @export
 */
export type GetBidsRecommendationsResponseDTO = {
    /**
     * Список товаров с рекомендованными ставками.
     * @type {Array<SkuBidRecommendationItemDTO>}
     * @memberof GetBidsRecommendationsResponseDTO
     */
    recommendations: Array<SkuBidRecommendationItemDTO>;
}

/**
 * 
 * @export
 */
export type GetBusinessBuyerInfoResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetBusinessBuyerInfoResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OrderBusinessBuyerDTO}
     * @memberof GetBusinessBuyerInfoResponse
     */
    result?: OrderBusinessBuyerDTO;
}

/**
 * 
 * @export
 */
export type GetBusinessDocumentsInfoResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetBusinessDocumentsInfoResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OrderBusinessDocumentsDTO}
     * @memberof GetBusinessDocumentsInfoResponse
     */
    result?: OrderBusinessDocumentsDTO;
}

/**
 * Информация о кабинете и его настройках.
 * @export
 */
export type GetBusinessSettingsInfoDTO = {
    /**
     * 
     * @type {BusinessDTO}
     * @memberof GetBusinessSettingsInfoDTO
     */
    info?: BusinessDTO;
    /**
     * 
     * @type {BusinessSettingsDTO}
     * @memberof GetBusinessSettingsInfoDTO
     */
    settings?: BusinessSettingsDTO;
}

/**
 * Ответ на запрос настроек кабинета.
 * @export
 */
export type GetBusinessSettingsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetBusinessSettingsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetBusinessSettingsInfoDTO}
     * @memberof GetBusinessSettingsResponse
     */
    result?: GetBusinessSettingsInfoDTO;
}

/**
 * Ответ на запрос списка логинов, связанных с магазином.
 * @export
 */
export type GetCampaignLoginsResponse = {
    /**
     * Список логинов.
     * @type {Array<string>}
     * @memberof GetCampaignLoginsResponse
     */
    logins: Array<string>;
}

/**
 * Параметры размещения товара в магазине.
 * @export
 */
export type GetCampaignOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof GetCampaignOfferDTO
     */
    offerId: string;
    /**
     * 
     * @type {QuantumDTO}
     * @memberof GetCampaignOfferDTO
     */
    quantum?: QuantumDTO;
    /**
     * Есть ли товар в продаже. 
     * @type {boolean}
     * @memberof GetCampaignOfferDTO
     */
    available?: boolean;
    /**
     * 
     * @type {GetPriceWithDiscountDTO}
     * @memberof GetCampaignOfferDTO
     */
    basicPrice?: GetPriceWithDiscountDTO;
    /**
     * 
     * @type {GetPriceWithVatDTO}
     * @memberof GetCampaignOfferDTO
     */
    campaignPrice?: GetPriceWithVatDTO;
    /**
     * 
     * @type {OfferCampaignStatusType}
     * @memberof GetCampaignOfferDTO
     */
    status?: OfferCampaignStatusType;
    /**
     * Ошибки, препятствующие размещению товара на витрине. 
     * @type {Array<OfferErrorDTO>}
     * @memberof GetCampaignOfferDTO
     */
    errors?: Array<OfferErrorDTO>;
    /**
     * Предупреждения, не препятствующие размещению товара на витрине. 
     * @type {Array<OfferErrorDTO>}
     * @memberof GetCampaignOfferDTO
     */
    warnings?: Array<OfferErrorDTO>;
}

/**
 * Фильтрации товаров  В запросе можно указать либо фильтр offerIds, либо любые другие фильтры товаров. Совместное использование фильтра offerIds с другими фильтрациями приведет к ошибке. 
 * @export
 */
export type GetCampaignOffersRequest = {
    /**
     * Идентификаторы товаров, информация о которых нужна.  {% note warning \"Такой список возвращается только целиком\" %}  Не используйте это поле одновременно с фильтрами по статусам карточек, категориям, брендам или тегам. Если вы хотите воспользоваться фильтрами, оставьте поле пустым.  Если вы запрашиваете информацию по конкретным SKU, не заполняйте:  * `page_token` * `limit`  {% endnote %}    
     * @type {Array<string>}
     * @memberof GetCampaignOffersRequest
     */
    offerIds?: Array<string>;
    /**
     * Фильтр по статусам товаров. 
     * @type {Array<OfferCampaignStatusType>}
     * @memberof GetCampaignOffersRequest
     */
    statuses?: Array<OfferCampaignStatusType>;
    /**
     * Фильтр по категориям на Маркете.
     * @type {Array<number>}
     * @memberof GetCampaignOffersRequest
     */
    categoryIds?: Array<number>;
    /**
     * Фильтр по брендам.
     * @type {Array<string>}
     * @memberof GetCampaignOffersRequest
     */
    vendorNames?: Array<string>;
    /**
     * Фильтр по тегам.
     * @type {Array<string>}
     * @memberof GetCampaignOffersRequest
     */
    tags?: Array<string>;
}

/**
 * Ответ на запрос списка товаров в магазине.
 * @export
 */
export type GetCampaignOffersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetCampaignOffersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetCampaignOffersResultDTO}
     * @memberof GetCampaignOffersResponse
     */
    result?: GetCampaignOffersResultDTO;
}

/**
 * Список товаров в заданном магазине.
 * @export
 */
export type GetCampaignOffersResultDTO = {
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof GetCampaignOffersResultDTO
     */
    paging?: ScrollingPagerDTO;
    /**
     * Страница списка товаров.
     * @type {Array<GetCampaignOfferDTO>}
     * @memberof GetCampaignOffersResultDTO
     */
    offers: Array<GetCampaignOfferDTO>;
}

/**
 * Ответ на запрос региона магазина.
 * @export
 */
export type GetCampaignRegionResponse = {
    /**
     * 
     * @type {RegionDTO}
     * @memberof GetCampaignRegionResponse
     */
    region?: RegionDTO;
}

/**
 * Информация о магазине к данным идентификатора кампании.
 * @export
 */
export type GetCampaignResponse = {
    /**
     * 
     * @type {CampaignDTO}
     * @memberof GetCampaignResponse
     */
    campaign?: CampaignDTO;
}

/**
 * Ответ на запрос настроек магазина.
 * @export
 */
export type GetCampaignSettingsResponse = {
    /**
     * 
     * @type {CampaignSettingsDTO}
     * @memberof GetCampaignSettingsResponse
     */
    settings?: CampaignSettingsDTO;
}

/**
 * Результаты поиска магазинов.
 * @export
 */
export type GetCampaignsResponse = {
    /**
     * Список с информацией по каждому магазину.
     * @type {Array<CampaignDTO>}
     * @memberof GetCampaignsResponse
     */
    campaigns: Array<CampaignDTO>;
    /**
     * 
     * @type {FlippingPagerDTO}
     * @memberof GetCampaignsResponse
     */
    pager?: FlippingPagerDTO;
}

/**
 * Категории и лимит на установку кванта и минимального количества товаров.
 * @export
 */
export type GetCategoriesMaxSaleQuantumDTO = {
    /**
     * Категории и лимит на установку кванта и минимального количества товаров.
     * @type {Array<MaxSaleQuantumDTO>}
     * @memberof GetCategoriesMaxSaleQuantumDTO
     */
    results: Array<MaxSaleQuantumDTO>;
    /**
     * Ошибки, которые появились из-за переданных категорий.
     * @type {Array<CategoryErrorDTO>}
     * @memberof GetCategoriesMaxSaleQuantumDTO
     */
    errors?: Array<CategoryErrorDTO>;
}

/**
 * Список категорий, для которых нужно вернуть лимит на установку кванта и минимального количества товаров. 
 * @export
 */
export type GetCategoriesMaxSaleQuantumRequest = {
    /**
     * Идентификаторы листовых категории на Маркете — тех, у которых нет дочерних категорий.
     * @type {Set<number>}
     * @memberof GetCategoriesMaxSaleQuantumRequest
     */
    marketCategoryIds: Set<number>;
}

/**
 * 
 * @export
 */
export type GetCategoriesMaxSaleQuantumResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetCategoriesMaxSaleQuantumResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Категории и лимит на установку кванта и минимального количества товаров.
     * @type {Array<MaxSaleQuantumDTO>}
     * @memberof GetCategoriesMaxSaleQuantumResponse
     */
    results: Array<MaxSaleQuantumDTO>;
    /**
     * Ошибки, которые появились из-за переданных категорий.
     * @type {Array<CategoryErrorDTO>}
     * @memberof GetCategoriesMaxSaleQuantumResponse
     */
    errors?: Array<CategoryErrorDTO>;
}

/**
 * Параметры запроса категорий. 
 * @export
 */
export type GetCategoriesRequest = {
    /**
     * 
     * @type {LanguageType}
     * @memberof GetCategoriesRequest
     */
    language?: LanguageType;
}

/**
 * 
 * @export
 */
export type GetCategoriesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetCategoriesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {CategoryDTO}
     * @memberof GetCategoriesResponse
     */
    result?: CategoryDTO;
}

/**
 * Ответ со списком характеристик для категории и их допустимыми значениями.
 * @export
 */
export type GetCategoryContentParametersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetCategoryContentParametersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {CategoryContentParametersDTO}
     * @memberof GetCategoryContentParametersResponse
     */
    result?: CategoryContentParametersDTO;
}

/**
 * Историю какого чата нужно получить — и начиная с какого сообщения. 
 * @export
 */
export type GetChatHistoryRequest = {
    /**
     * Идентификатор сообщения, начиная с которого нужно получить все последующие сообщения.
     * @type {number}
     * @memberof GetChatHistoryRequest
     */
    messageIdFrom?: number;
}

/**
 * 
 * @export
 */
export type GetChatHistoryResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetChatHistoryResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {ChatMessagesResultDTO}
     * @memberof GetChatHistoryResponse
     */
    result?: ChatMessagesResultDTO;
}

/**
 * Информация о чатах.
 * @export
 */
export type GetChatInfoDTO = {
    /**
     * Идентификатор чата.
     * @type {number}
     * @memberof GetChatInfoDTO
     */
    chatId: number;
    /**
     * Идентификатор заказа.
     * @type {number}
     * @memberof GetChatInfoDTO
     */
    orderId: number;
    /**
     * 
     * @type {ChatType}
     * @memberof GetChatInfoDTO
     */
    type: ChatType;
    /**
     * 
     * @type {ChatStatusType}
     * @memberof GetChatInfoDTO
     */
    status: ChatStatusType;
    /**
     * Дата и время создания чата.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
     * @type {Date}
     * @memberof GetChatInfoDTO
     */
    createdAt: Date;
    /**
     * Дата и время последнего сообщения в чате.
     * @type {Date}
     * @memberof GetChatInfoDTO
     */
    updatedAt: Date;
}

/**
 * Список чатов.
 * @export
 */
export type GetChatsInfoDTO = {
    /**
     * Информация о чатах.
     * @type {Array<GetChatInfoDTO>}
     * @memberof GetChatsInfoDTO
     */
    chats: Array<GetChatInfoDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof GetChatsInfoDTO
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Фильтры по чатам, которые нужно вернуть. 
 * @export
 */
export type GetChatsRequest = {
    /**
     * Фильтр по идентификаторам заказов на Маркете.
     * @type {Array<number>}
     * @memberof GetChatsRequest
     */
    orderIds?: Array<number>;
    /**
     * Фильтр по типам чатов.
     * @type {Array<ChatType>}
     * @memberof GetChatsRequest
     */
    types?: Array<ChatType>;
    /**
     * Фильтр по статусам чатов.
     * @type {Array<ChatStatusType>}
     * @memberof GetChatsRequest
     */
    statuses?: Array<ChatStatusType>;
}

/**
 * 
 * @export
 */
export type GetChatsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetChatsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetChatsInfoDTO}
     * @memberof GetChatsResponse
     */
    result?: GetChatsInfoDTO;
}

/**
 * Ответ на запрос списка служб доставки.
 * @export
 */
export type GetDeliveryServicesResponse = {
    /**
     * 
     * @type {DeliveryServicesDTO}
     * @memberof GetDeliveryServicesResponse
     */
    result?: DeliveryServicesDTO;
}

/**
 * 
 * @export
 */
export type GetFeedIndexLogsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetFeedIndexLogsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {FeedIndexLogsResultDTO}
     * @memberof GetFeedIndexLogsResponse
     */
    result?: FeedIndexLogsResultDTO;
}

/**
 * Ответ на запрос информации о прайс-листе.
 * @export
 */
export type GetFeedResponse = {
    /**
     * 
     * @type {FeedDTO}
     * @memberof GetFeedResponse
     */
    feed?: FeedDTO;
}

/**
 * 
 * @export
 */
export type GetFeedbackListResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetFeedbackListResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {FeedbackListDTO}
     * @memberof GetFeedbackListResponse
     */
    result?: FeedbackListDTO;
}

/**
 * Ответ на запрос списка прайс-листов.
 * @export
 */
export type GetFeedsResponse = {
    /**
     * Список прайс-листов.
     * @type {Array<FeedDTO>}
     * @memberof GetFeedsResponse
     */
    feeds: Array<FeedDTO>;
}

/**
 * 
 * @export
 */
export type GetFulfillmentWarehousesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetFulfillmentWarehousesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {FulfillmentWarehousesDTO}
     * @memberof GetFulfillmentWarehousesResponse
     */
    result?: FulfillmentWarehousesDTO;
}

/**
 * Фильтр запроса комментариев отзыва. 
 * @export
 */
export type GetGoodsFeedbackCommentsRequest = {
    /**
     * Идентификатор отзыва. 
     * @type {number}
     * @memberof GetGoodsFeedbackCommentsRequest
     */
    feedbackId: number;
}

/**
 * 
 * @export
 */
export type GetGoodsFeedbackCommentsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetGoodsFeedbackCommentsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GoodsFeedbackCommentListDTO}
     * @memberof GetGoodsFeedbackCommentsResponse
     */
    result?: GoodsFeedbackCommentListDTO;
}

/**
 * Фильтр запроса отзывов в кабинете. 
 * @export
 */
export type GetGoodsFeedbackRequest = {
    /**
     * Начало периода. Не включительно.  Если параметр не указан, возвращается информация за 6 месяцев до указанной в `dateTimeTo` даты. 
     * @type {Date}
     * @memberof GetGoodsFeedbackRequest
     */
    dateTimeFrom?: Date;
    /**
     * Конец периода. Не включительно.  Если параметр не указан, используется текущая дата. 
     * @type {Date}
     * @memberof GetGoodsFeedbackRequest
     */
    dateTimeTo?: Date;
    /**
     * 
     * @type {FeedbackReactionStatusType}
     * @memberof GetGoodsFeedbackRequest
     */
    reactionStatus?: FeedbackReactionStatusType;
    /**
     * Оценка товара.
     * @type {Set<number>}
     * @memberof GetGoodsFeedbackRequest
     */
    ratingValues?: Set<number>;
    /**
     * Фильтр по идентификатору модели товара.  Получить идентификатор модели можно с помощью одного из запросов:  * [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md);  * [POST businesses/{businessId}/offer-cards](../../reference/content/getOfferCardsContentStatus.md);  * [POST models](../../reference/models/getModels.md). 
     * @type {Set<number>}
     * @memberof GetGoodsFeedbackRequest
     */
    modelIds?: Set<number>;
    /**
     * Фильтр отзывов за баллы Плюса.
     * @type {boolean}
     * @memberof GetGoodsFeedbackRequest
     */
    paid?: boolean;
}

/**
 * 
 * @export
 */
export type GetGoodsFeedbackResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetGoodsFeedbackResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GoodsFeedbackListDTO}
     * @memberof GetGoodsFeedbackResponse
     */
    result?: GoodsFeedbackListDTO;
}

/**
 * Запрос отчета по товарам.
 * @export
 */
export type GetGoodsStatsRequest = {
    /**
     * Список ваших идентификаторов SKU. 
     * @type {Set<string>}
     * @memberof GetGoodsStatsRequest
     */
    shopSkus: Set<string>;
}

/**
 * Ответ на запрос отчета по товарам.
 * @export
 */
export type GetGoodsStatsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetGoodsStatsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GoodsStatsDTO}
     * @memberof GetGoodsStatsResponse
     */
    result?: GoodsStatsDTO;
}

/**
 * Ответ на запрос списка скрытий.
 * @export
 */
export type GetHiddenOffersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetHiddenOffersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetHiddenOffersResultDTO}
     * @memberof GetHiddenOffersResponse
     */
    result?: GetHiddenOffersResultDTO;
}

/**
 * Список скрытых вами товаров. 
 * @export
 */
export type GetHiddenOffersResultDTO = {
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof GetHiddenOffersResultDTO
     */
    paging?: ScrollingPagerDTO;
    /**
     * Список скрытых товаров.
     * @type {Array<HiddenOfferDTO>}
     * @memberof GetHiddenOffersResultDTO
     */
    hiddenOffers: Array<HiddenOfferDTO>;
}

/**
 * Информация о товарах в каталоге. 
 * @export
 */
export type GetMappingDTO = {
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof GetMappingDTO
     */
    marketSku?: number;
    /**
     * Название карточки товара.  Может отсутствовать в ответе, если товар еще не привязан к карточке. 
     * @type {string}
     * @memberof GetMappingDTO
     */
    marketSkuName?: string;
    /**
     * Идентификатор модели на Маркете.  Может отсутствовать в ответе, если товар еще не привязан к карточке. 
     * @type {number}
     * @memberof GetMappingDTO
     */
    marketModelId?: number;
    /**
     * Название модели на Маркете.  Может отсутствовать в ответе, если товар еще не привязан к карточке. 
     * @type {string}
     * @memberof GetMappingDTO
     */
    marketModelName?: string;
    /**
     * Идентификатор категории на Маркете, в которую попал товар.  Может отсутствовать в ответе, если Маркет еще не определил категорию товара. 
     * @type {number}
     * @memberof GetMappingDTO
     */
    marketCategoryId?: number;
    /**
     * Название категории карточки на Маркете.  Может отсутствовать в ответе, если Маркет еще не определил категорию товара. 
     * @type {string}
     * @memberof GetMappingDTO
     */
    marketCategoryName?: string;
}

/**
 * Ответ на запрос списка предложений для моделей.
 * @export
 */
export type GetModelsOffersResponse = {
    /**
     * Список моделей товаров.
     * @type {Array<EnrichedModelDTO>}
     * @memberof GetModelsOffersResponse
     */
    models: Array<EnrichedModelDTO>;
    /**
     * 
     * @type {CurrencyType}
     * @memberof GetModelsOffersResponse
     */
    currency?: CurrencyType;
    /**
     * Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
     * @type {number}
     * @memberof GetModelsOffersResponse
     */
    regionId?: number;
}

/**
 * Запрос информации о моделях.
 * @export
 */
export type GetModelsRequest = {
    /**
     * Список моделей.
     * @type {Array<number>}
     * @memberof GetModelsRequest
     */
    models: Array<number>;
}

/**
 * Ответ на запрос информации о моделях.
 * @export
 */
export type GetModelsResponse = {
    /**
     * Список моделей товаров.
     * @type {Array<ModelDTO>}
     * @memberof GetModelsResponse
     */
    models: Array<ModelDTO>;
    /**
     * 
     * @type {CurrencyType}
     * @memberof GetModelsResponse
     */
    currency?: CurrencyType;
    /**
     * Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
     * @type {number}
     * @memberof GetModelsResponse
     */
    regionId?: number;
}

/**
 * 
 * @export
 */
export type GetOfferCardsContentStatusRequest = {
    /**
     * Идентификаторы товаров, информация о которых нужна. <br><br> ⚠️ Не используйте это поле одновременно с фильтрами по статусам карточек, категориям, брендам или тегам. Если вы хотите воспользоваться фильтрами, оставьте поле пустым. 
     * @type {Set<string>}
     * @memberof GetOfferCardsContentStatusRequest
     */
    offerIds?: Set<string>;
    /**
     * Фильтр по статусам карточек.  [Что такое карточка товара](https://yandex.ru/support/marketplace/assortment/content/index.html) 
     * @type {Set<OfferCardStatusType>}
     * @memberof GetOfferCardsContentStatusRequest
     */
    cardStatuses?: Set<OfferCardStatusType>;
    /**
     * Фильтр по категориям на Маркете.
     * @type {Set<number>}
     * @memberof GetOfferCardsContentStatusRequest
     */
    categoryIds?: Set<number>;
}

/**
 * Ответ со списком состояний товаров и пагинацией.
 * @export
 */
export type GetOfferCardsContentStatusResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetOfferCardsContentStatusResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OfferCardsContentStatusDTO}
     * @memberof GetOfferCardsContentStatusResponse
     */
    result?: OfferCardsContentStatusDTO;
}

/**
 * Параметры товара.
 * @export
 */
export type GetOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof GetOfferDTO
     */
    offerId: string;
    /**
     * Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
     * @type {string}
     * @memberof GetOfferDTO
     */
    name?: string;
    /**
     * Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать `marketCategoryId`, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
     * @type {number}
     * @memberof GetOfferDTO
     */
    marketCategoryId?: number;
    /**
     * Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
     * @type {string}
     * @memberof GetOfferDTO
     */
    category?: string;
    /**
     * Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/images/sku12345.jpg`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/images/sku12345.jpg`  ❌ `https://www.dropbox.com/s/818f/tovar.jpg`  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html) 
     * @type {Array<string>}
     * @memberof GetOfferDTO
     */
    pictures?: Array<string>;
    /**
     * Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/video/sku12345.avi`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/video/sku12345.avi`  ❌ `https://www.dropbox.com/s/818f/super-tovar.avi`  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html) 
     * @type {Array<string>}
     * @memberof GetOfferDTO
     */
    videos?: Array<string>;
    /**
     * Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле `manuals`, загруженные ранее инструкции удалятся. 
     * @type {Array<OfferManualDTO>}
     * @memberof GetOfferDTO
     */
    manuals?: Array<OfferManualDTO>;
    /**
     * Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
     * @type {string}
     * @memberof GetOfferDTO
     */
    vendor?: string;
    /**
     * Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
     * @type {Array<string>}
     * @memberof GetOfferDTO
     */
    barcodes?: Array<string>;
    /**
     * Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
     * @type {string}
     * @memberof GetOfferDTO
     */
    description?: string;
    /**
     * Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx). 
     * @type {Array<string>}
     * @memberof GetOfferDTO
     */
    manufacturerCountries?: Array<string>;
    /**
     * 
     * @type {OfferWeightDimensionsDTO}
     * @memberof GetOfferDTO
     */
    weightDimensions?: OfferWeightDimensionsDTO;
    /**
     * Артикул товара от производителя.
     * @type {string}
     * @memberof GetOfferDTO
     */
    vendorCode?: string;
    /**
     * Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов. 
     * @type {Array<string>}
     * @memberof GetOfferDTO
     */
    tags?: Array<string>;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof GetOfferDTO
     */
    shelfLife?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof GetOfferDTO
     */
    lifeTime?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof GetOfferDTO
     */
    guaranteePeriod?: TimePeriodDTO;
    /**
     * Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть. 
     * @type {string}
     * @memberof GetOfferDTO
     */
    customsCommodityCode?: string;
    /**
     * Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html). 
     * @type {Array<string>}
     * @memberof GetOfferDTO
     */
    certificates?: Array<string>;
    /**
     * Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр. 
     * @type {number}
     * @memberof GetOfferDTO
     */
    boxCount?: number;
    /**
     * 
     * @type {OfferConditionDTO}
     * @memberof GetOfferDTO
     */
    condition?: OfferConditionDTO;
    /**
     * 
     * @type {OfferType}
     * @memberof GetOfferDTO
     */
    type?: OfferType;
    /**
     * Признак цифрового товара. Укажите `true`, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md) 
     * @type {boolean}
     * @memberof GetOfferDTO
     */
    downloadable?: boolean;
    /**
     * Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей. 
     * @type {boolean}
     * @memberof GetOfferDTO
     */
    adult?: boolean;
    /**
     * 
     * @type {AgeDTO}
     * @memberof GetOfferDTO
     */
    age?: AgeDTO;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. При передаче характеристик используйте `parameterValues`.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви. 
     * @type {Array<OfferParamDTO>}
     * @memberof GetOfferDTO
     */
    params?: Array<OfferParamDTO>;
    /**
     * 
     * @type {GetPriceWithDiscountDTO}
     * @memberof GetOfferDTO
     */
    basicPrice?: GetPriceWithDiscountDTO;
    /**
     * 
     * @type {GetPriceDTO}
     * @memberof GetOfferDTO
     */
    purchasePrice?: GetPriceDTO;
    /**
     * 
     * @type {GetPriceDTO}
     * @memberof GetOfferDTO
     */
    additionalExpenses?: GetPriceDTO;
    /**
     * 
     * @type {GetPriceDTO}
     * @memberof GetOfferDTO
     */
    cofinancePrice?: GetPriceDTO;
    /**
     * 
     * @type {OfferCardStatusType}
     * @memberof GetOfferDTO
     */
    cardStatus?: OfferCardStatusType;
    /**
     * Список магазинов, в которых размещен товар. 
     * @type {Array<OfferCampaignStatusDTO>}
     * @memberof GetOfferDTO
     */
    campaigns?: Array<OfferCampaignStatusDTO>;
    /**
     * Информация о том, какие для товара доступны модели размещения. 
     * @type {Array<OfferSellingProgramDTO>}
     * @memberof GetOfferDTO
     */
    sellingPrograms?: Array<OfferSellingProgramDTO>;
    /**
     * Товар помещен в архив. 
     * @type {boolean}
     * @memberof GetOfferDTO
     */
    archived?: boolean;
}

/**
 * Информация о товаре.
 * @export
 */
export type GetOfferMappingDTO = {
    /**
     * 
     * @type {GetOfferDTO}
     * @memberof GetOfferMappingDTO
     */
    offer?: GetOfferDTO;
    /**
     * 
     * @type {GetMappingDTO}
     * @memberof GetOfferMappingDTO
     */
    mapping?: GetMappingDTO;
}

/**
 * Ответ на запрос списка товаров в каталоге.
 * @export
 */
export type GetOfferMappingEntriesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetOfferMappingEntriesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OfferMappingEntriesDTO}
     * @memberof GetOfferMappingEntriesResponse
     */
    result?: OfferMappingEntriesDTO;
}

/**
 * 
 * @export
 */
export type GetOfferMappingsRequest = {
    /**
     * Идентификаторы товаров, информация о которых нужна.  {% note warning \"Такой список возвращается только целиком\" %}  Если вы запрашиваете информацию по конкретным SKU, не заполняйте: * `page_token`; * `limit`; * `cardStatuses`; * `categoryIds`; * `vendorNames`; * `tags`; * `archived`.  {% endnote %}    
     * @type {Array<string>}
     * @memberof GetOfferMappingsRequest
     */
    offerIds?: Array<string>;
    /**
     * Фильтр по статусам карточек.  [Что такое карточка товара](https://yandex.ru/support/marketplace/assortment/content/index.html) 
     * @type {Array<OfferCardStatusType>}
     * @memberof GetOfferMappingsRequest
     */
    cardStatuses?: Array<OfferCardStatusType>;
    /**
     * Фильтр по категориям на Маркете.
     * @type {Array<number>}
     * @memberof GetOfferMappingsRequest
     */
    categoryIds?: Array<number>;
    /**
     * Фильтр по брендам.
     * @type {Array<string>}
     * @memberof GetOfferMappingsRequest
     */
    vendorNames?: Array<string>;
    /**
     * Фильтр по тегам.
     * @type {Array<string>}
     * @memberof GetOfferMappingsRequest
     */
    tags?: Array<string>;
    /**
     * Фильтр по нахождению в архиве.  Передайте `true`, чтобы получить товары, находящиеся в архиве. Если фильтр не заполнен или передано `false`, в ответе возвращаются товары, не находящиеся в архиве. 
     * @type {boolean}
     * @memberof GetOfferMappingsRequest
     */
    archived?: boolean;
}

/**
 * 
 * @export
 */
export type GetOfferMappingsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetOfferMappingsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetOfferMappingsResultDTO}
     * @memberof GetOfferMappingsResponse
     */
    result?: GetOfferMappingsResultDTO;
}

/**
 * Информация о товарах.
 * @export
 */
export type GetOfferMappingsResultDTO = {
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof GetOfferMappingsResultDTO
     */
    paging?: ScrollingPagerDTO;
    /**
     * Информация о товарах.
     * @type {Array<GetOfferMappingDTO>}
     * @memberof GetOfferMappingsResultDTO
     */
    offerMappings: Array<GetOfferMappingDTO>;
}

/**
 * 
 * @export
 */
export type GetOfferRecommendationsRequest = {
    /**
     * Идентификаторы товаров, информация о которых нужна. ⚠️ Не используйте это поле одновременно с остальными фильтрами. Если вы хотите воспользоваться фильтрами, оставьте поле пустым.
     * @type {Array<string>}
     * @memberof GetOfferRecommendationsRequest
     */
    offerIds?: Array<string>;
    /**
     * 
     * @type {FieldStateType}
     * @memberof GetOfferRecommendationsRequest
     */
    cofinancePriceFilter?: FieldStateType;
    /**
     * 
     * @type {FieldStateType}
     * @memberof GetOfferRecommendationsRequest
     */
    recommendedCofinancePriceFilter?: FieldStateType;
    /**
     * 
     * @type {PriceCompetitivenessType}
     * @memberof GetOfferRecommendationsRequest
     */
    competitivenessFilter?: PriceCompetitivenessType;
}

/**
 * 
 * @export
 */
export type GetOfferRecommendationsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetOfferRecommendationsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OfferRecommendationsResultDTO}
     * @memberof GetOfferRecommendationsResponse
     */
    result?: OfferRecommendationsResultDTO;
}

/**
 * Список предложений с пагинатором.
 * @export
 */
export type GetOffersResponse = {
    /**
     * Список предложений магазина.
     * @type {Array<OfferDTO>}
     * @memberof GetOffersResponse
     */
    offers: Array<OfferDTO>;
    /**
     * 
     * @type {FlippingPagerDTO}
     * @memberof GetOffersResponse
     */
    pager?: FlippingPagerDTO;
}

/**
 * 
 * @export
 */
export type GetOrderBuyerInfoResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetOrderBuyerInfoResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OrderBuyerInfoDTO}
     * @memberof GetOrderBuyerInfoResponse
     */
    result?: OrderBuyerInfoDTO;
}

/**
 * Ответ с информацией для печати ярлыков.
 * @export
 */
export type GetOrderLabelsDataResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetOrderLabelsDataResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OrderLabelDTO}
     * @memberof GetOrderLabelsDataResponse
     */
    result?: OrderLabelDTO;
}

/**
 * 
 * @export
 */
export type GetOrderResponse = {
    /**
     * 
     * @type {OrderDTO}
     * @memberof GetOrderResponse
     */
    order?: OrderDTO;
}

/**
 * Модель для ответа API списка информации по заказам.
 * @export
 */
export type GetOrdersResponse = {
    /**
     * 
     * @type {FlippingPagerDTO}
     * @memberof GetOrdersResponse
     */
    pager?: FlippingPagerDTO;
    /**
     * Модель заказа. 
     * @type {Array<OrderDTO>}
     * @memberof GetOrdersResponse
     */
    orders: Array<OrderDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof GetOrdersResponse
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Запрос информации по заказам.
 * @export
 */
export type GetOrdersStatsRequest = {
    /**
     * Начальная дата, когда заказ был сформирован.  Формат даты: `ГГГГ‑ММ‑ДД`.  Нельзя использовать вместе с параметрами `updateFrom` и `updateTo`. 
     * @type {Date}
     * @memberof GetOrdersStatsRequest
     */
    dateFrom?: Date;
    /**
     * Конечная дата, когда заказ был сформирован.  Формат даты: `ГГГГ‑ММ‑ДД`.  Нельзя использовать вместе с параметрами `updateFrom` и `updateTo`. 
     * @type {Date}
     * @memberof GetOrdersStatsRequest
     */
    dateTo?: Date;
    /**
     * Начальная дата периода, за который были изменения статуса заказа.  Формат даты: `ГГГГ‑ММ‑ДД`.  Нельзя использовать вместе с параметрами `dateFrom` и `dateTo`. 
     * @type {Date}
     * @memberof GetOrdersStatsRequest
     */
    updateFrom?: Date;
    /**
     * Конечная дата периода, за который были изменения статуса заказа.  Формат даты: `ГГГГ‑ММ‑ДД`.  Нельзя использовать вместе с параметрами `dateFrom` и `dateTo`. 
     * @type {Date}
     * @memberof GetOrdersStatsRequest
     */
    updateTo?: Date;
    /**
     * Список идентификаторов заказов.
     * @type {Array<number>}
     * @memberof GetOrdersStatsRequest
     */
    orders?: Array<number>;
    /**
     * Список статусов заказов.
     * @type {Array<OrderStatsStatusType>}
     * @memberof GetOrdersStatsRequest
     */
    statuses?: Array<OrderStatsStatusType>;
    /**
     * Нужно ли вернуть только те заказы, в составе которых есть хотя бы один товар с кодом идентификации [в системе «Честный ЗНАК»](https://честныйзнак.рф/):  * `true` — да. * `false` — нет. Такие коды присваиваются товарам, которые подлежат маркировке и относятся к определенным категориям. 
     * @type {boolean}
     * @memberof GetOrdersStatsRequest
     */
    hasCis?: boolean;
}

/**
 * Ответ на запрос информации по заказам.
 * @export
 */
export type GetOrdersStatsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetOrdersStatsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OrdersStatsDTO}
     * @memberof GetOrdersStatsResponse
     */
    result?: OrdersStatsDTO;
}

/**
 * 
 * @export
 */
export type GetOutletLicensesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetOutletLicensesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OutletLicensesResponseDTO}
     * @memberof GetOutletLicensesResponse
     */
    result?: OutletLicensesResponseDTO;
}

/**
 * Ответ на запрос информации о точке продаж.
 * @export
 */
export type GetOutletResponse = {
    /**
     * 
     * @type {FullOutletDTO}
     * @memberof GetOutletResponse
     */
    outlet?: FullOutletDTO;
}

/**
 * Ответ на запрос информации о точках продаж.
 * @export
 */
export type GetOutletsResponse = {
    /**
     * Информация о точках продаж.
     * @type {Array<FullOutletDTO>}
     * @memberof GetOutletsResponse
     */
    outlets: Array<FullOutletDTO>;
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof GetOutletsResponse
     */
    paging?: ScrollingPagerDTO;
    /**
     * 
     * @type {FlippingPagerDTO}
     * @memberof GetOutletsResponse
     */
    pager?: FlippingPagerDTO;
}

/**
 * Цена с указанием времени последнего обновления.
 * @export
 */
export type GetPriceDTO = {
    /**
     * Значение.
     * @type {number}
     * @memberof GetPriceDTO
     */
    value: number;
    /**
     * 
     * @type {CurrencyType}
     * @memberof GetPriceDTO
     */
    currencyId: CurrencyType;
    /**
     * Время последнего обновления.
     * @type {Date}
     * @memberof GetPriceDTO
     */
    updatedAt: Date;
}

/**
 * Цена с указанием скидки и времени последнего обновления.
 * @export
 */
export type GetPriceWithDiscountDTO = {
    /**
     * Значение.
     * @type {number}
     * @memberof GetPriceWithDiscountDTO
     */
    value: number;
    /**
     * 
     * @type {CurrencyType}
     * @memberof GetPriceWithDiscountDTO
     */
    currencyId: CurrencyType;
    /**
     * Цена до скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
     * @type {number}
     * @memberof GetPriceWithDiscountDTO
     */
    discountBase?: number;
    /**
     * Время последнего обновления.
     * @type {Date}
     * @memberof GetPriceWithDiscountDTO
     */
    updatedAt: Date;
}

/**
 * Цена с указанием ставки НДС и времени последнего обновления.
 * @export
 */
export type GetPriceWithVatDTO = {
    /**
     * Цена на товар.
     * @type {number}
     * @memberof GetPriceWithVatDTO
     */
    value?: number;
    /**
     * Цена на товар без скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
     * @type {number}
     * @memberof GetPriceWithVatDTO
     */
    discountBase?: number;
    /**
     * 
     * @type {CurrencyType}
     * @memberof GetPriceWithVatDTO
     */
    currencyId?: CurrencyType;
    /**
     * Идентификатор ставки НДС, применяемой для товара:  * `2` — 10%. * `5` — 0%. * `6` — не облагается НДС. * `7` — 20%.  Если параметр не указан, используется ставка НДС, установленная в кабинете. 
     * @type {number}
     * @memberof GetPriceWithVatDTO
     */
    vat?: number;
    /**
     * Время последнего обновления.
     * @type {Date}
     * @memberof GetPriceWithVatDTO
     */
    updatedAt: Date;
}

/**
 * Запрос списка цен.
 * @export
 */
export type GetPricesByOfferIdsRequest = {
    /**
     * Список SKU.  {% note warning \"Такой список возвращается только целиком\" %}  Если вы запрашиваете информацию по конкретным SKU, не заполняйте:  * `page_token` * `limit`  {% endnote %}    
     * @type {Array<string>}
     * @memberof GetPricesByOfferIdsRequest
     */
    offerIds?: Array<string>;
}

/**
 * Ответ на запрос списка цен.
 * @export
 */
export type GetPricesByOfferIdsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetPricesByOfferIdsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OfferPriceByOfferIdsListResponseDTO}
     * @memberof GetPricesByOfferIdsResponse
     */
    result?: OfferPriceByOfferIdsListResponseDTO;
}

/**
 * Ответ на запрос списка цен.
 * @export
 */
export type GetPricesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetPricesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OfferPriceListResponseDTO}
     * @memberof GetPricesResponse
     */
    result?: OfferPriceListResponseDTO;
}

/**
 * Информация о товарах в акции.
 * @export
 */
export type GetPromoAssortmentInfoDTO = {
    /**
     * Количество товаров, которые участвуют или участвовали в акции.  Учитываются только товары, которые были добавлены вручную.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
     * @type {number}
     * @memberof GetPromoAssortmentInfoDTO
     */
    activeOffers: number;
    /**
     * Количество доступных товаров в акции.  Параметр возвращается только для текущих и будущих акций. 
     * @type {number}
     * @memberof GetPromoAssortmentInfoDTO
     */
    potentialOffers?: number;
    /**
     * Есть ли изменения в ассортименте, которые еще не применились. Сохранение изменений занимает некоторое время.  Параметр возвращается только для текущих и будущих акций. 
     * @type {boolean}
     * @memberof GetPromoAssortmentInfoDTO
     */
    processing?: boolean;
}

/**
 * Информация об акции «Бестселлеры Маркета».
 * @export
 */
export type GetPromoBestsellerInfoDTO = {
    /**
     * Является ли акция «Бестселлером Маркета». Подробнее об этой акции читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/bestsellers).
     * @type {boolean}
     * @memberof GetPromoBestsellerInfoDTO
     */
    bestseller: boolean;
    /**
     * До какой даты можно добавить товар в акцию «Бестселлеры Маркета».  Параметр возвращается только для текущих и будущих акций «Бестселлеры Маркета». 
     * @type {Date}
     * @memberof GetPromoBestsellerInfoDTO
     */
    entryDeadline?: Date;
}

/**
 * Ограничения в акции.
 * @export
 */
export type GetPromoConstraintsDTO = {
    /**
     * Идентификаторы складов, для которых действует акция. Товары, которые лежат на других складах, не будут продаваться по акции.  Параметр возвращается, только если в условиях акции есть ограничение по складу. 
     * @type {Array<number>}
     * @memberof GetPromoConstraintsDTO
     */
    warehouseIds?: Array<number>;
}

/**
 * Информация об акции.
 * @export
 */
export type GetPromoDTO = {
    /**
     * Идентификатор акции.
     * @type {string}
     * @memberof GetPromoDTO
     */
    id: string;
    /**
     * Название акции.
     * @type {string}
     * @memberof GetPromoDTO
     */
    name: string;
    /**
     * 
     * @type {PromoPeriodDTO}
     * @memberof GetPromoDTO
     */
    period: PromoPeriodDTO;
    /**
     * Участвует или участвовал ли продавец в этой акции.  Для текущих и будущих акций возвращается со значением `true`, если в акции есть товары, которые были добавлены вручную. Если товары не участвуют в акции или добавлены в нее автоматически, параметр возвращается со значением `false`.  Для прошедших акций всегда возвращается со значением `true`.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
     * @type {boolean}
     * @memberof GetPromoDTO
     */
    participating: boolean;
    /**
     * 
     * @type {GetPromoAssortmentInfoDTO}
     * @memberof GetPromoDTO
     */
    assortmentInfo: GetPromoAssortmentInfoDTO;
    /**
     * 
     * @type {GetPromoMechanicsInfoDTO}
     * @memberof GetPromoDTO
     */
    mechanicsInfo: GetPromoMechanicsInfoDTO;
    /**
     * 
     * @type {GetPromoBestsellerInfoDTO}
     * @memberof GetPromoDTO
     */
    bestsellerInfo: GetPromoBestsellerInfoDTO;
    /**
     * Список каналов продвижения товаров.
     * @type {Array<ChannelType>}
     * @memberof GetPromoDTO
     */
    channels?: Array<ChannelType>;
    /**
     * 
     * @type {GetPromoConstraintsDTO}
     * @memberof GetPromoDTO
     */
    constraints?: GetPromoConstraintsDTO;
}

/**
 * Информация о типе акции.
 * @export
 */
export type GetPromoMechanicsInfoDTO = {
    /**
     * 
     * @type {MechanicsType}
     * @memberof GetPromoMechanicsInfoDTO
     */
    type: MechanicsType;
    /**
     * 
     * @type {GetPromoPromocodeInfoDTO}
     * @memberof GetPromoMechanicsInfoDTO
     */
    promocodeInfo?: GetPromoPromocodeInfoDTO;
}

/**
 * Товар, который участвует или может участвовать в акции.
 * @export
 */
export type GetPromoOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof GetPromoOfferDTO
     */
    offerId: string;
    /**
     * 
     * @type {PromoOfferParticipationStatusType}
     * @memberof GetPromoOfferDTO
     */
    status: PromoOfferParticipationStatusType;
    /**
     * 
     * @type {PromoOfferParamsDTO}
     * @memberof GetPromoOfferDTO
     */
    params: PromoOfferParamsDTO;
    /**
     * 
     * @type {PromoOfferAutoParticipatingDetailsDTO}
     * @memberof GetPromoOfferDTO
     */
    autoParticipatingDetails?: PromoOfferAutoParticipatingDetailsDTO;
}

/**
 * Получение списка товаров, которые участвуют или могут участвовать в акции.
 * @export
 */
export type GetPromoOffersRequest = {
    /**
     * Идентификатор акции.
     * @type {string}
     * @memberof GetPromoOffersRequest
     */
    promoId: string;
    /**
     * 
     * @type {PromoOfferParticipationStatusFilterType}
     * @memberof GetPromoOffersRequest
     */
    statusType?: PromoOfferParticipationStatusFilterType;
}

/**
 * 
 * @export
 */
export type GetPromoOffersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetPromoOffersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetPromoOffersResultDTO}
     * @memberof GetPromoOffersResponse
     */
    result?: GetPromoOffersResultDTO;
}

/**
 * Список товаров, которые участвуют или могут участвовать в акции.
 * @export
 */
export type GetPromoOffersResultDTO = {
    /**
     * Товары, которые участвуют или могут участвовать в акции.
     * @type {Array<GetPromoOfferDTO>}
     * @memberof GetPromoOffersResultDTO
     */
    offers: Array<GetPromoOfferDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof GetPromoOffersResultDTO
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Информация для типа `MARKET_PROMOCODE`.  Параметр заполняется только для этого типа акции. 
 * @export
 */
export type GetPromoPromocodeInfoDTO = {
    /**
     * Промокод.
     * @type {string}
     * @memberof GetPromoPromocodeInfoDTO
     */
    promocode: string;
    /**
     * Процент скидки по промокоду.
     * @type {number}
     * @memberof GetPromoPromocodeInfoDTO
     */
    discount: number;
}

/**
 * Фильтры для получения списка акций.
 * @export
 */
export type GetPromosRequest = {
    /**
     * 
     * @type {PromoParticipationType}
     * @memberof GetPromosRequest
     */
    participation?: PromoParticipationType;
    /**
     * 
     * @type {MechanicsType}
     * @memberof GetPromosRequest
     */
    mechanics?: MechanicsType;
}

/**
 * 
 * @export
 */
export type GetPromosResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetPromosResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetPromosResultDTO}
     * @memberof GetPromosResponse
     */
    result?: GetPromosResultDTO;
}

/**
 * Информация об акциях Маркета.
 * @export
 */
export type GetPromosResultDTO = {
    /**
     * Акции Маркета.
     * @type {Array<GetPromoDTO>}
     * @memberof GetPromosResultDTO
     */
    promos: Array<GetPromoDTO>;
}

/**
 * 
 * @export
 */
export type GetQualityRatingDetailsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetQualityRatingDetailsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {QualityRatingDetailsDTO}
     * @memberof GetQualityRatingDetailsResponse
     */
    result?: QualityRatingDetailsDTO;
}

/**
 * Запрос информации по индексу качества.
 * @export
 */
export type GetQualityRatingRequest = {
    /**
     * Начало периода.  Формат даты: `ГГГГ‑ММ‑ДД`.  Не может быть раньше 30 дней от текущей даты. 
     * @type {Date}
     * @memberof GetQualityRatingRequest
     */
    dateFrom?: Date;
    /**
     * Конец периода.  Формат даты: `ГГГГ‑ММ‑ДД`.  Не может быть позже текущей даты. 
     * @type {Date}
     * @memberof GetQualityRatingRequest
     */
    dateTo?: Date;
    /**
     * Список идентификаторов магазинов.
     * @type {Set<number>}
     * @memberof GetQualityRatingRequest
     */
    campaignIds: Set<number>;
}

/**
 * Информация об индексе качества магазинов.
 * @export
 */
export type GetQualityRatingResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetQualityRatingResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {CampaignsQualityRatingDTO}
     * @memberof GetQualityRatingResponse
     */
    result?: CampaignsQualityRatingDTO;
}

/**
 * Фильтрации товаров  В запросе можно указать либо фильтр offerIds, либо любые другие фильтры товаров. Совместное использование фильтра offerIds с другими фильтрациями приведет к ошибке. 
 * @export
 */
export type GetQuarantineOffersRequest = {
    /**
     * Идентификаторы товаров, информация о которых нужна. <br><br> ⚠️ Не используйте это поле одновременно с фильтрами по статусам карточек, категориям, брендам или тегам. Если вы хотите воспользоваться фильтрами, оставьте поле пустым. 
     * @type {Array<string>}
     * @memberof GetQuarantineOffersRequest
     */
    offerIds?: Array<string>;
    /**
     * Фильтр по статусам карточек.  [Что такое карточка товара](https://yandex.ru/support/marketplace/assortment/content/index.html) 
     * @type {Array<OfferCardStatusType>}
     * @memberof GetQuarantineOffersRequest
     */
    cardStatuses?: Array<OfferCardStatusType>;
    /**
     * Фильтр по категориям на Маркете.
     * @type {Array<number>}
     * @memberof GetQuarantineOffersRequest
     */
    categoryIds?: Array<number>;
    /**
     * Фильтр по брендам.
     * @type {Array<string>}
     * @memberof GetQuarantineOffersRequest
     */
    vendorNames?: Array<string>;
    /**
     * Фильтр по тегам.
     * @type {Array<string>}
     * @memberof GetQuarantineOffersRequest
     */
    tags?: Array<string>;
}

/**
 * Ответ на запрос списка товаров в карантине.
 * @export
 */
export type GetQuarantineOffersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetQuarantineOffersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetQuarantineOffersResultDTO}
     * @memberof GetQuarantineOffersResponse
     */
    result?: GetQuarantineOffersResultDTO;
}

/**
 * Список товаров в карантине.
 * @export
 */
export type GetQuarantineOffersResultDTO = {
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof GetQuarantineOffersResultDTO
     */
    paging?: ScrollingPagerDTO;
    /**
     * Страница списка товаров в карантине.
     * @type {Array<QuarantineOfferDTO>}
     * @memberof GetQuarantineOffersResultDTO
     */
    offers: Array<QuarantineOfferDTO>;
}

/**
 * 
 * @export
 */
export type GetRegionWithChildrenResponse = {
    /**
     * 
     * @type {FlippingPagerDTO}
     * @memberof GetRegionWithChildrenResponse
     */
    pager?: FlippingPagerDTO;
    /**
     * 
     * @type {RegionDTO}
     * @memberof GetRegionWithChildrenResponse
     */
    regions?: RegionDTO;
}

/**
 * 
 * @export
 */
export type GetRegionsResponse = {
    /**
     * Регион доставки.
     * @type {Array<RegionDTO>}
     * @memberof GetRegionsResponse
     */
    regions: Array<RegionDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof GetRegionsResponse
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Ответ на запрос информации об отчете.
 * @export
 */
export type GetReportInfoResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetReportInfoResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {ReportInfoDTO}
     * @memberof GetReportInfoResponse
     */
    result?: ReportInfoDTO;
}

/**
 * 
 * @export
 */
export type GetReturnResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetReturnResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {ReturnDTO}
     * @memberof GetReturnResponse
     */
    result?: ReturnDTO;
}

/**
 * 
 * @export
 */
export type GetReturnsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetReturnsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {PagedReturnsDTO}
     * @memberof GetReturnsResponse
     */
    result?: PagedReturnsDTO;
}

/**
 * 
 * @export
 */
export type GetShipmentOrdersInfoResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetShipmentOrdersInfoResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OrdersShipmentInfoDTO}
     * @memberof GetShipmentOrdersInfoResponse
     */
    result?: OrdersShipmentInfoDTO;
}

/**
 * 
 * @export
 */
export type GetShipmentResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetShipmentResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {ShipmentDTO}
     * @memberof GetShipmentResponse
     */
    result?: ShipmentDTO;
}

/**
 * Запрос рекомендованных карточек товара.
 * @export
 */
export type GetSuggestedOfferMappingEntriesRequest = {
    /**
     * Список товаров.
     * @type {Array<MappingsOfferDTO>}
     * @memberof GetSuggestedOfferMappingEntriesRequest
     */
    offers: Array<MappingsOfferDTO>;
}

/**
 * Ответ со списком рекомендованных карточек товара.
 * @export
 */
export type GetSuggestedOfferMappingEntriesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetSuggestedOfferMappingEntriesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OfferMappingSuggestionsListDTO}
     * @memberof GetSuggestedOfferMappingEntriesResponse
     */
    result?: OfferMappingSuggestionsListDTO;
}

/**
 * 
 * @export
 */
export type GetSuggestedOfferMappingsRequest = {
    /**
     * Список товаров.
     * @type {Array<SuggestedOfferDTO>}
     * @memberof GetSuggestedOfferMappingsRequest
     */
    offers?: Array<SuggestedOfferDTO>;
}

/**
 * 
 * @export
 */
export type GetSuggestedOfferMappingsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetSuggestedOfferMappingsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetSuggestedOfferMappingsResultDTO}
     * @memberof GetSuggestedOfferMappingsResponse
     */
    result?: GetSuggestedOfferMappingsResultDTO;
}

/**
 * Подобранные карточки на Маркете.
 * @export
 */
export type GetSuggestedOfferMappingsResultDTO = {
    /**
     * Список товаров.
     * @type {Array<SuggestedOfferMappingDTO>}
     * @memberof GetSuggestedOfferMappingsResultDTO
     */
    offers: Array<SuggestedOfferMappingDTO>;
}

/**
 * Список складов с информацией об остатках на каждом из них.
 * @export
 */
export type GetWarehouseStocksDTO = {
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof GetWarehouseStocksDTO
     */
    paging?: ScrollingPagerDTO;
    /**
     * Страница списка складов.
     * @type {Array<WarehouseOffersDTO>}
     * @memberof GetWarehouseStocksDTO
     */
    warehouses: Array<WarehouseOffersDTO>;
}

/**
 * Фильтры для запроса остатков. 
 * @export
 */
export type GetWarehouseStocksRequest = {
    /**
     * **Только для модели FBY**  Возвращать ли информацию по оборачиваемости.  Значение по умолчанию — `false`. Если информация нужна, передайте значение `true`. 
     * @type {boolean}
     * @memberof GetWarehouseStocksRequest
     */
    withTurnover?: boolean;
    /**
     * Фильтр по нахождению в архиве.  Передайте `true`, чтобы получить информацию об остатках товаров, которые находятся в архиве. Если фильтр не заполнен или передано `false`, в ответе возвращается информация о товарах, которые не находятся в архиве. 
     * @type {boolean}
     * @memberof GetWarehouseStocksRequest
     */
    archived?: boolean;
    /**
     * Фильтр по вашим SKU товаров.  Возвращается информация об остатках всех переданных SKU, включая товары в архиве.  {% note warning \"Такой список возвращается только целиком\" %}  Если вы запрашиваете информацию по конкретным SKU, не заполняйте:  * `page_token` * `limit` * `archived`  {% endnote %}    
     * @type {Set<string>}
     * @memberof GetWarehouseStocksRequest
     */
    offerIds?: Set<string>;
}

/**
 * 
 * @export
 */
export type GetWarehouseStocksResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetWarehouseStocksResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GetWarehouseStocksDTO}
     * @memberof GetWarehouseStocksResponse
     */
    result?: GetWarehouseStocksDTO;
}

/**
 * 
 * @export
 */
export type GetWarehousesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof GetWarehousesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {WarehousesDTO}
     * @memberof GetWarehousesResponse
     */
    result?: WarehousesDTO;
}

/**
 * Информация об авторе комментария.
 * @export
 */
export type GoodsFeedbackCommentAuthorDTO = {
    /**
     * 
     * @type {GoodsFeedbackCommentAuthorType}
     * @memberof GoodsFeedbackCommentAuthorDTO
     */
    type?: GoodsFeedbackCommentAuthorType;
    /**
     * Имя автора или название кабинета.
     * @type {string}
     * @memberof GoodsFeedbackCommentAuthorDTO
     */
    name?: string;
}

/**
 * Тип автора:  * `USER` — пользователь. * `BUSINESS` — кабинет. 
 * @export
 * @enum {string}
 */
export type GoodsFeedbackCommentAuthorType = 'USER' | 'BUSINESS';

/**
 * Комментарий к отзыву.
 * @export
 */
export type GoodsFeedbackCommentDTO = {
    /**
     * Идентификатор комментария к отзыву. 
     * @type {number}
     * @memberof GoodsFeedbackCommentDTO
     */
    id: number;
    /**
     * Текст комментария.
     * @type {string}
     * @memberof GoodsFeedbackCommentDTO
     */
    text: string;
    /**
     * Может ли продавец изменять комментарий или удалять его.
     * @type {boolean}
     * @memberof GoodsFeedbackCommentDTO
     */
    canModify?: boolean;
    /**
     * Идентификатор комментария к отзыву. 
     * @type {number}
     * @memberof GoodsFeedbackCommentDTO
     */
    parentId?: number;
    /**
     * 
     * @type {GoodsFeedbackCommentAuthorDTO}
     * @memberof GoodsFeedbackCommentDTO
     */
    author: GoodsFeedbackCommentAuthorDTO;
    /**
     * 
     * @type {GoodsFeedbackCommentStatusType}
     * @memberof GoodsFeedbackCommentDTO
     */
    status: GoodsFeedbackCommentStatusType;
}

/**
 * Комментарии к отзыву.
 * @export
 */
export type GoodsFeedbackCommentListDTO = {
    /**
     * Список комментариев.
     * @type {Array<GoodsFeedbackCommentDTO>}
     * @memberof GoodsFeedbackCommentListDTO
     */
    comments: Array<GoodsFeedbackCommentDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof GoodsFeedbackCommentListDTO
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Статус комментария:  * `PUBLISHED` — опубликован. * `UNMODERATED` — не проверен. * `BANNED` — заблокирован. * `DELETED` — удален. 
 * @export
 * @enum {string}
 */
export type GoodsFeedbackCommentStatusType = 'PUBLISHED' | 'UNMODERATED' | 'BANNED' | 'DELETED';

/**
 * Отзыв о товаре.
 * @export
 */
export type GoodsFeedbackDTO = {
    /**
     * Идентификатор отзыва. 
     * @type {number}
     * @memberof GoodsFeedbackDTO
     */
    feedbackId: number;
    /**
     * Дата и время создания отзыва.
     * @type {Date}
     * @memberof GoodsFeedbackDTO
     */
    createdAt: Date;
    /**
     * Нужен ли ответ на отзыв.
     * @type {boolean}
     * @memberof GoodsFeedbackDTO
     */
    needReaction: boolean;
    /**
     * 
     * @type {GoodsFeedbackIdentifiersDTO}
     * @memberof GoodsFeedbackDTO
     */
    identifiers: GoodsFeedbackIdentifiersDTO;
    /**
     * Имя автора отзыва.
     * @type {string}
     * @memberof GoodsFeedbackDTO
     */
    author?: string;
    /**
     * 
     * @type {GoodsFeedbackDescriptionDTO}
     * @memberof GoodsFeedbackDTO
     */
    description?: GoodsFeedbackDescriptionDTO;
    /**
     * 
     * @type {GoodsFeedbackMediaDTO}
     * @memberof GoodsFeedbackDTO
     */
    media?: GoodsFeedbackMediaDTO;
    /**
     * 
     * @type {GoodsFeedbackStatisticsDTO}
     * @memberof GoodsFeedbackDTO
     */
    statistics: GoodsFeedbackStatisticsDTO;
}

/**
 * Текстовая часть отзыва.
 * @export
 */
export type GoodsFeedbackDescriptionDTO = {
    /**
     * Описание плюсов товара в отзыве.
     * @type {string}
     * @memberof GoodsFeedbackDescriptionDTO
     */
    advantages?: string;
    /**
     * Описание минусов товара в отзыве.
     * @type {string}
     * @memberof GoodsFeedbackDescriptionDTO
     */
    disadvantages?: string;
    /**
     * Комментарий в отзыве.
     * @type {string}
     * @memberof GoodsFeedbackDescriptionDTO
     */
    comment?: string;
}

/**
 * Идентификаторы, которые связаны с отзывом.
 * @export
 */
export type GoodsFeedbackIdentifiersDTO = {
    /**
     * Идентификатор заказа на Маркете.
     * @type {number}
     * @memberof GoodsFeedbackIdentifiersDTO
     */
    orderId: number;
    /**
     * Идентификатор модели товара.
     * @type {number}
     * @memberof GoodsFeedbackIdentifiersDTO
     */
    modelId: number;
}

/**
 * Список отзывов о товарах. 
 * @export
 */
export type GoodsFeedbackListDTO = {
    /**
     * Список отзывов.
     * @type {Array<GoodsFeedbackDTO>}
     * @memberof GoodsFeedbackListDTO
     */
    feedbacks: Array<GoodsFeedbackDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof GoodsFeedbackListDTO
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Фото и видео.
 * @export
 */
export type GoodsFeedbackMediaDTO = {
    /**
     * Ссылки на фото.
     * @type {Array<string>}
     * @memberof GoodsFeedbackMediaDTO
     */
    photos?: Array<string>;
    /**
     * Ссылки на видео.
     * @type {Array<string>}
     * @memberof GoodsFeedbackMediaDTO
     */
    videos?: Array<string>;
}

/**
 * Статистическая информация по отзыву.
 * @export
 */
export type GoodsFeedbackStatisticsDTO = {
    /**
     * Оценка товара.
     * @type {number}
     * @memberof GoodsFeedbackStatisticsDTO
     */
    rating: number;
    /**
     * Количество комментариев к отзыву.  Учитываются только ответы на отзывы, а не дочерние комментарии. 
     * @type {number}
     * @memberof GoodsFeedbackStatisticsDTO
     */
    commentsCount: number;
    /**
     * Рекомендуют ли этот товар.
     * @type {boolean}
     * @memberof GoodsFeedbackStatisticsDTO
     */
    recommended?: boolean;
    /**
     * Количество баллов Плюса, которое автор получил за отзыв.
     * @type {number}
     * @memberof GoodsFeedbackStatisticsDTO
     */
    paidAmount?: number;
}

/**
 * Отчет по товарам.
 * @export
 */
export type GoodsStatsDTO = {
    /**
     * Список товаров.
     * @type {Array<GoodsStatsGoodsDTO>}
     * @memberof GoodsStatsDTO
     */
    shopSkus: Array<GoodsStatsGoodsDTO>;
}

/**
 * Информация о товаре.
 * @export
 */
export type GoodsStatsGoodsDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof GoodsStatsGoodsDTO
     */
    shopSku?: string;
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof GoodsStatsGoodsDTO
     */
    marketSku?: number;
    /**
     * Название товара.
     * @type {string}
     * @memberof GoodsStatsGoodsDTO
     */
    name?: string;
    /**
     * Цена на товар в валюте, которая установлена [в кабинете продавца на Маркете](https://partner.market.yandex.ru/).
     * @type {number}
     * @memberof GoodsStatsGoodsDTO
     */
    price?: number;
    /**
     * Идентификатор категории товара на Маркете.
     * @type {number}
     * @memberof GoodsStatsGoodsDTO
     */
    categoryId?: number;
    /**
     * Название категории товара на Маркете.
     * @type {string}
     * @memberof GoodsStatsGoodsDTO
     */
    categoryName?: string;
    /**
     * 
     * @type {GoodsStatsWeightDimensionsDTO}
     * @memberof GoodsStatsGoodsDTO
     */
    weightDimensions?: GoodsStatsWeightDimensionsDTO;
    /**
     * Информация о складах, на которых хранится товар.  Параметр не приходит, если товара нет ни на одном складе. 
     * @type {Array<GoodsStatsWarehouseDTO>}
     * @memberof GoodsStatsGoodsDTO
     */
    warehouses?: Array<GoodsStatsWarehouseDTO>;
    /**
     * Информация о тарифах, по которым нужно заплатить за услуги Маркета.  По некоторым услугам могут возвращаться несколько разных стоимостей. Например, в модели FBS стоимость услуги `SORTING` (обработка заказа) зависит от способа отгрузки и количества заказов в отгрузке. Подробнее о тарифах на услуги читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/introduction/rates/models/). 
     * @type {Array<TariffDTO>}
     * @memberof GoodsStatsGoodsDTO
     */
    tariffs?: Array<TariffDTO>;
    /**
     * Ссылки (URL) изображений товара в хорошем качестве.
     * @type {Array<string>}
     * @memberof GoodsStatsGoodsDTO
     */
    pictures?: Array<string>;
}

/**
 * Информация о складе.
 * @export
 */
export type GoodsStatsWarehouseDTO = {
    /**
     * Идентификатор склада.
     * @type {number}
     * @memberof GoodsStatsWarehouseDTO
     */
    id?: number;
    /**
     * Название склада.
     * @type {string}
     * @memberof GoodsStatsWarehouseDTO
     */
    name?: string;
    /**
     * Информация об остатках товаров на складе.
     * @type {Array<WarehouseStockDTO>}
     * @memberof GoodsStatsWarehouseDTO
     */
    stocks: Array<WarehouseStockDTO>;
}

/**
 * Информация о весе и габаритах товара.  Если товар уже привязан к карточке (`marketSku`), в ответе вернутся габариты из карточки Маркета, а не размеры, которые вы передаете. 
 * @export
 */
export type GoodsStatsWeightDimensionsDTO = {
    /**
     * Длина товара в сантиметрах.
     * @type {number}
     * @memberof GoodsStatsWeightDimensionsDTO
     */
    length?: number;
    /**
     * Ширина товара в сантиметрах.
     * @type {number}
     * @memberof GoodsStatsWeightDimensionsDTO
     */
    width?: number;
    /**
     * Высота товара в сантиметрах.
     * @type {number}
     * @memberof GoodsStatsWeightDimensionsDTO
     */
    height?: number;
    /**
     * Вес товара в килограммах.
     * @type {number}
     * @memberof GoodsStatsWeightDimensionsDTO
     */
    weight?: number;
}

/**
 * GPS-координаты широты и долготы. 
 * @export
 */
export type GpsDTO = {
    /**
     * Широта.
     * @type {number}
     * @memberof GpsDTO
     */
    latitude: number;
    /**
     * Долгота.
     * @type {number}
     * @memberof GpsDTO
     */
    longitude: number;
}

/**
 * Информация о скрытии.
 * @export
 */
export type HiddenOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof HiddenOfferDTO
     */
    offerId: string;
}

/**
 * Язык:  * `RU` — русский.  * `EN` — английский. 
 * @export
 * @enum {string}
 */
export type LanguageType = 'RU' | 'EN';

/**
 * Статус проверки лицензии:  * `NEW` — лицензия проверяется. * `SUCCESS` — лицензия прошла проверку. * `FAIL` — лицензия не прошла проверку. 
 * @export
 * @enum {string}
 */
export type LicenseCheckStatusType = 'NEW' | 'SUCCESS' | 'FAIL' | 'REVOKE' | 'DONT_WANT' | 'FAIL_MANUAL';

/**
 * Тип лицензии:  * `ALCOHOL` — лицензия на розничную продажу алкогольной продукции. 
 * @export
 * @enum {string}
 */
export type LicenseType = 'ALCOHOL' | 'UNKNOWN';

/**
 * Описание пункта вывоза для возврата.
 * @export
 */
export type LogisticPickupPointDTO = {
    /**
     * Идентификатор пункта вывоза.
     * @type {number}
     * @memberof LogisticPickupPointDTO
     */
    id?: number;
    /**
     * Название пункта вывоза.
     * @type {string}
     * @memberof LogisticPickupPointDTO
     */
    name?: string;
    /**
     * 
     * @type {PickupAddressDTO}
     * @memberof LogisticPickupPointDTO
     */
    address?: PickupAddressDTO;
    /**
     * Дополнительные инструкции к вывозу.
     * @type {string}
     * @memberof LogisticPickupPointDTO
     */
    instruction?: string;
    /**
     * 
     * @type {LogisticPointType}
     * @memberof LogisticPickupPointDTO
     */
    type?: LogisticPointType;
    /**
     * Идентификатор логистического партнера, к которому относится логистическая точка.
     * @type {number}
     * @memberof LogisticPickupPointDTO
     */
    logisticPartnerId?: number;
}

/**
 * Тип логистической точки:    * `WAREHOUSE` — склад.   * `PICKUP_POINT` — обычная точка выдачи заказов (ПВЗ).   * `PICKUP_TERMINAL` — постамат.   * `PICKUP_POST_OFFICE` — отделение почтовой связи (ОПС).   * `PICKUP_MIXED` — торговый зал и пункт выдачи заказов.   * `PICKUP_RETAIL` — торговый зал. 
 * @export
 * @enum {string}
 */
export type LogisticPointType = 'WAREHOUSE' | 'PICKUP_POINT' | 'PICKUP_TERMINAL' | 'PICKUP_POST_OFFICE' | 'PICKUP_MIXED' | 'PICKUP_RETAIL' | 'UNKNOWN';

/**
 * Информация о товарах в каталоге.
 * @export
 */
export type MappingsOfferDTO = {
    /**
     * Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
     * @type {string}
     * @memberof MappingsOfferDTO
     */
    name?: string;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof MappingsOfferDTO
     */
    shopSku?: string;
    /**
     * Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
     * @type {string}
     * @memberof MappingsOfferDTO
     */
    category?: string;
    /**
     * Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
     * @type {string}
     * @memberof MappingsOfferDTO
     */
    vendor?: string;
    /**
     * Артикул товара от производителя.
     * @type {string}
     * @memberof MappingsOfferDTO
     */
    vendorCode?: string;
    /**
     * Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
     * @type {string}
     * @memberof MappingsOfferDTO
     */
    description?: string;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof MappingsOfferDTO
     */
    id?: string;
    /**
     * Идентификатор фида.
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    feedId?: number;
    /**
     * Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
     * @type {Array<string>}
     * @memberof MappingsOfferDTO
     */
    barcodes?: Array<string>;
    /**
     * URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
     * @type {Array<string>}
     * @memberof MappingsOfferDTO
     */
    urls?: Array<string>;
    /**
     * Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр `picture`. 
     * @type {Array<string>}
     * @memberof MappingsOfferDTO
     */
    pictures?: Array<string>;
    /**
     * Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
     * @type {string}
     * @memberof MappingsOfferDTO
     */
    manufacturer?: string;
    /**
     * Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
     * @type {Array<string>}
     * @memberof MappingsOfferDTO
     */
    manufacturerCountries?: Array<string>;
    /**
     * Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    minShipment?: number;
    /**
     * Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    transportUnitSize?: number;
    /**
     * Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    quantumOfSupply?: number;
    /**
     * Срок, за который продавец поставляет товары на склад, в днях.
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    deliveryDurationDays?: number;
    /**
     * Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    boxCount?: number;
    /**
     * Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
     * @type {Array<string>}
     * @memberof MappingsOfferDTO
     */
    customsCommodityCodes?: Array<string>;
    /**
     * 
     * @type {OfferWeightDimensionsDTO}
     * @memberof MappingsOfferDTO
     */
    weightDimensions?: OfferWeightDimensionsDTO;
    /**
     * Дни недели, в которые продавец поставляет товары на склад.
     * @type {Array<DayOfWeekType>}
     * @memberof MappingsOfferDTO
     */
    supplyScheduleDays?: Array<DayOfWeekType>;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `shelfLife`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    shelfLifeDays?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `lifeTime`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    lifeTimeDays?: number;
    /**
     * Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    guaranteePeriodDays?: number;
    /**
     * 
     * @type {OfferProcessingStateDTO}
     * @memberof MappingsOfferDTO
     */
    processingState?: OfferProcessingStateDTO;
    /**
     * 
     * @type {OfferAvailabilityStatusType}
     * @memberof MappingsOfferDTO
     */
    availability?: OfferAvailabilityStatusType;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof MappingsOfferDTO
     */
    shelfLife?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof MappingsOfferDTO
     */
    lifeTime?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof MappingsOfferDTO
     */
    guaranteePeriod?: TimePeriodDTO;
    /**
     * Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
     * @type {string}
     * @memberof MappingsOfferDTO
     */
    certificate?: string;
    /**
     * Цена на товар в рублях.
     * @type {number}
     * @memberof MappingsOfferDTO
     */
    price?: number;
}

/**
 * Базовая информация о товарах в каталоге.
 * @export
 */
export type MappingsOfferInfoDTO = {
    /**
     * Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
     * @type {string}
     * @memberof MappingsOfferInfoDTO
     */
    name?: string;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof MappingsOfferInfoDTO
     */
    shopSku?: string;
    /**
     * Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
     * @type {string}
     * @memberof MappingsOfferInfoDTO
     */
    category?: string;
    /**
     * Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
     * @type {string}
     * @memberof MappingsOfferInfoDTO
     */
    vendor?: string;
    /**
     * Артикул товара от производителя.
     * @type {string}
     * @memberof MappingsOfferInfoDTO
     */
    vendorCode?: string;
    /**
     * Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
     * @type {string}
     * @memberof MappingsOfferInfoDTO
     */
    description?: string;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof MappingsOfferInfoDTO
     */
    id?: string;
    /**
     * Идентификатор фида.
     * @type {number}
     * @memberof MappingsOfferInfoDTO
     */
    feedId?: number;
    /**
     * Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
     * @type {Array<string>}
     * @memberof MappingsOfferInfoDTO
     */
    barcodes?: Array<string>;
    /**
     * URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
     * @type {Array<string>}
     * @memberof MappingsOfferInfoDTO
     */
    urls?: Array<string>;
    /**
     * Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр `picture`. 
     * @type {Array<string>}
     * @memberof MappingsOfferInfoDTO
     */
    pictures?: Array<string>;
    /**
     * Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
     * @type {string}
     * @memberof MappingsOfferInfoDTO
     */
    manufacturer?: string;
    /**
     * Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
     * @type {Array<string>}
     * @memberof MappingsOfferInfoDTO
     */
    manufacturerCountries?: Array<string>;
    /**
     * Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
     * @type {number}
     * @memberof MappingsOfferInfoDTO
     */
    minShipment?: number;
    /**
     * Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
     * @type {number}
     * @memberof MappingsOfferInfoDTO
     */
    transportUnitSize?: number;
    /**
     * Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
     * @type {number}
     * @memberof MappingsOfferInfoDTO
     */
    quantumOfSupply?: number;
    /**
     * Срок, за который продавец поставляет товары на склад, в днях.
     * @type {number}
     * @memberof MappingsOfferInfoDTO
     */
    deliveryDurationDays?: number;
    /**
     * Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
     * @type {number}
     * @memberof MappingsOfferInfoDTO
     */
    boxCount?: number;
    /**
     * Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
     * @type {Array<string>}
     * @memberof MappingsOfferInfoDTO
     */
    customsCommodityCodes?: Array<string>;
    /**
     * 
     * @type {OfferWeightDimensionsDTO}
     * @memberof MappingsOfferInfoDTO
     */
    weightDimensions?: OfferWeightDimensionsDTO;
    /**
     * Дни недели, в которые продавец поставляет товары на склад.
     * @type {Array<DayOfWeekType>}
     * @memberof MappingsOfferInfoDTO
     */
    supplyScheduleDays?: Array<DayOfWeekType>;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `shelfLife`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
     * @type {number}
     * @memberof MappingsOfferInfoDTO
     */
    shelfLifeDays?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `lifeTime`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
     * @type {number}
     * @memberof MappingsOfferInfoDTO
     */
    lifeTimeDays?: number;
    /**
     * Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
     * @type {number}
     * @memberof MappingsOfferInfoDTO
     */
    guaranteePeriodDays?: number;
    /**
     * 
     * @type {OfferProcessingStateDTO}
     * @memberof MappingsOfferInfoDTO
     */
    processingState?: OfferProcessingStateDTO;
    /**
     * 
     * @type {OfferAvailabilityStatusType}
     * @memberof MappingsOfferInfoDTO
     */
    availability?: OfferAvailabilityStatusType;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof MappingsOfferInfoDTO
     */
    shelfLife?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof MappingsOfferInfoDTO
     */
    lifeTime?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof MappingsOfferInfoDTO
     */
    guaranteePeriod?: TimePeriodDTO;
    /**
     * Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
     * @type {string}
     * @memberof MappingsOfferInfoDTO
     */
    certificate?: string;
}

/**
 * Лимит на установку кванта и минимального количества товаров по категориям. 
 * @export
 */
export type MaxSaleQuantumDTO = {
    /**
     * Идентификатор категории.
     * @type {number}
     * @memberof MaxSaleQuantumDTO
     */
    id: number;
    /**
     * Название категории.
     * @type {string}
     * @memberof MaxSaleQuantumDTO
     */
    name?: string;
    /**
     * Лимит на установку кванта и минимального количества товаров.
     * @type {number}
     * @memberof MaxSaleQuantumDTO
     */
    maxSaleQuantum?: number;
}

/**
 * Тип акции:  * `DIRECT_DISCOUNT` — прямая скидка.  * `BLUE_FLASH` — флеш-акция.  * `MARKET_PROMOCODE` — скидка по промокоду. 
 * @export
 * @enum {string}
 */
export type MechanicsType = 'DIRECT_DISCOUNT' | 'BLUE_FLASH' | 'MARKET_PROMOCODE';

/**
 * Модель товара.
 * @export
 */
export type ModelDTO = {
    /**
     * Идентификатор модели товара.
     * @type {number}
     * @memberof ModelDTO
     */
    id?: number;
    /**
     * Название модели товара.
     * @type {string}
     * @memberof ModelDTO
     */
    name?: string;
    /**
     * 
     * @type {ModelPriceDTO}
     * @memberof ModelDTO
     */
    prices?: ModelPriceDTO;
}

/**
 * Информация о предложении.
 * @export
 */
export type ModelOfferDTO = {
    /**
     * Скидка на предложение в процентах.
     * @type {number}
     * @memberof ModelOfferDTO
     */
    discount?: number;
    /**
     * Наименование предложения.
     * @type {string}
     * @memberof ModelOfferDTO
     */
    name?: string;
    /**
     * Позиция предложения в выдаче Маркета на карточке модели.
     * @type {number}
     * @memberof ModelOfferDTO
     */
    pos?: number;
    /**
     * Цена предложения без скидки магазина.
     * @type {number}
     * @memberof ModelOfferDTO
     */
    preDiscountPrice?: number;
    /**
     * Цена предложения без скидки, которую получает покупатель при оплате через Yandex Pay.
     * @type {number}
     * @memberof ModelOfferDTO
     */
    price?: number;
    /**
     * Идентификатор региона предложения (регион, откуда доставляется товар).  Сначала показываются предложения, доставляемые из региона, указанного в запросе в параметре `regionId`. Предложения, доставляемые из других регионов, показываются после них. 
     * @type {number}
     * @memberof ModelOfferDTO
     */
    regionId?: number;
    /**
     * Стоимость доставки товара в регион:  * `0` — доставка осуществляется бесплатно. * `-1` — магазин не осуществляет доставку этого товара (самовывоз).  Если стоимость доставки неизвестна, параметр не выводится. 
     * @type {number}
     * @memberof ModelOfferDTO
     */
    shippingCost?: number;
    /**
     * Название магазина (в том виде, в котором отображается на Маркете).
     * @type {string}
     * @memberof ModelOfferDTO
     */
    shopName?: string;
    /**
     * Рейтинг магазина.  Возможные значения: * `-1` — у магазинов, недавно появившихся на Маркете, рейтинг появляется не сразу. До момента появления рейтинга для таких магазинов возвращается значение `-1`. * `1`. * `2`. * `3`. * `4`. * `5`. 
     * @type {number}
     * @memberof ModelOfferDTO
     */
    shopRating?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %} 
     * @type {number}
     * @memberof ModelOfferDTO
     */
    inStock?: number;
}

/**
 * Информация о ценах на модель товара.
 * @export
 */
export type ModelPriceDTO = {
    /**
     * Средняя цена предложения для модели в регионе.
     * @type {number}
     * @memberof ModelPriceDTO
     */
    avg?: number;
    /**
     * Максимальная цена предложения для модели в регионе.
     * @type {number}
     * @memberof ModelPriceDTO
     */
    max?: number;
    /**
     * Минимальная цена предложения для модели в регионе.
     * @type {number}
     * @memberof ModelPriceDTO
     */
    min?: number;
}

/**
 * Список моделей товаров.
 * @export
 */
export type ModelsDTO = {
    /**
     * Список моделей товаров.
     * @type {Array<ModelDTO>}
     * @memberof ModelsDTO
     */
    models: Array<ModelDTO>;
}

/**
 * Планы по поставкам:  * `ACTIVE` — поставки будут. * `INACTIVE` — поставок не будет: товар есть на складе, но вы больше не планируете его поставлять. Через 60 дней после того, как товар закончится на складе, этот статус изменится на `DELISTED`. * `DELISTED` — архив: товар закончился на складе, и его поставок больше не будет. Если товар вернется на склад (например, покупатель вернет заказ), этот статус изменится на `INACTIVE`. 
 * @export
 * @enum {string}
 */
export type OfferAvailabilityStatusType = 'ACTIVE' | 'INACTIVE' | 'DELISTED';

/**
 * Статус товара в магазине.
 * @export
 */
export type OfferCampaignStatusDTO = {
    /**
     * Идентификатор кампании. 
     * @type {number}
     * @memberof OfferCampaignStatusDTO
     */
    campaignId: number;
    /**
     * 
     * @type {OfferCampaignStatusType}
     * @memberof OfferCampaignStatusDTO
     */
    status: OfferCampaignStatusType;
}

/**
 * Статус товара:  * `PUBLISHED` — Готов к продаже. * `CHECKING` — На проверке. * `DISABLED_BY_PARTNER` — Скрыт вами. * `REJECTED_BY_MARKET` — Отклонен. * `DISABLED_AUTOMATICALLY` — Исправьте ошибки. * `CREATING_CARD` — Создается карточка. * `NO_CARD` — Нужна карточка. * `NO_STOCKS` — Нет на складе. * `ARCHIVED` — В архиве.  [Что обозначает каждый из статусов](https://yandex.ru/support/marketplace/assortment/add/statuses.html) 
 * @export
 * @enum {string}
 */
export type OfferCampaignStatusType = 'PUBLISHED' | 'CHECKING' | 'DISABLED_BY_PARTNER' | 'DISABLED_AUTOMATICALLY' | 'REJECTED_BY_MARKET' | 'CREATING_CARD' | 'NO_CARD' | 'NO_STOCKS' | 'ARCHIVED';

/**
 * Информация о состоянии карточки товара.  Если поле `mapping` отсутствует в ответе, Маркет еще не успел обработать информацию о товаре. Чтобы определить категорию такого товара, повторите запрос через несколько минут. 
 * @export
 */
export type OfferCardDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof OfferCardDTO
     */
    offerId: string;
    /**
     * 
     * @type {GetMappingDTO}
     * @memberof OfferCardDTO
     */
    mapping?: GetMappingDTO;
    /**
     * Список характеристик с их значениями. 
     * @type {Array<ParameterValueDTO>}
     * @memberof OfferCardDTO
     */
    parameterValues?: Array<ParameterValueDTO>;
    /**
     * 
     * @type {OfferCardStatusType}
     * @memberof OfferCardDTO
     */
    cardStatus?: OfferCardStatusType;
    /**
     * Процент заполненности карточки.
     * @type {number}
     * @memberof OfferCardDTO
     */
    contentRating?: number;
    /**
     * Список рекомендаций к заполнению карточки.  Рекомендации Маркета помогают заполнять карточку так, чтобы покупателям было проще найти ваш товар и решиться на покупку. 
     * @type {Array<OfferCardRecommendationDTO>}
     * @memberof OfferCardDTO
     */
    recommendations?: Array<OfferCardRecommendationDTO>;
    /**
     * Ошибки в контенте, препятствующие размещению товара на витрине.
     * @type {Array<OfferErrorDTO>}
     * @memberof OfferCardDTO
     */
    errors?: Array<OfferErrorDTO>;
    /**
     * Связанные с контентом предупреждения, не препятствующие размещению товара на витрине.
     * @type {Array<OfferErrorDTO>}
     * @memberof OfferCardDTO
     */
    warnings?: Array<OfferErrorDTO>;
}

/**
 * Рекомендация по заполнению карточки товара.
 * @export
 */
export type OfferCardRecommendationDTO = {
    /**
     * 
     * @type {OfferCardRecommendationType}
     * @memberof OfferCardRecommendationDTO
     */
    type: OfferCardRecommendationType;
    /**
     * Процент выполнения рекомендации. Указывается для рекомендаций некоторых типов.
     * @type {number}
     * @memberof OfferCardRecommendationDTO
     */
    percent?: number;
}

/**
 * Рекомендация по дополнению или замене контента. Не возвращается для карточек, которые заполнены Маркетом или содержат бывшие в употреблении товары.  Часть рекомендаций относятся к **основным параметрам**, которые есть у товаров любых категорий. Другие — к тем **характеристикам**, которые есть у товара потому, что он относится к определенной категории.  **1. Рекомендации, относящиеся к основным параметрам**  Каждая такая рекомендация относится к **единственному параметру**. Чтобы заполнить этот параметр, пользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  Рекомендации по заполнению параметров в `updateOfferMappings`:  * `RECOGNIZED_VENDOR` — напишите название производителя так, как его пишет сам производитель (параметр `vendor`). * `PICTURE_COUNT` — добавьте изображения (параметр `pictures`). * `FIRST_PICTURE_SIZE` — замените первое изображение более крупным (параметр `pictures`). * `TITLE_LENGTH` — измените название (параметр `name`). Составьте название по схеме: тип + бренд или производитель + модель + особенности, если есть (размер, вес, цвет). * `DESCRIPTION_LENGTH` — добавьте описание рекомендуемого размера (параметр `description`). * `AVERAGE_PICTURE_SIZE` — замените все изображения на изображения высокого качества (параметр `pictures`). * `FIRST_VIDEO_LENGTH` — добавьте первое видео рекомендуемой длины (параметр `videos`). * `AVERAGE_VIDEO_SIZE` — замените все видео на видео высокого качества (параметр `videos`). * `VIDEO_COUNT` — добавьте больше видео (параметр `videos`).  Рекомендуемые значения параметров описаны в [Справке Яндекс Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/add/).  **2. Рекомендации, относящиеся к характеристикам по категориям**  Каждая такая рекомендация предполагает заполнение **одной или нескольких характеристик**. Чтобы узнать, какие именно характеристики нужно заполнить, воспользуйтесь запросом [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md). Например, если вы получили рекомендацию `MAIN`, нужно заполнить характеристики, имеющие `MAIN` в массиве `recommendationTypes`.  Рекомендации:  * `MAIN` — заполните ключевые характеристики товара, которые используются в поиске и фильтрах. * `ADDITIONAL` — заполните дополнительные характеристики товара. * `DISTINCTIVE` — заполните характеристики, которыми отличаются друг от друга варианты товара.  **3. Устаревшие рекомендации**  * `HAS_VIDEO`. * `FILTERABLE`. * `HAS_DESCRIPTION`. * `HAS_BARCODE`. 
 * @export
 * @enum {string}
 */
export type OfferCardRecommendationType = 'HAS_VIDEO' | 'RECOGNIZED_VENDOR' | 'MAIN' | 'ADDITIONAL' | 'DISTINCTIVE' | 'FILTERABLE' | 'PICTURE_COUNT' | 'HAS_DESCRIPTION' | 'HAS_BARCODE' | 'FIRST_PICTURE_SIZE' | 'TITLE_LENGTH' | 'DESCRIPTION_LENGTH' | 'AVERAGE_PICTURE_SIZE' | 'FIRST_VIDEO_SIZE' | 'FIRST_VIDEO_LENGTH' | 'AVERAGE_VIDEO_SIZE' | 'VIDEO_COUNT';

/**
 * Статус карточки товара:  * `HAS_CARD_CAN_NOT_UPDATE` — Карточка Маркета. * `HAS_CARD_CAN_UPDATE` — Можно дополнить. * `HAS_CARD_CAN_UPDATE_ERRORS` — Изменения не приняты. * `HAS_CARD_CAN_UPDATE_PROCESSING` — Изменения на проверке. * `NO_CARD_NEED_CONTENT` — Создайте карточку. * `NO_CARD_MARKET_WILL_CREATE` — Создаст Маркет. * `NO_CARD_ERRORS` — Не создана из-за ошибки. * `NO_CARD_PROCESSING` — Проверяем данные. * `NO_CARD_ADD_TO_CAMPAIGN` — Разместите товар в магазине.  [Что обозначает каждый из статусов](https://yandex.ru/support/marketplace/assortment/content/statuses.html) 
 * @export
 * @enum {string}
 */
export type OfferCardStatusType = 'HAS_CARD_CAN_NOT_UPDATE' | 'HAS_CARD_CAN_UPDATE' | 'HAS_CARD_CAN_UPDATE_ERRORS' | 'HAS_CARD_CAN_UPDATE_PROCESSING' | 'NO_CARD_NEED_CONTENT' | 'NO_CARD_MARKET_WILL_CREATE' | 'NO_CARD_ERRORS' | 'NO_CARD_PROCESSING' | 'NO_CARD_ADD_TO_CAMPAIGN';

/**
 * Список товаров с информацией о состоянии карточек.
 * @export
 */
export type OfferCardsContentStatusDTO = {
    /**
     * Страница списка товаров с информацией о состоянии карточек.
     * @type {Array<OfferCardDTO>}
     * @memberof OfferCardsContentStatusDTO
     */
    offerCards: Array<OfferCardDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof OfferCardsContentStatusDTO
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Состояние уцененного товара. 
 * @export
 */
export type OfferConditionDTO = {
    /**
     * 
     * @type {OfferConditionType}
     * @memberof OfferConditionDTO
     */
    type?: OfferConditionType;
    /**
     * 
     * @type {OfferConditionQualityType}
     * @memberof OfferConditionDTO
     */
    quality?: OfferConditionQualityType;
    /**
     * Описание товара. Подробно опишите дефекты, насколько они заметны и где их искать. 
     * @type {string}
     * @memberof OfferConditionDTO
     */
    reason?: string;
}

/**
 * Внешний вид товара:  * `PERFECT` — идеальный. * `EXCELLENT` — отличный. * `GOOD` — хороший. * `NOT_SPECIFIED` — не выбран. 
 * @export
 * @enum {string}
 */
export type OfferConditionQualityType = 'PERFECT' | 'EXCELLENT' | 'GOOD' | 'NOT_SPECIFIED';

/**
 * Тип уценки:  * `PREOWNED` —  бывший в употреблении товар, раньше принадлежал другому человеку. * `SHOWCASESAMPLE` — витринный образец. * `REFURBISHED` — повторная продажа товара. * `REDUCTION` — товар с дефектами. * `RENOVATED` — восстановленный товар. * `NOT_SPECIFIED` — не выбран.  `REFURBISHED` — специальное значение для одежды, обуви и аксессуаров. Используется только для уцененных товаров из этой категории. Другие значения для одежды, обуви и аксессуаров не используются. 
 * @export
 * @enum {string}
 */
export type OfferConditionType = 'PREOWNED' | 'SHOWCASESAMPLE' | 'REFURBISHED' | 'REDUCTION' | 'RENOVATED' | 'NOT_SPECIFIED';

/**
 * Товар с указанными характеристиками.
 * @export
 */
export type OfferContentDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof OfferContentDTO
     */
    offerId: string;
    /**
     * Идентификатор категории на Маркете. Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).
     * @type {number}
     * @memberof OfferContentDTO
     */
    categoryId: number;
    /**
     * Список характеристик с их значениями.  С `parameterValues` обязательно передавайте `marketCategoryId` — идентификатор категории на Маркете, к которой относятся указанные характеристики товара.  При **изменении** характеристик передавайте только те, значение которых нужно обновить.  Чтобы **удалить** значение заданной характеристики, передайте ее `parameterId` с пустым `value`.  Максимальное количество характеристик — 300. 
     * @type {Array<ParameterValueDTO>}
     * @memberof OfferContentDTO
     */
    parameterValues: Array<ParameterValueDTO>;
}

/**
 * Текст ошибки.
 * @export
 */
export type OfferContentErrorDTO = {
    /**
     * 
     * @type {OfferContentErrorType}
     * @memberof OfferContentErrorDTO
     */
    type: OfferContentErrorType;
    /**
     * Идентификатор характеристики, с которой связана ошибка.
     * @type {number}
     * @memberof OfferContentErrorDTO
     */
    parameterId?: number;
    /**
     * Текст ошибки.
     * @type {string}
     * @memberof OfferContentErrorDTO
     */
    message: string;
}

/**
 * Типы ошибок:  * `OFFER_NOT_FOUND` — такого товара нет в каталоге. * `UNKNOWN_CATEGORY` — указана неизвестная категория. * `CATEGORY_MISMATCH` — указана категория, которая не совпадает с категорией товара. * `UNKNOWN_PARAMETER` — передана характеристика, которой нет среди характеристик категории. * `UNEXPECTED_BOOLEAN_VALUE` — вместо boolean-значения передано что-то другое. * `NUMBER_FORMAT` — передана строка, не обозначающая число, вместо числа. * `VALUE_BLANK` — передано пустое значение. * `INVALID_UNIT_ID` — передана единица измерения, недопустимая для характеристики. * `INVALID_GROUP_ID_LENGTH` — в названии превышено допустимое значение символов — 255. * `INVALID_GROUP_ID_CHARACTERS` — переданы [недопустимые символы](*ascii-code). 
 * @export
 * @enum {string}
 */
export type OfferContentErrorType = 'OFFER_NOT_FOUND' | 'UNKNOWN_CATEGORY' | 'CATEGORY_MISMATCH' | 'UNKNOWN_PARAMETER' | 'UNEXPECTED_BOOLEAN_VALUE' | 'NUMBER_FORMAT' | 'VALUE_BLANK' | 'INVALID_UNIT_ID' | 'INVALID_GROUP_ID_LENGTH' | 'INVALID_GROUP_ID_CHARACTERS';

/**
 * Предложение.
 * @export
 */
export type OfferDTO = {
    /**
     * Цена предложения.  До версии 2.0 партнерского API у параметра был тип String. 
     * @type {number}
     * @memberof OfferDTO
     */
    price?: number;
    /**
     * Идентификатор прайс-листа, содержащего предложение.  Параметр доступен начиная с версии 2.0 партнерского API. 
     * @type {number}
     * @memberof OfferDTO
     */
    feedId?: number;
    /**
     * Идентификатор предложения из прайс-листа.  Параметр выводится, если в прайс-листе задан уникальный идентификатор. Если в прайс-листе содержится несколько предложений с одинаковыми идентификаторами, параметр `id` указывается только для первого из них, для остальных параметры `id` и `feedId` не выводятся.  Параметр доступен начиная с версии 2.0 партнерского API. 
     * @type {string}
     * @memberof OfferDTO
     */
    id?: string;
    /**
     * Идентификатор категории предложения, указанный магазином в прайс-листе.  Параметр выводится только для предложений, у которых указана категория в прайс-листе.  Параметр доступен начиная с версии 2.0 партнерского API. 
     * @type {string}
     * @memberof OfferDTO
     */
    shopCategoryId?: string;
    /**
     * Идентификатор категории предложения в дереве категорий Маркета. Параметр доступен начиная с версии 2.0 партнерского API. 
     * @type {number}
     * @memberof OfferDTO
     */
    marketCategoryId?: number;
    /**
     * Цена предложения без скидки.
     * @type {number}
     * @memberof OfferDTO
     */
    preDiscountPrice?: number;
    /**
     * Скидка на предложение в процентах.
     * @type {number}
     * @memberof OfferDTO
     */
    discount?: number;
    /**
     * Является ли предложение уцененным:  * `true` — да. * `false` — нет.  Параметр доступен начиная с версии 2.58 партнерского API. 
     * @type {boolean}
     * @memberof OfferDTO
     */
    cutPrice?: boolean;
    /**
     * URL-адрес предложения на сайте магазина.
     * @type {string}
     * @memberof OfferDTO
     */
    url?: string;
    /**
     * Идентификатор модели Маркета, с которой соотнесено предложение.  Если предложение не соотнесено ни с какой карточкой модели, то параметр `modelid` содержит значение `0`.  {% note info %}  Идентификатор модели присутствует в URL карточки модели в виде значения параметра `product`. Например: `https://market.yandex.ru/product/13584121`.  {% endnote %} 
     * @type {number}
     * @memberof OfferDTO
     */
    modelId: number;
    /**
     * Наименование предложения.
     * @type {string}
     * @memberof OfferDTO
     */
    name?: string;
    /**
     * 
     * @type {CurrencyType}
     * @memberof OfferDTO
     */
    currency?: CurrencyType;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Ставка на клик. 
     * @type {number}
     * @memberof OfferDTO
     */
    bid?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Ставка на клик. 
     * @type {number}
     * @memberof OfferDTO
     */
    cbid?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Процент комиссии на товар при продаже по CPA. 
     * @type {number}
     * @memberof OfferDTO
     */
    fee?: number;
    /**
     * Признак блокировки предложения. Возможные значения: * `false` — предложение активно, параметр не выводится. * `true` — предложение заблокировано. Параметр выводится, если предложение заблокировано и не попадает в выдачу Маркета. Это может произойти из-за отключения магазина. 
     * @type {boolean}
     * @memberof OfferDTO
     */
    blocked?: boolean;
}

/**
 * Сообщение об ошибке, связанной с размещением товара.
 * @export
 */
export type OfferErrorDTO = {
    /**
     * Тип ошибки.
     * @type {string}
     * @memberof OfferErrorDTO
     */
    message?: string;
    /**
     * Пояснение.
     * @type {string}
     * @memberof OfferErrorDTO
     */
    comment?: string;
}

/**
 * Информация о состоянии цены на товар.
 * @export
 */
export type OfferForRecommendationDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof OfferForRecommendationDTO
     */
    offerId?: string;
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof OfferForRecommendationDTO
     */
    price?: BasePriceDTO;
    /**
     * 
     * @type {GetPriceDTO}
     * @memberof OfferForRecommendationDTO
     */
    cofinancePrice?: GetPriceDTO;
    /**
     * 
     * @type {PriceCompetitivenessType}
     * @memberof OfferForRecommendationDTO
     */
    competitiveness?: PriceCompetitivenessType;
    /**
     * Количество показов карточки товара за последние 7 дней.
     * @type {number}
     * @memberof OfferForRecommendationDTO
     */
    shows?: number;
}

/**
 * Инструкция по использованию товара. 
 * @export
 */
export type OfferManualDTO = {
    /**
     * Ссылка на инструкцию.
     * @type {string}
     * @memberof OfferManualDTO
     */
    url: string;
    /**
     * Название инструкции, которое будет отображаться на карточке товара. 
     * @type {string}
     * @memberof OfferManualDTO
     */
    title?: string;
}

/**
 * Информация о текущей карточке товара на Маркете.
 * @export
 */
export type OfferMappingDTO = {
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof OfferMappingDTO
     */
    marketSku?: number;
    /**
     * Идентификатор модели для текущей карточки товара на Маркете.  Например, две лопатки разных цветов имеют разные SKU на Маркете (параметр `marketSku`), но одинаковый идентификатор модели товара. 
     * @type {number}
     * @memberof OfferMappingDTO
     */
    modelId?: number;
    /**
     * Идентификатор категории для текущей карточки товара на Маркете.
     * @type {number}
     * @memberof OfferMappingDTO
     */
    categoryId?: number;
}

/**
 * Информация о товарах в каталоге.
 * @export
 */
export type OfferMappingEntriesDTO = {
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof OfferMappingEntriesDTO
     */
    paging?: ScrollingPagerDTO;
    /**
     * Информация о товарах в каталоге.
     * @type {Array<OfferMappingEntryDTO>}
     * @memberof OfferMappingEntriesDTO
     */
    offerMappingEntries: Array<OfferMappingEntryDTO>;
}

/**
 * Список товаров. 
 * @export
 */
export type OfferMappingEntryDTO = {
    /**
     * 
     * @type {OfferMappingDTO}
     * @memberof OfferMappingEntryDTO
     */
    mapping?: OfferMappingDTO;
    /**
     * 
     * @type {OfferMappingDTO}
     * @memberof OfferMappingEntryDTO
     */
    awaitingModerationMapping?: OfferMappingDTO;
    /**
     * 
     * @type {OfferMappingDTO}
     * @memberof OfferMappingEntryDTO
     */
    rejectedMapping?: OfferMappingDTO;
    /**
     * 
     * @type {MappingsOfferDTO}
     * @memberof OfferMappingEntryDTO
     */
    offer?: MappingsOfferDTO;
}

/**
 * Текст ошибки.
 * @export
 */
export type OfferMappingErrorDTO = {
    /**
     * 
     * @type {OfferMappingErrorType}
     * @memberof OfferMappingErrorDTO
     */
    type: OfferMappingErrorType;
    /**
     * Идентификатор характеристики, с которой связана ошибка.
     * @type {number}
     * @memberof OfferMappingErrorDTO
     */
    parameterId?: number;
    /**
     * Текст ошибки.
     * @type {string}
     * @memberof OfferMappingErrorDTO
     */
    message: string;
}

/**
 * Типы ошибок:  * `UNKNOWN_CATEGORY` — указана неизвестная категория. * `CATEGORY_MISMATCH` — указана категория, которая не совпадает с категорией товара. * `EMPTY_MARKET_CATEGORY` — не указана категория Маркета при передаче характеристик категории. * `UNKNOWN_PARAMETER` — передана характеристика, которой нет среди характеристик категории. * `UNEXPECTED_BOOLEAN_VALUE` — вместо boolean-значения передано что-то другое. * `NUMBER_FORMAT` — передана строка, не обозначающая число, вместо числа. * `VALUE_BLANK` — передано пустое значение. * `INVALID_UNIT_ID` — передана единица измерения, недопустимая для характеристики. * `INVALID_GROUP_ID_LENGTH` — в названии превышено допустимое значение символов — 255. * `INVALID_GROUP_ID_CHARACTERS` — переданы [недопустимые символы](*ascii-code). * `INVALID_PICKER_URL` — передана ссылка на изображение для миниатюры, которой нет в переданных ссылках на изображение товара. 
 * @export
 * @enum {string}
 */
export type OfferMappingErrorType = 'UNKNOWN_CATEGORY' | 'CATEGORY_MISMATCH' | 'EMPTY_MARKET_CATEGORY' | 'UNKNOWN_PARAMETER' | 'UNEXPECTED_BOOLEAN_VALUE' | 'NUMBER_FORMAT' | 'VALUE_BLANK' | 'INVALID_UNIT_ID' | 'INVALID_GROUP_ID_LENGTH' | 'INVALID_GROUP_ID_CHARACTERS' | 'INVALID_PICKER_URL';

/**
 * Информация о карточке товара.
 * @export
 */
export type OfferMappingInfoDTO = {
    /**
     * 
     * @type {OfferMappingDTO}
     * @memberof OfferMappingInfoDTO
     */
    mapping?: OfferMappingDTO;
    /**
     * 
     * @type {OfferMappingDTO}
     * @memberof OfferMappingInfoDTO
     */
    awaitingModerationMapping?: OfferMappingDTO;
    /**
     * 
     * @type {OfferMappingDTO}
     * @memberof OfferMappingInfoDTO
     */
    rejectedMapping?: OfferMappingDTO;
}

/**
 * Вид маппинга.
 * @export
 * @enum {string}
 */
export type OfferMappingKindType = 'ACTIVE' | 'ALL';

/**
 * Список рекомендованных карточек товара.
 * @export
 */
export type OfferMappingSuggestionsListDTO = {
    /**
     * Список товаров.
     * @type {Array<EnrichedMappingsOfferDTO>}
     * @memberof OfferMappingSuggestionsListDTO
     */
    offers: Array<EnrichedMappingsOfferDTO>;
}

/**
 * Параметры товара.  Если у товара несколько значений одного параметра, передайте их с одним и тем же `name`, но разными `value`.  {% cut \"Пример\" %}  ```json \"params\": [   {     \"name\": \"Цвет\",     \"value\": \"Зеленый\"   },   {     \"name\": \"Цвет\",     \"value\": \"Желтый\"   } ] ```  {% endcut %} 
 * @export
 */
export type OfferParamDTO = {
    /**
     * Название.  Должно совпадать с названием характеристики на Маркете. Узнать его можно из Excel-шаблона категории или через запрос [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md). 
     * @type {string}
     * @memberof OfferParamDTO
     */
    name: string;
    /**
     * Значение. 
     * @type {string}
     * @memberof OfferParamDTO
     */
    value: string;
}

/**
 * Список цен.
 * @export
 */
export type OfferPriceByOfferIdsListResponseDTO = {
    /**
     * Страница списка цен.
     * @type {Array<OfferPriceByOfferIdsResponseDTO>}
     * @memberof OfferPriceByOfferIdsListResponseDTO
     */
    offers: Array<OfferPriceByOfferIdsResponseDTO>;
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof OfferPriceByOfferIdsListResponseDTO
     */
    paging?: ScrollingPagerDTO;
}

/**
 * Информация об установленной цене.
 * @export
 */
export type OfferPriceByOfferIdsResponseDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof OfferPriceByOfferIdsResponseDTO
     */
    offerId?: string;
    /**
     * 
     * @type {PriceDTO}
     * @memberof OfferPriceByOfferIdsResponseDTO
     */
    price?: PriceDTO;
    /**
     * Дата и время последнего обновления цены.
     * @type {Date}
     * @memberof OfferPriceByOfferIdsResponseDTO
     */
    updatedAt?: Date;
}

/**
 * Товар с информацией о новой цене на него.
 * @export
 */
export type OfferPriceDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof OfferPriceDTO
     */
    offerId?: string;
    /**
     * 
     * @type {PriceDTO}
     * @memberof OfferPriceDTO
     */
    price?: PriceDTO;
}

/**
 * Список цен на товары.
 * @export
 */
export type OfferPriceListResponseDTO = {
    /**
     * Страница списка.
     * @type {Array<OfferPriceResponseDTO>}
     * @memberof OfferPriceListResponseDTO
     */
    offers: Array<OfferPriceResponseDTO>;
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof OfferPriceListResponseDTO
     */
    paging?: ScrollingPagerDTO;
    /**
     * Количество всех цен магазина, измененных через API.
     * @type {number}
     * @memberof OfferPriceListResponseDTO
     */
    total?: number;
}

/**
 * Информация об установленной цене на товар.
 * @export
 */
export type OfferPriceResponseDTO = {
    /**
     * Идентификатор предложения из прайс-листа.
     * @type {string}
     * @memberof OfferPriceResponseDTO
     */
    id?: string;
    /**
     * 
     * @type {PriceDTO}
     * @memberof OfferPriceResponseDTO
     */
    price?: PriceDTO;
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof OfferPriceResponseDTO
     */
    marketSku?: number;
    /**
     * Дата и время последнего обновления цены на товар.
     * @type {Date}
     * @memberof OfferPriceResponseDTO
     */
    updatedAt?: Date;
}

/**
 * Причины, по которым товар не прошел модерацию.
 * @export
 */
export type OfferProcessingNoteDTO = {
    /**
     * 
     * @type {OfferProcessingNoteType}
     * @memberof OfferProcessingNoteDTO
     */
    type?: OfferProcessingNoteType;
    /**
     * Дополнительная информация о причине отклонения товара. 
     * @type {string}
     * @memberof OfferProcessingNoteDTO
     */
    payload?: string;
}

/**
 * Тип причины, по которой товар не прошел модерацию:  * `ASSORTMENT` — товар производится в разных вариантах. Каждый из них нужно описать как отдельный товар (входной параметр `offer-mapping-entry` запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md) или строка в каталоге, если вы загружаете товары через кабинет продавца на Маркете). * `CANCELLED` — товар отозван с модерации по вашей инициативе. * `CONFLICTING_INFORMATION` _(ранее ошибочно `CONFLICTING`)_ — вы предоставили противоречивую информацию о товаре. Параметры, которые нужно исправить, указаны в параметре `payload`. * `DEPARTMENT_FROZEN` — правила размещения товаров в данной категории перерабатываются, поэтому товар пока не может пройти модерацию. * `INCORRECT_INFORMATION` — информация о товаре, которую вы предоставили, противоречит описанию от производителя. Параметры, которые нужно исправить, указаны в параметре `payload`. * `LEGAL_CONFLICT` — товар не прошел модерацию по юридическим причинам. Например, он официально не продается в России или у вас нет разрешения на его продажу. * `NEED_CLASSIFICATION_INFORMATION` — информации о товаре, которую вы предоставили, не хватает, чтобы отнести его к категории. Проверьте, что правильно указали название, категорию, производителя и страны производства товара, а также URL изображений или страниц с описанием, по которым можно идентифицировать товар. * `NEED_INFORMATION` — товар раньше не продавался в России и пока не размещается на Маркете. Для него можно создать карточку. Подробнее см. в разделе [Работа с карточкой товара](https://yandex.ru/support/marketplace/assortment/content/index.html) Справки Маркета для продавцов. * `NEED_PICTURES` — для идентификации товара нужны его изображения. Отправьте URL изображений товара в запросе [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md) или загрузите обновленный каталог через кабинет продавца на Маркете. * `NEED_VENDOR` — неверно указан производитель товара. * `NO_CATEGORY`, `NO_KNOWLEDGE` — товары из указанной категории пока не размещаются на Маркете. Если категория появится, товар будет снова отправлен на модерацию. * `NO_PARAMETERS_IN_SHOP_TITLE` — товар производится в разных вариантах, и из указанного названия непонятно, о каком идет речь. Параметры, которые нужно добавить в название товара, указаны в параметре `payload`. * `NO_SIZE_MEASURE` — для этого товара нужна размерная сетка. Отправьте ее в службу поддержки или вашему менеджеру. Требования к размерной сетке указаны в параметре `payload`. * `UNKNOWN` — товар не прошел модерацию по другой причине. Обратитесь в службу поддержки или к вашему менеджеру. 
 * @export
 * @enum {string}
 */
export type OfferProcessingNoteType = 'ASSORTMENT' | 'CANCELLED' | 'CONFLICTING_INFORMATION' | 'OTHER' | 'DEPARTMENT_FROZEN' | 'INCORRECT_INFORMATION' | 'LEGAL_CONFLICT' | 'NEED_CLASSIFICATION_INFORMATION' | 'NEED_INFORMATION' | 'NEED_PICTURES' | 'NEED_VENDOR' | 'NO_CATEGORY' | 'NO_KNOWLEDGE' | 'NO_PARAMETERS_IN_SHOP_TITLE' | 'NO_SIZE_MEASURE' | 'SAMPLE_LINE';

/**
 * Информация о статусе публикации товара на Маркете.
 * @export
 */
export type OfferProcessingStateDTO = {
    /**
     * 
     * @type {OfferProcessingStatusType}
     * @memberof OfferProcessingStateDTO
     */
    status?: OfferProcessingStatusType;
    /**
     * Причины, по которым товар не прошел модерацию.
     * @type {Array<OfferProcessingNoteDTO>}
     * @memberof OfferProcessingStateDTO
     */
    notes?: Array<OfferProcessingNoteDTO>;
}

/**
 * Статус публикации товара:  * `READY` — товар прошел модерацию. Чтобы разместить его на Маркете, установите для него цену. * `IN_WORK` — товар проходит модерацию. Это занимает несколько дней. * `NEED_CONTENT` — для товара без SKU на Маркете `marketSku` нужно найти карточку самостоятельно (через API или кабинет продавца на Маркете) или создать ее, если товар еще не продается на Маркете. * `NEED_INFO` — товар не прошел модерацию из-за ошибок или недостающих сведений в описании товара. Информация о причинах отклонения возвращается в параметре `notes`. * `REJECTED` — товар не прошел модерацию, так как Маркет не планирует размещать подобные товары. * `SUSPENDED` — товар не прошел модерацию, так как Маркет пока не размещает подобные товары. 
 * @export
 * @enum {string}
 */
export type OfferProcessingStatusType = 'UNKNOWN' | 'READY' | 'IN_WORK' | 'NEED_INFO' | 'NEED_MAPPING' | 'NEED_CONTENT' | 'CONTENT_PROCESSING' | 'SUSPENDED' | 'REJECTED' | 'REVIEW' | 'CREATE_ERROR' | 'UPDATE_ERROR';

/**
 * Информация о состоянии цен и рекомендации. 
 * @export
 */
export type OfferRecommendationDTO = {
    /**
     * 
     * @type {OfferForRecommendationDTO}
     * @memberof OfferRecommendationDTO
     */
    offer?: OfferForRecommendationDTO;
    /**
     * 
     * @type {OfferRecommendationInfoDTO}
     * @memberof OfferRecommendationDTO
     */
    recommendation?: OfferRecommendationInfoDTO;
}

/**
 * Рекомендации, касающиеся цены на товар.
 * @export
 */
export type OfferRecommendationInfoDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof OfferRecommendationInfoDTO
     */
    offerId?: string;
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof OfferRecommendationInfoDTO
     */
    recommendedCofinancePrice?: BasePriceDTO;
    /**
     * 
     * @type {PriceCompetitivenessThresholdsDTO}
     * @memberof OfferRecommendationInfoDTO
     */
    competitivenessThresholds?: PriceCompetitivenessThresholdsDTO;
}

/**
 * Список товаров с рекомендациями.
 * @export
 */
export type OfferRecommendationsResultDTO = {
    /**
     * 
     * @type {ScrollingPagerDTO}
     * @memberof OfferRecommendationsResultDTO
     */
    paging?: ScrollingPagerDTO;
    /**
     * Страница списка товаров.
     * @type {Array<OfferRecommendationDTO>}
     * @memberof OfferRecommendationsResultDTO
     */
    offerRecommendations: Array<OfferRecommendationDTO>;
}

/**
 * Информация о том, по каким моделям можно продавать товар, а по каким нельзя.
 * @export
 */
export type OfferSellingProgramDTO = {
    /**
     * 
     * @type {SellingProgramType}
     * @memberof OfferSellingProgramDTO
     */
    sellingProgram: SellingProgramType;
    /**
     * 
     * @type {OfferSellingProgramStatusType}
     * @memberof OfferSellingProgramDTO
     */
    status: OfferSellingProgramStatusType;
}

/**
 * Информация о доступности или недоступности.  * `FINE` — доступно. * `REJECT` — недоступно. 
 * @export
 * @enum {string}
 */
export type OfferSellingProgramStatusType = 'FINE' | 'REJECT';

/**
 * Особый тип товара:  * `MEDICINE` — лекарства. * `BOOK` — бумажные и электронные книги. * `AUDIOBOOK` — аудиокниги. * `ARTIST_TITLE` — музыкальная и видеопродукция. * `ON_DEMAND` — товары на заказ.  {% note info \"Если ваш товар — книга\" %}  Укажите год издания в характеристиках товара. [Подробнее о параметре](../../reference/business-assortment/updateOfferMappings.md#offerparamdto)  {% endnote %} 
 * @export
 * @enum {string}
 */
export type OfferType = 'DEFAULT' | 'MEDICINE' | 'BOOK' | 'AUDIOBOOK' | 'ARTIST_TITLE' | 'ON_DEMAND';

/**
 * Габариты упаковки и вес товара.  Если товар занимает несколько коробок, перед измерением размеров сложите их компактно.  ![Схема измерения многоместных грузов](../../_images/reference/boxes-measure.png) 
 * @export
 */
export type OfferWeightDimensionsDTO = {
    /**
     * Длина упаковки в см. 
     * @type {number}
     * @memberof OfferWeightDimensionsDTO
     */
    length: number;
    /**
     * Ширина упаковки в см. 
     * @type {number}
     * @memberof OfferWeightDimensionsDTO
     */
    width: number;
    /**
     * Высота упаковки в см. 
     * @type {number}
     * @memberof OfferWeightDimensionsDTO
     */
    height: number;
    /**
     * Вес товара в кг с учетом упаковки (брутто). 
     * @type {number}
     * @memberof OfferWeightDimensionsDTO
     */
    weight: number;
}

/**
 * Найденные предложения магазина.
 * @export
 */
export type OffersDTO = {
    /**
     * Список предложений магазина.
     * @type {Array<OfferDTO>}
     * @memberof OffersDTO
     */
    offers: Array<OfferDTO>;
}

/**
 * Значение ограничивающей характеристики и список допустимых значений ограничиваемой характеристики.
 * @export
 */
export type OptionValuesLimitedDTO = {
    /**
     * Идентификатор значения ограничивающей характеристики.
     * @type {number}
     * @memberof OptionValuesLimitedDTO
     */
    limitingOptionValueId: number;
    /**
     * Идентификаторы допустимых значений ограничиваемой характеристики. 
     * @type {Array<number>}
     * @memberof OptionValuesLimitedDTO
     */
    optionValueIds: Array<number>;
}

/**
 * Информация о коробке.
 * @export
 */
export type OrderBoxLayoutDTO = {
    /**
     * Список товаров в коробке.  Если в коробке едет часть большого товара, в списке может быть только один пункт. 
     * @type {Array<OrderBoxLayoutItemDTO>}
     * @memberof OrderBoxLayoutDTO
     */
    items: Array<OrderBoxLayoutItemDTO>;
}

/**
 * Информация о товаре в коробке.
 * @export
 */
export type OrderBoxLayoutItemDTO = {
    /**
     * Идентификатор товара в заказе.  {% cut \"Где его взять\" %}  Идентификатор приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр `id` в `items`.  {% endcut %}   
     * @type {number}
     * @memberof OrderBoxLayoutItemDTO
     */
    id: number;
    /**
     * Количество единиц товара в коробке.  Используйте это поле, если в коробке поедут целые товары, не разделенные на части. Не используйте это поле одновременно с `partialCount`. 
     * @type {number}
     * @memberof OrderBoxLayoutItemDTO
     */
    fullCount?: number;
    /**
     * 
     * @type {OrderBoxLayoutPartialCountDTO}
     * @memberof OrderBoxLayoutItemDTO
     */
    partialCount?: OrderBoxLayoutPartialCountDTO;
    /**
     * Переданные вами коды маркировки.
     * @type {Array<BriefOrderItemInstanceDTO>}
     * @memberof OrderBoxLayoutItemDTO
     */
    instances?: Array<BriefOrderItemInstanceDTO>;
}

/**
 * Информация о части товара в коробке.
 * @export
 */
export type OrderBoxLayoutPartialCountDTO = {
    /**
     * Номер части, начиная с 1.
     * @type {number}
     * @memberof OrderBoxLayoutPartialCountDTO
     */
    current: number;
    /**
     * На сколько всего частей разделен товар.
     * @type {number}
     * @memberof OrderBoxLayoutPartialCountDTO
     */
    total: number;
}

/**
 * Распределение товаров по коробкам.
 * @export
 */
export type OrderBoxesLayoutDTO = {
    /**
     * Список коробок.
     * @type {Array<EnrichedOrderBoxLayoutDTO>}
     * @memberof OrderBoxesLayoutDTO
     */
    boxes: Array<EnrichedOrderBoxLayoutDTO>;
}

/**
 * Информация о покупателе. 
 * @export
 */
export type OrderBusinessBuyerDTO = {
    /**
     * ИНН.
     * @type {string}
     * @memberof OrderBusinessBuyerDTO
     */
    inn?: string;
    /**
     * КПП.
     * @type {string}
     * @memberof OrderBusinessBuyerDTO
     */
    kpp?: string;
    /**
     * Наименование юридического лица.
     * @type {string}
     * @memberof OrderBusinessBuyerDTO
     */
    organizationName?: string;
    /**
     * Юридический адрес.
     * @type {string}
     * @memberof OrderBusinessBuyerDTO
     */
    organizationJurAddress?: string;
}

/**
 * Информация о документах. 
 * @export
 */
export type OrderBusinessDocumentsDTO = {
    /**
     * 
     * @type {DocumentDTO}
     * @memberof OrderBusinessDocumentsDTO
     */
    upd?: DocumentDTO;
    /**
     * 
     * @type {DocumentDTO}
     * @memberof OrderBusinessDocumentsDTO
     */
    ukd?: DocumentDTO;
    /**
     * 
     * @type {DocumentDTO}
     * @memberof OrderBusinessDocumentsDTO
     */
    torgTwelve?: DocumentDTO;
    /**
     * 
     * @type {DocumentDTO}
     * @memberof OrderBusinessDocumentsDTO
     */
    sf?: DocumentDTO;
    /**
     * 
     * @type {DocumentDTO}
     * @memberof OrderBusinessDocumentsDTO
     */
    ksf?: DocumentDTO;
}

/**
 * Информация о покупателе с базовыми полями.
 * @export
 */
export type OrderBuyerBasicInfoDTO = {
    /**
     * Идентификатор покупателя.
     * @type {string}
     * @memberof OrderBuyerBasicInfoDTO
     */
    id?: string;
    /**
     * Фамилия покупателя.
     * @type {string}
     * @memberof OrderBuyerBasicInfoDTO
     */
    lastName?: string;
    /**
     * Имя покупателя.
     * @type {string}
     * @memberof OrderBuyerBasicInfoDTO
     */
    firstName?: string;
    /**
     * Отчество покупателя.
     * @type {string}
     * @memberof OrderBuyerBasicInfoDTO
     */
    middleName?: string;
    /**
     * 
     * @type {OrderBuyerType}
     * @memberof OrderBuyerBasicInfoDTO
     */
    type?: OrderBuyerType;
}

/**
 * Информация о покупателе.  Параметры `id`, `lastName`, `firstName` и `middleName` возвращаются, только если вы работаете по модели DBS. 
 * @export
 */
export type OrderBuyerDTO = {
    /**
     * Идентификатор покупателя.
     * @type {string}
     * @memberof OrderBuyerDTO
     */
    id?: string;
    /**
     * Фамилия покупателя.
     * @type {string}
     * @memberof OrderBuyerDTO
     */
    lastName?: string;
    /**
     * Имя покупателя.
     * @type {string}
     * @memberof OrderBuyerDTO
     */
    firstName?: string;
    /**
     * Отчество покупателя.
     * @type {string}
     * @memberof OrderBuyerDTO
     */
    middleName?: string;
    /**
     * 
     * @type {OrderBuyerType}
     * @memberof OrderBuyerDTO
     */
    type?: OrderBuyerType;
}

/**
 * Информация о покупателе и его номере телефона.
 * @export
 */
export type OrderBuyerInfoDTO = {
    /**
     * Идентификатор покупателя.
     * @type {string}
     * @memberof OrderBuyerInfoDTO
     */
    id?: string;
    /**
     * Фамилия покупателя.
     * @type {string}
     * @memberof OrderBuyerInfoDTO
     */
    lastName?: string;
    /**
     * Имя покупателя.
     * @type {string}
     * @memberof OrderBuyerInfoDTO
     */
    firstName?: string;
    /**
     * Отчество покупателя.
     * @type {string}
     * @memberof OrderBuyerInfoDTO
     */
    middleName?: string;
    /**
     * 
     * @type {OrderBuyerType}
     * @memberof OrderBuyerInfoDTO
     */
    type?: OrderBuyerType;
    /**
     * Подменный номер телефона покупателя. Подробнее о таких номерах читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/orders/dbs/call#fake-number).  Формат номера: `+<код_страны><код_региона><номер_телефона>`. 
     * @type {string}
     * @memberof OrderBuyerInfoDTO
     */
    phone?: string;
}

/**
 * Тип покупателя:  * `PERSON` — физическое лицо.  * `BUSINESS` — организация. 
 * @export
 * @enum {string}
 */
export type OrderBuyerType = 'PERSON' | 'BUSINESS';

/**
 * Варианты причин, по которым заказ не может быть отменен.  * `ORDER_DELIVERED` — заказ уже доставлен. * `ORDER_IN_DELIVERY` — заказ уже у курьера. 
 * @export
 * @enum {string}
 */
export type OrderCancellationReasonType = 'ORDER_DELIVERED' | 'ORDER_IN_DELIVERY';

/**
 * Информация о курьере.
 * @export
 */
export type OrderCourierDTO = {
    /**
     * Полное имя курьера.
     * @type {string}
     * @memberof OrderCourierDTO
     */
    fullName?: string;
    /**
     * Номер телефона курьера.
     * @type {string}
     * @memberof OrderCourierDTO
     */
    phone?: string;
    /**
     * Добавочный номер телефона.
     * @type {string}
     * @memberof OrderCourierDTO
     */
    phoneExtension?: string;
    /**
     * Номер транспортного средства.
     * @type {string}
     * @memberof OrderCourierDTO
     */
    vehicleNumber?: string;
    /**
     * Описание машины. Например, модель и цвет.
     * @type {string}
     * @memberof OrderCourierDTO
     */
    vehicleDescription?: string;
}

/**
 * Заказ.
 * @export
 */
export type OrderDTO = {
    /**
     * Идентификатор заказа.
     * @type {number}
     * @memberof OrderDTO
     */
    id?: number;
    /**
     * 
     * @type {OrderStatusType}
     * @memberof OrderDTO
     */
    status?: OrderStatusType;
    /**
     * 
     * @type {OrderSubstatusType}
     * @memberof OrderDTO
     */
    substatus?: OrderSubstatusType;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    creationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    updatedAt?: string;
    /**
     * 
     * @type {CurrencyType}
     * @memberof OrderDTO
     */
    currency?: CurrencyType;
    /**
     * Платеж покупателя. 
     * @type {number}
     * @memberof OrderDTO
     */
    itemsTotal?: number;
    /**
     * Стоимость доставки. 
     * @type {number}
     * @memberof OrderDTO
     */
    deliveryTotal?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел.  {% endnote %}  Стоимость всех товаров в заказе в валюте покупателя после применения скидок и без учета стоимости доставки. 
     * @type {number}
     * @memberof OrderDTO
     */
    buyerItemsTotal?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел.  {% endnote %}  Стоимость всех товаров в заказе в валюте покупателя после применения скидок и с учетом стоимости доставки. 
     * @type {number}
     * @memberof OrderDTO
     */
    buyerTotal?: number;
    /**
     * Стоимость всех товаров в заказе в валюте покупателя без учета стоимости доставки и до применения скидок по:  * акциям; * купонам; * промокодам. 
     * @type {number}
     * @memberof OrderDTO
     */
    buyerItemsTotalBeforeDiscount?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел.  {% endnote %}  Стоимость всех товаров в заказе в валюте покупателя до применения скидок и с учетом стоимости доставки (`buyerItemsTotalBeforeDiscount` + стоимость доставки). 
     * @type {number}
     * @memberof OrderDTO
     */
    buyerTotalBeforeDiscount?: number;
    /**
     * 
     * @type {OrderPaymentType}
     * @memberof OrderDTO
     */
    paymentType?: OrderPaymentType;
    /**
     * 
     * @type {OrderPaymentMethodType}
     * @memberof OrderDTO
     */
    paymentMethod?: OrderPaymentMethodType;
    /**
     * Тип заказа:  * `false` — настоящий заказ покупателя.  * `true` — [тестовый](../../pushapi/concepts/sandbox.md) заказ Маркета. 
     * @type {boolean}
     * @memberof OrderDTO
     */
    fake?: boolean;
    /**
     * Список товаров в заказе.
     * @type {Array<OrderItemDTO>}
     * @memberof OrderDTO
     */
    items: Array<OrderItemDTO>;
    /**
     * Список субсидий по типам.
     * @type {Array<OrderSubsidyDTO>}
     * @memberof OrderDTO
     */
    subsidies?: Array<OrderSubsidyDTO>;
    /**
     * 
     * @type {OrderDeliveryDTO}
     * @memberof OrderDTO
     */
    delivery?: OrderDeliveryDTO;
    /**
     * 
     * @type {OrderBuyerDTO}
     * @memberof OrderDTO
     */
    buyer?: OrderBuyerDTO;
    /**
     * Комментарий к заказу.
     * @type {string}
     * @memberof OrderDTO
     */
    notes?: string;
    /**
     * 
     * @type {OrderTaxSystemType}
     * @memberof OrderDTO
     */
    taxSystem?: OrderTaxSystemType;
    /**
     * **Только для модели DBS**  Запрошена ли отмена. 
     * @type {boolean}
     * @memberof OrderDTO
     */
    cancelRequested?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    expiryDate?: string;
}

/**
 * Адрес доставки.  Указывается, если `type=DELIVERY`, `type=POST` или `type=PICKUP` (адрес пункта выдачи). 
 * @export
 */
export type OrderDeliveryAddressDTO = {
    /**
     * Страна.  Обязательный параметр. 
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    country?: string;
    /**
     * Почтовый индекс.  Указывается, если выбрана доставка почтой (`delivery type=POST`). 
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    postcode?: string;
    /**
     * Город или населенный пункт.  Обязательный параметр. 
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    city?: string;
    /**
     * Район.
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    district?: string;
    /**
     * Станция метро.
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    subway?: string;
    /**
     * Улица.  Обязательный параметр. 
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    street?: string;
    /**
     * Дом или владение.  Обязательный параметр. 
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    house?: string;
    /**
     * Корпус или строение.
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    block?: string;
    /**
     * Подъезд.
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    entrance?: string;
    /**
     * Код домофона.
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    entryphone?: string;
    /**
     * Этаж.
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    floor?: string;
    /**
     * Квартира или офис.
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    apartment?: string;
    /**
     * Телефон получателя заказа.  Обязательный параметр. 
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    phone?: string;
    /**
     * Фамилия, имя и отчество получателя заказа.  Обязательный параметр. 
     * @type {string}
     * @memberof OrderDeliveryAddressDTO
     */
    recipient?: string;
    /**
     * 
     * @type {GpsDTO}
     * @memberof OrderDeliveryAddressDTO
     */
    gps?: GpsDTO;
}

/**
 * Информация о доставке.
 * @export
 */
export type OrderDeliveryDTO = {
    /**
     * Идентификатор доставки, присвоенный магазином.  Указывается, только если магазин передал данный идентификатор в ответе на запрос методом [POST cart](../../pushapi/reference/cart.md). 
     * @type {string}
     * @memberof OrderDeliveryDTO
     */
    id?: string;
    /**
     * 
     * @type {OrderDeliveryType}
     * @memberof OrderDeliveryDTO
     */
    type?: OrderDeliveryType;
    /**
     * Наименование службы доставки.
     * @type {string}
     * @memberof OrderDeliveryDTO
     */
    serviceName?: string;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Стоимость доставки смотрите в параметре `deliveryTotal`.  {% endnote %}  Стоимость доставки в валюте заказа. 
     * @type {number}
     * @memberof OrderDeliveryDTO
     */
    price?: number;
    /**
     * 
     * @type {OrderDeliveryPartnerType}
     * @memberof OrderDeliveryDTO
     */
    deliveryPartnerType?: OrderDeliveryPartnerType;
    /**
     * 
     * @type {OrderCourierDTO}
     * @memberof OrderDeliveryDTO
     */
    courier?: OrderCourierDTO;
    /**
     * 
     * @type {OrderDeliveryDatesDTO}
     * @memberof OrderDeliveryDTO
     */
    dates?: OrderDeliveryDatesDTO;
    /**
     * 
     * @type {RegionDTO}
     * @memberof OrderDeliveryDTO
     */
    region?: RegionDTO;
    /**
     * 
     * @type {OrderDeliveryAddressDTO}
     * @memberof OrderDeliveryDTO
     */
    address?: OrderDeliveryAddressDTO;
    /**
     * 
     * @type {OrderVatType}
     * @memberof OrderDeliveryDTO
     */
    vat?: OrderVatType;
    /**
     * Идентификатор службы доставки.
     * @type {number}
     * @memberof OrderDeliveryDTO
     */
    deliveryServiceId?: number;
    /**
     * 
     * @type {OrderLiftType}
     * @memberof OrderDeliveryDTO
     */
    liftType?: OrderLiftType;
    /**
     * Стоимость подъема на этаж.
     * @type {number}
     * @memberof OrderDeliveryDTO
     */
    liftPrice?: number;
    /**
     * Идентификатор пункта самовывоза, присвоенный магазином.
     * @type {string}
     * @memberof OrderDeliveryDTO
     */
    outletCode?: string;
    /**
     * Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {string}
     * @memberof OrderDeliveryDTO
     */
    outletStorageLimitDate?: string;
    /**
     * 
     * @type {OrderDeliveryDispatchType}
     * @memberof OrderDeliveryDTO
     */
    dispatchType?: OrderDeliveryDispatchType;
    /**
     * Информация для отслеживания перемещений посылки.
     * @type {Array<OrderTrackDTO>}
     * @memberof OrderDeliveryDTO
     */
    tracks?: Array<OrderTrackDTO>;
    /**
     * Информация о посылках.
     * @type {Array<OrderShipmentDTO>}
     * @memberof OrderDeliveryDTO
     */
    shipments?: Array<OrderShipmentDTO>;
    /**
     * Приблизительная ли дата доставки.
     * @type {boolean}
     * @memberof OrderDeliveryDTO
     */
    estimated?: boolean;
    /**
     * 
     * @type {OrderDeliveryEacType}
     * @memberof OrderDeliveryDTO
     */
    eacType?: OrderDeliveryEacType;
    /**
     * Код подтверждения ЭАПП (для типа `MERCHANT_TO_COURIER`). 
     * @type {string}
     * @memberof OrderDeliveryDTO
     */
    eacCode?: string;
}

/**
 * Информация о новой дате доставки заказа.
 * @export
 */
export type OrderDeliveryDateDTO = {
    /**
     * Новая дата доставки заказа.  Формат даты: `ГГГГ-ММ-ДД`. 
     * @type {Date}
     * @memberof OrderDeliveryDateDTO
     */
    toDate: Date;
}

/**
 * Причина переноса доставки заказа. Возможные причины изменения даты:   - ```USER_MOVED_DELIVERY_DATES``` — покупатель попросил изменить дату или вы договорились привезти ему заказ раньше изначальной даты. Кроме этого указывается для подтверждения даты доставки товаров на заказ с долгой (31-60 дней) доставкой.   - ```PARTNER_MOVED_DELIVERY_DATES``` — магазин не может доставить заказ в срок. 
 * @export
 * @enum {string}
 */
export type OrderDeliveryDateReasonType = 'USER_MOVED_DELIVERY_DATES' | 'PARTNER_MOVED_DELIVERY_DATES';

/**
 * Диапазон дат доставки.
 * @export
 */
export type OrderDeliveryDatesDTO = {
    /**
     * Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {string}
     * @memberof OrderDeliveryDatesDTO
     */
    fromDate?: string;
    /**
     * Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {string}
     * @memberof OrderDeliveryDatesDTO
     */
    toDate?: string;
    /**
     * Начало интервала времени доставки.  Передается только совместно с параметром `type=DELIVERY`.  Формат времени: 24-часовой, `ЧЧ:ММ`. В качестве минут всегда должно быть указано `00` (исключение — `23:59`).  Минимальное значение: `00:00`. 
     * @type {string}
     * @memberof OrderDeliveryDatesDTO
     */
    fromTime?: string;
    /**
     * Конец интервала времени доставки.  Передается только совместно с параметром `type=DELIVERY`.  Формат времени: 24-часовой, `ЧЧ:ММ`. В качестве минут всегда должно быть указано `00` (исключение — `23:59`).  Максимальное значение: `23:59`. 
     * @type {string}
     * @memberof OrderDeliveryDatesDTO
     */
    toTime?: string;
    /**
     * Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {string}
     * @memberof OrderDeliveryDatesDTO
     */
    realDeliveryDate?: string;
}

/**
 * Способ отгрузки:  * `BUYER` — доставка покупателю.  * `MARKET_PARTNER_OUTLET` — доставка в пункт выдачи партнера.  * `MARKET_BRANDED_OUTLET` — доставка в пункт выдачи заказов Маркета.  * `SHOP_OUTLET` — доставка в пункт выдачи заказов магазина.  * `DROPOFF` — доставка в пункт выдачи, который принимает заказы от продавцов и передает их курьерам.  * `UNKNOWN` — неизвестный тип. 
 * @export
 * @enum {string}
 */
export type OrderDeliveryDispatchType = 'UNKNOWN' | 'BUYER' | 'MARKET_PARTNER_OUTLET' | 'MARKET_BRANDED_OUTLET' | 'SHOP_OUTLET' | 'DROPOFF';

/**
 * Тип кода подтверждения ЭАПП:  * `MERCHANT_TO_COURIER` — продавец передает код курьеру.  * `COURIER_TO_MERCHANT` — курьер передает код продавцу.  * `CHECKING_BY_MERCHANT` — продавец проверяет код на своей стороне. 
 * @export
 * @enum {string}
 */
export type OrderDeliveryEacType = 'MERCHANT_TO_COURIER' | 'COURIER_TO_MERCHANT' | 'CHECKING_BY_MERCHANT';

/**
 * Тип сотрудничества со службой доставки в рамках конкретного заказа:  * `SHOP` — магазин работает со службой доставки напрямую или доставляет заказы самостоятельно.  * `YANDEX_MARKET` — магазин работает со службой доставки через Маркет.  * `UNKNOWN` — неизвестный тип. 
 * @export
 * @enum {string}
 */
export type OrderDeliveryPartnerType = 'SHOP' | 'YANDEX_MARKET' | 'UNKNOWN';

/**
 * Способ доставки заказа:  * `DELIVERY` — курьерская доставка.  * `PICKUP` — самовывоз.  * `POST` — почта.  * `DIGITAL` — для цифровых товаров.  * `UNKNOWN` — неизвестный тип. 
 * @export
 * @enum {string}
 */
export type OrderDeliveryType = 'DELIVERY' | 'PICKUP' | 'POST' | 'DIGITAL' | 'UNKNOWN';

/**
 * Ключ цифрового товара.
 * @export
 */
export type OrderDigitalItemDTO = {
    /**
     * Идентификатор товара в заказе.  Он приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр `id` в `items`. 
     * @type {number}
     * @memberof OrderDigitalItemDTO
     */
    id: number;
    /**
     * Сам ключ.
     * @type {string}
     * @memberof OrderDigitalItemDTO
     */
    code: string;
    /**
     * Инструкция по активации.
     * @type {string}
     * @memberof OrderDigitalItemDTO
     */
    slip: string;
    /**
     * Дата, до которой нужно активировать ключ. Если ключ действует бессрочно, укажите любую дату в отдаленном будущем.  Формат даты: `ГГГГ-ММ-ДД`. 
     * @type {Date}
     * @memberof OrderDigitalItemDTO
     */
    activate_till: Date;
}

/**
 * Статус документа:  * `READY` — готов. * `NOT_READY` — не готов. 
 * @export
 * @enum {string}
 */
export type OrderDocumentStatusType = 'READY' | 'NOT_READY';

/**
 * Список товаров в заказе.
 * @export
 */
export type OrderItemDTO = {
    /**
     * Идентификатор товара в заказе.  Позволяет идентифицировать товар в рамках данного заказа. 
     * @type {number}
     * @memberof OrderItemDTO
     */
    id?: number;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof OrderItemDTO
     */
    offerId?: string;
    /**
     * Название товара.
     * @type {string}
     * @memberof OrderItemDTO
     */
    offerName?: string;
    /**
     * Цена на товар в валюте заказа без учета вознаграждения партнеру за скидки по промокодам, купонам и акциям (параметр `subsidies`). 
     * @type {number}
     * @memberof OrderItemDTO
     */
    price?: number;
    /**
     * Цена на товар в валюте покупателя. В цене уже учтены скидки по:  * акциям; * купонам; * промокодам. 
     * @type {number}
     * @memberof OrderItemDTO
     */
    buyerPrice?: number;
    /**
     * Стоимость товара в валюте покупателя до применения скидок по:  * акциям; * купонам; * промокодам. 
     * @type {number}
     * @memberof OrderItemDTO
     */
    buyerPriceBeforeDiscount?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел.  {% endnote %}  Стоимость товара в валюте магазина до применения скидок. 
     * @type {number}
     * @memberof OrderItemDTO
     */
    priceBeforeDiscount?: number;
    /**
     * Количество единиц товара.
     * @type {number}
     * @memberof OrderItemDTO
     */
    count?: number;
    /**
     * 
     * @type {OrderVatType}
     * @memberof OrderItemDTO
     */
    vat?: OrderVatType;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof OrderItemDTO
     */
    shopSku?: string;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `subsidies`.  {% endnote %}  Общее вознаграждение партнеру за DBS-доставку и все скидки на товар:  * по промокодам; * по купонам; * по баллам Плюса; * по акциям.  Передается в валюте заказа. 
     * @type {number}
     * @memberof OrderItemDTO
     */
    subsidy?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Идентификатор склада в системе партнера, на который сформирован заказ. 
     * @type {string}
     * @memberof OrderItemDTO
     */
    partnerWarehouseId?: string;
    /**
     * Информация о вознаграждениях партнеру за скидки на товар по промокодам, купонам и акциям.
     * @type {Array<OrderItemPromoDTO>}
     * @memberof OrderItemDTO
     */
    promos?: Array<OrderItemPromoDTO>;
    /**
     * Информация о маркировке единиц товара.  Возвращаются данные для маркировки, переданные в запросе [PUT campaigns/{campaignId}/orders/{orderId}/cis](../../reference/orders/provideOrderItemCis.md).  Если магазин еще не передавал коды для этого заказа, `instances` отсутствует. 
     * @type {Array<OrderItemInstanceDTO>}
     * @memberof OrderItemDTO
     */
    instances?: Array<OrderItemInstanceDTO>;
    /**
     * Информация об удалении товара из заказа. 
     * @type {Array<OrderItemDetailDTO>}
     * @memberof OrderItemDTO
     */
    details?: Array<OrderItemDetailDTO>;
    /**
     * Список субсидий по типам.
     * @type {Array<OrderItemSubsidyDTO>}
     * @memberof OrderItemDTO
     */
    subsidies?: Array<OrderItemSubsidyDTO>;
    /**
     * Список необходимых маркировок товара.
     * @type {Array<OrderItemInstanceType>}
     * @memberof OrderItemDTO
     */
    requiredInstanceTypes?: Array<OrderItemInstanceType>;
}

/**
 * Детали по товару в заказе.
 * @export
 */
export type OrderItemDetailDTO = {
    /**
     * Количество единиц товара.
     * @type {number}
     * @memberof OrderItemDetailDTO
     */
    itemCount?: number;
    /**
     * 
     * @type {OrderItemStatusType}
     * @memberof OrderItemDetailDTO
     */
    itemStatus?: OrderItemStatusType;
    /**
     * Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {string}
     * @memberof OrderItemDetailDTO
     */
    updateDate?: string;
}

/**
 * Переданные вами для данной позиции коды маркировки или УИНы. Коды «Честного знака» возвращаются в двух вариантах — с криптохвостом и без. 
 * @export
 */
export type OrderItemInstanceDTO = {
    /**
     * Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/) без криптохвоста.
     * @type {string}
     * @memberof OrderItemInstanceDTO
     */
    cis?: string;
    /**
     * Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/) с криптохвостом.
     * @type {string}
     * @memberof OrderItemInstanceDTO
     */
    cisFull?: string;
    /**
     * УИН ювелирного изделия (16-значный код) Производитель получает УИН, когда регистрирует изделие в системе контроля за оборотом драгоценных металлов и камней — ГИИС ДМДК. 
     * @type {string}
     * @memberof OrderItemInstanceDTO
     */
    uin?: string;
    /**
     * Регистрационный номер партии товара.  Представляет собой строку из четырех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ/ХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на партию товара. Далее — дата, номер декларации и номер маркированного товара в декларации. 
     * @type {string}
     * @memberof OrderItemInstanceDTO
     */
    rnpt?: string;
    /**
     * Грузовая таможенная декларация.  Представляет собой строку из трех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на ввезенные товары. Далее — дата и номер декларации. 
     * @type {string}
     * @memberof OrderItemInstanceDTO
     */
    gtd?: string;
}

/**
 * Позиция в корзине, требующая маркировки.
 * @export
 */
export type OrderItemInstanceModificationDTO = {
    /**
     * Идентификатор товара в заказе.  Он приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр `id` в `items`. 
     * @type {number}
     * @memberof OrderItemInstanceModificationDTO
     */
    id: number;
    /**
     * Список кодов маркировки единиц товара. 
     * @type {Array<BriefOrderItemInstanceDTO>}
     * @memberof OrderItemInstanceModificationDTO
     */
    instances: Array<BriefOrderItemInstanceDTO>;
}

/**
 * Вид маркировки товара:  * `CIS` — КИЗ, идентификатор единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).  * `UIN` — УИН, уникальный идентификационный номер.  * `RNPT` — РНПТ, регистрационный номер партии товара.  * `GTD` — номер ГТД, грузовой таможенной декларации. 
 * @export
 * @enum {string}
 */
export type OrderItemInstanceType = 'CIS' | 'UIN' | 'RNPT' | 'GTD';

/**
 * Список товаров в заказе.  Если магазин не передал информацию о товаре во входных данных, он будет удален из заказа.  Обязательный параметр. 
 * @export
 */
export type OrderItemModificationDTO = {
    /**
     * Идентификатор товара в рамках заказа.  Получить идентификатор можно с помощью ресурсов [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).  Обязательный параметр. 
     * @type {number}
     * @memberof OrderItemModificationDTO
     */
    id: number;
    /**
     * Новое количество товара.
     * @type {number}
     * @memberof OrderItemModificationDTO
     */
    count: number;
    /**
     * Информация о маркировке единиц товара.  Передавайте в запросе все единицы товара, который подлежит маркировке.  Обязательный параметр, если в заказе есть товары, подлежащие маркировке [в системе «Честный ЗНАК»](https://честныйзнак.рф/). 
     * @type {Array<BriefOrderItemInstanceDTO>}
     * @memberof OrderItemModificationDTO
     */
    instances?: Array<BriefOrderItemInstanceDTO>;
}

/**
 * Информация о вознаграждениях партнеру за скидки на товар по промокодам, купонам и акциям.
 * @export
 */
export type OrderItemPromoDTO = {
    /**
     * 
     * @type {OrderPromoType}
     * @memberof OrderItemPromoDTO
     */
    type: OrderPromoType;
    /**
     * Размер пользовательской скидки в валюте покупателя. 
     * @type {number}
     * @memberof OrderItemPromoDTO
     */
    discount?: number;
    /**
     * Вознаграждение партнеру от Маркета за товар, проданный в рамках акции.  Передается в валюте заказа. 
     * @type {number}
     * @memberof OrderItemPromoDTO
     */
    subsidy?: number;
    /**
     * Идентификатор акции поставщика. 
     * @type {string}
     * @memberof OrderItemPromoDTO
     */
    shopPromoId?: string;
    /**
     * Идентификатор акции в рамках соглашения на оказание услуг по продвижению сервиса между Маркетом и партнером.  Параметр передается, только если параметр `type=MARKET_DEAL`. 
     * @type {string}
     * @memberof OrderItemPromoDTO
     */
    marketPromoId?: string;
}

/**
 * Возвращенный или невыкупленный товар:  * `REJECTED` — невыкупленный.  * `RETURNED` — возвращенный. 
 * @export
 * @enum {string}
 */
export type OrderItemStatusType = 'REJECTED' | 'RETURNED';

/**
 * Общее вознаграждение партнеру за все скидки на товар:  * по промокодам, купонам и акциям; * по баллам Плюса.  Передается в валюте заказа. 
 * @export
 */
export type OrderItemSubsidyDTO = {
    /**
     * 
     * @type {OrderItemSubsidyType}
     * @memberof OrderItemSubsidyDTO
     */
    type?: OrderItemSubsidyType;
    /**
     * Сумма субсидии.
     * @type {number}
     * @memberof OrderItemSubsidyDTO
     */
    amount?: number;
}

/**
 * Тип субсидии:  * `YANDEX_CASHBACK` — скидка по подписке Яндекс Плюс.  * `SUBSIDY` — скидка Маркета (по акциям, промокодам, купонам и т. д.). 
 * @export
 * @enum {string}
 */
export type OrderItemSubsidyType = 'YANDEX_CASHBACK' | 'SUBSIDY';

/**
 * Причина обновления состава заказа.
 * @export
 * @enum {string}
 */
export type OrderItemsModificationRequestReasonType = 'PARTNER_REQUESTED_REMOVE' | 'USER_REQUESTED_REMOVE';

/**
 * Краткие сведения о промаркированных товарах. Параметр возвращается, если ответ `OK`. 
 * @export
 */
export type OrderItemsModificationResultDTO = {
    /**
     * Список позиций в заказе, подлежащих маркировке.
     * @type {Array<BriefOrderItemDTO>}
     * @memberof OrderItemsModificationResultDTO
     */
    items: Array<BriefOrderItemDTO>;
}

/**
 * Данные для печати ярлыка.
 * @export
 */
export type OrderLabelDTO = {
    /**
     * Идентификатор заказа.
     * @type {number}
     * @memberof OrderLabelDTO
     */
    orderId: number;
    /**
     * Количество коробок в заказе.
     * @type {number}
     * @memberof OrderLabelDTO
     */
    placesNumber: number;
    /**
     * URL файла с ярлыками‑наклейками на все коробки в заказе.  Соответствует URL, по которому выполняется запрос [GET campaigns/{campaignId}/orders/{orderId}/delivery/labels](../../reference/orders/generateOrderLabels.md). 
     * @type {string}
     * @memberof OrderLabelDTO
     */
    url: string;
    /**
     * Информация на ярлыке.
     * @type {Array<ParcelBoxLabelDTO>}
     * @memberof OrderLabelDTO
     */
    parcelBoxLabels: Array<ParcelBoxLabelDTO>;
}

/**
 * Тип подъема заказа на этаж:  * `NOT_NEEDED` — не требуется.  * `MANUAL` — ручной.  * `ELEVATOR` — лифт.  * `CARGO_ELEVATOR` — грузовой лифт.  * `FREE` — любой из перечисленных выше, если включена опция бесплатного подъема.  * `UNKNOWN` — неизвестный тип. 
 * @export
 * @enum {string}
 */
export type OrderLiftType = 'NOT_NEEDED' | 'MANUAL' | 'ELEVATOR' | 'CARGO_ELEVATOR' | 'FREE' | 'UNKNOWN';

/**
 * Информация о грузоместе.
 * @export
 */
export type OrderParcelBoxDTO = {
    /**
     * Идентификатор грузоместа.
     * @type {number}
     * @memberof OrderParcelBoxDTO
     */
    id?: number;
    /**
     * Идентификатор грузового места в информационной системе магазина.
     * @type {string}
     * @memberof OrderParcelBoxDTO
     */
    fulfilmentId?: string;
}

/**
 * Способ оплаты заказа:  * Значения, если выбрана оплата при оформлении заказа (`\"paymentType\": \"PREPAID\"`):    * `YANDEX` — банковской картой.    * `APPLE_PAY` — Apple Pay.    * `GOOGLE_PAY` — Google Pay.    * `CREDIT` — в кредит.    * `TINKOFF_CREDIT` — в кредит в Тинькофф Банке.    * `TINKOFF_INSTALLMENTS` — рассрочка в Тинькофф Банке.    * `EXTERNAL_CERTIFICATE` — подарочным сертификатом (например, из приложения «Сбербанк Онлайн»).    * `SBP` — через систему быстрых платежей.    * `B2B_ACCOUNT_PREPAYMENT` — заказ оплачивает организация.   * Значения, если выбрана оплата при получении заказа (`\"paymentType\": \"POSTPAID\"`):    * `CARD_ON_DELIVERY` — банковской картой.    * `BOUND_CARD_ON_DELIVERY` — привязанной картой при получении.    * `CASH_ON_DELIVERY` — наличными.    * `B2B_ACCOUNT_POSTPAYMENT` — заказ оплачивает организация после доставки.  * `UNKNOWN` — неизвестный тип.  Значение по умолчанию: `CASH_ON_DELIVERY`. 
 * @export
 * @enum {string}
 */
export type OrderPaymentMethodType = 'CASH_ON_DELIVERY' | 'CARD_ON_DELIVERY' | 'BOUND_CARD_ON_DELIVERY' | 'YANDEX' | 'APPLE_PAY' | 'EXTERNAL_CERTIFICATE' | 'CREDIT' | 'GOOGLE_PAY' | 'TINKOFF_CREDIT' | 'SBP' | 'TINKOFF_INSTALLMENTS' | 'B2B_ACCOUNT_PREPAYMENT' | 'B2B_ACCOUNT_POSTPAYMENT' | 'UNKNOWN';

/**
 * Тип оплаты заказа:  * `PREPAID` — оплата при оформлении заказа.  * `POSTPAID` — оплата при получении заказа.  * `UNKNOWN` — неизвестный тип.  Если параметр отсутствует, заказ будет оплачен при получении. 
 * @export
 * @enum {string}
 */
export type OrderPaymentType = 'PREPAID' | 'POSTPAID' | 'UNKNOWN';

/**
 * Тип скидки:  * `DIRECT_DISCOUNT` — прямая скидка, которую устанавливает продавец или Маркет.  * `BLUE_SET` — комплекты.  * `BLUE_FLASH` — флеш-акция.  * `MARKET_COUPON` — скидка по промокоду Маркета.  * `MARKET_PROMOCODE` — скидка по промокоду магазина.  * `MARKET_BLUE` — скидка на Маркете.  * `YANDEX_PLUS` — бесплатная доставка с подпиской Яндекс Плюс.  * `YANDEX_EMPLOYEE` — бесплатная доставка по определенным адресам.  * `LIMITED_FREE_DELIVERY_PROMO` — бесплатная доставка по ограниченному предложению.  * `FREE_DELIVERY_THRESHOLD` — бесплатная доставка при достижении определенной суммы заказа.  * `MULTICART_DISCOUNT` — скидка за то, что оформлена мультикорзина.  * `FREE_DELIVERY_FOR_LDI` — бесплатная доставка за то, что один из товаров крупногабаритный.  * `FREE_DELIVERY_FOR_LSC` — бесплатная доставка за то, что одна из корзин в мультикорзине крупногабаритная.  * `FREE_PICKUP` — бесплатная доставка в пункт выдачи заказов.  * `CHEAPEST_AS_GIFT` — самый дешевый товар в подарок.  * `CASHBACK` — кешбэк.  * `SUPPLIER_MULTICART_DISCOUNT` — скидка за доставку.  * `SPREAD_DISCOUNT_COUNT` — скидка за количество одинаковых товаров.  * `SPREAD_DISCOUNT_RECEIPT` — скидка от суммы чека.  * `ANNOUNCEMENT_PROMO` — информационная акция, скидка не применяется к товарам.  * `DISCOUNT_BY_PAYMENT_TYPE` — прямая скидка при оплате картой Плюса.  * `PERCENT_DISCOUNT` — прямая скидка в процентах.  * `DCO_EXTRA_DISCOUNT` — дополнительная скидка, необходимая для расчета субсидии от Маркета.  * `EMPTY_PROMO` — скрытые промокоды.  * `BLOCKING_PROMO` — блокирующее промо.  * `UNKNOWN` — неизвестный тип.  Устаревшие типы:  * `GENERIC_BUNDLE`.  * `MARKET_DEAL`.  * `MARKET_PRIME`.  * `MARKET_COIN`.  * `BERU_PLUS`.  * `PRICE_DROP_AS_YOU_SHOP`.  * `SECRET_SALE`. 
 * @export
 * @enum {string}
 */
export type OrderPromoType = 'DIRECT_DISCOUNT' | 'BLUE_SET' | 'BLUE_FLASH' | 'GENERIC_BUNDLE' | 'MARKET_COUPON' | 'MARKET_PROMOCODE' | 'MARKET_DEAL' | 'MARKET_BLUE' | 'MARKET_PRIME' | 'YANDEX_PLUS' | 'BERU_PLUS' | 'MARKET_COIN' | 'YANDEX_EMPLOYEE' | 'LIMITED_FREE_DELIVERY_PROMO' | 'FREE_DELIVERY_THRESHOLD' | 'MULTICART_DISCOUNT' | 'PRICE_DROP_AS_YOU_SHOP' | 'FREE_DELIVERY_FOR_LDI' | 'FREE_DELIVERY_FOR_LSC' | 'SECRET_SALE' | 'FREE_PICKUP' | 'CHEAPEST_AS_GIFT' | 'CASHBACK' | 'SUPPLIER_MULTICART_DISCOUNT' | 'SPREAD_DISCOUNT_COUNT' | 'SPREAD_DISCOUNT_RECEIPT' | 'ANNOUNCEMENT_PROMO' | 'DISCOUNT_BY_PAYMENT_TYPE' | 'PERCENT_DISCOUNT' | 'DCO_EXTRA_DISCOUNT' | 'EMPTY_PROMO' | 'BLOCKING_PROMO' | 'UNKNOWN';

/**
 * Список посылок.  В параметре может указываться несколько посылок. 
 * @export
 */
export type OrderShipmentDTO = {
    /**
     * Идентификатор посылки, присвоенный Маркетом.
     * @type {number}
     * @memberof OrderShipmentDTO
     */
    id?: number;
    /**
     * Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {string}
     * @memberof OrderShipmentDTO
     */
    shipmentDate?: string;
    /**
     * **Только для модели Экспресс**  Время, к которому магазин должен упаковать заказ и перевести его в статус `READY_TO_SHIP`. После смены статуса за заказом приедет курьер.  Поле может появиться не сразу. Запрашивайте информацию о заказе в течении 5–10 минут, пока оно не вернется.  Формат времени: 24-часовой, `ЧЧ:ММ`.  Если заказ сделан организацией, параметр не возвращается до согласования даты доставки. 
     * @type {string}
     * @memberof OrderShipmentDTO
     */
    shipmentTime?: string;
    /**
     * **Только для модели DBS**  Информация для отслеживания перемещений посылки. 
     * @type {Array<OrderTrackDTO>}
     * @memberof OrderShipmentDTO
     */
    tracks?: Array<OrderTrackDTO>;
    /**
     * Список грузовых мест.
     * @type {Array<OrderParcelBoxDTO>}
     * @memberof OrderShipmentDTO
     */
    boxes?: Array<OrderParcelBoxDTO>;
}

/**
 * Информация по заказу.
 * @export
 */
export type OrderStateDTO = {
    /**
     * Идентификатор заказа.
     * @type {number}
     * @memberof OrderStateDTO
     */
    id: number;
    /**
     * 
     * @type {OrderStatusType}
     * @memberof OrderStateDTO
     */
    status: OrderStatusType;
    /**
     * 
     * @type {OrderSubstatusType}
     * @memberof OrderStateDTO
     */
    substatus?: OrderSubstatusType;
}

/**
 * Текущий статус заказа:  * `CANCELLED_BEFORE_PROCESSING` — заказ отменен до начала его обработки.  * `CANCELLED_IN_DELIVERY` — заказ отменен во время его доставки.  * `CANCELLED_IN_PROCESSING` — заказ отменен во время его обработки.  * `DELIVERY` — заказ передан службе доставки.  * `DELIVERED` — заказ доставлен.  * `PARTIALLY_DELIVERED` — заказ частично доставлен.  * `PARTIALLY_RETURNED` — заказ частично возвращен покупателем.  * `PENDING` — заказ ожидает подтверждения.  * `PICKUP` — заказ доставлен в пункт выдачи.  * `PROCESSING` — заказ в обработке.  * `RESERVED` — товар зарезервирован на складе.  * `RETURNED` — заказ полностью возвращен покупателем.  * `UNKNOWN` — неизвестный статус заказа.  * `UNPAID` — заказ от юридического лица ожидает оплаты.  * `LOST` — заказ утерян. 
 * @export
 * @enum {string}
 */
export type OrderStatsStatusType = 'CANCELLED_BEFORE_PROCESSING' | 'CANCELLED_IN_DELIVERY' | 'CANCELLED_IN_PROCESSING' | 'DELIVERY' | 'DELIVERED' | 'PARTIALLY_DELIVERED' | 'PARTIALLY_RETURNED' | 'PENDING' | 'PICKUP' | 'PROCESSING' | 'RESERVED' | 'RETURNED' | 'UNKNOWN' | 'UNPAID' | 'LOST';

/**
 * Заказ.
 * @export
 */
export type OrderStatusChangeDTO = {
    /**
     * 
     * @type {OrderStatusType}
     * @memberof OrderStatusChangeDTO
     */
    status: OrderStatusType;
    /**
     * 
     * @type {OrderSubstatusType}
     * @memberof OrderStatusChangeDTO
     */
    substatus?: OrderSubstatusType;
    /**
     * 
     * @type {OrderStatusChangeDeliveryDTO}
     * @memberof OrderStatusChangeDTO
     */
    delivery?: OrderStatusChangeDeliveryDTO;
}

/**
 * Информация о доставке.
 * @export
 */
export type OrderStatusChangeDeliveryDTO = {
    /**
     * 
     * @type {OrderStatusChangeDeliveryDatesDTO}
     * @memberof OrderStatusChangeDeliveryDTO
     */
    dates?: OrderStatusChangeDeliveryDatesDTO;
}

/**
 * Диапазон дат доставки.
 * @export
 */
export type OrderStatusChangeDeliveryDatesDTO = {
    /**
     * **Только для модели DBS**  Фактическая дата доставки. <br><br> Когда передавать параметр `realDeliveryDate`:  * Не передавайте параметр, если:   * переводите заказ в любой статус, кроме `PICKUP` или `DELIVERED`;   * меняете статус заказа на `PICKUP` или `DELIVERED` в день доставки — будет указана дата выполнения запроса. * Передавайте дату доставки, если переводите заказ в статус `PICKUP` или `DELIVERED` не в день доставки. Нельзя указывать дату доставки в будущем.    {% note warning \"Индекс качества\" %}    Передача статуса после установленного срока снижает индекс качества. О сроках читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/tech#dbs).    {% endnote %}      
     * @type {Date}
     * @memberof OrderStatusChangeDeliveryDatesDTO
     */
    realDeliveryDate?: Date;
}

/**
 * Статус заказа:  * `CANCELLED` — отменен.  * `DELIVERED` — получен покупателем.  * `DELIVERY` — передан в службу доставки.  * `PICKUP` — доставлен в пункт самовывоза.  * `PROCESSING` — находится в обработке.  * `PENDING` — ожидает обработки со стороны продавца.  * `UNPAID` — оформлен, но еще не оплачен (если выбрана оплата при оформлении).  * `PLACING` — оформляется, подготовка к резервированию.  * `RESERVED` — зарезервирован, но недооформлен.  * `PARTIALLY_RETURNED` — возвращен частично.  * `RETURNED` — возвращен полностью.  * `UNKNOWN` — неизвестный статус.  Также могут возвращаться другие значения. Обрабатывать их не требуется. 
 * @export
 * @enum {string}
 */
export type OrderStatusType = 'PLACING' | 'RESERVED' | 'UNPAID' | 'PROCESSING' | 'DELIVERY' | 'PICKUP' | 'DELIVERED' | 'CANCELLED' | 'PENDING' | 'PARTIALLY_RETURNED' | 'RETURNED' | 'UNKNOWN';

/**
 * Общее вознаграждение партнеру за DBS-доставку и все скидки на товар:  * по промокодам, купонам и акциям; * по баллам Плюса; * по доставке (DBS).  Передается в валюте заказа. 
 * @export
 */
export type OrderSubsidyDTO = {
    /**
     * 
     * @type {OrderSubsidyType}
     * @memberof OrderSubsidyDTO
     */
    type?: OrderSubsidyType;
    /**
     * Сумма субсидии.
     * @type {number}
     * @memberof OrderSubsidyDTO
     */
    amount?: number;
}

/**
 * Тип субсидии:  * `YANDEX_CASHBACK` — скидка по подписке Яндекс Плюс.  * `SUBSIDY` — скидка Маркета (по акциям, промокодам, купонам и т. д.)  * `DELIVERY` — скидка за доставку (DBS). 
 * @export
 * @enum {string}
 */
export type OrderSubsidyType = 'YANDEX_CASHBACK' | 'SUBSIDY' | 'DELIVERY';

/**
 * Этап обработки заказа (если он имеет статус `PROCESSING`) или причина отмены заказа (если он имеет статус `CANCELLED`).  * Значения для заказа в статусе `PROCESSING`:      * `STARTED` — заказ подтвержден, его можно начать обрабатывать.      * `READY_TO_SHIP` — заказ собран и готов к отправке.  * Значения для заказа в статусе `CANCELLED`:      * `PROCESSING_EXPIRED` — значение более не используется.      * `REPLACING_ORDER` — покупатель решил заменить товар другим по собственной инициативе.      * `RESERVATION_EXPIRED` — покупатель не завершил оформление зарезервированного заказа в течение 10 минут.      * `SHOP_FAILED` — магазин не может выполнить заказ.      * `USER_CHANGED_MIND` — покупатель отменил заказ по личным причинам.      * `USER_NOT_PAID` — покупатель не оплатил заказ (для типа оплаты `PREPAID`) в течение 30 минут.      * `USER_REFUSED_DELIVERY` — покупателя не устроили условия доставки.      * `USER_REFUSED_PRODUCT` — покупателю не подошел товар.      * `USER_REFUSED_QUALITY` — покупателя не устроило качество товара.      * `USER_UNREACHABLE` — не удалось связаться с покупателем. Для отмены с этой причиной необходимо выполнить условия:        * не менее 3 звонков с 8 до 21 в часовом поясе покупателя;       * перерыв между первым и третьим звонком не менее 90 минут;       * соединение не короче 5 секунд.        Если хотя бы одно из этих условий не выполнено (кроме случая, когда номер недоступен), отменить заказ не получится. Вернется ответ с кодом ошибки 400.  * `TECHNICAL_ERROR` — техническая ошибка на стороне Маркета. Обратитесь в поддержку.  Также могут возвращаться другие значения. Обрабатывать их не требуется. 
 * @export
 * @enum {string}
 */
export type OrderSubstatusType = 'RESERVATION_EXPIRED' | 'USER_NOT_PAID' | 'USER_UNREACHABLE' | 'USER_CHANGED_MIND' | 'USER_REFUSED_DELIVERY' | 'USER_REFUSED_PRODUCT' | 'SHOP_FAILED' | 'USER_REFUSED_QUALITY' | 'REPLACING_ORDER' | 'PROCESSING_EXPIRED' | 'PENDING_EXPIRED' | 'SHOP_PENDING_CANCELLED' | 'PENDING_CANCELLED' | 'USER_FRAUD' | 'RESERVATION_FAILED' | 'USER_PLACED_OTHER_ORDER' | 'USER_BOUGHT_CHEAPER' | 'MISSING_ITEM' | 'BROKEN_ITEM' | 'WRONG_ITEM' | 'PICKUP_EXPIRED' | 'DELIVERY_PROBLEMS' | 'LATE_CONTACT' | 'CUSTOM' | 'DELIVERY_SERVICE_FAILED' | 'WAREHOUSE_FAILED_TO_SHIP' | 'DELIVERY_SERIVCE_UNDELIVERED' | 'DELIVERY_SERVICE_UNDELIVERED' | 'PREORDER' | 'AWAIT_CONFIRMATION' | 'STARTED' | 'PACKAGING' | 'READY_TO_SHIP' | 'SHIPPED' | 'ASYNC_PROCESSING' | 'USER_REFUSED_TO_PROVIDE_PERSONAL_DATA' | 'WAITING_USER_INPUT' | 'WAITING_BANK_DECISION' | 'BANK_REJECT_CREDIT_OFFER' | 'CUSTOMER_REJECT_CREDIT_OFFER' | 'CREDIT_OFFER_FAILED' | 'AWAIT_DELIVERY_DATES_CONFIRMATION' | 'SERVICE_FAULT' | 'DELIVERY_SERVICE_RECEIVED' | 'USER_RECEIVED' | 'WAITING_FOR_STOCKS' | 'AS_PART_OF_MULTI_ORDER' | 'READY_FOR_LAST_MILE' | 'LAST_MILE_STARTED' | 'ANTIFRAUD' | 'DELIVERY_USER_NOT_RECEIVED' | 'DELIVERY_SERVICE_DELIVERED' | 'DELIVERED_USER_NOT_RECEIVED' | 'USER_WANTED_ANOTHER_PAYMENT_METHOD' | 'USER_RECEIVED_TECHNICAL_ERROR' | 'USER_FORGOT_TO_USE_BONUS' | 'RECEIVED_ON_DISTRIBUTION_CENTER' | 'DELIVERY_SERVICE_NOT_RECEIVED' | 'DELIVERY_SERVICE_LOST' | 'SHIPPED_TO_WRONG_DELIVERY_SERVICE' | 'DELIVERED_USER_RECEIVED' | 'WAITING_TINKOFF_DECISION' | 'COURIER_SEARCH' | 'COURIER_FOUND' | 'COURIER_IN_TRANSIT_TO_SENDER' | 'COURIER_ARRIVED_TO_SENDER' | 'COURIER_RECEIVED' | 'COURIER_NOT_FOUND' | 'COURIER_NOT_DELIVER_ORDER' | 'COURIER_RETURNS_ORDER' | 'COURIER_RETURNED_ORDER' | 'WAITING_USER_DELIVERY_INPUT' | 'PICKUP_SERVICE_RECEIVED' | 'PICKUP_USER_RECEIVED' | 'CANCELLED_COURIER_NOT_FOUND' | 'COURIER_NOT_COME_FOR_ORDER' | 'DELIVERY_NOT_MANAGED_REGION' | 'INCOMPLETE_CONTACT_INFORMATION' | 'INCOMPLETE_MULTI_ORDER' | 'INAPPROPRIATE_WEIGHT_SIZE' | 'TECHNICAL_ERROR' | 'SORTING_CENTER_LOST' | 'COURIER_SEARCH_NOT_STARTED' | 'LOST' | 'AWAIT_PAYMENT' | 'AWAIT_LAVKA_RESERVATION' | 'USER_WANTS_TO_CHANGE_ADDRESS' | 'FULL_NOT_RANSOM' | 'PRESCRIPTION_MISMATCH' | 'DROPOFF_LOST' | 'DROPOFF_CLOSED' | 'DELIVERY_TO_STORE_STARTED' | 'USER_WANTS_TO_CHANGE_DELIVERY_DATE' | 'WRONG_ITEM_DELIVERED' | 'DAMAGED_BOX' | 'AWAIT_DELIVERY_DATES' | 'LAST_MILE_COURIER_SEARCH' | 'PICKUP_POINT_CLOSED' | 'LEGAL_INFO_CHANGED' | 'USER_HAS_NO_TIME_TO_PICKUP_ORDER' | 'DELIVERY_CUSTOMS_ARRIVED' | 'DELIVERY_CUSTOMS_CLEARED' | 'FIRST_MILE_DELIVERY_SERVICE_RECEIVED' | 'AWAIT_AUTO_DELIVERY_DATES' | 'AWAIT_USER_PERSONAL_DATA' | 'NO_PERSONAL_DATA_EXPIRED' | 'CUSTOMS_PROBLEMS' | 'AWAIT_CASHIER' | 'WAITING_POSTPAID_BUDGET_RESERVATION' | 'AWAIT_SERVICEABLE_CONFIRMATION' | 'POSTPAID_BUDGET_RESERVATION_FAILED' | 'AWAIT_CUSTOM_PRICE_CONFIRMATION' | 'READY_FOR_PICKUP' | 'UNKNOWN';

/**
 * Система налогообложения (СНО) магазина на момент оформления заказа:  * `ECHN` — единый сельскохозяйственный налог (ЕСХН).  * `ENVD` — единый налог на вмененный доход (ЕНВД).  * `OSN` — общая система налогообложения (ОСН).  * `PSN` — патентная система налогообложения (ПСН).  * `USN` — упрощенная система налогообложения (УСН).  * `USN_MINUS_COST` — упрощенная система налогообложения, доходы, уменьшенные на величину расходов (УСН «Доходы минус расходы»).  * `NPD` — налог на профессиональный доход (НПД).  * `UNKNOWN_VALUE` — неизвестное значение. Используется только совместно с параметром `payment-method=YANDEX`. 
 * @export
 * @enum {string}
 */
export type OrderTaxSystemType = 'OSN' | 'USN' | 'USN_MINUS_COST' | 'ENVD' | 'ECHN' | 'PSN' | 'NPD' | 'UNKNOWN_VALUE';

/**
 * Информация о трек-номере посылки (DBS).
 * @export
 */
export type OrderTrackDTO = {
    /**
     * Трек‑номер посылки.
     * @type {string}
     * @memberof OrderTrackDTO
     */
    trackCode?: string;
    /**
     * Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
     * @type {number}
     * @memberof OrderTrackDTO
     */
    deliveryServiceId?: number;
}

/**
 * Изменился ли статус заказа:  * `OK` — статус изменен.  * `ERROR` — статус не изменен. В этом случае появится сообщение об ошибке в параметре `errorDetails`. 
 * @export
 * @enum {string}
 */
export type OrderUpdateStatusType = 'OK' | 'ERROR';

/**
 * Ставка налога на добавленную стоимость (НДС) на товар:  * `NO_VAT` — НДС не облагается, используется только для отдельных видов услуг.  * `VAT_0` — НДС 0%. Например, используется при продаже товаров, вывезенных в таможенной процедуре экспорта, или при оказании услуг по международной перевозке товаров.  * `VAT_10` — НДС 10%. Например, используется при реализации отдельных продовольственных и медицинских товаров.  * `VAT_10_110` — НДС 10/110. Расчетная ставка НДС 10%, применяется только при предоплате.  * `VAT_20` — НДС 20%. Основная ставка с 2019 года.  * `VAT_20_120` — НДС 20/120. Расчетная ставка НДС 20%, применяется только при предоплате.  * `VAT_18` — НДС 18%. Основная ставка до 2019 года.  * `VAT_18_118` — НДС 18/118. Ставка использовалась до 1 января 2019 года при предоплате.  * `UNKNOWN_VALUE` — неизвестный тип.  Используется только совместно с параметром `payment-method=YANDEX`. 
 * @export
 * @enum {string}
 */
export type OrderVatType = 'NO_VAT' | 'VAT_0' | 'VAT_10' | 'VAT_10_110' | 'VAT_20' | 'VAT_20_120' | 'VAT_18' | 'VAT_18_118' | 'UNKNOWN_VALUE';

/**
 * Годные/негодные ярлыки по заказам в отгрузке.
 * @export
 */
export type OrdersShipmentInfoDTO = {
    /**
     * Идентификаторы заказов в отгрузке, для которых можно распечатать ярлыки.
     * @type {Set<number>}
     * @memberof OrdersShipmentInfoDTO
     */
    orderIdsWithLabels: Set<number>;
    /**
     * Идентификаторы заказов в отгрузке, для которых нельзя распечатать ярлыки.
     * @type {Set<number>}
     * @memberof OrdersShipmentInfoDTO
     */
    orderIdsWithoutLabels: Set<number>;
}

/**
 * Информация о стоимости услуг.
 * @export
 */
export type OrdersStatsCommissionDTO = {
    /**
     * 
     * @type {OrdersStatsCommissionType}
     * @memberof OrdersStatsCommissionDTO
     */
    type?: OrdersStatsCommissionType;
    /**
     * Сумма в рублях, которая была выставлена в момент создания заказа и которую нужно оплатить. Точность — два знака после запятой. 
     * @type {number}
     * @memberof OrdersStatsCommissionDTO
     */
    actual?: number;
}

/**
 * Услуга:  * `FEE` — размещение товара на Маркете. * `FULFILLMENT` — складская обработка. Не возвращается с 1 января 2024 года. * `LOYALTY_PARTICIPATION_FEE` — участие в программе лояльности и отзывы за баллы. * `AUCTION_PROMOTION` — буст продаж с оплатой за продажи. * `INSTALLMENT` — рассрочка. Не возвращается с 24 февраля 2022 года. * `DELIVERY_TO_CUSTOMER` — доставка покупателю (FBY, FBS). Для DBS и Экспресс — если заказ возвращается через логистику Маркета. * `EXPRESS_DELIVERY_TO_CUSTOMER` — экспресс-доставка покупателю (Экспресс). * `AGENCY` — прием платежа покупателя. * `PAYMENT_TRANSFER` — перевод платежа покупателя. * `RETURNED_ORDERS_STORAGE` — хранение невыкупов и возвратов (FBS). Для DBS и Экспресс — если заказ возвращается через логистику Маркета. * `SORTING` — обработка заказа (FBS). * `INTAKE_SORTING` — организация забора заказов со склада продавца (FBS). * `RETURN_PROCESSING` — обработка заказов на складе (FBS). Для DBS и Экспресс — если заказ возвращается через логистику Маркета. * `ILLIQUID_GOODS_SALE` — вознаграждение за продажу невывезенных товаров. 
 * @export
 * @enum {string}
 */
export type OrdersStatsCommissionType = 'FEE' | 'FULFILLMENT' | 'LOYALTY_PARTICIPATION_FEE' | 'AUCTION_PROMOTION' | 'INSTALLMENT' | 'DELIVERY_TO_CUSTOMER' | 'EXPRESS_DELIVERY_TO_CUSTOMER' | 'AGENCY' | 'PAYMENT_TRANSFER' | 'RETURNED_ORDERS_STORAGE' | 'SORTING' | 'INTAKE_SORTING' | 'RETURN_PROCESSING' | 'ILLIQUID_GOODS_SALE';

/**
 * Информация по заказам.
 * @export
 */
export type OrdersStatsDTO = {
    /**
     * Список заказов.
     * @type {Array<OrdersStatsOrderDTO>}
     * @memberof OrdersStatsDTO
     */
    orders: Array<OrdersStatsOrderDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof OrdersStatsDTO
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Информация о регионе доставки.
 * @export
 */
export type OrdersStatsDeliveryRegionDTO = {
    /**
     * Идентификатор региона доставки.
     * @type {number}
     * @memberof OrdersStatsDeliveryRegionDTO
     */
    id?: number;
    /**
     * Название региона доставки.
     * @type {string}
     * @memberof OrdersStatsDeliveryRegionDTO
     */
    name?: string;
}

/**
 * Информация об удалении товара из заказа.
 * @export
 */
export type OrdersStatsDetailsDTO = {
    /**
     * 
     * @type {OrdersStatsItemStatusType}
     * @memberof OrdersStatsDetailsDTO
     */
    itemStatus?: OrdersStatsItemStatusType;
    /**
     * Количество товара со статусом, указанном в параметре `itemStatus`.
     * @type {number}
     * @memberof OrdersStatsDetailsDTO
     */
    itemCount?: number;
    /**
     * Дата, когда товар получил статус, указанный в параметре `itemStatus`.  Формат даты: `ГГГГ-ММ-ДД`. 
     * @type {Date}
     * @memberof OrdersStatsDetailsDTO
     */
    updateDate?: Date;
    /**
     * 
     * @type {OrdersStatsStockType}
     * @memberof OrdersStatsDetailsDTO
     */
    stockType?: OrdersStatsStockType;
}

/**
 * Список товаров в заказе после возможных изменений.  В ходе обработки заказа Маркет может удалить из него единицы товаров — при проблемах на складе или по инициативе пользователя.  * Если из заказа удалены все единицы товара, его не будет в списке `items` — только в списке `initialItems`.  * Если в заказе осталась хотя бы одна единица товара, он будет и в списке `items` (с уменьшенным количеством единиц `count`), и в списке `initialItems` (с первоначальным количеством единиц `initialCount`). 
 * @export
 */
export type OrdersStatsItemDTO = {
    /**
     * Название товара.
     * @type {string}
     * @memberof OrdersStatsItemDTO
     */
    offerName?: string;
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof OrdersStatsItemDTO
     */
    marketSku?: number;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof OrdersStatsItemDTO
     */
    shopSku?: string;
    /**
     * Количество единиц товара с учетом удаленных единиц.  Если из заказа удалены все единицы товара, он попадет только в список `initialItems`. 
     * @type {number}
     * @memberof OrdersStatsItemDTO
     */
    count?: number;
    /**
     * Цена или скидки на товар.
     * @type {Array<OrdersStatsPriceDTO>}
     * @memberof OrdersStatsItemDTO
     */
    prices?: Array<OrdersStatsPriceDTO>;
    /**
     * 
     * @type {OrdersStatsWarehouseDTO}
     * @memberof OrdersStatsItemDTO
     */
    warehouse?: OrdersStatsWarehouseDTO;
    /**
     * Информация об удалении товара из заказа.
     * @type {Array<OrdersStatsDetailsDTO>}
     * @memberof OrdersStatsItemDTO
     */
    details?: Array<OrdersStatsDetailsDTO>;
    /**
     * Список кодов идентификации товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).
     * @type {Array<string>}
     * @memberof OrdersStatsItemDTO
     */
    cisList?: Array<string>;
    /**
     * Первоначальное количество единиц товара.
     * @type {number}
     * @memberof OrdersStatsItemDTO
     */
    initialCount?: number;
    /**
     * Списанная ставка ближайшего конкурента.  Указывается в процентах от стоимости товара и умножается на 100. Например, ставка 5% обозначается как 500. 
     * @type {number}
     * @memberof OrdersStatsItemDTO
     */
    bidFee?: number;
    /**
     * Порог для скидок с Маркетом на момент оформления заказа. [Что это такое?](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  Указан в рублях. Точность — два знака после запятой. 
     * @type {number}
     * @memberof OrdersStatsItemDTO
     */
    cofinanceThreshold?: number;
    /**
     * Скидка с Маркетом. [Что это такое?](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  Указана в рублях. Точность — два знака после запятой. 
     * @type {number}
     * @memberof OrdersStatsItemDTO
     */
    cofinanceValue?: number;
}

/**
 * Статус товара:  * `REJECTED` — товар был добавлен в созданный заказ, но не был оплачен. * `RETURNED` — товар вернули. 
 * @export
 * @enum {string}
 */
export type OrdersStatsItemStatusType = 'REJECTED' | 'RETURNED';

/**
 * Информация о заказе.
 * @export
 */
export type OrdersStatsOrderDTO = {
    /**
     * Идентификатор заказа.
     * @type {number}
     * @memberof OrdersStatsOrderDTO
     */
    id?: number;
    /**
     * Дата создания заказа.  Формат даты: `ГГГГ-ММ-ДД`. 
     * @type {Date}
     * @memberof OrdersStatsOrderDTO
     */
    creationDate?: Date;
    /**
     * Дата и время, когда статус заказа был изменен в последний раз.  Формат даты и времени: ISO 8601. Например, `2017-11-21T00:00:00`. Часовой пояс — UTC+03:00 (Москва). 
     * @type {Date}
     * @memberof OrdersStatsOrderDTO
     */
    statusUpdateDate?: Date;
    /**
     * 
     * @type {OrderStatsStatusType}
     * @memberof OrdersStatsOrderDTO
     */
    status?: OrderStatsStatusType;
    /**
     * Идентификатор заказа в информационной системе магазина.
     * @type {string}
     * @memberof OrdersStatsOrderDTO
     */
    partnerOrderId?: string;
    /**
     * 
     * @type {OrdersStatsOrderPaymentType}
     * @memberof OrdersStatsOrderDTO
     */
    paymentType?: OrdersStatsOrderPaymentType;
    /**
     * Тип заказа:  * `false` — настоящий заказ покупателя.  * `true` — [тестовый](../../pushapi/concepts/sandbox.md) заказ Маркета. 
     * @type {boolean}
     * @memberof OrdersStatsOrderDTO
     */
    fake?: boolean;
    /**
     * 
     * @type {OrdersStatsDeliveryRegionDTO}
     * @memberof OrdersStatsOrderDTO
     */
    deliveryRegion?: OrdersStatsDeliveryRegionDTO;
    /**
     * Список товаров в заказе после возможных изменений.
     * @type {Array<OrdersStatsItemDTO>}
     * @memberof OrdersStatsOrderDTO
     */
    items: Array<OrdersStatsItemDTO>;
    /**
     * Список товаров в заказе до изменений.
     * @type {Array<OrdersStatsItemDTO>}
     * @memberof OrdersStatsOrderDTO
     */
    initialItems?: Array<OrdersStatsItemDTO>;
    /**
     * Информация о денежных переводах по заказу.
     * @type {Array<OrdersStatsPaymentDTO>}
     * @memberof OrdersStatsOrderDTO
     */
    payments: Array<OrdersStatsPaymentDTO>;
    /**
     * Информация о комиссиях за заказ.
     * @type {Array<OrdersStatsCommissionDTO>}
     * @memberof OrdersStatsOrderDTO
     */
    commissions: Array<OrdersStatsCommissionDTO>;
}

/**
 * Тип оплаты заказа: - `CREDIT` — заказ оформлен в кредит. - `POSTPAID` — заказ оплачен после того, как был получен. - `PREPAID` — заказ оплачен до того, как был получен. 
 * @export
 * @enum {string}
 */
export type OrdersStatsOrderPaymentType = 'CREDIT' | 'POSTPAID' | 'PREPAID' | 'TINKOFF_CREDIT';

/**
 * Информация о денежных переводах по заказу.
 * @export
 */
export type OrdersStatsPaymentDTO = {
    /**
     * Идентификатор денежного перевода.
     * @type {string}
     * @memberof OrdersStatsPaymentDTO
     */
    id?: string;
    /**
     * Дата денежного перевода.  Формат даты: `ГГГГ-ММ-ДД`. 
     * @type {Date}
     * @memberof OrdersStatsPaymentDTO
     */
    _date?: Date;
    /**
     * 
     * @type {OrdersStatsPaymentType}
     * @memberof OrdersStatsPaymentDTO
     */
    type?: OrdersStatsPaymentType;
    /**
     * 
     * @type {OrdersStatsPaymentSourceType}
     * @memberof OrdersStatsPaymentDTO
     */
    source?: OrdersStatsPaymentSourceType;
    /**
     * Сумма денежного перевода. Значение указывается в рублях независимо от способа денежного перевода. Точность — два знака после запятой. 
     * @type {number}
     * @memberof OrdersStatsPaymentDTO
     */
    total?: number;
    /**
     * 
     * @type {OrdersStatsPaymentOrderDTO}
     * @memberof OrdersStatsPaymentDTO
     */
    paymentOrder?: OrdersStatsPaymentOrderDTO;
}

/**
 * Информация о платежном получении.
 * @export
 */
export type OrdersStatsPaymentOrderDTO = {
    /**
     * Номер платежного поручения.
     * @type {string}
     * @memberof OrdersStatsPaymentOrderDTO
     */
    id?: string;
    /**
     * Дата платежного поручения.  Формат даты: `ГГГГ‑ММ‑ДД`. 
     * @type {Date}
     * @memberof OrdersStatsPaymentOrderDTO
     */
    _date?: Date;
}

/**
 * Способ денежного перевода: - `BUYER` — оплата или возврат деньгами. - `CASHBACK` — оплата или возврат баллами Плюса. - `MARKETPLACE` — оплата или возврат купонами. - `SPLIT` — оплата картой по частям (Сплит). 
 * @export
 * @enum {string}
 */
export type OrdersStatsPaymentSourceType = 'BUYER' | 'CASHBACK' | 'MARKETPLACE' | 'SPLIT';

/**
 * Тип денежного перевода: - `PAYMENT` — оплата. - `REFUND` — возврат. 
 * @export
 * @enum {string}
 */
export type OrdersStatsPaymentType = 'PAYMENT' | 'REFUND' | 'UNKNOWN';

/**
 * Цена или скидки на товар.
 * @export
 */
export type OrdersStatsPriceDTO = {
    /**
     * 
     * @type {OrdersStatsPriceType}
     * @memberof OrdersStatsPriceDTO
     */
    type?: OrdersStatsPriceType;
    /**
     * Цена или скидка на единицу товара в заказе. Указана в рублях. Точность — два знака после запятой. 
     * @type {number}
     * @memberof OrdersStatsPriceDTO
     */
    costPerItem?: number;
    /**
     * Суммарная цена или скидка на все единицы товара в заказе. Указана в рублях. Точность — два знака после запятой. 
     * @type {number}
     * @memberof OrdersStatsPriceDTO
     */
    total?: number;
}

/**
 * Тип скидки или цена на товар: - `BUYER` — цена на товар с учетом скидок, в том числе купонов. - `CASHBACK` — баллы Плюса. - `MARKETPLACE` — купоны. 
 * @export
 * @enum {string}
 */
export type OrdersStatsPriceType = 'BUYER' | 'CASHBACK' | 'MARKETPLACE';

/**
 * Тип товара:  * `DEFECT` — товар бракованный.  * `FIT` — товар надлежащего качества. 
 * @export
 * @enum {string}
 */
export type OrdersStatsStockType = 'FIT' | 'FREEZE' | 'AVAILABLE' | 'QUARANTINE' | 'UTILIZATION' | 'DEFECT' | 'EXPIRED';

/**
 * Информация о складе, на котором хранится товар.
 * @export
 */
export type OrdersStatsWarehouseDTO = {
    /**
     * Идентификатор склада.
     * @type {number}
     * @memberof OrdersStatsWarehouseDTO
     */
    id?: number;
    /**
     * Название склада.
     * @type {string}
     * @memberof OrdersStatsWarehouseDTO
     */
    name?: string;
}

/**
 * Адрес точки продаж. 
 * @export
 */
export type OutletAddressDTO = {
    /**
     * Идентификатор региона.  Идентификатор можно получить c помощью запроса [GET regions](../../reference/regions/searchRegionsByName.md).  {% note alert %}  При создании и редактировании точек продаж можно указывать только регионы типов `TOWN` (город), `CITY` (крупный город) и `REPUBLIC_AREA` (район субъекта федерации). Тип региона указан в выходных параметрах type запросов [GET regions](../../reference/regions/searchRegionsByName.md) и [GET regions/{regionId}](../../reference/regions/searchRegionsById.md).  {% endnote %} 
     * @type {number}
     * @memberof OutletAddressDTO
     */
    regionId: number;
    /**
     * Улица.
     * @type {string}
     * @memberof OutletAddressDTO
     */
    street?: string;
    /**
     * Номер дома.
     * @type {string}
     * @memberof OutletAddressDTO
     */
    _number?: string;
    /**
     * Номер строения.
     * @type {string}
     * @memberof OutletAddressDTO
     */
    building?: string;
    /**
     * Номер владения.
     * @type {string}
     * @memberof OutletAddressDTO
     */
    estate?: string;
    /**
     * Номер корпуса.
     * @type {string}
     * @memberof OutletAddressDTO
     */
    block?: string;
    /**
     * Дополнительная информация.
     * @type {string}
     * @memberof OutletAddressDTO
     */
    additional?: string;
    /**
     * Порядковый номер километра дороги, на котором располагается точка продаж, если отсутствует улица.
     * @type {number}
     * @memberof OutletAddressDTO
     */
    km?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его. Город или населенный пункт возвращается в параметре `regionId`.  {% endnote %} 
     * @type {string}
     * @memberof OutletAddressDTO
     */
    city?: string;
}

/**
 * Информация о точке продаж.
 * @export
 */
export type OutletDTO = {
    /**
     * Название точки продаж. 
     * @type {string}
     * @memberof OutletDTO
     */
    name: string;
    /**
     * 
     * @type {OutletType}
     * @memberof OutletDTO
     */
    type: OutletType;
    /**
     * Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, `20.4522144, 54.7104264`.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в `address`. 
     * @type {string}
     * @memberof OutletDTO
     */
    coords?: string;
    /**
     * Признак основной точки продаж.  Возможные значения:  * `false` — неосновная точка продаж. * `true` — основная точка продаж. 
     * @type {boolean}
     * @memberof OutletDTO
     */
    isMain?: boolean;
    /**
     * Идентификатор точки продаж, присвоенный магазином.
     * @type {string}
     * @memberof OutletDTO
     */
    shopOutletCode?: string;
    /**
     * 
     * @type {OutletVisibilityType}
     * @memberof OutletDTO
     */
    visibility?: OutletVisibilityType;
    /**
     * 
     * @type {OutletAddressDTO}
     * @memberof OutletDTO
     */
    address: OutletAddressDTO;
    /**
     * Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`. 
     * @type {Array<string>}
     * @memberof OutletDTO
     */
    phones: Array<string>;
    /**
     * 
     * @type {OutletWorkingScheduleDTO}
     * @memberof OutletDTO
     */
    workingSchedule: OutletWorkingScheduleDTO;
    /**
     * Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр `type=DEPOT` или `type=MIXED`. 
     * @type {Array<OutletDeliveryRuleDTO>}
     * @memberof OutletDTO
     */
    deliveryRules?: Array<OutletDeliveryRuleDTO>;
    /**
     * Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях.
     * @type {number}
     * @memberof OutletDTO
     */
    storagePeriod?: number;
}

/**
 * Информация об условиях доставки для данной точки продаж.
 * @export
 */
export type OutletDeliveryRuleDTO = {
    /**
     * Минимальный срок доставки товаров в точку продаж. Указан в рабочих днях.  Минимальное значение: `0` — доставка в день заказа.  Максимальное значение: `60`.  Допустимые сроки доставки (разница между `minDeliveryDays` и `maxDeliveryDays`) зависят от региона.  Для доставки по своему региону разница не должна превышать двух дней. Например, если `minDeliveryDays` равно 1, то для `maxDeliveryDays` допускаются значения от 1 до 3.  Для доставки в другие регионы:  * Если `minDeliveryDays` до 18 дней, разница не должна превышать четырех дней. Например, если `minDeliveryDays` равно 10, то для `maxDeliveryDays` допускаются значения от 10 до 14. * Если `minDeliveryDays` больше 18 дней, разница должна быть не больше чем в два раза. Например, если `minDeliveryDays` равно 21, то для `maxDeliveryDays` допускаются значения от 21 до 42.  Обязательный параметр, если `type=\"DEPOT\"` или `type=\"MIXED\"`.  Взаимоисключающий с параметром `unspecifiedDeliveryInterval`. 
     * @type {number}
     * @memberof OutletDeliveryRuleDTO
     */
    minDeliveryDays?: number;
    /**
     * Максимальный срок доставки товаров в точку продаж. Указан в рабочих днях.  Минимальное значение: `0` — доставка в день заказа.  Максимальное значение: `60`.  Допустимые сроки доставки (разница между `minDeliveryDays` и `maxDeliveryDays`) зависят от региона.  Для доставки по своему региону разница не должна превышать двух дней. Например, если `minDeliveryDays` равно 1, то для `maxDeliveryDays` допускаются значения от 1 до 3.  Для доставки в другие регионы:  * Если `minDeliveryDays` до 18 дней, разница не должна превышать четырех дней. Например, если `minDeliveryDays` равно 10, то для `maxDeliveryDays` допускаются значения от 10 до 14. * Если `minDeliveryDays` больше 18 дней, разница должна быть не больше чем в два раза. Например, если `minDeliveryDays` равно 21, то для `maxDeliveryDays` допускаются значения от 21 до 42.  Обязательный параметр, если `type=\"DEPOT\"` или `type=\"MIXED\"`.  Взаимоисключающий с параметром `unspecifiedDeliveryInterval`. 
     * @type {number}
     * @memberof OutletDeliveryRuleDTO
     */
    maxDeliveryDays?: number;
    /**
     * Идентификатор службы доставки товаров в точку продаж.  Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md). 
     * @type {number}
     * @memberof OutletDeliveryRuleDTO
     */
    deliveryServiceId?: number;
    /**
     * Час, до которого покупателю нужно сделать заказ, чтобы он был доставлен в точку продаж в сроки от `minDeliveryDays` до `maxDeliveryDays`.  Если покупатель оформит заказ после указанного часа, он будет доставлен в сроки от `minDeliveryDays` + 1 рабочий день до `maxDeliveryDays` + 1 рабочий день.  Значение по умолчанию: `24`. 
     * @type {number}
     * @memberof OutletDeliveryRuleDTO
     */
    orderBefore?: number;
    /**
     * Цена на товар, начиная с которой действует бесплатный самовывоз товара из точки продаж.
     * @type {number}
     * @memberof OutletDeliveryRuleDTO
     */
    priceFreePickup?: number;
    /**
     * Признак доставки товаров в точку продаж на заказ.  Признак выставлен, если:  * точный срок доставки в точку продаж заранее неизвестен (например, если магазин собирает несколько заказов для отправки в точку или населенный пункт); * все товары изготавливаются или поставляются на заказ.  Возможные значения: * `true` — товары доставляются в точку продаж на заказ.  Параметр указывается только со значением `true`.  Взаимоисключающий с параметрами `minDeliveryDays` и `maxDeliveryDays`. 
     * @type {boolean}
     * @memberof OutletDeliveryRuleDTO
     */
    unspecifiedDeliveryInterval?: boolean;
}

/**
 * Информация о лицензии.
 * @export
 */
export type OutletLicenseDTO = {
    /**
     * Идентификатор лицензии.  Параметр указывается, только если нужно изменить информацию о существующей лицензии. Ее идентификатор можно узнать с помощью запроса [GET campaigns/{campaignId}/outlets/licenses](../../reference/outlets/getOutletLicenses.md). При передаче информации о новой лицензии указывать идентификатор не нужно.  Идентификатор лицензии присваивается Маркетом. Не путайте его с номером, указанным на лицензии: он передается в параметре `number`. 
     * @type {number}
     * @memberof OutletLicenseDTO
     */
    id?: number;
    /**
     * Идентификатор точки продаж, для которой действительна лицензия.
     * @type {number}
     * @memberof OutletLicenseDTO
     */
    outletId?: number;
    /**
     * 
     * @type {LicenseType}
     * @memberof OutletLicenseDTO
     */
    licenseType?: LicenseType;
    /**
     * Номер лицензии.
     * @type {string}
     * @memberof OutletLicenseDTO
     */
    _number?: string;
    /**
     * Дата выдачи лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время `00:00:00` и часовой пояс, соответствующий региону точки продаж. Например, если лицензия для точки продаж в Москве выдана 13 ноября 2017 года, то параметр должен иметь значение `2017-11-13T00:00:00+03:00`.  Обязательный параметр.  Не может быть позже даты окончания срока действия, указанной в параметре `dateOfExpiry`. 
     * @type {Date}
     * @memberof OutletLicenseDTO
     */
    dateOfIssue?: Date;
    /**
     * Дата окончания действия лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время `00:00:00` и часовой пояс, соответствующий региону точки продаж. Например, если действие лицензии для точки продаж в Москве заканчивается 20 ноября 2022 года, то параметр должен иметь значение `2022-11-20T00:00:00+03:00`.  Обязательный параметр.  Не может быть раньше даты выдачи, указанной в параметре `dateOfIssue`. 
     * @type {Date}
     * @memberof OutletLicenseDTO
     */
    dateOfExpiry?: Date;
}

/**
 * Ответ на запрос информации о лицензиях для точек продаж.
 * @export
 */
export type OutletLicensesResponseDTO = {
    /**
     * Список лицензий.
     * @type {Array<FullOutletLicenseDTO>}
     * @memberof OutletLicensesResponseDTO
     */
    licenses: Array<FullOutletLicenseDTO>;
}

/**
 * Результат выполнения запроса. Выводится, если `status=\"OK\"`. 
 * @export
 */
export type OutletResponseDTO = {
    /**
     * Идентификатор точки продаж, присвоенный Маркетом.
     * @type {number}
     * @memberof OutletResponseDTO
     */
    id?: number;
}

/**
 * Статус точки продаж.  Возможные значения:  * `AT_MODERATION` — проверяется. * `FAILED` — не прошла проверку и отклонена модератором. * `MODERATED` — проверена и одобрена. * `NONMODERATED` — новая точка, нуждается в проверке. 
 * @export
 * @enum {string}
 */
export type OutletStatusType = 'AT_MODERATION' | 'FAILED' | 'MODERATED' | 'NONMODERATED' | 'UNKNOWN';

/**
 * Тип точки продаж.  Возможные значения:  * `DEPOT` — пункт выдачи заказов. * `MIXED` — смешанный тип точки продаж (торговый зал и пункт выдачи заказов). * `RETAIL` — розничная точка продаж (торговый зал). 
 * @export
 * @enum {string}
 */
export type OutletType = 'DEPOT' | 'MIXED' | 'RETAIL' | 'NOT_DEFINED';

/**
 * Состояние точки продаж.  Возможные значения:  * `HIDDEN` — точка продаж выключена. * `VISIBLE` — точка продаж включена. 
 * @export
 * @enum {string}
 */
export type OutletVisibilityType = 'HIDDEN' | 'VISIBLE' | 'UNKNOWN';

/**
 * Список режимов работы точки продаж. 
 * @export
 */
export type OutletWorkingScheduleDTO = {
    /**
     * Признак, работает ли точка продаж в дни государственных праздников.  Возможные значения:  * `false` — точка продаж не работает в дни государственных праздников. * `true` — точка продаж работает в дни государственных праздников. 
     * @type {boolean}
     * @memberof OutletWorkingScheduleDTO
     */
    workInHoliday?: boolean;
    /**
     * Список расписаний работы точки продаж. 
     * @type {Array<OutletWorkingScheduleItemDTO>}
     * @memberof OutletWorkingScheduleDTO
     */
    scheduleItems: Array<OutletWorkingScheduleItemDTO>;
}

/**
 * Расписание работы точки продаж.
 * @export
 */
export type OutletWorkingScheduleItemDTO = {
    /**
     * 
     * @type {DayOfWeekType}
     * @memberof OutletWorkingScheduleItemDTO
     */
    startDay: DayOfWeekType;
    /**
     * 
     * @type {DayOfWeekType}
     * @memberof OutletWorkingScheduleItemDTO
     */
    endDay: DayOfWeekType;
    /**
     * Точка продаж работает c указанного часа.  Формат: `ЧЧ:ММ`. 
     * @type {string}
     * @memberof OutletWorkingScheduleItemDTO
     */
    startTime: string;
    /**
     * Точка продаж работает до указанного часа.  Формат: `ЧЧ:ММ`. 
     * @type {string}
     * @memberof OutletWorkingScheduleItemDTO
     */
    endTime: string;
}

/**
 * Размещение ярлыков на странице: * `A7` — в PDF-файле будут страницы формата близкому к A7. На каждой странице размещается ярлык размером 75 × 120 мм (80,4 × 125,6 мм с учетом полей). * `A4` — в PDF-файле будут страницы формата A4. На каждой странице размещаются восемь ярлыков размером 70,6 × 99,1 мм без полей. 
 * @export
 * @enum {string}
 */
export type PageFormatType = 'A7' | 'A4';

/**
 * Возвраты.
 * @export
 */
export type PagedReturnsDTO = {
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof PagedReturnsDTO
     */
    paging?: ForwardScrollingPagerDTO;
    /**
     * Список возвратов.
     * @type {Array<ReturnDTO>}
     * @memberof PagedReturnsDTO
     */
    returns: Array<ReturnDTO>;
}

/**
 * Количество палет в отгрузке.
 * @export
 */
export type PalletsCountDTO = {
    /**
     * Количество палет, которое заявил продавец.
     * @type {number}
     * @memberof PalletsCountDTO
     */
    planned?: number;
    /**
     * Количество палет, которое приняли в сортировочном центре.
     * @type {number}
     * @memberof PalletsCountDTO
     */
    fact?: number;
}

/**
 * Тип данных:  * `TEXT` — текст. * `ENUM` — список возможных значений. * `BOOLEAN` — `true` или `false`. * `NUMERIC` — число. 
 * @export
 * @enum {string}
 */
export type ParameterType = 'TEXT' | 'ENUM' | 'BOOLEAN' | 'NUMERIC';

/**
 * Ограничения на значения характеристик.
 * @export
 */
export type ParameterValueConstraintsDTO = {
    /**
     * Минимальное число.
     * @type {number}
     * @memberof ParameterValueConstraintsDTO
     */
    minValue?: number;
    /**
     * Максимальное число.
     * @type {number}
     * @memberof ParameterValueConstraintsDTO
     */
    maxValue?: number;
    /**
     * Максимальная длина текста.
     * @type {number}
     * @memberof ParameterValueConstraintsDTO
     */
    maxLength?: number;
}

/**
 * Значение характеристики.  Вы можете указывать несколько значений одной характеристики при условии, что:  * Тип характеристики — `ENUM`. * В ответе на запрос [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md) у данной характеристики поле `multivalue` имеет значение `true`.  Для этого в `parameterValues` передавайте каждое значение отдельно — несколько объектов с параметрами `parameterId`, `valueId` и `value`. Параметр `parameterId` должен быть одинаковым. 
 * @export
 */
export type ParameterValueDTO = {
    /**
     * Идентификатор характеристики.
     * @type {number}
     * @memberof ParameterValueDTO
     */
    parameterId: number;
    /**
     * Идентификатор единицы измерения. Если вы не передали параметр `unitId`, используется единица измерения по умолчанию.
     * @type {number}
     * @memberof ParameterValueDTO
     */
    unitId?: number;
    /**
     * Идентификатор значения.  Обязательно указывайте идентификатор, если передаете значение из перечня допустимых значений, полученного от Маркета.  Только для характеристик типа `ENUM`. 
     * @type {number}
     * @memberof ParameterValueDTO
     */
    valueId?: number;
    /**
     * Значение.
     * @type {string}
     * @memberof ParameterValueDTO
     */
    value?: string;
}

/**
 * Значение характеристики.
 * @export
 */
export type ParameterValueOptionDTO = {
    /**
     * Идентификатор значения.
     * @type {number}
     * @memberof ParameterValueOptionDTO
     */
    id: number;
    /**
     * Значение.
     * @type {string}
     * @memberof ParameterValueOptionDTO
     */
    value: string;
    /**
     * Описание значения.
     * @type {string}
     * @memberof ParameterValueOptionDTO
     */
    description?: string;
}

/**
 * Элемент отображает одно грузовое место. Вложенные поля больше не используются, передавайте элемент пустым в запросах и не обращайте внимание на содержимое в ответах.
 * @export
 */
export type ParcelBoxDTO = {
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %} 
     * @type {number}
     * @memberof ParcelBoxDTO
     */
    id?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %} 
     * @type {string}
     * @memberof ParcelBoxDTO
     */
    fulfilmentId?: string;
}

/**
 * Информация о ярлыке для коробки.
 * @export
 */
export type ParcelBoxLabelDTO = {
    /**
     * Соответствует URL, по которому выполняется запрос [GET campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label](../../reference/orders/generateOrderLabel.md). 
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    url: string;
    /**
     * Юридическое название магазина.
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    supplierName: string;
    /**
     * Юридическое название службы доставки.
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    deliveryServiceName: string;
    /**
     * Идентификатор заказа в системе Маркета.
     * @type {number}
     * @memberof ParcelBoxLabelDTO
     */
    orderId: number;
    /**
     * Идентификатор заказа в информационной системе магазина.  Совпадает с `orderId`, если Маркету неизвестен номер заказа в системе магазина. 
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    orderNum: string;
    /**
     * Фамилия и инициалы получателя заказа.
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    recipientName: string;
    /**
     * Идентификатор коробки.
     * @type {number}
     * @memberof ParcelBoxLabelDTO
     */
    boxId: number;
    /**
     * Идентификатор коробки в информационной системе магазина.  Возвращается в формате: `номер заказа на Маркете-номер коробки`. Например, `7206821‑1`, `7206821‑2` и т. д. 
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    fulfilmentId: string;
    /**
     * Номер коробки в заказе. Возвращается в формате: `номер места/общее количество мест`. 
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    place: string;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Общая масса всех товаров в заказе. Возвращается в формате: `weight кг`. 
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    weight: string;
    /**
     * Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    deliveryServiceId: string;
    /**
     * Адрес получателя.
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    deliveryAddress?: string;
    /**
     * Дата отгрузки в формате `dd.MM.yyyy`.
     * @type {string}
     * @memberof ParcelBoxLabelDTO
     */
    shipmentDate?: string;
}

/**
 * Информация о грузовых местах в заказе.
 * @export
 */
export type ParcelDTO = {
    /**
     * Список грузовых мест. Маркет определяет количество мест по длине этого списка.
     * @type {Array<ParcelBoxDTO>}
     * @memberof ParcelDTO
     */
    boxes: Array<ParcelBoxDTO>;
}

/**
 * Данные о складе отправления.
 * @export
 */
export type PartnerShipmentWarehouseDTO = {
    /**
     * Идентификатор склада отправления.
     * @type {number}
     * @memberof PartnerShipmentWarehouseDTO
     */
    id?: number;
    /**
     * Наименование склада отправления.
     * @type {string}
     * @memberof PartnerShipmentWarehouseDTO
     */
    name?: string;
    /**
     * Адрес склада отправления.
     * @type {string}
     * @memberof PartnerShipmentWarehouseDTO
     */
    address?: string;
}

/**
 * Частота выплат:  * `DAILY` — ежедневно. * `WEEKLY` — раз в неделю. * `BIWEEKLY` — раз в две недели. * `MONTHLY` — раз в месяц.  Подробнее о графике выплат читайте [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/introduction/rates/acquiring.html). 
 * @export
 * @enum {string}
 */
export type PaymentFrequencyType = 'DAILY' | 'WEEKLY' | 'BIWEEKLY' | 'MONTHLY';

/**
 * Адрес доставки.
 * @export
 */
export type PickupAddressDTO = {
    /**
     * Страна.
     * @type {string}
     * @memberof PickupAddressDTO
     */
    country?: string;
    /**
     * Город.
     * @type {string}
     * @memberof PickupAddressDTO
     */
    city?: string;
    /**
     * Улица.
     * @type {string}
     * @memberof PickupAddressDTO
     */
    street?: string;
    /**
     * Номер дома.
     * @type {string}
     * @memberof PickupAddressDTO
     */
    house?: string;
    /**
     * Почтовый индекс.
     * @type {string}
     * @memberof PickupAddressDTO
     */
    postcode?: string;
}

/**
 * Модель, по которой работает магазин:  * `FBS` — FBS или Экспресс. * `FBY` — FBY. * `DBS` — DBS. 
 * @export
 * @enum {string}
 */
export type PlacementType = 'FBS' | 'FBY' | 'DBS';

/**
 * Максимальные значения цены, при которых она является привлекательной или умеренной.
 * @export
 */
export type PriceCompetitivenessThresholdsDTO = {
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof PriceCompetitivenessThresholdsDTO
     */
    optimalPrice?: BasePriceDTO;
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof PriceCompetitivenessThresholdsDTO
     */
    averagePrice?: BasePriceDTO;
}

/**
 * Привлекательность цены:  * `OPTIMAL` — привлекательная. * `AVERAGE` — умеренная. * `LOW` — непривлекательная. 
 * @export
 * @enum {string}
 */
export type PriceCompetitivenessType = 'OPTIMAL' | 'AVERAGE' | 'LOW';

/**
 * Цена с указанием скидки, валюты и времени последнего обновления.
 * @export
 */
export type PriceDTO = {
    /**
     * Цена на товар.
     * @type {number}
     * @memberof PriceDTO
     */
    value?: number;
    /**
     * Цена на товар без скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
     * @type {number}
     * @memberof PriceDTO
     */
    discountBase?: number;
    /**
     * 
     * @type {CurrencyType}
     * @memberof PriceDTO
     */
    currencyId?: CurrencyType;
    /**
     * Идентификатор ставки НДС, применяемой для товара:  * `2` — 10%. * `5` — 0%. * `6` — не облагается НДС. * `7` — 20%.  Если параметр не указан, используется ставка НДС, установленная в кабинете. 
     * @type {number}
     * @memberof PriceDTO
     */
    vat?: number;
}

/**
 * Причина попадания товара в карантин.
 * @export
 */
export type PriceQuarantineVerdictDTO = {
    /**
     * 
     * @type {PriceQuarantineVerdictType}
     * @memberof PriceQuarantineVerdictDTO
     */
    type?: PriceQuarantineVerdictType;
    /**
     * Цена, из-за которой товар попал в карантин, и значения для сравнения. Конкретный набор параметров зависит от типа карантина.
     * @type {Array<PriceQuarantineVerdictParameterDTO>}
     * @memberof PriceQuarantineVerdictDTO
     */
    params: Array<PriceQuarantineVerdictParameterDTO>;
}

/**
 * Имя параметра причины скрытия товара по цене.  * `CURRENT_PRICE` — цена, из-за которой товар попал в карантин. * `LAST_VALID_PRICE` — последняя цена до попадания в карантин (только для карантина типа `PRICE_CHANGE`). * `MIN_PRICE` — порог попадания в карантин (только для карантина типов `LOW_PRICE` и `LOW_PRICE_PROMO`). * `CURRENCY` — валюта. 
 * @export
 * @enum {string}
 */
export type PriceQuarantineVerdictParamNameType = 'CURRENT_PRICE' | 'LAST_VALID_PRICE' | 'MIN_PRICE' | 'CURRENCY';

/**
 * Параметр карантина.
 * @export
 */
export type PriceQuarantineVerdictParameterDTO = {
    /**
     * 
     * @type {PriceQuarantineVerdictParamNameType}
     * @memberof PriceQuarantineVerdictParameterDTO
     */
    name: PriceQuarantineVerdictParamNameType;
    /**
     * Значение параметра.
     * @type {string}
     * @memberof PriceQuarantineVerdictParameterDTO
     */
    value: string;
}

/**
 * Типы карантина:  * `PRICE_CHANGE` — новая цена слишком сильно отличается от прежней. В поле `params` будет  новая цена `CURRENT_PRICE` и последняя цена до попадания в карантин `LAST_VALID_PRICE`. * `LOW_PRICE` — установленная цена слишком сильно отличается от рыночной. В поле `params` будет установленная вами цена `CURRENT_PRICE` и порог попадания в карантин `MIN_PRICE`. * `LOW_PRICE_PROMO` — цена после применения акций слишком сильно отличается от рыночной. В поле `params` будет цена после применения акций `CURRENT_PRICE` и порог попадания в карантин `MIN_PRICE`. 
 * @export
 * @enum {string}
 */
export type PriceQuarantineVerdictType = 'PRICE_CHANGE' | 'LOW_PRICE' | 'LOW_PRICE_PROMO';

/**
 * Рекомендованная цена.
 * @export
 */
export type PriceRecommendationItemDTO = {
    /**
     * Идентификатор кампании.
     * @type {number}
     * @memberof PriceRecommendationItemDTO
     */
    campaignId: number;
    /**
     * Рекомендованная цена на товар. Чтобы продвижение хорошо работало, цена на товар должна быть не выше этого значения. [Подробно о рекомендованных ценах](https://yandex.ru/support/marketplace/marketing/campaigns.html#prices) 
     * @type {number}
     * @memberof PriceRecommendationItemDTO
     */
    price: number;
}

/**
 * Тип цены.
 * @export
 */
export type PriceSuggestDTO = {
    /**
     * 
     * @type {PriceSuggestType}
     * @memberof PriceSuggestDTO
     */
    type?: PriceSuggestType;
    /**
     * Цена в рублях.
     * @type {number}
     * @memberof PriceSuggestDTO
     */
    price?: number;
}

/**
 * Товар с ценами для продвижения.
 * @export
 */
export type PriceSuggestOfferDTO = {
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof PriceSuggestOfferDTO
     */
    marketSku?: number;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof PriceSuggestOfferDTO
     */
    offerId?: string;
    /**
     * Цены для продвижения. 
     * @type {Array<PriceSuggestDTO>}
     * @memberof PriceSuggestOfferDTO
     */
    priceSuggestion?: Array<PriceSuggestDTO>;
}

/**
 * Тип цены:  * `BUYBOX` — самая низкая цена на товар, по которой он продается сейчас. Эта цена обновляется в режиме реального времени. Если вы установите цену ниже, начнет показываться ваше предложение. Если для этого значения в параметре `price` указана цена, которая совпадает с вашей, значит, ваш товар уже показывается на витрине. Если кроме вас этот товар продают другие продавцы по такой же цене, их предложения также будут отображаться вместе с вашими по очереди. * `DEFAULT_OFFER` — рекомендованная Маркетом цена, которая привлекает покупателей. Рассчитывается только для популярных на сервисе товаров и обновляется раз в четыре часа. * `MIN_PRICE_MARKET` — минимальная цена на Маркете. Самая низкая цена среди всех предложений товара на Маркете во всех регионах, включая те, которые не видны на витрине. Эта цена обновляется в режиме реального времени и обеспечивает большее количество показов на Маркете, чем самая низкая или рекомендованная цена. 
 * @export
 * @enum {string}
 */
export type PriceSuggestType = 'BUYBOX' | 'DEFAULT_OFFER' | 'MIN_PRICE_MARKET';

/**
 * Информация об автоматическом добавлении товара в акцию.  Причины, по которым товар не был добавлен автоматически в других магазинах, можно узнать в кабинете продавца на Маркете на странице акции.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
 * @export
 */
export type PromoOfferAutoParticipatingDetailsDTO = {
    /**
     * Магазины, в которых товар добавлен в акцию автоматически.  Возвращается, если статус товара в акции — `PARTIALLY_AUTO`. 
     * @type {Array<number>}
     * @memberof PromoOfferAutoParticipatingDetailsDTO
     */
    campaignIds?: Array<number>;
}

/**
 * Параметры товара в акции с типом `DIRECT_DISCOUNT` или `BLUE_FLASH`.
 * @export
 */
export type PromoOfferDiscountParamsDTO = {
    /**
     * Зачеркнутая цена — та, по которой товар продавался до акции.  Указывается в рублях.  Возвращается, только если товар участвует в акции. 
     * @type {number}
     * @memberof PromoOfferDiscountParamsDTO
     */
    price?: number;
    /**
     * Цена по акции — та, по которой вы хотите продавать товар.  Указывается в рублях.  Возвращается, только если товар участвует в акции. 
     * @type {number}
     * @memberof PromoOfferDiscountParamsDTO
     */
    promoPrice?: number;
    /**
     * Максимально возможная цена для участия в акции.  Указывается в рублях.  Возвращается для всех товаров. 
     * @type {number}
     * @memberof PromoOfferDiscountParamsDTO
     */
    maxPromoPrice: number;
}

/**
 * Параметры товара в акции.  Возвращается параметр, который соответствует типу акции. 
 * @export
 */
export type PromoOfferParamsDTO = {
    /**
     * 
     * @type {PromoOfferDiscountParamsDTO}
     * @memberof PromoOfferParamsDTO
     */
    discountParams?: PromoOfferDiscountParamsDTO;
    /**
     * 
     * @type {PromoOfferPromocodeParamsDTO}
     * @memberof PromoOfferParamsDTO
     */
    promocodeParams?: PromoOfferPromocodeParamsDTO;
}

/**
 * Фильтр для товаров, которые добавлены в акцию вручную:  * `MANUALLY_ADDED` — товары, которые добавлены вручную.  * `NOT_MANUALLY_ADDED`— товары, которые не участвуют в акции и те, которые добавлены автоматически.  Если не передать параметр `statusType`, вернутся все товары.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
 * @export
 * @enum {string}
 */
export type PromoOfferParticipationStatusFilterType = 'MANUALLY_ADDED' | 'NOT_MANUALLY_ADDED';

/**
 * Статус товара в акции:  * `AUTO` — добавлен автоматически во всех магазинах кабинета, в которых товар доступен для покупки.  * `PARTIALLY_AUTO` — добавлен автоматически у части магазинов.  * `MANUAL` — добавлен вручную.  * `NOT_PARTICIPATING` — не участвует в акции.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
 * @export
 * @enum {string}
 */
export type PromoOfferParticipationStatusType = 'AUTO' | 'PARTIALLY_AUTO' | 'MANUAL' | 'NOT_PARTICIPATING';

/**
 * Параметры товара в акции с типом `MARKET_PROMOCODE`.
 * @export
 */
export type PromoOfferPromocodeParamsDTO = {
    /**
     * Максимально возможная цена для участия в акции до применения промокода.  Указывается в рублях.  Возвращается для всех товаров. 
     * @type {number}
     * @memberof PromoOfferPromocodeParamsDTO
     */
    maxPrice: number;
}

/**
 * Предупреждение, которое появилось при добавлении товара:  * `DEEP_DISCOUNT_OFFER` — большая разница с ценой в каталоге. Проверьте, нет ли ошибки.  * `CATALOG_PRICE_IS_LOWER_THAN_PROMO` — [базовая цена](*basic-price) в кабинете ниже цены по акции. У товара в акции будет отображаться базовая цена.  * `SHOP_PRICES_ARE_LOWER_THAN_PROMO` — цена в отдельном магазине ниже цены по акции. У товара в акции будет отображаться цена в магазине. Для остальных магазинов будет действовать цена по акции.  * `PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE` — в отдельном магазине цена с учетом промокода выше максимально возможной цены. Товар не будет участвовать в акции.  * `SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO` — товар в отдельном магазине не подходит под условия акции. 
 * @export
 * @enum {string}
 */
export type PromoOfferUpdateWarningCodeType = 'DEEP_DISCOUNT_OFFER' | 'CATALOG_PRICE_IS_LOWER_THAN_PROMO' | 'SHOP_PRICES_ARE_LOWER_THAN_PROMO' | 'PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE' | 'SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO';

/**
 * Предупреждение, которое появилось при добавлении товара в акцию или изменении его цен.
 * @export
 */
export type PromoOfferUpdateWarningDTO = {
    /**
     * 
     * @type {PromoOfferUpdateWarningCodeType}
     * @memberof PromoOfferUpdateWarningDTO
     */
    code: PromoOfferUpdateWarningCodeType;
    /**
     * Идентификаторы магазинов в кабинете, для которых получены предупреждения.  Не возвращается, если предупреждения действуют для всех магазинов в кабинете. 
     * @type {Array<number>}
     * @memberof PromoOfferUpdateWarningDTO
     */
    campaignIds?: Array<number>;
}

/**
 * Какие акции вернутся:  * `PARTICIPATING_NOW` — текущие и будущие акции продавца.  * `PARTICIPATED` — завершенные акции продавца за последний год. Если за год их было меньше 15, в ответе придут 15 последних акций за все время. 
 * @export
 * @enum {string}
 */
export type PromoParticipationType = 'PARTICIPATING_NOW' | 'PARTICIPATED';

/**
 * Время проведения акции.
 * @export
 */
export type PromoPeriodDTO = {
    /**
     * Дата и время начала акции.
     * @type {Date}
     * @memberof PromoPeriodDTO
     */
    dateTimeFrom: Date;
    /**
     * Дата и время окончания акции.
     * @type {Date}
     * @memberof PromoPeriodDTO
     */
    dateTimeTo: Date;
}

/**
 * Запрос на передачу ключей цифровых товаров.
 * @export
 */
export type ProvideOrderDigitalCodesRequest = {
    /**
     * Список проданных ключей.  Если в заказе есть несколько **одинаковых** товаров (например, несколько ключей к одной и той же подписке), передайте каждый в виде отдельного элемента массива. `id` у этих элементов должен быть один и тот же. 
     * @type {Array<OrderDigitalItemDTO>}
     * @memberof ProvideOrderDigitalCodesRequest
     */
    items: Array<OrderDigitalItemDTO>;
}

/**
 * 
 * @export
 */
export type ProvideOrderItemIdentifiersRequest = {
    /**
     * Список позиций, требующих маркировки. 
     * @type {Array<OrderItemInstanceModificationDTO>}
     * @memberof ProvideOrderItemIdentifiersRequest
     */
    items: Array<OrderItemInstanceModificationDTO>;
}

/**
 * 
 * @export
 */
export type ProvideOrderItemIdentifiersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof ProvideOrderItemIdentifiersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OrderItemsModificationResultDTO}
     * @memberof ProvideOrderItemIdentifiersResponse
     */
    result?: OrderItemsModificationResultDTO;
}

/**
 * description.
 * @export
 */
export type PutSkuBidsRequest = {
    /**
     * Список товаров и ставки для продвижения, которые на них нужно установить.
     * @type {Array<SkuBidItemDTO>}
     * @memberof PutSkuBidsRequest
     */
    bids: Array<SkuBidItemDTO>;
}

/**
 * Информация о заказе, который повлиял на индекс качества.
 * @export
 */
export type QualityRatingAffectedOrderDTO = {
    /**
     * Идентификатор заказа.
     * @type {number}
     * @memberof QualityRatingAffectedOrderDTO
     */
    orderId: number;
    /**
     * Описание проблемы.
     * @type {string}
     * @memberof QualityRatingAffectedOrderDTO
     */
    description: string;
    /**
     * 
     * @type {AffectedOrderQualityRatingComponentType}
     * @memberof QualityRatingAffectedOrderDTO
     */
    componentType: AffectedOrderQualityRatingComponentType;
}

/**
 * Составляющая индекса качества.
 * @export
 */
export type QualityRatingComponentDTO = {
    /**
     * Значение составляющей в процентах.
     * @type {number}
     * @memberof QualityRatingComponentDTO
     */
    value: number;
    /**
     * 
     * @type {QualityRatingComponentType}
     * @memberof QualityRatingComponentDTO
     */
    componentType: QualityRatingComponentType;
}

/**
 * Составляющие индекса качества.  **Для модели DBS:** * `DBS_CANCELLATION_RATE` — доля отмененных товаров. * `DBS_LATE_DELIVERY_RATE` — доля заказов, доставленных после плановой даты.  **Для моделей FBS и Экспресс:** * `FBS_CANCELLATION_RATE` — доля отмененных товаров. * `FBS_LATE_SHIP_RATE` — доля не вовремя отгруженных заказов.  **Для модели FBY:** * `FBY_LATE_DELIVERY_RATE` — доля товаров, которые приехали на склад с опозданием. * `FBY_CANCELLATION_RATE` — доля отмененных или недоставленных товаров. * `FBY_DELIVERY_DIFF_RATE` — доля товаров, которые не прибыли вместе с поставкой или которые не приняли. * `FBY_LATE_EDITING_RATE` — доля товаров, которые поздно убрали из заявки. 
 * @export
 * @enum {string}
 */
export type QualityRatingComponentType = 'DBS_CANCELLATION_RATE' | 'DBS_LATE_DELIVERY_RATE' | 'FBS_CANCELLATION_RATE' | 'FBS_LATE_SHIP_RATE' | 'FBY_LATE_DELIVERY_RATE' | 'FBY_CANCELLATION_RATE' | 'FBY_DELIVERY_DIFF_RATE' | 'FBY_LATE_EDITING_RATE';

/**
 * Информация об индексе качества.
 * @export
 */
export type QualityRatingDTO = {
    /**
     * Значение индекса качества.
     * @type {number}
     * @memberof QualityRatingDTO
     */
    rating: number;
    /**
     * Дата вычисления.  Формат даты: `ГГГГ‑ММ‑ДД`. 
     * @type {Date}
     * @memberof QualityRatingDTO
     */
    calculationDate: Date;
    /**
     * Составляющие индекса качества.
     * @type {Array<QualityRatingComponentDTO>}
     * @memberof QualityRatingDTO
     */
    components: Array<QualityRatingComponentDTO>;
}

/**
 * Информация о заказах, которые повлияли на индекс качества.
 * @export
 */
export type QualityRatingDetailsDTO = {
    /**
     * Список заказов, которые повлияли на индекс качества.
     * @type {Array<QualityRatingAffectedOrderDTO>}
     * @memberof QualityRatingDetailsDTO
     */
    affectedOrders: Array<QualityRatingAffectedOrderDTO>;
}

/**
 * Настройка продажи квантами.  Чтобы сбросить установленные ранее значения, передайте пустой параметр `quantum`.  {% cut \"Пример\" %}  ```json {   \"offers\": [     {       \"offerId\": \"08e35dc1-89a2-11e3-8055-0015e9b8c48d\",       \"quantum\": {}     }   ] } ```  {% endcut %} 
 * @export
 */
export type QuantumDTO = {
    /**
     * Минимальное количество единиц товара в заказе. Например, если указать 10, покупатель сможет добавить в корзину не меньше 10 единиц.  ⚠️ Если количество товара на складе меньше заданного, ограничение не сработает и покупатель сможет его заказать. 
     * @type {number}
     * @memberof QuantumDTO
     */
    minQuantity?: number;
    /**
     * На сколько единиц покупатель сможет увеличить количество товара в корзине.  Например, если задать 5, покупатель сможет добавить к заказу только 5, 10, 15, ... единиц товара.  ⚠️ Если количество товара на складе не дотягивает до кванта, ограничение не сработает и покупатель сможет заказать количество, не кратное кванту. 
     * @type {number}
     * @memberof QuantumDTO
     */
    stepQuantity?: number;
}

/**
 * Товар в карантине.
 * @export
 */
export type QuarantineOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof QuarantineOfferDTO
     */
    offerId?: string;
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof QuarantineOfferDTO
     */
    currentPrice?: BasePriceDTO;
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof QuarantineOfferDTO
     */
    lastValidPrice?: BasePriceDTO;
    /**
     * Причины попадания товара в карантин.
     * @type {Array<PriceQuarantineVerdictDTO>}
     * @memberof QuarantineOfferDTO
     */
    verdicts?: Array<PriceQuarantineVerdictDTO>;
}

/**
 * Способ возврата товара покупателем:  * `SHOP` — в точку возврата магазина.  * `DELIVERY_SERVICE` — отправить курьером.  * `POST` — почта. 
 * @export
 * @enum {string}
 */
export type RecipientType = 'SHOP' | 'DELIVERY_SERVICE' | 'POST';

/**
 * Cтатус возврата денег:  * `STARTED_BY_USER` — создан клиентом из личного кабинета.  * `REFUND_IN_PROGRESS` — ждет решение о возврате денег.  * `REFUNDED` — по возврату проведены все возвратные денежные транзакции.  * `FAILED` — невозможно провести возврат покупателю.  * `WAITING_FOR_DECISION` — ожидает решения.  * `DECISION_MADE` — по возврату принято решение.  * `REFUNDED_WITH_BONUSES` — возврат осуществлен баллами Плюса или промокодом.  * `REFUNDED_BY_SHOP` — магазин сделал самостоятельно возврат денег.  * `COMPLETE_WITHOUT_REFUND` — возврат денег не требуется.  * `CANCELLED` — возврат отменен. 
 * @export
 * @enum {string}
 */
export type RefundStatusType = 'STARTED_BY_USER' | 'REFUND_IN_PROGRESS' | 'REFUNDED' | 'FAILED' | 'WAITING_FOR_DECISION' | 'DECISION_MADE' | 'REFUNDED_WITH_BONUSES' | 'REFUNDED_BY_SHOP' | 'CANCELLED' | 'COMPLETE_WITHOUT_REFUND' | 'UNKNOWN';

/**
 * Регион доставки.
 * @export
 */
export type RegionDTO = {
    /**
     * Идентификатор региона.
     * @type {number}
     * @memberof RegionDTO
     */
    id?: number;
    /**
     * Название региона.
     * @type {string}
     * @memberof RegionDTO
     */
    name: string;
    /**
     * 
     * @type {RegionType}
     * @memberof RegionDTO
     */
    type: RegionType;
    /**
     * 
     * @type {RegionDTO}
     * @memberof RegionDTO
     */
    parent?: RegionDTO;
    /**
     * Дочерние регионы.
     * @type {Array<RegionDTO>}
     * @memberof RegionDTO
     */
    children?: Array<RegionDTO>;
}

/**
 * Тип региона.  Возможные значения:  * `CITY_DISTRICT` — район города.  * `CITY` — крупный город.  * `CONTINENT` — континент.  * `COUNTRY_DISTRICT` — область.  * `COUNTRY` — страна.  * `REGION` — регион.  * `REPUBLIC_AREA` — район субъекта федерации.  * `REPUBLIC` — субъект федерации.  * `SUBWAY_STATION` — станция метро.  * `VILLAGE` — город.  * `OTHER` — неизвестный регион. 
 * @export
 * @enum {string}
 */
export type RegionType = 'OTHER' | 'CONTINENT' | 'REGION' | 'COUNTRY' | 'COUNTRY_DISTRICT' | 'REPUBLIC' | 'CITY' | 'VILLAGE' | 'CITY_DISTRICT' | 'SUBWAY_STATION' | 'REPUBLIC_AREA';

/**
 * Региональная информация.
 * @export
 */
export type RegionalModelInfoDTO = {
    /**
     * 
     * @type {CurrencyType}
     * @memberof RegionalModelInfoDTO
     */
    currency?: CurrencyType;
    /**
     * Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
     * @type {number}
     * @memberof RegionalModelInfoDTO
     */
    regionId?: number;
}

/**
 * Информация о товаре и ошибки, которые появились при его удалении.
 * @export
 */
export type RejectedPromoOfferDeleteDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof RejectedPromoOfferDeleteDTO
     */
    offerId: string;
    /**
     * 
     * @type {RejectedPromoOfferDeleteReasonType}
     * @memberof RejectedPromoOfferDeleteDTO
     */
    reason: RejectedPromoOfferDeleteReasonType;
}

/**
 * Описание ошибки:  * `OFFER_DOES_NOT_EXIST` — в кабинете нет товара с таким SKU. 
 * @export
 * @enum {string}
 */
export type RejectedPromoOfferDeleteReasonType = 'OFFER_DOES_NOT_EXIST';

/**
 * Описание отклоненного изменения.
 * @export
 */
export type RejectedPromoOfferUpdateDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof RejectedPromoOfferUpdateDTO
     */
    offerId: string;
    /**
     * 
     * @type {RejectedPromoOfferUpdateReasonType}
     * @memberof RejectedPromoOfferUpdateDTO
     */
    reason: RejectedPromoOfferUpdateReasonType;
}

/**
 * Причина отклонения изменения:  * `OFFER_DOES_NOT_EXIST` — в кабинете нет товара с таким SKU.  * `OFFER_DUPLICATION` — один и тот же товар передан несколько раз.  * `OFFER_NOT_ELIGIBLE_FOR_PROMO` — товар не подходит под условия акции.  * `OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED` — товар не добавлен в акцию по техническим причинам.  * `DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED` — истек срок добавления товаров в акцию.  * `EMPTY_OLD_PRICE` — не указана зачеркнутая цена.  * `EMPTY_PROMO_PRICE` — не указана цена по акции.  * `MAX_PROMO_PRICE_EXCEEDED` — цена по акции превышает максимально возможную цену для участия в акции.  * `PROMO_PRICE_BIGGER_THAN_MAX` — цена по акции больше 95% от зачеркнутой цены.  * `PROMO_PRICE_SMALLER_THAN_MIN` — цена по акции меньше 1% от зачеркнутой цены. 
 * @export
 * @enum {string}
 */
export type RejectedPromoOfferUpdateReasonType = 'OFFER_DOES_NOT_EXIST' | 'OFFER_DUPLICATION' | 'OFFER_NOT_ELIGIBLE_FOR_PROMO' | 'OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED' | 'DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED' | 'EMPTY_OLD_PRICE' | 'EMPTY_PROMO_PRICE' | 'MAX_PROMO_PRICE_EXCEEDED' | 'PROMO_PRICE_BIGGER_THAN_MAX' | 'PROMO_PRICE_SMALLER_THAN_MIN';

/**
 * Формат отчета:  * `FILE` — файл с электронной таблицей. * `CSV` — ZIP-архив с CSV-файлами на каждый лист отчета. 
 * @export
 * @enum {string}
 */
export type ReportFormatType = 'FILE' | 'CSV';

/**
 * Статус генерации и ссылка на готовый отчет.
 * @export
 */
export type ReportInfoDTO = {
    /**
     * 
     * @type {ReportStatusType}
     * @memberof ReportInfoDTO
     */
    status: ReportStatusType;
    /**
     * 
     * @type {ReportSubStatusType}
     * @memberof ReportInfoDTO
     */
    subStatus?: ReportSubStatusType;
    /**
     * Дата и время запроса на генерацию.
     * @type {Date}
     * @memberof ReportInfoDTO
     */
    generationRequestedAt: Date;
    /**
     * Дата и время завершения генерации.
     * @type {Date}
     * @memberof ReportInfoDTO
     */
    generationFinishedAt?: Date;
    /**
     * Ссылка на готовый отчет.
     * @type {string}
     * @memberof ReportInfoDTO
     */
    file?: string;
    /**
     * Ожидаемая продолжительность генерации в миллисекундах.
     * @type {number}
     * @memberof ReportInfoDTO
     */
    estimatedGenerationTime?: number;
}

/**
 * Статус генерации отчета:  * `PENDING` — отчет ожидает генерации. * `PROCESSING` — отчет генерируется. * `FAILED` — во время генерации произошла ошибка. * `DONE` — отчет готов. 
 * @export
 * @enum {string}
 */
export type ReportStatusType = 'PENDING' | 'PROCESSING' | 'FAILED' | 'DONE';

/**
 * Подстатус генерации отчета: * `NO_DATA` — для такого отчета нет данных. * `TOO_LARGE` — отчет превысил допустимый размер — укажите меньший период времени или уточните условия запроса. * `RESOURCE_NOT_FOUND` — для такого отчета не удалось найти часть сущностей. 
 * @export
 * @enum {string}
 */
export type ReportSubStatusType = 'NO_DATA' | 'TOO_LARGE' | 'RESOURCE_NOT_FOUND';

/**
 * Возврат заказа.
 * @export
 */
export type ReturnDTO = {
    /**
     * Идентификатор возврата.
     * @type {number}
     * @memberof ReturnDTO
     */
    id?: number;
    /**
     * Номер заказа.
     * @type {number}
     * @memberof ReturnDTO
     */
    orderId?: number;
    /**
     * Дата создания возврата клиентом.
     * @type {Date}
     * @memberof ReturnDTO
     */
    creationDate?: Date;
    /**
     * Дата обновления возврата.
     * @type {Date}
     * @memberof ReturnDTO
     */
    updateDate?: Date;
    /**
     * 
     * @type {RefundStatusType}
     * @memberof ReturnDTO
     */
    refundStatus?: RefundStatusType;
    /**
     * 
     * @type {LogisticPickupPointDTO}
     * @memberof ReturnDTO
     */
    logisticPickupPoint?: LogisticPickupPointDTO;
    /**
     * 
     * @type {RecipientType}
     * @memberof ReturnDTO
     */
    shipmentRecipientType?: RecipientType;
    /**
     * 
     * @type {ReturnShipmentStatusType}
     * @memberof ReturnDTO
     */
    shipmentStatus?: ReturnShipmentStatusType;
    /**
     * Сумма возврата.
     * @type {number}
     * @memberof ReturnDTO
     */
    refundAmount?: number;
    /**
     * Список товаров в возврате.
     * @type {Array<ReturnItemDTO>}
     * @memberof ReturnDTO
     */
    items: Array<ReturnItemDTO>;
    /**
     * 
     * @type {ReturnType}
     * @memberof ReturnDTO
     */
    returnType?: ReturnType;
    /**
     * Используется ли опция **Быстрый возврат денег за дешевый брак**. 
     * @type {boolean}
     * @memberof ReturnDTO
     */
    fastReturn?: boolean;
}

/**
 * Решения по возвратам.
 * @export
 */
export type ReturnDecisionDTO = {
    /**
     * Идентификатор товара в возврате.
     * @type {number}
     * @memberof ReturnDecisionDTO
     */
    returnItemId?: number;
    /**
     * Количество единиц товара.
     * @type {number}
     * @memberof ReturnDecisionDTO
     */
    count?: number;
    /**
     * Комментарий.
     * @type {string}
     * @memberof ReturnDecisionDTO
     */
    comment?: string;
    /**
     * 
     * @type {ReturnDecisionReasonType}
     * @memberof ReturnDecisionDTO
     */
    reasonType?: ReturnDecisionReasonType;
    /**
     * 
     * @type {ReturnDecisionSubreasonType}
     * @memberof ReturnDecisionDTO
     */
    subreasonType?: ReturnDecisionSubreasonType;
    /**
     * 
     * @type {ReturnDecisionType}
     * @memberof ReturnDecisionDTO
     */
    decisionType?: ReturnDecisionType;
    /**
     * Сумма возврата.
     * @type {number}
     * @memberof ReturnDecisionDTO
     */
    refundAmount?: number;
    /**
     * Компенсация за обратную доставку.
     * @type {number}
     * @memberof ReturnDecisionDTO
     */
    partnerCompensation?: number;
    /**
     * Список хеш-кодов фотографий товара от покупателя.
     * @type {Array<string>}
     * @memberof ReturnDecisionDTO
     */
    images?: Array<string>;
}

/**
 * Причины возврата:  * `BAD_QUALITY` — бракованный товар (есть недостатки).  * `DO_NOT_FIT` — товар не подошел.  * `WRONG_ITEM` — привезли не тот товар.  * `DAMAGE_DELIVERY` — товар поврежден при доставке.  * `LOYALTY_FAIL` — невозможно установить виновного в браке/пересорте.  * `CONTENT_FAIL` — ошибочное описание товара по вине Маркета.  * `UNKNOWN` — причина не известна. 
 * @export
 * @enum {string}
 */
export type ReturnDecisionReasonType = 'BAD_QUALITY' | 'DOES_NOT_FIT' | 'WRONG_ITEM' | 'DAMAGE_DELIVERY' | 'LOYALTY_FAIL' | 'CONTENT_FAIL' | 'UNKNOWN';

/**
 * Детали причин возврата:   * `DO_NOT_FIT`:     * `USER_DID_NOT_LIKE` — товар не понравился.     * `USER_CHANGED_MIND` — передумал покупать.     * `DELIVERED_TOO_LONG` — длительный срок доставки, поэтому передумал.    * `BAD_QUALITY`:     * `BAD_PACKAGE` — упаковка товара была нарушена.     * `DAMAGED` — царапины, сколы.     * `NOT_WORKING` — не включается / не работает.     * `INCOMPLETENESS` — некомплект (не хватает детали в наборе, к товару).    * `WRONG_ITEM`:     * `WRONG_ITEM` — не тот товар.     * `WRONG_COLOR` — не соответствует по цвету.     * `DID_NOT_MATCH_DESCRIPTION` — не соответствует заявленным характеристикам/описанию. 
 * @export
 * @enum {string}
 */
export type ReturnDecisionSubreasonType = 'USER_DID_NOT_LIKE' | 'USER_CHANGED_MIND' | 'DELIVERED_TOO_LONG' | 'BAD_PACKAGE' | 'DAMAGED' | 'NOT_WORKING' | 'INCOMPLETENESS' | 'WRONG_ITEM' | 'WRONG_COLOR' | 'DID_NOT_MATCH_DESCRIPTION' | 'UNKNOWN';

/**
 * Решение по возврату:  * `REFUND_MONEY` — вернуть деньги покупателю.  * `REFUND_MONEY_INCLUDING_SHIPMENT` — вернуть деньги за товар и пересылку.  * `REPAIR` — отремонтировать товар.  * `REPLACE` — заменить товар.  * `SEND_TO_EXAMINATION` — взять товар на экспертизу.  * `DECLINE_REFUND` — отказать в возврате.  * `OTHER_DECISION` — другое решение. 
 * @export
 * @enum {string}
 */
export type ReturnDecisionType = 'REFUND_MONEY' | 'REFUND_MONEY_INCLUDING_SHIPMENT' | 'REPAIR' | 'REPLACE' | 'SEND_TO_EXAMINATION' | 'DECLINE_REFUND' | 'OTHER_DECISION' | 'UNKNOWN';

/**
 * Логистическая информация по возврату.
 * @export
 */
export type ReturnInstanceDTO = {
    /**
     * 
     * @type {ReturnInstanceStockType}
     * @memberof ReturnInstanceDTO
     */
    stockType?: ReturnInstanceStockType;
    /**
     * 
     * @type {ReturnInstanceStatusType}
     * @memberof ReturnInstanceDTO
     */
    status?: ReturnInstanceStatusType;
    /**
     * Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).
     * @type {string}
     * @memberof ReturnInstanceDTO
     */
    cis?: string;
    /**
     * Международный идентификатор мобильного оборудования.
     * @type {string}
     * @memberof ReturnInstanceDTO
     */
    imei?: string;
}

/**
 * Логистический статус конкретного товара.
 * @export
 * @enum {string}
 */
export type ReturnInstanceStatusType = 'CREATED' | 'RECEIVED' | 'IN_TRANSIT' | 'READY_FOR_PICKUP' | 'PICKED' | 'RECEIVED_ON_FULFILLMENT' | 'CANCELLED' | 'LOST' | 'UTILIZED' | 'PREPARED_FOR_UTILIZATION' | 'EXPROPRIATED' | 'NOT_IN_DEMAND';

/**
 * Тип остатка на складе.
 * @export
 * @enum {string}
 */
export type ReturnInstanceStockType = 'FIT' | 'DEFECT' | 'ANOMALY' | 'SURPLUS' | 'EXPIRED' | 'MISGRADING' | 'UNDEFINED' | 'INCORRECT_IMEI' | 'INCORRECT_SERIAL_NUMBER' | 'INCORRECT_CIS' | 'PART_MISSING' | 'NON_COMPLIENT' | 'NOT_ACCEPTABLE' | 'SERVICE' | 'MARKDOWN' | 'DEMO' | 'REPAIR' | 'FIRMWARE' | 'UNKNOWN';

/**
 * Список товаров в возврате.
 * @export
 */
export type ReturnItemDTO = {
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof ReturnItemDTO
     */
    marketSku?: number;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof ReturnItemDTO
     */
    shopSku: string;
    /**
     * Количество единиц товара.
     * @type {number}
     * @memberof ReturnItemDTO
     */
    count: number;
    /**
     * Список решений по возврату.
     * @type {Array<ReturnDecisionDTO>}
     * @memberof ReturnItemDTO
     */
    decisions?: Array<ReturnDecisionDTO>;
    /**
     * Список логистических позиций возврата.
     * @type {Array<ReturnInstanceDTO>}
     * @memberof ReturnItemDTO
     */
    instances?: Array<ReturnInstanceDTO>;
    /**
     * Список трек-кодов для почтовых отправлений.
     * @type {Array<TrackDTO>}
     * @memberof ReturnItemDTO
     */
    tracks?: Array<TrackDTO>;
}

/**
 * Решение по возврату.
 * @export
 * @enum {string}
 */
export type ReturnRequestDecisionType = 'REFUND_MONEY' | 'REFUND_MONEY_INCLUDING_SHIPMENT' | 'REPAIR' | 'REPLACE' | 'SEND_TO_EXAMINATION' | 'DECLINE_REFUND' | 'OTHER_DECISION';

/**
 * Статус передачи возврата:  * `CREATED` — возврат создан.  * `RECEIVED` — принят у покупателя.  * `IN_TRANSIT` — возврат в пути.  * `READY_FOR_PICKUP` — возврат готов к выдаче магазину.  * `PICKED` — возврат выдан магазину.  * `LOST` — возврат утерян при транспортировке.  * `CANCELLED` — возврат отменен.  * `FULFILMENT_RECEIVED` — возврат принят на складе Маркета.  * `PREPARED_FOR_UTILIZATION` — возврат передан в утилизацию.  * `UTILIZED` — возврат утилизирован. 
 * @export
 * @enum {string}
 */
export type ReturnShipmentStatusType = 'CREATED' | 'RECEIVED' | 'IN_TRANSIT' | 'READY_FOR_PICKUP' | 'PICKED' | 'LOST' | 'EXPIRED' | 'CANCELLED' | 'FULFILMENT_RECEIVED' | 'PREPARED_FOR_UTILIZATION' | 'NOT_IN_DEMAND' | 'UTILIZED' | 'READY_FOR_EXPROPRIATION' | 'RECEIVED_FOR_EXPROPRIATION';

/**
 * Тип заказа для фильтрации:  * `RETURN` — возврат.  * `UNREDEEMED` — невыкуп.  Если не указывать, в ответе будут и возвраты, и невыкупы. 
 * @export
 * @enum {string}
 */
export type ReturnType = 'UNREDEEMED' | 'RETURN';

/**
 * Информация о страницах результатов.
 * @export
 */
export type ScrollingPagerDTO = {
    /**
     * Идентификатор следующей страницы результатов.
     * @type {string}
     * @memberof ScrollingPagerDTO
     */
    nextPageToken?: string;
    /**
     * Идентификатор предыдущей страницы результатов.
     * @type {string}
     * @memberof ScrollingPagerDTO
     */
    prevPageToken?: string;
}

/**
 * 
 * @export
 */
export type SearchModelsResponse = {
    /**
     * Список моделей товаров.
     * @type {Array<ModelDTO>}
     * @memberof SearchModelsResponse
     */
    models: Array<ModelDTO>;
    /**
     * 
     * @type {CurrencyType}
     * @memberof SearchModelsResponse
     */
    currency?: CurrencyType;
    /**
     * Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
     * @type {number}
     * @memberof SearchModelsResponse
     */
    regionId?: number;
    /**
     * 
     * @type {FlippingPagerDTO}
     * @memberof SearchModelsResponse
     */
    pager?: FlippingPagerDTO;
}

/**
 * Запрос информации об отгрузках.
 * @export
 */
export type SearchShipmentsRequest = {
    /**
     * Начальная дата для фильтрации по дате отгрузки (включительно).  Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {Date}
     * @memberof SearchShipmentsRequest
     */
    dateFrom: Date;
    /**
     * Конечная дата для фильтрации по дате отгрузки (включительно).  Формат даты: `ДД-ММ-ГГГГ`. 
     * @type {Date}
     * @memberof SearchShipmentsRequest
     */
    dateTo: Date;
    /**
     * Список статусов отгрузок.
     * @type {Set<ShipmentStatusType>}
     * @memberof SearchShipmentsRequest
     */
    statuses?: Set<ShipmentStatusType>;
    /**
     * Список идентификаторов заказов из отгрузок.
     * @type {Set<number>}
     * @memberof SearchShipmentsRequest
     */
    orderIds?: Set<number>;
    /**
     * Возвращать ли отмененные заказы.  Значение по умолчанию — `true`. Если возвращать отмененные заказы не нужно, передайте значение `false`. 
     * @type {boolean}
     * @memberof SearchShipmentsRequest
     */
    cancelledOrders?: boolean;
}

/**
 * Ответ на запрос информации об отгрузках.
 * @export
 */
export type SearchShipmentsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof SearchShipmentsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {SearchShipmentsResponseDTO}
     * @memberof SearchShipmentsResponse
     */
    result?: SearchShipmentsResponseDTO;
}

/**
 * Информация об отгрузках.
 * @export
 */
export type SearchShipmentsResponseDTO = {
    /**
     * Список с информацией об отгрузках.
     * @type {Array<ShipmentInfoDTO>}
     * @memberof SearchShipmentsResponseDTO
     */
    shipments: Array<ShipmentInfoDTO>;
    /**
     * 
     * @type {ForwardScrollingPagerDTO}
     * @memberof SearchShipmentsResponseDTO
     */
    paging?: ForwardScrollingPagerDTO;
}

/**
 * Модель размещения:  * `FBY` — FBY. * `FBS` — FBS. * `DBS` — DBS. * `EXPRESS` — Экспресс. 
 * @export
 * @enum {string}
 */
export type SellingProgramType = 'FBY' | 'FBS' | 'DBS' | 'EXPRESS';

/**
 * В какой чат нужно отправить сообщение и текст сообщения.
 * @export
 */
export type SendMessageToChatRequest = {
    /**
     * Текст сообщения. Максимальная длина — 4096 символа.
     * @type {string}
     * @memberof SendMessageToChatRequest
     */
    message: string;
}

/**
 * Запрос на обновление изменение параметров прайс-листа.
 * @export
 */
export type SetFeedParamsRequest = {
    /**
     * Параметры прайс-листа.  Обязательный параметр. 
     * @type {Array<FeedParameterDTO>}
     * @memberof SetFeedParamsRequest
     */
    parameters: Array<FeedParameterDTO>;
}

/**
 * 
 * @export
 */
export type SetOrderBoxLayoutRequest = {
    /**
     * Список коробок.
     * @type {Array<OrderBoxLayoutDTO>}
     * @memberof SetOrderBoxLayoutRequest
     */
    boxes: Array<OrderBoxLayoutDTO>;
    /**
     * Передайте `true`, если вы собираетесь удалить часть товаров из заказа.
     * @type {boolean}
     * @memberof SetOrderBoxLayoutRequest
     */
    allowRemove?: boolean;
}

/**
 * 
 * @export
 */
export type SetOrderBoxLayoutResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof SetOrderBoxLayoutResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {OrderBoxesLayoutDTO}
     * @memberof SetOrderBoxLayoutResponse
     */
    result?: OrderBoxesLayoutDTO;
}

/**
 * 
 * @export
 */
export type SetOrderDeliveryDateRequest = {
    /**
     * 
     * @type {OrderDeliveryDateDTO}
     * @memberof SetOrderDeliveryDateRequest
     */
    dates: OrderDeliveryDateDTO;
    /**
     * 
     * @type {OrderDeliveryDateReasonType}
     * @memberof SetOrderDeliveryDateRequest
     */
    reason: OrderDeliveryDateReasonType;
}

/**
 * 
 * @export
 */
export type SetOrderDeliveryTrackCodeRequest = {
    /**
     * Трек‑номер посылки.
     * @type {string}
     * @memberof SetOrderDeliveryTrackCodeRequest
     */
    trackCode: string;
    /**
     * Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
     * @type {number}
     * @memberof SetOrderDeliveryTrackCodeRequest
     */
    deliveryServiceId: number;
}

/**
 * 
 * @export
 */
export type SetOrderShipmentBoxesRequest = {
    /**
     * Список грузовых мест. Маркет определяет количество мест по длине этого списка.
     * @type {Array<ParcelBoxDTO>}
     * @memberof SetOrderShipmentBoxesRequest
     */
    boxes: Array<ParcelBoxDTO>;
}

/**
 * 
 * @export
 */
export type SetOrderShipmentBoxesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof SetOrderShipmentBoxesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {ShipmentBoxesDTO}
     * @memberof SetOrderShipmentBoxesResponse
     */
    result?: ShipmentBoxesDTO;
}

/**
 * Решения по позиции в возврате.
 * @export
 */
export type SetReturnDecisionRequest = {
    /**
     * Идентификатор товара в возврате.
     * @type {number}
     * @memberof SetReturnDecisionRequest
     */
    returnItemId: number;
    /**
     * 
     * @type {ReturnRequestDecisionType}
     * @memberof SetReturnDecisionRequest
     */
    decisionType: ReturnRequestDecisionType;
    /**
     * Комментарий к решению. Укажите:  * для `REFUND_MONEY_INCLUDING_SHIPMENT`— стоимость обратной пересылки;  * для `REPAIR` — когда вы устраните недостатки товара;  * для `DECLINE_REFUND` — причину отказа;  * для `OTHER_DECISION` — какое решение вы предлагаете. 
     * @type {string}
     * @memberof SetReturnDecisionRequest
     */
    comment?: string;
}

/**
 * Запрос на передачу количества упаковок в отгрузке.
 * @export
 */
export type SetShipmentPalletsCountRequest = {
    /**
     * Количество упаковок в отгрузке.
     * @type {number}
     * @memberof SetShipmentPalletsCountRequest
     */
    placesCount: number;
}

/**
 * Тип атрибуции:   * `CLICKS` — по кликам.   * `SHOWS` — по показам. <br><br>  О том, какие данные в отчете зависят и не зависят от типа атрибуции, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf#stats). 
 * @export
 * @enum {string}
 */
export type ShelfsStatisticsAttributionType = 'CLICKS' | 'SHOWS';

/**
 * Действия с отгрузкой:  * `CONFIRM` — подтвердить отгрузку. * `DOWNLOAD_ACT` — скачать акт приема-передачи отгрузки. * `DOWNLOAD_INBOUND_ACT` — скачать список принятых заказов. * `DOWNLOAD_DISCREPANCY_ACT` — скачать акт расхождений. * `CHANGE_PALLETS_COUNT` — указать количество палет. 
 * @export
 * @enum {string}
 */
export type ShipmentActionType = 'CONFIRM' | 'DOWNLOAD_ACT' | 'DOWNLOAD_INBOUND_ACT' | 'DOWNLOAD_DISCREPANCY_ACT' | 'CHANGE_PALLETS_COUNT';

/**
 * В ответе Маркет возвращает переданный вами список грузовых мест. Не обращайте на это поле внимания. 
 * @export
 */
export type ShipmentBoxesDTO = {
    /**
     * Список грузовых мест. Маркет определил количество мест по длине этого списка. 
     * @type {Array<ParcelBoxDTO>}
     * @memberof ShipmentBoxesDTO
     */
    boxes: Array<ParcelBoxDTO>;
}

/**
 * Информация об отгрузке.
 * @export
 */
export type ShipmentDTO = {
    /**
     * Идентификатор отгрузки.
     * @type {number}
     * @memberof ShipmentDTO
     */
    id?: number;
    /**
     * Начало планового интервала отгрузки.
     * @type {Date}
     * @memberof ShipmentDTO
     */
    planIntervalFrom?: Date;
    /**
     * Конец планового интервала отгрузки.
     * @type {Date}
     * @memberof ShipmentDTO
     */
    planIntervalTo?: Date;
    /**
     * 
     * @type {ShipmentType}
     * @memberof ShipmentDTO
     */
    shipmentType?: ShipmentType;
    /**
     * 
     * @type {PartnerShipmentWarehouseDTO}
     * @memberof ShipmentDTO
     */
    warehouse?: PartnerShipmentWarehouseDTO;
    /**
     * 
     * @type {PartnerShipmentWarehouseDTO}
     * @memberof ShipmentDTO
     */
    warehouseTo?: PartnerShipmentWarehouseDTO;
    /**
     * Идентификатор отгрузки в вашей системе. Если вы еще не передавали идентификатор, вернется идентификатор из параметра `id`.
     * @type {string}
     * @memberof ShipmentDTO
     */
    externalId?: string;
    /**
     * 
     * @type {DeliveryServiceDTO}
     * @memberof ShipmentDTO
     */
    deliveryService?: DeliveryServiceDTO;
    /**
     * 
     * @type {PalletsCountDTO}
     * @memberof ShipmentDTO
     */
    palletsCount?: PalletsCountDTO;
    /**
     * Идентификаторы заказов в отгрузке.
     * @type {Set<number>}
     * @memberof ShipmentDTO
     */
    orderIds: Set<number>;
    /**
     * Количество заказов, которое Маркет запланировал к отгрузке.
     * @type {number}
     * @memberof ShipmentDTO
     */
    draftCount?: number;
    /**
     * Количество заказов, которое Маркет подтвердил к отгрузке.
     * @type {number}
     * @memberof ShipmentDTO
     */
    plannedCount?: number;
    /**
     * Количество заказов, принятых в сортировочном центре или пункте приема.
     * @type {number}
     * @memberof ShipmentDTO
     */
    factCount?: number;
    /**
     * 
     * @type {ShipmentStatusChangeDTO}
     * @memberof ShipmentDTO
     */
    currentStatus?: ShipmentStatusChangeDTO;
    /**
     * Доступные действия над отгрузкой.
     * @type {Set<ShipmentActionType>}
     * @memberof ShipmentDTO
     */
    availableActions: Set<ShipmentActionType>;
}

/**
 * Список с информацией об отгрузках.
 * @export
 */
export type ShipmentInfoDTO = {
    /**
     * Идентификатор отгрузки.
     * @type {number}
     * @memberof ShipmentInfoDTO
     */
    id?: number;
    /**
     * Начало планового интервала отгрузки.
     * @type {Date}
     * @memberof ShipmentInfoDTO
     */
    planIntervalFrom?: Date;
    /**
     * Конец планового интервала отгрузки.
     * @type {Date}
     * @memberof ShipmentInfoDTO
     */
    planIntervalTo?: Date;
    /**
     * 
     * @type {ShipmentType}
     * @memberof ShipmentInfoDTO
     */
    shipmentType?: ShipmentType;
    /**
     * 
     * @type {PartnerShipmentWarehouseDTO}
     * @memberof ShipmentInfoDTO
     */
    warehouse?: PartnerShipmentWarehouseDTO;
    /**
     * 
     * @type {PartnerShipmentWarehouseDTO}
     * @memberof ShipmentInfoDTO
     */
    warehouseTo?: PartnerShipmentWarehouseDTO;
    /**
     * Идентификатор отгрузки в вашей системе. Если вы еще не передавали идентификатор, вернется идентификатор из параметра `id`.
     * @type {string}
     * @memberof ShipmentInfoDTO
     */
    externalId?: string;
    /**
     * 
     * @type {DeliveryServiceDTO}
     * @memberof ShipmentInfoDTO
     */
    deliveryService?: DeliveryServiceDTO;
    /**
     * 
     * @type {PalletsCountDTO}
     * @memberof ShipmentInfoDTO
     */
    palletsCount?: PalletsCountDTO;
    /**
     * Идентификаторы заказов в отгрузке.
     * @type {Set<number>}
     * @memberof ShipmentInfoDTO
     */
    orderIds: Set<number>;
    /**
     * Количество заказов, которое Маркет запланировал к отгрузке.
     * @type {number}
     * @memberof ShipmentInfoDTO
     */
    draftCount?: number;
    /**
     * Количество заказов, которое Маркет подтвердил к отгрузке.
     * @type {number}
     * @memberof ShipmentInfoDTO
     */
    plannedCount?: number;
    /**
     * Количество заказов, принятых в сортировочном центре или пункте приема.
     * @type {number}
     * @memberof ShipmentInfoDTO
     */
    factCount?: number;
    /**
     * 
     * @type {ShipmentStatusType}
     * @memberof ShipmentInfoDTO
     */
    status?: ShipmentStatusType;
    /**
     * Описание статуса отгрузки.
     * @type {string}
     * @memberof ShipmentInfoDTO
     */
    statusDescription?: string;
    /**
     * Время последнего изменения статуса отгрузки.
     * @type {Date}
     * @memberof ShipmentInfoDTO
     */
    statusUpdateTime?: Date;
}

/**
 * Формат страницы: * `A4` — формат страницы A4. * `A8` — формат страницы A8. 
 * @export
 * @enum {string}
 */
export type ShipmentPalletLabelPageFormatType = 'A4' | 'A8';

/**
 * Статус отгрузки.
 * @export
 */
export type ShipmentStatusChangeDTO = {
    /**
     * 
     * @type {ShipmentStatusType}
     * @memberof ShipmentStatusChangeDTO
     */
    status?: ShipmentStatusType;
    /**
     * Описание статуса отгрузки.
     * @type {string}
     * @memberof ShipmentStatusChangeDTO
     */
    description?: string;
    /**
     * Время последнего изменения статуса отгрузки.
     * @type {Date}
     * @memberof ShipmentStatusChangeDTO
     */
    updateTime?: Date;
}

/**
 * Статус отгрузки:  * `OUTBOUND_CREATED` — формируется. * `OUTBOUND_READY_FOR_CONFIRMATION` — можно обрабатывать. * `OUTBOUND_CONFIRMED` — подтверждена и готова к отправке. * `OUTBOUND_SIGNED` — по ней подписан электронный акт приема-передачи. * `ACCEPTED` — принята в сортировочном центре или пункте приема. * `ACCEPTED_WITH_DISCREPANCIES` — принята с расхождениями. * `FINISHED` — завершена. * `ERROR` — отменена из-за ошибки. 
 * @export
 * @enum {string}
 */
export type ShipmentStatusType = 'OUTBOUND_CREATED' | 'OUTBOUND_READY_FOR_CONFIRMATION' | 'OUTBOUND_CONFIRMED' | 'OUTBOUND_SIGNED' | 'FINISHED' | 'ACCEPTED' | 'ACCEPTED_WITH_DISCREPANCIES' | 'ERROR';

/**
 * Способ отгрузки заказов:  * `IMPORT` — вы самостоятельно привозите заказы в выбранный сортировочный центр или пункт приема заказов. * `WITHDRAW` — вы отгружаете заказы со своего склада курьерам Яндекс Маркета. 
 * @export
 * @enum {string}
 */
export type ShipmentType = 'IMPORT' | 'WITHDRAW';

/**
 * Группировка данных отчета. Возможные значения: * `CATEGORIES` — группировка по категориям. * `OFFERS` — группировка по товарам. 
 * @export
 * @enum {string}
 */
export type ShowsSalesGroupingType = 'CATEGORIES' | 'OFFERS';

/**
 * Идентификаторы отзывов.
 * @export
 */
export type SkipGoodsFeedbackReactionRequest = {
    /**
     * Список идентификаторов отзывов, на которые магазин не будет отвечать.
     * @type {Set<number>}
     * @memberof SkipGoodsFeedbackReactionRequest
     */
    feedbackIds: Set<number>;
}

/**
 * Список товаров и ставок на них.
 * @export
 */
export type SkuBidItemDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof SkuBidItemDTO
     */
    sku: string;
    /**
     * Значение ставки.
     * @type {number}
     * @memberof SkuBidItemDTO
     */
    bid: number;
}

/**
 * Список товаров с рекомендованными ставками.
 * @export
 */
export type SkuBidRecommendationItemDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof SkuBidRecommendationItemDTO
     */
    sku: string;
    /**
     * Значение ставки.
     * @type {number}
     * @memberof SkuBidRecommendationItemDTO
     */
    bid: number;
    /**
     * Список рекомендованных ставок с соответствующими долями показов. Чем больше ставка, тем большую долю показов она помогает получить. 
     * @type {Array<BidRecommendationItemDTO>}
     * @memberof SkuBidRecommendationItemDTO
     */
    bidRecommendations?: Array<BidRecommendationItemDTO>;
    /**
     * Рекомендованные цены.
     * @type {Array<PriceRecommendationItemDTO>}
     * @memberof SkuBidRecommendationItemDTO
     */
    priceRecommendations?: Array<PriceRecommendationItemDTO>;
}

/**
 * Направление сортировки.  Возможные значения: - `ASC` — сортировка по возрастанию. - `DESC` — сортировка по убыванию. 
 * @export
 * @enum {string}
 */
export type SortOrderType = 'ASC' | 'DESC';

/**
 * Товар, для которого требуется получить цены для продвижения.
 * @export
 */
export type SuggestOfferPriceDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof SuggestOfferPriceDTO
     */
    offerId?: string;
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof SuggestOfferPriceDTO
     */
    marketSku?: number;
}

/**
 * Запрос на получение списка цен для продвижения.
 * @export
 */
export type SuggestPricesRequest = {
    /**
     * Список товаров.
     * @type {Array<SuggestOfferPriceDTO>}
     * @memberof SuggestPricesRequest
     */
    offers: Array<SuggestOfferPriceDTO>;
}

/**
 * Ответ на запрос списка цен для продвижения.
 * @export
 */
export type SuggestPricesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof SuggestPricesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {SuggestPricesResultDTO}
     * @memberof SuggestPricesResponse
     */
    result?: SuggestPricesResultDTO;
}

/**
 * Результат запроса цен для продвижения.
 * @export
 */
export type SuggestPricesResultDTO = {
    /**
     * Список товаров с ценами для продвижения.
     * @type {Array<PriceSuggestOfferDTO>}
     * @memberof SuggestPricesResultDTO
     */
    offers: Array<PriceSuggestOfferDTO>;
}

/**
 * Информация о товаре.
 * @export
 */
export type SuggestedOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof SuggestedOfferDTO
     */
    offerId?: string;
    /**
     * Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
     * @type {string}
     * @memberof SuggestedOfferDTO
     */
    name?: string;
    /**
     * Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
     * @type {string}
     * @memberof SuggestedOfferDTO
     */
    category?: string;
    /**
     * Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
     * @type {string}
     * @memberof SuggestedOfferDTO
     */
    vendor?: string;
    /**
     * Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
     * @type {Array<string>}
     * @memberof SuggestedOfferDTO
     */
    barcodes?: Array<string>;
    /**
     * Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
     * @type {string}
     * @memberof SuggestedOfferDTO
     */
    description?: string;
    /**
     * Артикул товара от производителя.
     * @type {string}
     * @memberof SuggestedOfferDTO
     */
    vendorCode?: string;
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof SuggestedOfferDTO
     */
    basicPrice?: BasePriceDTO;
}

/**
 * Товар с соответствующей карточкой на Маркете.
 * @export
 */
export type SuggestedOfferMappingDTO = {
    /**
     * 
     * @type {SuggestedOfferDTO}
     * @memberof SuggestedOfferMappingDTO
     */
    offer?: SuggestedOfferDTO;
    /**
     * 
     * @type {GetMappingDTO}
     * @memberof SuggestedOfferMappingDTO
     */
    mapping?: GetMappingDTO;
}

/**
 * Информация о тарифах, по которым нужно заплатить за услуги Маркета.
 * @export
 */
export type TariffDTO = {
    /**
     * 
     * @type {TariffType}
     * @memberof TariffDTO
     */
    type: TariffType;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Значение тарифа в процентах. 
     * @type {number}
     * @memberof TariffDTO
     */
    percent?: number;
    /**
     * Значение тарифа в рублях.
     * @type {number}
     * @memberof TariffDTO
     */
    amount: number;
    /**
     * Параметры расчета тарифа.
     * @type {Array<TariffParameterDTO>}
     * @memberof TariffDTO
     */
    parameters: Array<TariffParameterDTO>;
}

/**
 * Детали расчета конкретной услуги Маркета.
 * @export
 */
export type TariffParameterDTO = {
    /**
     * Название параметра.
     * @type {string}
     * @memberof TariffParameterDTO
     */
    name: string;
    /**
     * Значение параметра.
     * @type {string}
     * @memberof TariffParameterDTO
     */
    value: string;
}

/**
 * Услуга Маркета или дополнительный тариф к услуге размещения:  * `AGENCY_COMMISSION` — прием платежа покупателя.  * `PAYMENT_TRANSFER` — перевод платежа покупателя.  * `STORAGE` — хранение товара на складе Маркета в течение суток.  * `SURPLUS` — хранение излишков на складе Маркета.  * `WITHDRAW` — вывоз товара со склада Маркета.  * `FEE` — размещение товара на Маркете.  * `DELIVERY_TO_CUSTOMER` — доставка покупателю.  * `CROSSREGIONAL_DELIVERY` — доставка в федеральный округ, город или населенный пункт.  * `CROSSREGIONAL_DELIVERY_RETURN` — доставка невыкупов и возвратов.  * `DISPOSAL` — утилизация.  * `SORTING_CENTER_STORAGE` — хранение невыкупов и возвратов.  * `EXPRESS_DELIVERY` — экспресс-доставка покупателю.  * `FF_XDOC_SUPPLY_BOX` — поставка товара через транзитный склад (за короб).  * `FF_XDOC_SUPPLY_PALLET` — поставка товара через транзитный склад (за палету).  * `SORTING` — обработка заказа.  * `MIDDLE_MILE` — средняя миля.  * `RETURN_PROCESSING` — обработка невыкупов и возвратов.  * `EXPRESS_CANCELLED_BY_PARTNER` — отмена заказа с экспресс-доставкой.  * `DELIVERY_TO_CUSTOMER_RETURN` — возврат доставляемого товара на склад.  * `CROSSBORDER_DELIVERY` — доставка из-за рубежа.  * `INTAKE_SORTING_BULKY_CARGO` — сортировка заказов с крупногабаритными товарами, которые Маркет забрал со склада продавца.  * `INTAKE_SORTING_SMALL_GOODS` — сортировка заказов с малогабаритными товарами, которые Маркет забрал со склада продавца.  * `INTAKE_SORTING_DAILY` — организация забора заказов со склада продавца.  * `FF_STORAGE_BILLING` — хранения товаров на складе.  * `CANCELLED_ORDER_FEE_QI` — отмена заказа по вине продавца.  * `LATE_ORDER_EXECUTION_FEE_QI` — несвоевременная отгрузка или доставка.  Подробнее об услугах Маркета читайте [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/introduction/rates/index.html). 
 * @export
 * @enum {string}
 */
export type TariffType = 'AGENCY_COMMISSION' | 'PAYMENT_TRANSFER' | 'STORAGE' | 'WITHDRAW' | 'SURPLUS' | 'FEE' | 'DELIVERY_TO_CUSTOMER' | 'CROSSREGIONAL_DELIVERY' | 'CROSSREGIONAL_DELIVERY_RETURN' | 'DISPOSAL' | 'SORTING_CENTER_STORAGE' | 'EXPRESS_DELIVERY' | 'FF_XDOC_SUPPLY_BOX' | 'FF_XDOC_SUPPLY_PALLET' | 'SORTING' | 'MIDDLE_MILE' | 'RETURN_PROCESSING' | 'EXPRESS_CANCELLED_BY_PARTNER' | 'DELIVERY_TO_CUSTOMER_RETURN' | 'CROSSBORDER_DELIVERY' | 'INTAKE_SORTING_BULKY_CARGO' | 'INTAKE_SORTING_SMALL_GOODS' | 'INTAKE_SORTING_DAILY' | 'FF_STORAGE_BILLING' | 'CANCELLED_ORDER_FEE_QI' | 'LATE_ORDER_EXECUTION_FEE_QI';

/**
 * Временной отрезок с комментарием. Требования к содержанию комментария зависят от контекста использования параметра и указаны в описании поля, которое его содержит.
 * @export
 */
export type TimePeriodDTO = {
    /**
     * Продолжительность в указанных единицах.
     * @type {number}
     * @memberof TimePeriodDTO
     */
    timePeriod: number;
    /**
     * 
     * @type {TimeUnitType}
     * @memberof TimePeriodDTO
     */
    timeUnit: TimeUnitType;
    /**
     * Комментарий.
     * @type {string}
     * @memberof TimePeriodDTO
     */
    comment?: string;
}

/**
 * Единица измерения времени:  * `HOUR` — час. * `DAY` — сутки. * `WEEK` — неделя. * `MONTH` — месяц. * `YEAR` — год. 
 * @export
 * @enum {string}
 */
export type TimeUnitType = 'HOUR' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';

/**
 * Информация о трек-номерах.
 * @export
 */
export type TrackDTO = {
    /**
     * Трек-код почтового отправления.
     * @type {string}
     * @memberof TrackDTO
     */
    trackCode?: string;
}

/**
 * Запрос переноса заказов из отгрузки.
 * @export
 */
export type TransferOrdersFromShipmentRequest = {
    /**
     * Список заказов, которые вы не успеваете подготовить.
     * @type {Array<number>}
     * @memberof TransferOrdersFromShipmentRequest
     */
    orderIds: Array<number>;
}

/**
 * Информация об оборачиваемости товара.
 * @export
 */
export type TurnoverDTO = {
    /**
     * 
     * @type {TurnoverType}
     * @memberof TurnoverDTO
     */
    turnover: TurnoverType;
    /**
     * Значение в днях. [Что это за число?](https://yandex.ru/support/marketplace/analytics/turnover.html)
     * @type {number}
     * @memberof TurnoverDTO
     */
    turnoverDays?: number;
}

/**
 * Оценка оборачиваемости.  |enum|Диапазон оборачиваемости|Комментарий| |-|-|-| |`LOW`|`turnoverDays` ≥ 120|| |`ALMOST_LOW`|100 ≤ `turnoverDays` < 120|| |`HIGH`|45 ≤ `turnoverDays` < 100|| |`VERY_HIGH`|0 ≤ `turnoverDays` < 45|| |`NO_SALES`|—|Продаж нет.| |`FREE_STORE`|Любое значение.|Товары этой категории сейчас хранятся бесплатно.| 
 * @export
 * @enum {string}
 */
export type TurnoverType = 'LOW' | 'ALMOST_LOW' | 'HIGH' | 'VERY_HIGH' | 'NO_SALES' | 'FREE_STORE';

/**
 * Единица измерения.
 * @export
 */
export type UnitDTO = {
    /**
     * Идентификатор единицы измерения.
     * @type {number}
     * @memberof UnitDTO
     */
    id: number;
    /**
     * Сокращенное название единицы измерения.
     * @type {string}
     * @memberof UnitDTO
     */
    name: string;
    /**
     * Полное название единицы измерения.
     * @type {string}
     * @memberof UnitDTO
     */
    fullName: string;
}

/**
 * Товар с новой ценой.
 * @export
 */
export type UpdateBusinessOfferPriceDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof UpdateBusinessOfferPriceDTO
     */
    offerId: string;
    /**
     * 
     * @type {UpdatePriceWithDiscountDTO}
     * @memberof UpdateBusinessOfferPriceDTO
     */
    price: UpdatePriceWithDiscountDTO;
}

/**
 * Запрос на установку базовых цен на товары.
 * @export
 */
export type UpdateBusinessPricesRequest = {
    /**
     * Список товаров с ценами.
     * @type {Array<UpdateBusinessOfferPriceDTO>}
     * @memberof UpdateBusinessPricesRequest
     */
    offers: Array<UpdateBusinessOfferPriceDTO>;
}

/**
 * Параметры размещения товара в магазине.
 * @export
 */
export type UpdateCampaignOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof UpdateCampaignOfferDTO
     */
    offerId: string;
    /**
     * 
     * @type {QuantumDTO}
     * @memberof UpdateCampaignOfferDTO
     */
    quantum?: QuantumDTO;
    /**
     * Есть ли товар в продаже. 
     * @type {boolean}
     * @memberof UpdateCampaignOfferDTO
     */
    available?: boolean;
    /**
     * Ставка НДС, применяемая для товара. Задается цифрой:  * `2` — 10%. * `5` — 0%. * `6` — не облагается НДС. * `7` — 20%.  Если параметр не указан, используется ставка НДС, установленная в кабинете продавца на Маркете. 
     * @type {number}
     * @memberof UpdateCampaignOfferDTO
     */
    vat?: number;
}

/**
 * Запрос на обновление предложений товаров магазина.
 * @export
 */
export type UpdateCampaignOffersRequest = {
    /**
     * Параметры размещения товаров в заданном магазине.
     * @type {Array<UpdateCampaignOfferDTO>}
     * @memberof UpdateCampaignOffersRequest
     */
    offers: Array<UpdateCampaignOfferDTO>;
}

/**
 * Комментарий к отзыву или другому комментарию.
 * @export
 */
export type UpdateGoodsFeedbackCommentDTO = {
    /**
     * Идентификатор комментария к отзыву. 
     * @type {number}
     * @memberof UpdateGoodsFeedbackCommentDTO
     */
    id?: number;
    /**
     * Идентификатор комментария к отзыву. 
     * @type {number}
     * @memberof UpdateGoodsFeedbackCommentDTO
     */
    parentId?: number;
    /**
     * Текст комментария.
     * @type {string}
     * @memberof UpdateGoodsFeedbackCommentDTO
     */
    text: string;
}

/**
 * Комментарий к отзыву.
 * @export
 */
export type UpdateGoodsFeedbackCommentRequest = {
    /**
     * Идентификатор отзыва. 
     * @type {number}
     * @memberof UpdateGoodsFeedbackCommentRequest
     */
    feedbackId: number;
    /**
     * 
     * @type {UpdateGoodsFeedbackCommentDTO}
     * @memberof UpdateGoodsFeedbackCommentRequest
     */
    comment: UpdateGoodsFeedbackCommentDTO;
}

/**
 * 
 * @export
 */
export type UpdateGoodsFeedbackCommentResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof UpdateGoodsFeedbackCommentResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {GoodsFeedbackCommentDTO}
     * @memberof UpdateGoodsFeedbackCommentResponse
     */
    result?: GoodsFeedbackCommentDTO;
}

/**
 * Карточка на Маркете, которая, с вашей точки зрения, подходит товару. Чтобы определить идентификатор подходящей карточки, воспользуйтесь поиском в кабинете (**Товары** → **Каталог** → **Загрузить товары**).  По результатам проверки Маркет может привязать товар к более подходящей карточке. 
 * @export
 */
export type UpdateMappingDTO = {
    /**
     * SKU на Маркете.
     * @type {number}
     * @memberof UpdateMappingDTO
     */
    marketSku?: number;
}

/**
 * Информация о товарах в каталоге.
 * @export
 */
export type UpdateMappingsOfferDTO = {
    /**
     * Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
     * @type {string}
     * @memberof UpdateMappingsOfferDTO
     */
    name?: string;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof UpdateMappingsOfferDTO
     */
    shopSku?: string;
    /**
     * Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
     * @type {string}
     * @memberof UpdateMappingsOfferDTO
     */
    category?: string;
    /**
     * Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
     * @type {string}
     * @memberof UpdateMappingsOfferDTO
     */
    vendor?: string;
    /**
     * Артикул товара от производителя.
     * @type {string}
     * @memberof UpdateMappingsOfferDTO
     */
    vendorCode?: string;
    /**
     * Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
     * @type {string}
     * @memberof UpdateMappingsOfferDTO
     */
    description?: string;
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof UpdateMappingsOfferDTO
     */
    id?: string;
    /**
     * Идентификатор фида.
     * @type {number}
     * @memberof UpdateMappingsOfferDTO
     */
    feedId?: number;
    /**
     * Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
     * @type {Array<string>}
     * @memberof UpdateMappingsOfferDTO
     */
    barcodes?: Array<string>;
    /**
     * URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
     * @type {Array<string>}
     * @memberof UpdateMappingsOfferDTO
     */
    urls?: Array<string>;
    /**
     * Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр `picture`. 
     * @type {Array<string>}
     * @memberof UpdateMappingsOfferDTO
     */
    pictures?: Array<string>;
    /**
     * Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
     * @type {string}
     * @memberof UpdateMappingsOfferDTO
     */
    manufacturer?: string;
    /**
     * Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
     * @type {Array<string>}
     * @memberof UpdateMappingsOfferDTO
     */
    manufacturerCountries?: Array<string>;
    /**
     * Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
     * @type {number}
     * @memberof UpdateMappingsOfferDTO
     */
    minShipment?: number;
    /**
     * Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
     * @type {number}
     * @memberof UpdateMappingsOfferDTO
     */
    transportUnitSize?: number;
    /**
     * Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
     * @type {number}
     * @memberof UpdateMappingsOfferDTO
     */
    quantumOfSupply?: number;
    /**
     * Срок, за который продавец поставляет товары на склад, в днях.
     * @type {number}
     * @memberof UpdateMappingsOfferDTO
     */
    deliveryDurationDays?: number;
    /**
     * Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
     * @type {number}
     * @memberof UpdateMappingsOfferDTO
     */
    boxCount?: number;
    /**
     * Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
     * @type {Array<string>}
     * @memberof UpdateMappingsOfferDTO
     */
    customsCommodityCodes?: Array<string>;
    /**
     * 
     * @type {OfferWeightDimensionsDTO}
     * @memberof UpdateMappingsOfferDTO
     */
    weightDimensions?: OfferWeightDimensionsDTO;
    /**
     * Дни недели, в которые продавец поставляет товары на склад.
     * @type {Array<DayOfWeekType>}
     * @memberof UpdateMappingsOfferDTO
     */
    supplyScheduleDays?: Array<DayOfWeekType>;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `shelfLife`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
     * @type {number}
     * @memberof UpdateMappingsOfferDTO
     */
    shelfLifeDays?: number;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `lifeTime`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
     * @type {number}
     * @memberof UpdateMappingsOfferDTO
     */
    lifeTimeDays?: number;
    /**
     * Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
     * @type {number}
     * @memberof UpdateMappingsOfferDTO
     */
    guaranteePeriodDays?: number;
    /**
     * 
     * @type {OfferProcessingStateDTO}
     * @memberof UpdateMappingsOfferDTO
     */
    processingState?: OfferProcessingStateDTO;
    /**
     * 
     * @type {OfferAvailabilityStatusType}
     * @memberof UpdateMappingsOfferDTO
     */
    availability?: OfferAvailabilityStatusType;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof UpdateMappingsOfferDTO
     */
    shelfLife?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof UpdateMappingsOfferDTO
     */
    lifeTime?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof UpdateMappingsOfferDTO
     */
    guaranteePeriod?: TimePeriodDTO;
    /**
     * Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
     * @type {string}
     * @memberof UpdateMappingsOfferDTO
     */
    certificate?: string;
}

/**
 * Запрос на установку новых значений для параметров.
 * @export
 */
export type UpdateOfferContentRequest = {
    /**
     * Список товаров с указанными характеристиками.
     * @type {Array<OfferContentDTO>}
     * @memberof UpdateOfferContentRequest
     */
    offersContent: Array<OfferContentDTO>;
}

/**
 * Описывает проблемы, которые появились при сохранении товара.
 * @export
 */
export type UpdateOfferContentResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof UpdateOfferContentResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Ошибки и предупреждения, которые появились при обработке переданных значений. Каждый элемент списка соответствует одному товару.  Если ошибок и предупреждений нет, поле не передается. 
     * @type {Array<UpdateOfferContentResultDTO>}
     * @memberof UpdateOfferContentResponse
     */
    results?: Array<UpdateOfferContentResultDTO>;
}

/**
 * Ошибки и предупреждения, которые появились из-за переданных характеристик.
 * @export
 */
export type UpdateOfferContentResultDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof UpdateOfferContentResultDTO
     */
    offerId: string;
    /**
     * Ошибки — информация в каталоге не обновится.
     * @type {Array<OfferContentErrorDTO>}
     * @memberof UpdateOfferContentResultDTO
     */
    errors?: Array<OfferContentErrorDTO>;
    /**
     * Предупреждения — информация в каталоге обновится.
     * @type {Array<OfferContentErrorDTO>}
     * @memberof UpdateOfferContentResultDTO
     */
    warnings?: Array<OfferContentErrorDTO>;
}

/**
 * Параметры товара.
 * @export
 */
export type UpdateOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof UpdateOfferDTO
     */
    offerId: string;
    /**
     * Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
     * @type {string}
     * @memberof UpdateOfferDTO
     */
    name?: string;
    /**
     * Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать `marketCategoryId`, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
     * @type {number}
     * @memberof UpdateOfferDTO
     */
    marketCategoryId?: number;
    /**
     * Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
     * @type {string}
     * @memberof UpdateOfferDTO
     */
    category?: string;
    /**
     * Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/images/sku12345.jpg`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/images/sku12345.jpg`  ❌ `https://www.dropbox.com/s/818f/tovar.jpg`  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html) 
     * @type {Array<string>}
     * @memberof UpdateOfferDTO
     */
    pictures?: Array<string>;
    /**
     * Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/video/sku12345.avi`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/video/sku12345.avi`  ❌ `https://www.dropbox.com/s/818f/super-tovar.avi`  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html) 
     * @type {Array<string>}
     * @memberof UpdateOfferDTO
     */
    videos?: Array<string>;
    /**
     * Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле `manuals`, загруженные ранее инструкции удалятся. 
     * @type {Array<OfferManualDTO>}
     * @memberof UpdateOfferDTO
     */
    manuals?: Array<OfferManualDTO>;
    /**
     * Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
     * @type {string}
     * @memberof UpdateOfferDTO
     */
    vendor?: string;
    /**
     * Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
     * @type {Array<string>}
     * @memberof UpdateOfferDTO
     */
    barcodes?: Array<string>;
    /**
     * Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
     * @type {string}
     * @memberof UpdateOfferDTO
     */
    description?: string;
    /**
     * Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx). 
     * @type {Array<string>}
     * @memberof UpdateOfferDTO
     */
    manufacturerCountries?: Array<string>;
    /**
     * 
     * @type {OfferWeightDimensionsDTO}
     * @memberof UpdateOfferDTO
     */
    weightDimensions?: OfferWeightDimensionsDTO;
    /**
     * Артикул товара от производителя.
     * @type {string}
     * @memberof UpdateOfferDTO
     */
    vendorCode?: string;
    /**
     * Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов. 
     * @type {Array<string>}
     * @memberof UpdateOfferDTO
     */
    tags?: Array<string>;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof UpdateOfferDTO
     */
    shelfLife?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof UpdateOfferDTO
     */
    lifeTime?: TimePeriodDTO;
    /**
     * 
     * @type {TimePeriodDTO}
     * @memberof UpdateOfferDTO
     */
    guaranteePeriod?: TimePeriodDTO;
    /**
     * Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть. 
     * @type {string}
     * @memberof UpdateOfferDTO
     */
    customsCommodityCode?: string;
    /**
     * Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html). 
     * @type {Array<string>}
     * @memberof UpdateOfferDTO
     */
    certificates?: Array<string>;
    /**
     * Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр. 
     * @type {number}
     * @memberof UpdateOfferDTO
     */
    boxCount?: number;
    /**
     * 
     * @type {OfferConditionDTO}
     * @memberof UpdateOfferDTO
     */
    condition?: OfferConditionDTO;
    /**
     * 
     * @type {OfferType}
     * @memberof UpdateOfferDTO
     */
    type?: OfferType;
    /**
     * Признак цифрового товара. Укажите `true`, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md) 
     * @type {boolean}
     * @memberof UpdateOfferDTO
     */
    downloadable?: boolean;
    /**
     * Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей. 
     * @type {boolean}
     * @memberof UpdateOfferDTO
     */
    adult?: boolean;
    /**
     * 
     * @type {AgeDTO}
     * @memberof UpdateOfferDTO
     */
    age?: AgeDTO;
    /**
     * {% note warning \"\" %}  Этот параметр устарел. При передаче характеристик используйте `parameterValues`.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви. 
     * @type {Array<OfferParamDTO>}
     * @memberof UpdateOfferDTO
     */
    params?: Array<OfferParamDTO>;
    /**
     * Список характеристик с их значениями.  С `parameterValues` обязательно передавайте `marketCategoryId` — идентификатор категории на Маркете, к которой относятся указанные характеристики товара.  При **изменении** характеристик передавайте только те, значение которых нужно обновить.  Чтобы **удалить** значение заданной характеристики, передайте ее `parameterId` с пустым `value`.  Максимальное количество характеристик — 300. 
     * @type {Array<ParameterValueDTO>}
     * @memberof UpdateOfferDTO
     */
    parameterValues?: Array<ParameterValueDTO>;
    /**
     * 
     * @type {UpdatePriceWithDiscountDTO}
     * @memberof UpdateOfferDTO
     */
    basicPrice?: UpdatePriceWithDiscountDTO;
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof UpdateOfferDTO
     */
    purchasePrice?: BasePriceDTO;
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof UpdateOfferDTO
     */
    additionalExpenses?: BasePriceDTO;
    /**
     * 
     * @type {BasePriceDTO}
     * @memberof UpdateOfferDTO
     */
    cofinancePrice?: BasePriceDTO;
}

/**
 * Информация о товаре.
 * @export
 */
export type UpdateOfferMappingDTO = {
    /**
     * 
     * @type {UpdateOfferDTO}
     * @memberof UpdateOfferMappingDTO
     */
    offer: UpdateOfferDTO;
    /**
     * 
     * @type {UpdateMappingDTO}
     * @memberof UpdateOfferMappingDTO
     */
    mapping?: UpdateMappingDTO;
}

/**
 * Список товаров.  В теле запроса можно передать от одного до 500 товаров.  Обязательный параметр. 
 * @export
 */
export type UpdateOfferMappingEntryDTO = {
    /**
     * 
     * @type {OfferMappingDTO}
     * @memberof UpdateOfferMappingEntryDTO
     */
    mapping?: OfferMappingDTO;
    /**
     * 
     * @type {OfferMappingDTO}
     * @memberof UpdateOfferMappingEntryDTO
     */
    awaitingModerationMapping?: OfferMappingDTO;
    /**
     * 
     * @type {OfferMappingDTO}
     * @memberof UpdateOfferMappingEntryDTO
     */
    rejectedMapping?: OfferMappingDTO;
    /**
     * 
     * @type {UpdateMappingsOfferDTO}
     * @memberof UpdateOfferMappingEntryDTO
     */
    offer?: UpdateMappingsOfferDTO;
}

/**
 * Запрос на обновление товаров.
 * @export
 */
export type UpdateOfferMappingEntryRequest = {
    /**
     * Информация о товарах в каталоге.
     * @type {Array<UpdateOfferMappingEntryDTO>}
     * @memberof UpdateOfferMappingEntryRequest
     */
    offerMappingEntries: Array<UpdateOfferMappingEntryDTO>;
}

/**
 * Ошибки и предупреждения, которые появились из-за переданных характеристик.
 * @export
 */
export type UpdateOfferMappingResultDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof UpdateOfferMappingResultDTO
     */
    offerId: string;
    /**
     * Ошибки — информация в каталоге не обновится.
     * @type {Array<OfferMappingErrorDTO>}
     * @memberof UpdateOfferMappingResultDTO
     */
    errors?: Array<OfferMappingErrorDTO>;
    /**
     * Предупреждения — информация в каталоге обновится.
     * @type {Array<OfferMappingErrorDTO>}
     * @memberof UpdateOfferMappingResultDTO
     */
    warnings?: Array<OfferMappingErrorDTO>;
}

/**
 * 
 * @export
 */
export type UpdateOfferMappingsRequest = {
    /**
     * Перечень товаров, которые нужно добавить или обновить.
     * @type {Array<UpdateOfferMappingDTO>}
     * @memberof UpdateOfferMappingsRequest
     */
    offerMappings: Array<UpdateOfferMappingDTO>;
    /**
     * Будут использоваться только переданные вами изображения товаров.  Значение по умолчанию — `false`. Если вы хотите заменить изображения, которые добавил Маркет, передайте значение `true`. 
     * @type {boolean}
     * @memberof UpdateOfferMappingsRequest
     */
    onlyPartnerMediaContent?: boolean;
}

/**
 * Описывает проблемы, возникшие при сохранении товара.
 * @export
 */
export type UpdateOfferMappingsResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof UpdateOfferMappingsResponse
     */
    status?: ApiResponseStatusType;
    /**
     * Ошибки и предупреждения, которые появились при обработке списка характеристик. Каждый элемент списка соответствует одному товару.  Если ошибок и предупреждений нет, поле не передается. 
     * @type {Array<UpdateOfferMappingResultDTO>}
     * @memberof UpdateOfferMappingsResponse
     */
    results?: Array<UpdateOfferMappingResultDTO>;
}

/**
 * Запрос на обновление состава заказа.
 * @export
 */
export type UpdateOrderItemRequest = {
    /**
     * Список товаров в заказе.  Если магазин не передал информацию о товаре во входных данных, он будет удален из заказа.  Обязательный параметр. 
     * @type {Array<OrderItemModificationDTO>}
     * @memberof UpdateOrderItemRequest
     */
    items: Array<OrderItemModificationDTO>;
    /**
     * 
     * @type {OrderItemsModificationRequestReasonType}
     * @memberof UpdateOrderItemRequest
     */
    reason?: OrderItemsModificationRequestReasonType;
}

/**
 * Список заказов.
 * @export
 */
export type UpdateOrderStatusDTO = {
    /**
     * Идентификатор заказа.
     * @type {number}
     * @memberof UpdateOrderStatusDTO
     */
    id?: number;
    /**
     * 
     * @type {OrderStatusType}
     * @memberof UpdateOrderStatusDTO
     */
    status?: OrderStatusType;
    /**
     * 
     * @type {OrderSubstatusType}
     * @memberof UpdateOrderStatusDTO
     */
    substatus?: OrderSubstatusType;
    /**
     * 
     * @type {OrderUpdateStatusType}
     * @memberof UpdateOrderStatusDTO
     */
    updateStatus?: OrderUpdateStatusType;
    /**
     * Ошибка при изменении статуса заказа. Содержит описание ошибки и идентификатор заказа.  Возвращается, если параметр `updateStatus` принимает значение `ERROR`. 
     * @type {string}
     * @memberof UpdateOrderStatusDTO
     */
    errorDetails?: string;
}

/**
 * 
 * @export
 */
export type UpdateOrderStatusRequest = {
    /**
     * 
     * @type {OrderStatusChangeDTO}
     * @memberof UpdateOrderStatusRequest
     */
    order: OrderStatusChangeDTO;
}

/**
 * Информация об изменении статуса заказа.
 * @export
 */
export type UpdateOrderStatusResponse = {
    /**
     * 
     * @type {OrderDTO}
     * @memberof UpdateOrderStatusResponse
     */
    order?: OrderDTO;
}

/**
 * Список заказов, статус которых обновился.
 * @export
 */
export type UpdateOrderStatusesDTO = {
    /**
     * Список с обновленными заказами.
     * @type {Array<UpdateOrderStatusDTO>}
     * @memberof UpdateOrderStatusesDTO
     */
    orders: Array<UpdateOrderStatusDTO>;
}

/**
 * Список заказов.
 * @export
 */
export type UpdateOrderStatusesRequest = {
    /**
     * Список заказов.
     * @type {Array<OrderStateDTO>}
     * @memberof UpdateOrderStatusesRequest
     */
    orders: Array<OrderStateDTO>;
}

/**
 * 
 * @export
 */
export type UpdateOrderStatusesResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof UpdateOrderStatusesResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {UpdateOrderStatusesDTO}
     * @memberof UpdateOrderStatusesResponse
     */
    result?: UpdateOrderStatusesDTO;
}

/**
 * Запрос на обновление срока хранения заказа в ПВЗ.
 * @export
 */
export type UpdateOrderStorageLimitRequest = {
    /**
     * Новая дата, до которой заказ будет храниться в пункте выдачи.  Срок хранения можно увеличить не больше, чем на 30 дней.  Формат даты: `ГГГГ-ММ-ДД`. 
     * @type {Date}
     * @memberof UpdateOrderStorageLimitRequest
     */
    newDate: Date;
}

/**
 * Запрос на создание или изменение лицензий для точек продаж.
 * @export
 */
export type UpdateOutletLicenseRequest = {
    /**
     * Список лицензий. Обязательный параметр, должен содержать информацию хотя бы об одной лицензии. 
     * @type {Array<OutletLicenseDTO>}
     * @memberof UpdateOutletLicenseRequest
     */
    licenses: Array<OutletLicenseDTO>;
}

/**
 * Цена с указанием скидки.
 * @export
 */
export type UpdatePriceWithDiscountDTO = {
    /**
     * Значение.
     * @type {number}
     * @memberof UpdatePriceWithDiscountDTO
     */
    value: number;
    /**
     * 
     * @type {CurrencyType}
     * @memberof UpdatePriceWithDiscountDTO
     */
    currencyId: CurrencyType;
    /**
     * Цена до скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
     * @type {number}
     * @memberof UpdatePriceWithDiscountDTO
     */
    discountBase?: number;
}

/**
 * Запрос на установку цен на товары.
 * @export
 */
export type UpdatePricesRequest = {
    /**
     * Список товаров.
     * @type {Array<OfferPriceDTO>}
     * @memberof UpdatePricesRequest
     */
    offers: Array<OfferPriceDTO>;
}

/**
 * Описание товаров, которые участвуют в акции.
 * @export
 */
export type UpdatePromoOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof UpdatePromoOfferDTO
     */
    offerId: string;
    /**
     * 
     * @type {UpdatePromoOfferParamsDTO}
     * @memberof UpdatePromoOfferDTO
     */
    params?: UpdatePromoOfferParamsDTO;
}

/**
 * Параметры товара в акции с типом `DIRECT_DISCOUNT` или `BLUE_FLASH`.  Обязательный параметр для акций с этими типами. 
 * @export
 */
export type UpdatePromoOfferDiscountParamsDTO = {
    /**
     * Зачеркнутая цена — та, по которой товар продавался до акции.  Указывается в рублях.  Число должно быть целым. 
     * @type {number}
     * @memberof UpdatePromoOfferDiscountParamsDTO
     */
    price?: number;
    /**
     * Цена по акции — та, по которой вы хотите продавать товар.  Указывается в рублях.  Число должно быть целым. 
     * @type {number}
     * @memberof UpdatePromoOfferDiscountParamsDTO
     */
    promoPrice?: number;
}

/**
 * Параметры товара, который участвует в акции.
 * @export
 */
export type UpdatePromoOfferParamsDTO = {
    /**
     * 
     * @type {UpdatePromoOfferDiscountParamsDTO}
     * @memberof UpdatePromoOfferParamsDTO
     */
    discountParams?: UpdatePromoOfferDiscountParamsDTO;
}

/**
 * Добавление товаров в акцию или обновление их параметров.  Чтобы добавить товары в акцию или обновить параметры каких-то товаров, передайте их в параметре `offers`. 
 * @export
 */
export type UpdatePromoOffersRequest = {
    /**
     * Идентификатор акции.
     * @type {string}
     * @memberof UpdatePromoOffersRequest
     */
    promoId: string;
    /**
     * Товары, которые необходимо добавить в акцию или цены которых нужно изменить.
     * @type {Array<UpdatePromoOfferDTO>}
     * @memberof UpdatePromoOffersRequest
     */
    offers: Array<UpdatePromoOfferDTO>;
}

/**
 * Результат добавления товаров в акцию.
 * @export
 */
export type UpdatePromoOffersResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof UpdatePromoOffersResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {UpdatePromoOffersResultDTO}
     * @memberof UpdatePromoOffersResponse
     */
    result?: UpdatePromoOffersResultDTO;
}

/**
 * Ошибки и предупреждения, которые появились при добавлении товаров в акцию.
 * @export
 */
export type UpdatePromoOffersResultDTO = {
    /**
     * Изменения, которые были отклонены.  Возвращается, только если есть отклоненные изменения. 
     * @type {Array<RejectedPromoOfferUpdateDTO>}
     * @memberof UpdatePromoOffersResultDTO
     */
    rejectedOffers?: Array<RejectedPromoOfferUpdateDTO>;
    /**
     * Изменения, по которым есть предупреждения. Они информируют о возможных проблемах. Информация о товарах обновится.  Возвращается, только если есть предупреждения. 
     * @type {Array<WarningPromoOfferUpdateDTO>}
     * @memberof UpdatePromoOffersResultDTO
     */
    warningOffers?: Array<WarningPromoOfferUpdateDTO>;
}

/**
 * Информация об остатках одного товара на одном из складов.
 * @export
 */
export type UpdateStockDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof UpdateStockDTO
     */
    sku: string;
    /**
     * Информация об остатках товара. 
     * @type {Array<UpdateStockItemDTO>}
     * @memberof UpdateStockDTO
     */
    items: Array<UpdateStockItemDTO>;
}

/**
 * Информация об остатках товара. 
 * @export
 */
export type UpdateStockItemDTO = {
    /**
     * Количество доступного товара. 
     * @type {number}
     * @memberof UpdateStockItemDTO
     */
    count: number;
    /**
     * Дата и время последнего обновления информации об остатках. <br><br> Если вы не передали параметр `updatedAt`, используется текущее время. <br><br> Формат даты и времени: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
     * @type {Date}
     * @memberof UpdateStockItemDTO
     */
    updatedAt?: Date;
}

/**
 * Запрос на изменение информации по остаткам товаров.
 * @export
 */
export type UpdateStocksRequest = {
    /**
     * Данные об остатках товаров. 
     * @type {Set<UpdateStockDTO>}
     * @memberof UpdateStocksRequest
     */
    skus: Set<UpdateStockDTO>;
}

/**
 * Время последнего обновления.
 * @export
 */
export type UpdateTimeDTO = {
    /**
     * Время последнего обновления.
     * @type {Date}
     * @memberof UpdateTimeDTO
     */
    updatedAt: Date;
}

/**
 * Ограничение на возможные значения, накладываемое другой характеристикой.  Если ограничивающая характеристика принимает определенное значение, список возможных значений ограничиваемой характеристики сокращается.  **Пример**  Характеристика **размер** сама по себе может принимать девять разных значений: `S`, `M`, `L`, `44`, `46`, `48`, `42/164`, `46/176`, `44S`.  Если ограничивающая характеристика **размерная сетка** принимает значение `RU`, список возможных значений размера сокращается до `44`, `46`, `48`. 
 * @export
 */
export type ValueRestrictionDTO = {
    /**
     * Идентификатор ограничивающей характеристики.
     * @type {number}
     * @memberof ValueRestrictionDTO
     */
    limitingParameterId: number;
    /**
     * Значения ограничивающей характеристики и соответствующие допустимые значения текущей характеристики.
     * @type {Array<OptionValuesLimitedDTO>}
     * @memberof ValueRestrictionDTO
     */
    limitedValues: Array<OptionValuesLimitedDTO>;
}

/**
 * 
 * @export
 */
export type VerifyOrderEacRequest = {
    /**
     * Код для подтверждения ЭАПП.
     * @type {string}
     * @memberof VerifyOrderEacRequest
     */
    code?: string;
}

/**
 * 
 * @export
 */
export type VerifyOrderEacResponse = {
    /**
     * 
     * @type {ApiResponseStatusType}
     * @memberof VerifyOrderEacResponse
     */
    status?: ApiResponseStatusType;
    /**
     * 
     * @type {EacVerificationResultDTO}
     * @memberof VerifyOrderEacResponse
     */
    result?: EacVerificationResultDTO;
}

/**
 * Адрес склада.
 * @export
 */
export type WarehouseAddressDTO = {
    /**
     * Город.
     * @type {string}
     * @memberof WarehouseAddressDTO
     */
    city: string;
    /**
     * Улица.
     * @type {string}
     * @memberof WarehouseAddressDTO
     */
    street?: string;
    /**
     * Номер дома.
     * @type {string}
     * @memberof WarehouseAddressDTO
     */
    _number?: string;
    /**
     * Номер строения.
     * @type {string}
     * @memberof WarehouseAddressDTO
     */
    building?: string;
    /**
     * Номер корпуса.
     * @type {string}
     * @memberof WarehouseAddressDTO
     */
    block?: string;
    /**
     * 
     * @type {GpsDTO}
     * @memberof WarehouseAddressDTO
     */
    gps: GpsDTO;
}

/**
 * Информация о складе.
 * @export
 */
export type WarehouseDTO = {
    /**
     * Идентификатор склада.
     * @type {number}
     * @memberof WarehouseDTO
     */
    id: number;
    /**
     * Название склада.
     * @type {string}
     * @memberof WarehouseDTO
     */
    name: string;
    /**
     * Идентификатор кампании в API и идентификатор магазина.
     * @type {number}
     * @memberof WarehouseDTO
     */
    campaignId: number;
    /**
     * Возможна ли доставка по модели Экспресс.
     * @type {boolean}
     * @memberof WarehouseDTO
     */
    express: boolean;
    /**
     * 
     * @type {WarehouseAddressDTO}
     * @memberof WarehouseDTO
     */
    address?: WarehouseAddressDTO;
}

/**
 * Информация о группе складов.
 * @export
 */
export type WarehouseGroupDTO = {
    /**
     * Название группы складов.
     * @type {string}
     * @memberof WarehouseGroupDTO
     */
    name: string;
    /**
     * 
     * @type {WarehouseDTO}
     * @memberof WarehouseGroupDTO
     */
    mainWarehouse: WarehouseDTO;
    /**
     * Список складов, входящих в группу.
     * @type {Array<WarehouseDTO>}
     * @memberof WarehouseGroupDTO
     */
    warehouses: Array<WarehouseDTO>;
}

/**
 * Информация об остатках товара.
 * @export
 */
export type WarehouseOfferDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof WarehouseOfferDTO
     */
    offerId: string;
    /**
     * 
     * @type {TurnoverDTO}
     * @memberof WarehouseOfferDTO
     */
    turnoverSummary?: TurnoverDTO;
    /**
     * Информация об остатках.
     * @type {Array<WarehouseStockDTO>}
     * @memberof WarehouseOfferDTO
     */
    stocks: Array<WarehouseStockDTO>;
    /**
     * Дата и время последнего обновления информации об остатках.  Формат даты и времени: ISO 8601 со смещением относительно UTC. Например, `2023-11-21T00:42:42+03:00`. 
     * @type {Date}
     * @memberof WarehouseOfferDTO
     */
    updatedAt?: Date;
}

/**
 * Информация об остатках товаров на складе.
 * @export
 */
export type WarehouseOffersDTO = {
    /**
     * Идентификатор склада.
     * @type {number}
     * @memberof WarehouseOffersDTO
     */
    warehouseId: number;
    /**
     * Информация об остатках.
     * @type {Array<WarehouseOfferDTO>}
     * @memberof WarehouseOffersDTO
     */
    offers: Array<WarehouseOfferDTO>;
}

/**
 * Информация об остатках товара.
 * @export
 */
export type WarehouseStockDTO = {
    /**
     * 
     * @type {WarehouseStockType}
     * @memberof WarehouseStockDTO
     */
    type: WarehouseStockType;
    /**
     * Значение остатков.
     * @type {number}
     * @memberof WarehouseStockDTO
     */
    count: number;
}

/**
 * Тип остатков товаров на складе:  * `AVAILABLE` (соответствует типу «Доступный к заказу» в отчете «Остатки на складе» в кабинете продавца на Маркете) — товар, доступный для продажи.  * `DEFECT` (соответствует типу «Брак») — товар с браком.  * `EXPIRED` (соответствует типу «Просрочен») — товар с истекшим сроком годности.  * `FIT` (соответствует типу «Годный») — товар, который доступен для продажи или уже зарезервирован.  * `FREEZE` — товар, который зарезервирован для заказов.  * `QUARANTINE` (соответствует типу «Карантин») — товар, временно недоступный для продажи (например, товар перемещают из одного помещения склада в другое).  * `UTILIZATION` — товар, который будет утилизирован. 
 * @export
 * @enum {string}
 */
export type WarehouseStockType = 'FIT' | 'FREEZE' | 'AVAILABLE' | 'QUARANTINE' | 'UTILIZATION' | 'DEFECT' | 'EXPIRED';

/**
 * Информация о складах и группах складов.
 * @export
 */
export type WarehousesDTO = {
    /**
     * Список складов, не входящих в группы.
     * @type {Array<WarehouseDTO>}
     * @memberof WarehousesDTO
     */
    warehouses: Array<WarehouseDTO>;
    /**
     * Список групп складов.
     * @type {Array<WarehouseGroupDTO>}
     * @memberof WarehousesDTO
     */
    warehouseGroups: Array<WarehouseGroupDTO>;
}

/**
 * Описание предупреждения, которое появилось при добавлении товара.
 * @export
 */
export type WarningPromoOfferUpdateDTO = {
    /**
     * Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
     * @type {string}
     * @memberof WarningPromoOfferUpdateDTO
     */
    offerId: string;
    /**
     * Предупреждения, которые появились при добавлении товара в акцию или изменении его цен.
     * @type {Array<PromoOfferUpdateWarningDTO>}
     * @memberof WarningPromoOfferUpdateDTO
     */
    warnings: Array<PromoOfferUpdateWarningDTO>;
}



/**
 * BidsApi - fetch parameter creator
 * @export
 */
export const BidsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsInfoForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids/info`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsInfoRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsInfoRequest != null ? getBidsInfoRequest : {}) : (((getBidsInfoRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsRecommendations.');
            }
            // verify required parameter 'getBidsRecommendationsRequest' is not null or undefined
            if (getBidsRecommendationsRequest === null || getBidsRecommendationsRequest === undefined) {
                throw new RequiredError('getBidsRecommendationsRequest','Required parameter getBidsRecommendationsRequest was null or undefined when calling getBidsRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/bids/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsRecommendationsRequest != null ? getBidsRecommendationsRequest : {}) : (((getBidsRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling putBidsForBusiness.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling putBidsForCampaign.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}/bids`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type BidsApiType = { 
    getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions): Promise<GetBidsInfoResponse>,

    getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions): Promise<GetBidsRecommendationsResponse>,

    putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * BidsApi - factory function to inject configuration 
 * @export
 */
export const BidsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): BidsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions = {}): Promise<GetBidsInfoResponse> {
            const localVarFetchArgs = BidsApiFetchParamCreator(configuration).getBidsInfoForBusiness(businessId, pageToken, limit, getBidsInfoRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions = {}): Promise<GetBidsRecommendationsResponse> {
            const localVarFetchArgs = BidsApiFetchParamCreator(configuration).getBidsRecommendations(businessId, getBidsRecommendationsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = BidsApiFetchParamCreator(configuration).putBidsForBusiness(businessId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = BidsApiFetchParamCreator(configuration).putBidsForCampaign(campaignId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * BusinessOfferMappingsApi - fetch parameter creator
 * @export
 */
export const BusinessOfferMappingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling addOffersToArchive.');
            }
            // verify required parameter 'addOffersToArchiveRequest' is not null or undefined
            if (addOffersToArchiveRequest === null || addOffersToArchiveRequest === undefined) {
                throw new RequiredError('addOffersToArchiveRequest','Required parameter addOffersToArchiveRequest was null or undefined when calling addOffersToArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/archive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addOffersToArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addOffersToArchiveRequest != null ? addOffersToArchiveRequest : {}) : (((addOffersToArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffers.');
            }
            // verify required parameter 'deleteOffersRequest' is not null or undefined
            if (deleteOffersRequest === null || deleteOffersRequest === undefined) {
                throw new RequiredError('deleteOffersRequest','Required parameter deleteOffersRequest was null or undefined when calling deleteOffers.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersRequest != null ? deleteOffersRequest : {}) : (((deleteOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffersFromArchive.');
            }
            // verify required parameter 'deleteOffersFromArchiveRequest' is not null or undefined
            if (deleteOffersFromArchiveRequest === null || deleteOffersFromArchiveRequest === undefined) {
                throw new RequiredError('deleteOffersFromArchiveRequest','Required parameter deleteOffersFromArchiveRequest was null or undefined when calling deleteOffersFromArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/unarchive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersFromArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersFromArchiveRequest != null ? deleteOffersFromArchiveRequest : {}) : (((deleteOffersFromArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferMappingsRequest != null ? getOfferMappingsRequest : {}) : (((getOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getSuggestedOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/suggestions`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingsRequest != null ? getSuggestedOfferMappingsRequest : {}) : (((getSuggestedOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferMappings.');
            }
            // verify required parameter 'updateOfferMappingsRequest' is not null or undefined
            if (updateOfferMappingsRequest === null || updateOfferMappingsRequest === undefined) {
                throw new RequiredError('updateOfferMappingsRequest','Required parameter updateOfferMappingsRequest was null or undefined when calling updateOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingsRequest != null ? updateOfferMappingsRequest : {}) : (((updateOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type BusinessOfferMappingsApiType = { 
    addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions): Promise<AddOffersToArchiveResponse>,

    deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions): Promise<DeleteOffersResponse>,

    deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions): Promise<DeleteOffersFromArchiveResponse>,

    getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions): Promise<GetOfferMappingsResponse>,

    getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingsResponse>,

    updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions): Promise<UpdateOfferMappingsResponse>,
}

/**
 * BusinessOfferMappingsApi - factory function to inject configuration 
 * @export
 */
export const BusinessOfferMappingsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): BusinessOfferMappingsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions = {}): Promise<AddOffersToArchiveResponse> {
            const localVarFetchArgs = BusinessOfferMappingsApiFetchParamCreator(configuration).addOffersToArchive(businessId, addOffersToArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions = {}): Promise<DeleteOffersResponse> {
            const localVarFetchArgs = BusinessOfferMappingsApiFetchParamCreator(configuration).deleteOffers(businessId, deleteOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions = {}): Promise<DeleteOffersFromArchiveResponse> {
            const localVarFetchArgs = BusinessOfferMappingsApiFetchParamCreator(configuration).deleteOffersFromArchive(businessId, deleteOffersFromArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetOfferMappingsResponse> {
            const localVarFetchArgs = BusinessOfferMappingsApiFetchParamCreator(configuration).getOfferMappings(businessId, pageToken, limit, getOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingsResponse> {
            const localVarFetchArgs = BusinessOfferMappingsApiFetchParamCreator(configuration).getSuggestedOfferMappings(businessId, getSuggestedOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions = {}): Promise<UpdateOfferMappingsResponse> {
            const localVarFetchArgs = BusinessOfferMappingsApiFetchParamCreator(configuration).updateOfferMappings(businessId, updateOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * BusinessesApi - fetch parameter creator
 * @export
 */
export const BusinessesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessSettings.');
            }
            const localVarPath = `/businesses/{businessId}/settings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type BusinessesApiType = { 
    getBusinessSettings(businessId: number, options?: RequestOptions): Promise<GetBusinessSettingsResponse>,
}

/**
 * BusinessesApi - factory function to inject configuration 
 * @export
 */
export const BusinessesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): BusinessesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options?: RequestOptions = {}): Promise<GetBusinessSettingsResponse> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).getBusinessSettings(businessId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CampaignsApi - fetch parameter creator
 * @export
 */
export const CampaignsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignLogins.');
            }
            const localVarPath = `/campaigns/{campaignId}/logins`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignRegion.');
            }
            const localVarPath = `/campaigns/{campaignId}/region`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignSettings.');
            }
            const localVarPath = `/campaigns/{campaignId}/settings`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/campaigns`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling getCampaignsByLogin.');
            }
            const localVarPath = `/campaigns/by_login/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CampaignsApiType = { 
    getCampaign(campaignId: number, options?: RequestOptions): Promise<GetCampaignResponse>,

    getCampaignLogins(campaignId: number, options?: RequestOptions): Promise<GetCampaignLoginsResponse>,

    getCampaignRegion(campaignId: number, options?: RequestOptions): Promise<GetCampaignRegionResponse>,

    getCampaignSettings(campaignId: number, options?: RequestOptions): Promise<GetCampaignSettingsResponse>,

    getCampaigns(page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,

    getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,
}

/**
 * CampaignsApi - factory function to inject configuration 
 * @export
 */
export const CampaignsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CampaignsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignResponse> {
            const localVarFetchArgs = CampaignsApiFetchParamCreator(configuration).getCampaign(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignLoginsResponse> {
            const localVarFetchArgs = CampaignsApiFetchParamCreator(configuration).getCampaignLogins(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignRegionResponse> {
            const localVarFetchArgs = CampaignsApiFetchParamCreator(configuration).getCampaignRegion(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignSettingsResponse> {
            const localVarFetchArgs = CampaignsApiFetchParamCreator(configuration).getCampaignSettings(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = CampaignsApiFetchParamCreator(configuration).getCampaigns(page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = CampaignsApiFetchParamCreator(configuration).getCampaignsByLogin(login, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CategoriesApi - fetch parameter creator
 * @export
 */
export const CategoriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'getCategoriesMaxSaleQuantumRequest' is not null or undefined
            if (getCategoriesMaxSaleQuantumRequest === null || getCategoriesMaxSaleQuantumRequest === undefined) {
                throw new RequiredError('getCategoriesMaxSaleQuantumRequest','Required parameter getCategoriesMaxSaleQuantumRequest was null or undefined when calling getCategoriesMaxSaleQuantum.');
            }
            const localVarPath = `/categories/max-sale-quantum`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesMaxSaleQuantumRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesMaxSaleQuantumRequest != null ? getCategoriesMaxSaleQuantumRequest : {}) : (((getCategoriesMaxSaleQuantumRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options: RequestOptions): FetchArgs {
            const localVarPath = `/categories/tree`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesRequest != null ? getCategoriesRequest : {}) : (((getCategoriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CategoriesApiType = { 
    getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions): Promise<GetCategoriesMaxSaleQuantumResponse>,

    getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions): Promise<GetCategoriesResponse>,
}

/**
 * CategoriesApi - factory function to inject configuration 
 * @export
 */
export const CategoriesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CategoriesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions = {}): Promise<GetCategoriesMaxSaleQuantumResponse> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions = {}): Promise<GetCategoriesResponse> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).getCategoriesTree(getCategoriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ChatsApi - fetch parameter creator
 * @export
 */
export const ChatsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling createChat.');
            }
            // verify required parameter 'createChatRequest' is not null or undefined
            if (createChatRequest === null || createChatRequest === undefined) {
                throw new RequiredError('createChatRequest','Required parameter createChatRequest was null or undefined when calling createChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/new`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createChatRequest != null ? createChatRequest : {}) : (((createChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'getChatHistoryRequest' is not null or undefined
            if (getChatHistoryRequest === null || getChatHistoryRequest === undefined) {
                throw new RequiredError('getChatHistoryRequest','Required parameter getChatHistoryRequest was null or undefined when calling getChatHistory.');
            }
            const localVarPath = `/businesses/{businessId}/chats/history`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatHistoryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatHistoryRequest != null ? getChatHistoryRequest : {}) : (((getChatHistoryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChats.');
            }
            // verify required parameter 'getChatsRequest' is not null or undefined
            if (getChatsRequest === null || getChatsRequest === undefined) {
                throw new RequiredError('getChatsRequest','Required parameter getChatsRequest was null or undefined when calling getChats.');
            }
            const localVarPath = `/businesses/{businessId}/chats`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatsRequest != null ? getChatsRequest : {}) : (((getChatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling sendFileToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/file/send`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'sendMessageToChatRequest' is not null or undefined
            if (sendMessageToChatRequest === null || sendMessageToChatRequest === undefined) {
                throw new RequiredError('sendMessageToChatRequest','Required parameter sendMessageToChatRequest was null or undefined when calling sendMessageToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/message`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof sendMessageToChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sendMessageToChatRequest != null ? sendMessageToChatRequest : {}) : (((sendMessageToChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ChatsApiType = { 
    createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions): Promise<CreateChatResponse>,

    getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatHistoryResponse>,

    getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatsResponse>,

    sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions): Promise<EmptyApiResponse>,

    sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * ChatsApi - factory function to inject configuration 
 * @export
 */
export const ChatsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ChatsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions = {}): Promise<CreateChatResponse> {
            const localVarFetchArgs = ChatsApiFetchParamCreator(configuration).createChat(businessId, createChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatHistoryResponse> {
            const localVarFetchArgs = ChatsApiFetchParamCreator(configuration).getChatHistory(businessId, chatId, getChatHistoryRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatsResponse> {
            const localVarFetchArgs = ChatsApiFetchParamCreator(configuration).getChats(businessId, getChatsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ChatsApiFetchParamCreator(configuration).sendFileToChat(businessId, chatId, file, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ChatsApiFetchParamCreator(configuration).sendMessageToChat(businessId, chatId, sendMessageToChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ContentApi - fetch parameter creator
 * @export
 */
export const ContentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getCategoryContentParameters.');
            }
            const localVarPath = `/category/{categoryId}/parameters`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferCardsContentStatus.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferCardsContentStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferCardsContentStatusRequest != null ? getOfferCardsContentStatusRequest : {}) : (((getOfferCardsContentStatusRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferContent.');
            }
            // verify required parameter 'updateOfferContentRequest' is not null or undefined
            if (updateOfferContentRequest === null || updateOfferContentRequest === undefined) {
                throw new RequiredError('updateOfferContentRequest','Required parameter updateOfferContentRequest was null or undefined when calling updateOfferContent.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferContentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferContentRequest != null ? updateOfferContentRequest : {}) : (((updateOfferContentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ContentApiType = { 
    getCategoryContentParameters(categoryId: number, options?: RequestOptions): Promise<GetCategoryContentParametersResponse>,

    getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions): Promise<GetOfferCardsContentStatusResponse>,

    updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions): Promise<UpdateOfferContentResponse>,
}

/**
 * ContentApi - factory function to inject configuration 
 * @export
 */
export const ContentApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ContentApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options?: RequestOptions = {}): Promise<GetCategoryContentParametersResponse> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getCategoryContentParameters(categoryId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions = {}): Promise<GetOfferCardsContentStatusResponse> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getOfferCardsContentStatus(businessId, pageToken, limit, getOfferCardsContentStatusRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions = {}): Promise<UpdateOfferContentResponse> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).updateOfferContent(businessId, updateOfferContentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * DbsApi - fetch parameter creator
 * @export
 */
export const DbsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Подтверждает или отклоняет запрос покупателя на отмену заказа, который передан службе доставки.  Покупатель может отменить заказ в течение его обработки или доставки. Если заказ еще обрабатывается (имеет статус PROCESSING), вам не нужно подтверждать отмену заказа — он будет отменен автоматически.  Если заказ уже передан службе доставки (принимает статус `DELIVERY` или `PICKUP`) и пользователь отменил его, вы можете предупредить службу об отмене в течение 48 часов. Если служба доставки узнала об отмене до передачи заказа покупателю, подтвердите отмену с помощью запроса [PUT campaigns/{campaignId}/orders/{orderId}/cancellation/accept](../../reference/orders/acceptOrderCancellation.md). Если заказ уже доставлен, отклоните отмену с помощью этого же запроса. Тогда у покупателя останется заказ, и деньги за него возвращаться не будут.  Чтобы узнать, какие заказы были отменены в статусе `DELIVERY` или `PICKUP`, отправьте запрос [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md). В его URL добавьте входной параметр `onlyWaitingForCancellationApprove=true`. Вы также можете узнать об отмененных заказах в кабинете или через почту — на нее придет уведомление об отмене.  Если в течение 48 часов вы не подтвердите или отклоните отмену, заказ будет отменен автоматически.  |**⚙️ Лимит:** 500 запросов в час| |-| 
         * @summary Отмена заказа покупателем
         * @throws {RequiredError}
         */
        acceptOrderCancellation(campaignId: number, orderId: number, acceptOrderCancellationRequest: AcceptOrderCancellationRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling acceptOrderCancellation.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling acceptOrderCancellation.');
            }
            // verify required parameter 'acceptOrderCancellationRequest' is not null or undefined
            if (acceptOrderCancellationRequest === null || acceptOrderCancellationRequest === undefined) {
                throw new RequiredError('acceptOrderCancellationRequest','Required parameter acceptOrderCancellationRequest was null or undefined when calling acceptOrderCancellation.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/cancellation/accept`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof acceptOrderCancellationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(acceptOrderCancellationRequest != null ? acceptOrderCancellationRequest : {}) : (((acceptOrderCancellationRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling addHiddenOffers.');
            }
            // verify required parameter 'addHiddenOffersRequest' is not null or undefined
            if (addHiddenOffersRequest === null || addHiddenOffersRequest === undefined) {
                throw new RequiredError('addHiddenOffersRequest','Required parameter addHiddenOffersRequest was null or undefined when calling addHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addHiddenOffersRequest != null ? addHiddenOffersRequest : {}) : (((addHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling addOffersToArchive.');
            }
            // verify required parameter 'addOffersToArchiveRequest' is not null or undefined
            if (addOffersToArchiveRequest === null || addOffersToArchiveRequest === undefined) {
                throw new RequiredError('addOffersToArchiveRequest','Required parameter addOffersToArchiveRequest was null or undefined when calling addOffersToArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/archive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addOffersToArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addOffersToArchiveRequest != null ? addOffersToArchiveRequest : {}) : (((addOffersToArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'calculateTariffsRequest' is not null or undefined
            if (calculateTariffsRequest === null || calculateTariffsRequest === undefined) {
                throw new RequiredError('calculateTariffsRequest','Required parameter calculateTariffsRequest was null or undefined when calling calculateTariffs.');
            }
            const localVarPath = `/tariffs/calculate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof calculateTariffsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(calculateTariffsRequest != null ? calculateTariffsRequest : {}) : (((calculateTariffsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling confirmBusinessPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine/confirm`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling confirmCampaignPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmCampaignPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine/confirm`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling createChat.');
            }
            // verify required parameter 'createChatRequest' is not null or undefined
            if (createChatRequest === null || createChatRequest === undefined) {
                throw new RequiredError('createChatRequest','Required parameter createChatRequest was null or undefined when calling createChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/new`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createChatRequest != null ? createChatRequest : {}) : (((createChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает точку продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Создание точки продаж
         * @throws {RequiredError}
         */
        createOutlet(campaignId: number, changeOutletRequest: ChangeOutletRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling createOutlet.');
            }
            // verify required parameter 'changeOutletRequest' is not null or undefined
            if (changeOutletRequest === null || changeOutletRequest === undefined) {
                throw new RequiredError('changeOutletRequest','Required parameter changeOutletRequest was null or undefined when calling createOutlet.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof changeOutletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(changeOutletRequest != null ? changeOutletRequest : {}) : (((changeOutletRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteCampaignOffers.');
            }
            // verify required parameter 'deleteCampaignOffersRequest' is not null or undefined
            if (deleteCampaignOffersRequest === null || deleteCampaignOffersRequest === undefined) {
                throw new RequiredError('deleteCampaignOffersRequest','Required parameter deleteCampaignOffersRequest was null or undefined when calling deleteCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteCampaignOffersRequest != null ? deleteCampaignOffersRequest : {}) : (((deleteCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            // verify required parameter 'deleteGoodsFeedbackCommentRequest' is not null or undefined
            if (deleteGoodsFeedbackCommentRequest === null || deleteGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('deleteGoodsFeedbackCommentRequest','Required parameter deleteGoodsFeedbackCommentRequest was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteGoodsFeedbackCommentRequest != null ? deleteGoodsFeedbackCommentRequest : {}) : (((deleteGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteHiddenOffers.');
            }
            // verify required parameter 'deleteHiddenOffersRequest' is not null or undefined
            if (deleteHiddenOffersRequest === null || deleteHiddenOffersRequest === undefined) {
                throw new RequiredError('deleteHiddenOffersRequest','Required parameter deleteHiddenOffersRequest was null or undefined when calling deleteHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteHiddenOffersRequest != null ? deleteHiddenOffersRequest : {}) : (((deleteHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffers.');
            }
            // verify required parameter 'deleteOffersRequest' is not null or undefined
            if (deleteOffersRequest === null || deleteOffersRequest === undefined) {
                throw new RequiredError('deleteOffersRequest','Required parameter deleteOffersRequest was null or undefined when calling deleteOffers.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersRequest != null ? deleteOffersRequest : {}) : (((deleteOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffersFromArchive.');
            }
            // verify required parameter 'deleteOffersFromArchiveRequest' is not null or undefined
            if (deleteOffersFromArchiveRequest === null || deleteOffersFromArchiveRequest === undefined) {
                throw new RequiredError('deleteOffersFromArchiveRequest','Required parameter deleteOffersFromArchiveRequest was null or undefined when calling deleteOffersFromArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/unarchive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersFromArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersFromArchiveRequest != null ? deleteOffersFromArchiveRequest : {}) : (((deleteOffersFromArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет точку продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Удаление точки продаж
         * @throws {RequiredError}
         */
        deleteOutlet(campaignId: number, outletId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteOutlet.');
            }
            // verify required parameter 'outletId' is not null or undefined
            if (outletId === null || outletId === undefined) {
                throw new RequiredError('outletId','Required parameter outletId was null or undefined when calling deleteOutlet.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/{outletId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет информацию о лицензиях для точек продаж.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Удаление лицензий для точек продаж
         * @throws {RequiredError}
         */
        deleteOutletLicenses(campaignId: number, ids?: Set<number>, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteOutletLicenses.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/licenses`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids) {
                localVarQueryParameter['ids'] = Array.from(ids).join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deletePromoOffers.');
            }
            // verify required parameter 'deletePromoOffersRequest' is not null or undefined
            if (deletePromoOffersRequest === null || deletePromoOffersRequest === undefined) {
                throw new RequiredError('deletePromoOffersRequest','Required parameter deletePromoOffersRequest was null or undefined when calling deletePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deletePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deletePromoOffersRequest != null ? deletePromoOffersRequest : {}) : (((deletePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateBoostConsolidatedRequest' is not null or undefined
            if (generateBoostConsolidatedRequest === null || generateBoostConsolidatedRequest === undefined) {
                throw new RequiredError('generateBoostConsolidatedRequest','Required parameter generateBoostConsolidatedRequest was null or undefined when calling generateBoostConsolidatedReport.');
            }
            const localVarPath = `/reports/boost-consolidated/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateBoostConsolidatedRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateBoostConsolidatedRequest != null ? generateBoostConsolidatedRequest : {}) : (((generateBoostConsolidatedRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateCompetitorsPositionReportRequest' is not null or undefined
            if (generateCompetitorsPositionReportRequest === null || generateCompetitorsPositionReportRequest === undefined) {
                throw new RequiredError('generateCompetitorsPositionReportRequest','Required parameter generateCompetitorsPositionReportRequest was null or undefined when calling generateCompetitorsPositionReport.');
            }
            const localVarPath = `/reports/competitors-position/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateCompetitorsPositionReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateCompetitorsPositionReportRequest != null ? generateCompetitorsPositionReportRequest : {}) : (((generateCompetitorsPositionReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsFeedbackRequest' is not null or undefined
            if (generateGoodsFeedbackRequest === null || generateGoodsFeedbackRequest === undefined) {
                throw new RequiredError('generateGoodsFeedbackRequest','Required parameter generateGoodsFeedbackRequest was null or undefined when calling generateGoodsFeedbackReport.');
            }
            const localVarPath = `/reports/goods-feedback/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsFeedbackRequest != null ? generateGoodsFeedbackRequest : {}) : (((generateGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию PDF-файла с ярлыками для переданных заказов. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  Узнать статус генерации и получить ссылку на готовый файл можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в нескольких заказах
         * @throws {RequiredError}
         */
        generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateMassOrderLabelsRequest' is not null or undefined
            if (generateMassOrderLabelsRequest === null || generateMassOrderLabelsRequest === undefined) {
                throw new RequiredError('generateMassOrderLabelsRequest','Required parameter generateMassOrderLabelsRequest was null or undefined when calling generateMassOrderLabelsReport.');
            }
            const localVarPath = `/reports/documents/labels/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateMassOrderLabelsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateMassOrderLabelsRequest != null ? generateMassOrderLabelsRequest : {}) : (((generateMassOrderLabelsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Формирует ярлык‑наклейку для коробки в заказе и возвращает ярлык в PDF‑файле.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовый ярлык‑наклейка для коробки в заказе
         * @throws {RequiredError}
         */
        generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'boxId' is not null or undefined
            if (boxId === null || boxId === undefined) {
                throw new RequiredError('boxId','Required parameter boxId was null or undefined when calling generateOrderLabel.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"boxId"}}`, encodeURIComponent(String(boxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает PDF-файл с ярлыками, которые нужно наклеить на коробки перед отгрузкой. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  На вход нужно передать идентификатор заказа и один необязательный параметр, который управляет версткой PDF-файла.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в одном заказе
         * @throws {RequiredError}
         */
        generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling generateOrderLabels.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling generateOrderLabels.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/labels`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generatePricesReportRequest' is not null or undefined
            if (generatePricesReportRequest === null || generatePricesReportRequest === undefined) {
                throw new RequiredError('generatePricesReportRequest','Required parameter generatePricesReportRequest was null or undefined when calling generatePricesReport.');
            }
            const localVarPath = `/reports/prices/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generatePricesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generatePricesReportRequest != null ? generatePricesReportRequest : {}) : (((generatePricesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShelfsStatisticsRequest' is not null or undefined
            if (generateShelfsStatisticsRequest === null || generateShelfsStatisticsRequest === undefined) {
                throw new RequiredError('generateShelfsStatisticsRequest','Required parameter generateShelfsStatisticsRequest was null or undefined when calling generateShelfsStatisticsReport.');
            }
            const localVarPath = `/reports/shelf-statistics/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShelfsStatisticsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShelfsStatisticsRequest != null ? generateShelfsStatisticsRequest : {}) : (((generateShelfsStatisticsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShowsSalesReportRequest' is not null or undefined
            if (generateShowsSalesReportRequest === null || generateShowsSalesReportRequest === undefined) {
                throw new RequiredError('generateShowsSalesReportRequest','Required parameter generateShowsSalesReportRequest was null or undefined when calling generateShowsSalesReport.');
            }
            const localVarPath = `/reports/shows-sales/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShowsSalesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShowsSalesReportRequest != null ? generateShowsSalesReportRequest : {}) : (((generateShowsSalesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateStocksOnWarehousesReportRequest' is not null or undefined
            if (generateStocksOnWarehousesReportRequest === null || generateStocksOnWarehousesReportRequest === undefined) {
                throw new RequiredError('generateStocksOnWarehousesReportRequest','Required parameter generateStocksOnWarehousesReportRequest was null or undefined when calling generateStocksOnWarehousesReport.');
            }
            const localVarPath = `/reports/stocks-on-warehouses/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateStocksOnWarehousesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateStocksOnWarehousesReportRequest != null ? generateStocksOnWarehousesReportRequest : {}) : (((generateStocksOnWarehousesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedMarketplaceServicesReportRequest' is not null or undefined
            if (generateUnitedMarketplaceServicesReportRequest === null || generateUnitedMarketplaceServicesReportRequest === undefined) {
                throw new RequiredError('generateUnitedMarketplaceServicesReportRequest','Required parameter generateUnitedMarketplaceServicesReportRequest was null or undefined when calling generateUnitedMarketplaceServicesReport.');
            }
            const localVarPath = `/reports/united-marketplace-services/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedMarketplaceServicesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedMarketplaceServicesReportRequest != null ? generateUnitedMarketplaceServicesReportRequest : {}) : (((generateUnitedMarketplaceServicesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedNettingReportRequest' is not null or undefined
            if (generateUnitedNettingReportRequest === null || generateUnitedNettingReportRequest === undefined) {
                throw new RequiredError('generateUnitedNettingReportRequest','Required parameter generateUnitedNettingReportRequest was null or undefined when calling generateUnitedNettingReport.');
            }
            const localVarPath = `/reports/united-netting/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedNettingReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedNettingReportRequest != null ? generateUnitedNettingReportRequest : {}) : (((generateUnitedNettingReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedOrdersRequest' is not null or undefined
            if (generateUnitedOrdersRequest === null || generateUnitedOrdersRequest === undefined) {
                throw new RequiredError('generateUnitedOrdersRequest','Required parameter generateUnitedOrdersRequest was null or undefined when calling generateUnitedOrdersReport.');
            }
            const localVarPath = `/reports/united-orders/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedOrdersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedOrdersRequest != null ? generateUnitedOrdersRequest : {}) : (((generateUnitedOrdersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getAllOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/all`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (chunk !== undefined) {
                localVarQueryParameter['chunk'] = ((chunk:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsInfoForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids/info`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsInfoRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsInfoRequest != null ? getBidsInfoRequest : {}) : (((getBidsInfoRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsRecommendations.');
            }
            // verify required parameter 'getBidsRecommendationsRequest' is not null or undefined
            if (getBidsRecommendationsRequest === null || getBidsRecommendationsRequest === undefined) {
                throw new RequiredError('getBidsRecommendationsRequest','Required parameter getBidsRecommendationsRequest was null or undefined when calling getBidsRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/bids/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsRecommendationsRequest != null ? getBidsRecommendationsRequest : {}) : (((getBidsRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getBusinessQuarantineOffers.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessSettings.');
            }
            const localVarPath = `/businesses/{businessId}/settings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignLogins.');
            }
            const localVarPath = `/campaigns/{campaignId}/logins`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignOffers.');
            }
            // verify required parameter 'getCampaignOffersRequest' is not null or undefined
            if (getCampaignOffersRequest === null || getCampaignOffersRequest === undefined) {
                throw new RequiredError('getCampaignOffersRequest','Required parameter getCampaignOffersRequest was null or undefined when calling getCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCampaignOffersRequest != null ? getCampaignOffersRequest : {}) : (((getCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getCampaignQuarantineOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignRegion.');
            }
            const localVarPath = `/campaigns/{campaignId}/region`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignSettings.');
            }
            const localVarPath = `/campaigns/{campaignId}/settings`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/campaigns`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling getCampaignsByLogin.');
            }
            const localVarPath = `/campaigns/by_login/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'getCategoriesMaxSaleQuantumRequest' is not null or undefined
            if (getCategoriesMaxSaleQuantumRequest === null || getCategoriesMaxSaleQuantumRequest === undefined) {
                throw new RequiredError('getCategoriesMaxSaleQuantumRequest','Required parameter getCategoriesMaxSaleQuantumRequest was null or undefined when calling getCategoriesMaxSaleQuantum.');
            }
            const localVarPath = `/categories/max-sale-quantum`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesMaxSaleQuantumRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesMaxSaleQuantumRequest != null ? getCategoriesMaxSaleQuantumRequest : {}) : (((getCategoriesMaxSaleQuantumRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options: RequestOptions): FetchArgs {
            const localVarPath = `/categories/tree`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesRequest != null ? getCategoriesRequest : {}) : (((getCategoriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getCategoryContentParameters.');
            }
            const localVarPath = `/category/{categoryId}/parameters`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'getChatHistoryRequest' is not null or undefined
            if (getChatHistoryRequest === null || getChatHistoryRequest === undefined) {
                throw new RequiredError('getChatHistoryRequest','Required parameter getChatHistoryRequest was null or undefined when calling getChatHistory.');
            }
            const localVarPath = `/businesses/{businessId}/chats/history`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatHistoryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatHistoryRequest != null ? getChatHistoryRequest : {}) : (((getChatHistoryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChats.');
            }
            // verify required parameter 'getChatsRequest' is not null or undefined
            if (getChatsRequest === null || getChatsRequest === undefined) {
                throw new RequiredError('getChatsRequest','Required parameter getChatsRequest was null or undefined when calling getChats.');
            }
            const localVarPath = `/businesses/{businessId}/chats`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatsRequest != null ? getChatsRequest : {}) : (((getChatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает справочник служб доставки: идентификаторы и наименования. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Справочник служб доставки
         * @throws {RequiredError}
         */
        getDeliveryServices(options: RequestOptions): FetchArgs {
            const localVarPath = `/delivery/services`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedIndexLogs.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeedIndexLogs.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/index-logs`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (publishedTimeFrom !== undefined) {
                localVarQueryParameter['published_time_from'] = ((publishedTimeFrom:any):Date).toISOString();
            }

            if (publishedTimeTo !== undefined) {
                localVarQueryParameter['published_time_to'] = ((publishedTimeTo:any):Date).toISOString();
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = ((status:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedbackAndCommentUpdates.');
            }
            const localVarPath = `/campaigns/{campaignId}/feedback/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeeds.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbackComments.');
            }
            // verify required parameter 'getGoodsFeedbackCommentsRequest' is not null or undefined
            if (getGoodsFeedbackCommentsRequest === null || getGoodsFeedbackCommentsRequest === undefined) {
                throw new RequiredError('getGoodsFeedbackCommentsRequest','Required parameter getGoodsFeedbackCommentsRequest was null or undefined when calling getGoodsFeedbackComments.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackCommentsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackCommentsRequest != null ? getGoodsFeedbackCommentsRequest : {}) : (((getGoodsFeedbackCommentsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbacks.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackRequest != null ? getGoodsFeedbackRequest : {}) : (((getGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getGoodsStats.');
            }
            // verify required parameter 'getGoodsStatsRequest' is not null or undefined
            if (getGoodsStatsRequest === null || getGoodsStatsRequest === undefined) {
                throw new RequiredError('getGoodsStatsRequest','Required parameter getGoodsStatsRequest was null or undefined when calling getGoodsStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/skus`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsStatsRequest != null ? getGoodsStatsRequest : {}) : (((getGoodsStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о модели товара.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Информация об одной модели
         * @throws {RequiredError}
         */
        getModel(modelId: number, regionId: number, currency?: CurrencyType, options: RequestOptions): FetchArgs {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling getModel.');
            }
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getModel.');
            }
            const localVarPath = `/models/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о первых десяти предложениях, расположенных на карточке модели.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей метод не поддерживается. Идентификатор групповой модели игнорируется.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Список предложений для одной модели
         * @throws {RequiredError}
         */
        getModelOffers(modelId: number, regionId: number, currency?: CurrencyType, orderByPrice?: SortOrderType, count?: number, page?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling getModelOffers.');
            }
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getModelOffers.');
            }
            const localVarPath = `/models/{modelId}/offers`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (orderByPrice !== undefined) {
                localVarQueryParameter['orderByPrice'] = ((orderByPrice:any):string);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = ((count:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о моделях товаров.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Информация о нескольких моделях
         * @throws {RequiredError}
         */
        getModels(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getModels.');
            }
            // verify required parameter 'getModelsRequest' is not null or undefined
            if (getModelsRequest === null || getModelsRequest === undefined) {
                throw new RequiredError('getModelsRequest','Required parameter getModelsRequest was null or undefined when calling getModels.');
            }
            const localVarPath = `/models`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getModelsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getModelsRequest != null ? getModelsRequest : {}) : (((getModelsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о первых десяти предложениях, расположенных на карточках моделей, идентификаторы которых указаны в запросе.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей выдача предложений не поддерживается. Идентификаторы групповых моделей игнорируются.  В одном запросе можно получить информацию о предложениях не более чем для 100 моделей.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Список предложений для нескольких моделей
         * @throws {RequiredError}
         */
        getModelsOffers(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, orderByPrice?: SortOrderType, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getModelsOffers.');
            }
            // verify required parameter 'getModelsRequest' is not null or undefined
            if (getModelsRequest === null || getModelsRequest === undefined) {
                throw new RequiredError('getModelsRequest','Required parameter getModelsRequest was null or undefined when calling getModelsOffers.');
            }
            const localVarPath = `/models/offers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (orderByPrice !== undefined) {
                localVarQueryParameter['orderByPrice'] = ((orderByPrice:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getModelsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getModelsRequest != null ? getModelsRequest : {}) : (((getModelsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferCardsContentStatus.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferCardsContentStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferCardsContentStatusRequest != null ? getOfferCardsContentStatusRequest : {}) : (((getOfferCardsContentStatusRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (shopSku) {
                localVarQueryParameter['shop_sku'] = shopSku.join(COLLECTION_FORMATS["csv"]);
            }

            if (mappingKind !== undefined) {
                localVarQueryParameter['mapping_kind'] = ((mappingKind:any):string);
            }

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS["csv"]);
            }

            if (availability) {
                localVarQueryParameter['availability'] = availability.join(COLLECTION_FORMATS["csv"]);
            }

            if (categoryId) {
                localVarQueryParameter['category_id'] = categoryId.join(COLLECTION_FORMATS["csv"]);
            }

            if (vendor) {
                localVarQueryParameter['vendor'] = vendor.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferMappingsRequest != null ? getOfferMappingsRequest : {}) : (((getOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferRecommendations.');
            }
            // verify required parameter 'getOfferRecommendationsRequest' is not null or undefined
            if (getOfferRecommendationsRequest === null || getOfferRecommendationsRequest === undefined) {
                throw new RequiredError('getOfferRecommendationsRequest','Required parameter getOfferRecommendationsRequest was null or undefined when calling getOfferRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/offers/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferRecommendationsRequest != null ? getOfferRecommendationsRequest : {}) : (((getOfferRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = ((query:any):string);
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (shopCategoryId !== undefined) {
                localVarQueryParameter['shopCategoryId'] = ((shopCategoryId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (matched !== undefined) {
                localVarQueryParameter['matched'] = ((matched:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrder.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/business-buyer`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/documents`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является юридическим лицом, воспользуйтесь запросом [POST campaigns/{campaignId}/orders/{orderId}/business-buyer](../../reference/order-business-information/getOrderBusinessBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY` или `PICKUP`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — физическом лице
         * @throws {RequiredError}
         */
        getOrderBuyerInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBuyerInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBuyerInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/buyer`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию на ярлыках, которые клеятся на коробки в заказе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Данные для самостоятельного изготовления ярлыков
         * @throws {RequiredError}
         */
        getOrderLabelsData(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderLabelsData.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderLabelsData.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/labels/data`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrders.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status).join(COLLECTION_FORMATS["csv"]);
            }

            if (substatus) {
                localVarQueryParameter['substatus'] = Array.from(substatus).join(COLLECTION_FORMATS["csv"]);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateFrom !== undefined) {
                localVarQueryParameter['supplierShipmentDateFrom'] = ((supplierShipmentDateFrom:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateTo !== undefined) {
                localVarQueryParameter['supplierShipmentDateTo'] = ((supplierShipmentDateTo:any):Date).toISOString().slice(0, 10);
            }

            if (updatedAtFrom !== undefined) {
                localVarQueryParameter['updatedAtFrom'] = ((updatedAtFrom:any):Date).toISOString();
            }

            if (updatedAtTo !== undefined) {
                localVarQueryParameter['updatedAtTo'] = ((updatedAtTo:any):Date).toISOString();
            }

            if (dispatchType !== undefined) {
                localVarQueryParameter['dispatchType'] = ((dispatchType:any):string);
            }

            if (fake !== undefined) {
                localVarQueryParameter['fake'] = ((fake:any):string);
            }

            if (hasCis !== undefined) {
                localVarQueryParameter['hasCis'] = ((hasCis:any):string);
            }

            if (onlyWaitingForCancellationApprove !== undefined) {
                localVarQueryParameter['onlyWaitingForCancellationApprove'] = ((onlyWaitingForCancellationApprove:any):string);
            }

            if (onlyEstimatedDelivery !== undefined) {
                localVarQueryParameter['onlyEstimatedDelivery'] = ((onlyEstimatedDelivery:any):string);
            }

            if (buyerType !== undefined) {
                localVarQueryParameter['buyerType'] = ((buyerType:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrdersStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOrdersStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOrdersStatsRequest != null ? getOrdersStatsRequest : {}) : (((getOrdersStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о точках продаж магазина.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация об одной точке продаж
         * @throws {RequiredError}
         */
        getOutlet(campaignId: number, outletId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOutlet.');
            }
            // verify required parameter 'outletId' is not null or undefined
            if (outletId === null || outletId === undefined) {
                throw new RequiredError('outletId','Required parameter outletId was null or undefined when calling getOutlet.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/{outletId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о лицензиях для точек продаж.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация о лицензиях для точек продаж
         * @throws {RequiredError}
         */
        getOutletLicenses(campaignId: number, outletIds?: Set<number>, ids?: Set<number>, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOutletLicenses.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/licenses`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (outletIds) {
                localVarQueryParameter['outletIds'] = Array.from(outletIds).join(COLLECTION_FORMATS["csv"]);
            }

            if (ids) {
                localVarQueryParameter['ids'] = Array.from(ids).join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список точек продаж магазина.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация о нескольких точках продаж
         * @throws {RequiredError}
         */
        getOutlets(campaignId: number, pageToken?: string, regionId?: number, shopOutletCode?: string, regionId2?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOutlets.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = ((regionId:any):string);
            }

            if (shopOutletCode !== undefined) {
                localVarQueryParameter['shop_outlet_code'] = ((shopOutletCode:any):string);
            }

            if (regionId2 !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId2:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = ((archived:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPricesByOfferIds.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPricesByOfferIdsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPricesByOfferIdsRequest != null ? getPricesByOfferIdsRequest : {}) : (((getPricesByOfferIdsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromoOffers.');
            }
            // verify required parameter 'getPromoOffersRequest' is not null or undefined
            if (getPromoOffersRequest === null || getPromoOffersRequest === undefined) {
                throw new RequiredError('getPromoOffersRequest','Required parameter getPromoOffersRequest was null or undefined when calling getPromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromoOffersRequest != null ? getPromoOffersRequest : {}) : (((getPromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromos.');
            }
            const localVarPath = `/businesses/{businessId}/promos`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromosRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromosRequest != null ? getPromosRequest : {}) : (((getPromosRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список заказов, которые повлияли на индекс качества магазина. Чтобы узнать значение индекса качества, выполните запрос [POST businesses/{businessId}/ratings/quality](../../reference/ratings/getQualityRatings.md).  |**⚙️ Лимит:** 100000 запросов в час| |-| 
         * @summary Заказы, которые повлияли на индекс качества
         * @throws {RequiredError}
         */
        getQualityRatingDetails(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getQualityRatingDetails.');
            }
            const localVarPath = `/campaigns/{campaignId}/ratings/quality/details`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getQualityRatings.');
            }
            // verify required parameter 'getQualityRatingRequest' is not null or undefined
            if (getQualityRatingRequest === null || getQualityRatingRequest === undefined) {
                throw new RequiredError('getQualityRatingRequest','Required parameter getQualityRatingRequest was null or undefined when calling getQualityRatings.');
            }
            const localVarPath = `/businesses/{businessId}/ratings/quality`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQualityRatingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQualityRatingRequest != null ? getQualityRatingRequest : {}) : (((getQualityRatingRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'reportId' is not null or undefined
            if (reportId === null || reportId === undefined) {
                throw new RequiredError('reportId','Required parameter reportId was null or undefined when calling getReportInfo.');
            }
            const localVarPath = `/reports/info/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturn.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Загружает заявление покупателя на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение заявления на возврат
         * @throws {RequiredError}
         */
        getReturnApplication(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturnApplication.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturnApplication.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturnApplication.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'imageHash' is not null or undefined
            if (imageHash === null || imageHash === undefined) {
                throw new RequiredError('imageHash','Required parameter imageHash was null or undefined when calling getReturnPhoto.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageHash"}}`, encodeURIComponent(String(imageHash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturns.');
            }
            const localVarPath = `/campaigns/{campaignId}/returns`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS["csv"]);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = ((type:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (fromDate2 !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate2:any):Date).toISOString().slice(0, 10);
            }

            if (toDate2 !== undefined) {
                localVarQueryParameter['to_date'] = ((toDate2:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getStocks.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/stocks`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getWarehouseStocksRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getWarehouseStocksRequest != null ? getWarehouseStocksRequest : {}) : (((getWarehouseStocksRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            // verify required parameter 'getSuggestedOfferMappingEntriesRequest' is not null or undefined
            if (getSuggestedOfferMappingEntriesRequest === null || getSuggestedOfferMappingEntriesRequest === undefined) {
                throw new RequiredError('getSuggestedOfferMappingEntriesRequest','Required parameter getSuggestedOfferMappingEntriesRequest was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingEntriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingEntriesRequest != null ? getSuggestedOfferMappingEntriesRequest : {}) : (((getSuggestedOfferMappingEntriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getSuggestedOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/suggestions`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingsRequest != null ? getSuggestedOfferMappingsRequest : {}) : (((getSuggestedOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedPrices.');
            }
            // verify required parameter 'suggestPricesRequest' is not null or undefined
            if (suggestPricesRequest === null || suggestPricesRequest === undefined) {
                throw new RequiredError('suggestPricesRequest','Required parameter suggestPricesRequest was null or undefined when calling getSuggestedPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof suggestPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(suggestPricesRequest != null ? suggestPricesRequest : {}) : (((suggestPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список складов и, если склады объединены, список групп складов. [Что такое группы складов и зачем они нужны](https://yandex.ru/support/marketplace/assortment/operations/stocks.html#unified-stocks)  Среди прочего запрос позволяет определить идентификатор, который нужно использовать при передаче остатков для группы складов.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Список складов и групп складов
         * @throws {RequiredError}
         */
        getWarehouses(businessId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getWarehouses.');
            }
            const localVarPath = `/businesses/{businessId}/warehouses`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает ключи цифровых товаров, которые покупатель заказал и оплатил. После выполнения запроса Маркет отправит ему письмо с ключами и инструкциями по активации, а также переведет заказ в финальный статус `DELIVERED`.  Ключ нужно передать в течение 30 минут после перехода заказа в статус `PROCESSING`.  Если в один заказ входят несколько ключей, передавайте их все в одном запросе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача ключей цифровых товаров
         * @throws {RequiredError}
         */
        provideOrderDigitalCodes(campaignId: number, orderId: number, provideOrderDigitalCodesRequest: ProvideOrderDigitalCodesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling provideOrderDigitalCodes.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling provideOrderDigitalCodes.');
            }
            // verify required parameter 'provideOrderDigitalCodesRequest' is not null or undefined
            if (provideOrderDigitalCodesRequest === null || provideOrderDigitalCodesRequest === undefined) {
                throw new RequiredError('provideOrderDigitalCodesRequest','Required parameter provideOrderDigitalCodesRequest was null or undefined when calling provideOrderDigitalCodes.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/deliverDigitalGoods`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof provideOrderDigitalCodesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(provideOrderDigitalCodesRequest != null ? provideOrderDigitalCodesRequest : {}) : (((provideOrderDigitalCodesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Передает Маркету коды маркировки для единиц товара в указанном заказе.  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  {% note warning %}  Прежде чем работать с этим методом, обязательно прочтите [статью о работе с маркируемыми товарами](https://yandex.ru/support/marketplace/orders/cz.html).  {% endnote %}  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кодов маркировки единиц товара
         * @throws {RequiredError}
         */
        provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling provideOrderItemIdentifiers.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling provideOrderItemIdentifiers.');
            }
            // verify required parameter 'provideOrderItemIdentifiersRequest' is not null or undefined
            if (provideOrderItemIdentifiersRequest === null || provideOrderItemIdentifiersRequest === undefined) {
                throw new RequiredError('provideOrderItemIdentifiersRequest','Required parameter provideOrderItemIdentifiersRequest was null or undefined when calling provideOrderItemIdentifiers.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/identifiers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof provideOrderItemIdentifiersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(provideOrderItemIdentifiersRequest != null ? provideOrderItemIdentifiersRequest : {}) : (((provideOrderItemIdentifiersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling putBidsForBusiness.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling putBidsForCampaign.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}/bids`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling refreshFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling refreshFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/refresh`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о моделях, удовлетворяющих заданным в запросе условиям поиска.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Поиск модели товара
         * @throws {RequiredError}
         */
        searchModels(query: string, regionId: number, currency?: CurrencyType, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling searchModels.');
            }
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchModels.');
            }
            const localVarPath = `/models`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = ((query:any):string);
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionChildren.');
            }
            const localVarPath = `/regions/{regionId}/children`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionsById.');
            }
            const localVarPath = `/regions/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling searchRegionsByName.');
            }
            const localVarPath = `/regions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling sendFileToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/file/send`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'sendMessageToChatRequest' is not null or undefined
            if (sendMessageToChatRequest === null || sendMessageToChatRequest === undefined) {
                throw new RequiredError('sendMessageToChatRequest','Required parameter sendMessageToChatRequest was null or undefined when calling sendMessageToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/message`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof sendMessageToChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sendMessageToChatRequest != null ? sendMessageToChatRequest : {}) : (((sendMessageToChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'setFeedParamsRequest' is not null or undefined
            if (setFeedParamsRequest === null || setFeedParamsRequest === undefined) {
                throw new RequiredError('setFeedParamsRequest','Required parameter setFeedParamsRequest was null or undefined when calling setFeedParams.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/params`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setFeedParamsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setFeedParamsRequest != null ? setFeedParamsRequest : {}) : (((setFeedParamsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note tip \"Подходит и для DBS\" %}  Запрос предназначен для работы с FBS-заказами, но вы можете использовать его для обработки DBS-заказов, если это удобно.  {% endnote %}  Позволяет выполнить три операции:  * передать Маркету информацию о распределении товаров по коробкам; * передать Маркету коды маркировки для товаров; * удалить товар из заказа, если его не оказалось на складе.  Если нужно что-то поправить в переданных данных, просто повторите запрос — это можно делать сколько угодно раз до перевода заказа в статус **Готов к отгрузке**. ⚠️ Если вы меняете раскладку уже после печати и расклейки ярлыков, не забудье перепечатать их и наклеить заново.  ## Как передать информацию о распределении товаров  В этом запросе вам нужно передать Маркету список коробок и указать, какие именно товары лежат в каждой из них. Коробки могут быть двух типов:  * **Содержащие товары целиком.** Такая коробка может содержать сколько угодно единиц любых товаров.  * **Содержащие часть товара.** Такие коробки содержат по одной части одного товара. Например, одна содержит внешний блок кондиционера, а другая — внутренний блок.  ⚠️ Одна коробка не может содержать и товары целиком, и части товаров.  ## Как передавать коды маркировки  Если в заказе есть товары, подлежащие маркировке, в запросе нужно передать соответствующие уникальные коды. [Что такое маркировка?](https://yandex.ru/support/marketplace/orders/cz.html)  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  Если товар едет в нескольких коробках, код маркировки нужно передать для каждой из них.  ## Как удалить товар из заказа  Чтобы удалить товар из заказа:  1. Добавьте в запрос `allowRemove: true`. 2. Передайте распределение по коробкам без товара, который нужно удалить.  {% note warning \"Удаление нельзя отменить\" %}  Эта операция необратима: покупатель сразу получит уведомление, а состав заказа изменится.  {% endnote %}  Чтобы удалить позицию целиком, не передавайте соответствующий `OrderBoxLayoutItemDTO`. Чтобы уменьшить количество товара, передайте уменьшенное значение в поле `fullCount`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если вы не можете отгрузить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  ## Примеры  {% cut \"Товар умещается в коробку\" %}  Вот как будет выглядеть запрос, если в одной коробке едут:    * три единицы одного товара, требующего маркировки;   * одна единица другого товара, не требущего маркировки.    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"fullCount\": 3,                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           },                           {                               \"cis\": \"010304109478gftJ14545762!\\u001dhGt264\"                           },                           {                               \"cis\": \"010304109478fRs28323ks23!\\u001dhet201\"                           }                       ]                   },                   {                       \"id\": 654321,                       \"fullCount\": 1                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Товар едет в разных коробках\" %}  Вот как будет выглядеть запрос, если товар едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Одинаковые товары, где каждый едет в нескольких коробках\" %}  Вот как будет выглядеть запрос, если каждый из двух одинаковых товаров едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Подготовка заказа
         * @throws {RequiredError}
         */
        setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderBoxLayout.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderBoxLayout.');
            }
            // verify required parameter 'setOrderBoxLayoutRequest' is not null or undefined
            if (setOrderBoxLayoutRequest === null || setOrderBoxLayoutRequest === undefined) {
                throw new RequiredError('setOrderBoxLayoutRequest','Required parameter setOrderBoxLayoutRequest was null or undefined when calling setOrderBoxLayout.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/boxes`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderBoxLayoutRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderBoxLayoutRequest != null ? setOrderBoxLayoutRequest : {}) : (((setOrderBoxLayoutRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод изменяет дату доставки заказа в статусе `PROCESSING` или `DELIVERY`. Для заказов с другими статусами дату доставки изменить нельзя.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение даты доставки заказа
         * @throws {RequiredError}
         */
        setOrderDeliveryDate(campaignId: number, orderId: number, setOrderDeliveryDateRequest: SetOrderDeliveryDateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderDeliveryDate.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderDeliveryDate.');
            }
            // verify required parameter 'setOrderDeliveryDateRequest' is not null or undefined
            if (setOrderDeliveryDateRequest === null || setOrderDeliveryDateRequest === undefined) {
                throw new RequiredError('setOrderDeliveryDateRequest','Required parameter setOrderDeliveryDateRequest was null or undefined when calling setOrderDeliveryDate.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/date`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderDeliveryDateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderDeliveryDateRequest != null ? setOrderDeliveryDateRequest : {}) : (((setOrderDeliveryDateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Вы можете использовать запрос, чтобы повысить лояльность покупателей. Если они могут узнать, на каком этапе доставки находятся их заказы, доверие покупателей к вашему магазину может возрасти.  {% endnote %}  Передает Маркету трек‑номер, по которому покупатель может отследить посылку со своим заказом через службу доставки.  Передать трек‑номер можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY` или `PICKUP`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача трек‑номера посылки
         * @throws {RequiredError}
         */
        setOrderDeliveryTrackCode(campaignId: number, orderId: number, setOrderDeliveryTrackCodeRequest: SetOrderDeliveryTrackCodeRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderDeliveryTrackCode.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderDeliveryTrackCode.');
            }
            // verify required parameter 'setOrderDeliveryTrackCodeRequest' is not null or undefined
            if (setOrderDeliveryTrackCodeRequest === null || setOrderDeliveryTrackCodeRequest === undefined) {
                throw new RequiredError('setOrderDeliveryTrackCodeRequest','Required parameter setOrderDeliveryTrackCodeRequest was null or undefined when calling setOrderDeliveryTrackCode.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/track`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderDeliveryTrackCodeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderDeliveryTrackCodeRequest != null ? setOrderDeliveryTrackCodeRequest : {}) : (((setOrderDeliveryTrackCodeRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Отгружаемый Маркету заказ может не влезть в одну коробку или упаковку — в этом случае получается, что он занимает несколько грузовых мест.  Количество грузовых мест нужно обязательно передавать Маркету, если оно не равно 1. Это делается перед переводом его в статус **Готов к отгрузке**. Подробно о том, что в какой момент нужно передавать, рассказано в [пошаговой инструкции](../../step-by-step/fbs.md).  Метод устроен немного нестандартно: количество задается длиной массива пустых объектов.  Раньше метод требовал передачи большего количества данных. Запросы, оформленные по старому образцу, работают, но лучше делать по-новому.  {% cut \"Как было раньше\" %}  Структура тела PUT-запроса:  ``` {   \"boxes\":   [     {       \"fulfilmentId\": \"{string}\",       \"weight\": {int64},       \"width\": {int64},       \"height\": {int64},       \"depth\": {int64},       \"items\":       [         {           \"id\": {int64},           \"count\": {int32}         },         ...       ]     },     ...   ] } ``` | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `boxes`       |           | Список грузовых мест.       |  **Параметры, вложенные в `boxes`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `fulfilmentId`       |  String   | Идентификатор грузового места в информационной системе магазина. Сформируйте идентификатор по шаблону: `номер заказа на Маркете-номер грузового места`. Например, `7206821‑1, 7206821‑2` и т. д. | | `weight`       | Int64        | Масса брутто грузового места (суммарная масса упаковки и содержимого) в граммах. | | `width`       | Int64   | Ширина грузового места в сантиметрах.       | | `height`       | Int64   | Высота грузового места в сантиметрах.       | | `depth`       | Int64   | Глубина грузового места в сантиметрах.        | | `items`       | Int64   | Список товаров в грузовом месте.       |  **Параметры, вложенные в `items`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `id`       | Int64     | Идентификатор товара в рамках заказа.   | | `count`    | Int32     | Количество единиц товара в грузовом месте.       |  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача количества грузовых мест в заказе
         * @throws {RequiredError}
         */
        setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'setOrderShipmentBoxesRequest' is not null or undefined
            if (setOrderShipmentBoxesRequest === null || setOrderShipmentBoxesRequest === undefined) {
                throw new RequiredError('setOrderShipmentBoxesRequest','Required parameter setOrderShipmentBoxesRequest was null or undefined when calling setOrderShipmentBoxes.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderShipmentBoxesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderShipmentBoxesRequest != null ? setOrderShipmentBoxesRequest : {}) : (((setOrderShipmentBoxesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Выбирает решение по возврату от покупателя. После этого для подтверждения решения нужно выполнить запрос [POST campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit](../../reference/orders/submitReturnDecision.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Принятие или изменение решения по возврату
         * @throws {RequiredError}
         */
        setReturnDecision(campaignId: number, orderId: number, returnId: number, setReturnDecisionRequest: SetReturnDecisionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setReturnDecision.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setReturnDecision.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling setReturnDecision.');
            }
            // verify required parameter 'setReturnDecisionRequest' is not null or undefined
            if (setReturnDecisionRequest === null || setReturnDecisionRequest === undefined) {
                throw new RequiredError('setReturnDecisionRequest','Required parameter setReturnDecisionRequest was null or undefined when calling setReturnDecision.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setReturnDecisionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setReturnDecisionRequest != null ? setReturnDecisionRequest : {}) : (((setReturnDecisionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            // verify required parameter 'skipGoodsFeedbackReactionRequest' is not null or undefined
            if (skipGoodsFeedbackReactionRequest === null || skipGoodsFeedbackReactionRequest === undefined) {
                throw new RequiredError('skipGoodsFeedbackReactionRequest','Required parameter skipGoodsFeedbackReactionRequest was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/skip-reaction`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof skipGoodsFeedbackReactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(skipGoodsFeedbackReactionRequest != null ? skipGoodsFeedbackReactionRequest : {}) : (((skipGoodsFeedbackReactionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает выбранное решение по возврату, отправленное в запросе [POST campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision](../../reference/orders/setReturnDecision.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Подтверждение решения по возврату
         * @throws {RequiredError}
         */
        submitReturnDecision(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling submitReturnDecision.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling submitReturnDecision.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling submitReturnDecision.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateBusinessPrices.');
            }
            // verify required parameter 'updateBusinessPricesRequest' is not null or undefined
            if (updateBusinessPricesRequest === null || updateBusinessPricesRequest === undefined) {
                throw new RequiredError('updateBusinessPricesRequest','Required parameter updateBusinessPricesRequest was null or undefined when calling updateBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/offer-prices/updates`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateBusinessPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateBusinessPricesRequest != null ? updateBusinessPricesRequest : {}) : (((updateBusinessPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateCampaignOffers.');
            }
            // verify required parameter 'updateCampaignOffersRequest' is not null or undefined
            if (updateCampaignOffersRequest === null || updateCampaignOffersRequest === undefined) {
                throw new RequiredError('updateCampaignOffersRequest','Required parameter updateCampaignOffersRequest was null or undefined when calling updateCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/update`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateCampaignOffersRequest != null ? updateCampaignOffersRequest : {}) : (((updateCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateGoodsFeedbackComment.');
            }
            // verify required parameter 'updateGoodsFeedbackCommentRequest' is not null or undefined
            if (updateGoodsFeedbackCommentRequest === null || updateGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('updateGoodsFeedbackCommentRequest','Required parameter updateGoodsFeedbackCommentRequest was null or undefined when calling updateGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateGoodsFeedbackCommentRequest != null ? updateGoodsFeedbackCommentRequest : {}) : (((updateGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferContent.');
            }
            // verify required parameter 'updateOfferContentRequest' is not null or undefined
            if (updateOfferContentRequest === null || updateOfferContentRequest === undefined) {
                throw new RequiredError('updateOfferContentRequest','Required parameter updateOfferContentRequest was null or undefined when calling updateOfferContent.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferContentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferContentRequest != null ? updateOfferContentRequest : {}) : (((updateOfferContentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOfferMappingEntries.');
            }
            // verify required parameter 'updateOfferMappingEntryRequest' is not null or undefined
            if (updateOfferMappingEntryRequest === null || updateOfferMappingEntryRequest === undefined) {
                throw new RequiredError('updateOfferMappingEntryRequest','Required parameter updateOfferMappingEntryRequest was null or undefined when calling updateOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingEntryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingEntryRequest != null ? updateOfferMappingEntryRequest : {}) : (((updateOfferMappingEntryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferMappings.');
            }
            // verify required parameter 'updateOfferMappingsRequest' is not null or undefined
            if (updateOfferMappingsRequest === null || updateOfferMappingsRequest === undefined) {
                throw new RequiredError('updateOfferMappingsRequest','Required parameter updateOfferMappingsRequest was null or undefined when calling updateOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingsRequest != null ? updateOfferMappingsRequest : {}) : (((updateOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Изменяет состав заказа, если позволяет выбранная служба доставки, в случаях:  * покупатель уменьшил количество товара; * магазин не может поставить все товары в заказе.  Для этого заказ должен находится в статусе `\"status\": \"PROCESSING\"` этапа обработки `\"substatus\": \"STARTED\"`. После передачи статуса `\"substatus\": \"READY_TO_SHIP\"` изменить состав невозможно.  Если одинаковых товаров несколько, для уменьшения количества передайте обновленное значение в атрибуте `count` параметра `item`.  Чтобы полностью удалить товар из заказа:  * передайте значение `0`; или * не передавайте параметр `item`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если необходимо удалить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  **Возврат денег покупателю**  Если покупатель оплатил товар при оформлении, Маркет вернет ему деньги за удаленные из заказа товары в течение двух дней:  * при оплате банковской картой — с момента, когда магазин переведет заказ в статус `SHIPPED`;  * при оплате через Apple Pay или Google Pay — с момента, когда магазин удалит товар из заказа.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Удаление товара из заказа или уменьшение числа единиц
         * @throws {RequiredError}
         */
        updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderItems.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderItems.');
            }
            // verify required parameter 'updateOrderItemRequest' is not null or undefined
            if (updateOrderItemRequest === null || updateOrderItemRequest === undefined) {
                throw new RequiredError('updateOrderItemRequest','Required parameter updateOrderItemRequest was null or undefined when calling updateOrderItems.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/items`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderItemRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderItemRequest != null ? updateOrderItemRequest : {}) : (((updateOrderItemRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет статус заказа. Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статуса одного заказа
         * @throws {RequiredError}
         */
        updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStatus.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderStatus.');
            }
            // verify required parameter 'updateOrderStatusRequest' is not null or undefined
            if (updateOrderStatusRequest === null || updateOrderStatusRequest === undefined) {
                throw new RequiredError('updateOrderStatusRequest','Required parameter updateOrderStatusRequest was null or undefined when calling updateOrderStatus.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/status`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStatusRequest != null ? updateOrderStatusRequest : {}) : (((updateOrderStatusRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет статусы нескольких заказов.  Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"`и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  Максимальное количество заказов, у которых можно изменить статус в одном запросе, — 30.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статусов нескольких заказов
         * @throws {RequiredError}
         */
        updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStatuses.');
            }
            // verify required parameter 'updateOrderStatusesRequest' is not null or undefined
            if (updateOrderStatusesRequest === null || updateOrderStatusesRequest === undefined) {
                throw new RequiredError('updateOrderStatusesRequest','Required parameter updateOrderStatusesRequest was null or undefined when calling updateOrderStatuses.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/status-update`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStatusesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStatusesRequest != null ? updateOrderStatusesRequest : {}) : (((updateOrderStatusesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Продлевает срок хранения заказа в пункте выдачи продавца.  Заказ должен быть в статусе `PICKUP`. Продлить срок можно только один раз, не больше чем на 30 дней.  Новый срок хранения можно получить в параметре `outletStorageLimitDate` запроса [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Продление срока хранения заказа
         * @throws {RequiredError}
         */
        updateOrderStorageLimit(campaignId: number, orderId: number, updateOrderStorageLimitRequest: UpdateOrderStorageLimitRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStorageLimit.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderStorageLimit.');
            }
            // verify required parameter 'updateOrderStorageLimitRequest' is not null or undefined
            if (updateOrderStorageLimitRequest === null || updateOrderStorageLimitRequest === undefined) {
                throw new RequiredError('updateOrderStorageLimitRequest','Required parameter updateOrderStorageLimitRequest was null or undefined when calling updateOrderStorageLimit.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/storage-limit`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStorageLimitRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStorageLimitRequest != null ? updateOrderStorageLimitRequest : {}) : (((updateOrderStorageLimitRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет информацию о точке продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Изменение информации о точке продаж
         * @throws {RequiredError}
         */
        updateOutlet(campaignId: number, outletId: number, changeOutletRequest: ChangeOutletRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOutlet.');
            }
            // verify required parameter 'outletId' is not null or undefined
            if (outletId === null || outletId === undefined) {
                throw new RequiredError('outletId','Required parameter outletId was null or undefined when calling updateOutlet.');
            }
            // verify required parameter 'changeOutletRequest' is not null or undefined
            if (changeOutletRequest === null || changeOutletRequest === undefined) {
                throw new RequiredError('changeOutletRequest','Required parameter changeOutletRequest was null or undefined when calling updateOutlet.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/{outletId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof changeOutletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(changeOutletRequest != null ? changeOutletRequest : {}) : (((changeOutletRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает информацию о новых и существующих лицензиях для точек продаж. Поддерживаются только лицензии на розничную продажу алкоголя.  Чтобы размещать алкогольную продукцию на Маркете, надо также прислать гарантийное письмо (если вы еще не делали этого раньше) и правильно оформить предложения в прайс-листе. Далее информация о лицензиях проходит проверку.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Создание и изменение лицензий для точек продаж
         * @throws {RequiredError}
         */
        updateOutletLicenses(campaignId: number, updateOutletLicenseRequest: UpdateOutletLicenseRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOutletLicenses.');
            }
            // verify required parameter 'updateOutletLicenseRequest' is not null or undefined
            if (updateOutletLicenseRequest === null || updateOutletLicenseRequest === undefined) {
                throw new RequiredError('updateOutletLicenseRequest','Required parameter updateOutletLicenseRequest was null or undefined when calling updateOutletLicenses.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/licenses`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOutletLicenseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOutletLicenseRequest != null ? updateOutletLicenseRequest : {}) : (((updateOutletLicenseRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updatePrices.');
            }
            // verify required parameter 'updatePricesRequest' is not null or undefined
            if (updatePricesRequest === null || updatePricesRequest === undefined) {
                throw new RequiredError('updatePricesRequest','Required parameter updatePricesRequest was null or undefined when calling updatePrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePricesRequest != null ? updatePricesRequest : {}) : (((updatePricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updatePromoOffers.');
            }
            // verify required parameter 'updatePromoOffersRequest' is not null or undefined
            if (updatePromoOffersRequest === null || updatePromoOffersRequest === undefined) {
                throw new RequiredError('updatePromoOffersRequest','Required parameter updatePromoOffersRequest was null or undefined when calling updatePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePromoOffersRequest != null ? updatePromoOffersRequest : {}) : (((updatePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает данные об остатках товаров на витрине.  Обязательно указывайте SKU **в точности** так, как он указан в каталоге. Например, _557722_ и _0557722_ — это два разных SKU.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-| 
         * @summary Передача информации об остатках
         * @throws {RequiredError}
         */
        updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateStocks.');
            }
            // verify required parameter 'updateStocksRequest' is not null or undefined
            if (updateStocksRequest === null || updateStocksRequest === undefined) {
                throw new RequiredError('updateStocksRequest','Required parameter updateStocksRequest was null or undefined when calling updateStocks.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/stocks`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateStocksRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateStocksRequest != null ? updateStocksRequest : {}) : (((updateStocksRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type DbsApiType = { 
    acceptOrderCancellation(campaignId: number, orderId: number, acceptOrderCancellationRequest: AcceptOrderCancellationRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions): Promise<AddOffersToArchiveResponse>,

    calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions): Promise<CalculateTariffsResponse>,

    confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions): Promise<CreateChatResponse>,

    createOutlet(campaignId: number, changeOutletRequest: ChangeOutletRequest, options?: RequestOptions): Promise<CreateOutletResponse>,

    deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions): Promise<DeleteCampaignOffersResponse>,

    deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions): Promise<DeleteOffersResponse>,

    deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions): Promise<DeleteOffersFromArchiveResponse>,

    deleteOutlet(campaignId: number, outletId: number, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteOutletLicenses(campaignId: number, ids?: Set<number>, options?: RequestOptions): Promise<EmptyApiResponse>,

    deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions): Promise<DeletePromoOffersResponse>,

    generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options?: RequestOptions): Promise<File>,

    generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options?: RequestOptions): Promise<File>,

    generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions): Promise<GetAllOffersResponse>,

    getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions): Promise<GetBidsInfoResponse>,

    getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions): Promise<GetBidsRecommendationsResponse>,

    getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,

    getBusinessSettings(businessId: number, options?: RequestOptions): Promise<GetBusinessSettingsResponse>,

    getCampaign(campaignId: number, options?: RequestOptions): Promise<GetCampaignResponse>,

    getCampaignLogins(campaignId: number, options?: RequestOptions): Promise<GetCampaignLoginsResponse>,

    getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetCampaignOffersResponse>,

    getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,

    getCampaignRegion(campaignId: number, options?: RequestOptions): Promise<GetCampaignRegionResponse>,

    getCampaignSettings(campaignId: number, options?: RequestOptions): Promise<GetCampaignSettingsResponse>,

    getCampaigns(page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,

    getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,

    getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions): Promise<GetCategoriesMaxSaleQuantumResponse>,

    getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions): Promise<GetCategoriesResponse>,

    getCategoryContentParameters(categoryId: number, options?: RequestOptions): Promise<GetCategoryContentParametersResponse>,

    getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatHistoryResponse>,

    getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatsResponse>,

    getDeliveryServices(options?: RequestOptions): Promise<GetDeliveryServicesResponse>,

    getFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<GetFeedResponse>,

    getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions): Promise<GetFeedIndexLogsResponse>,

    getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions): Promise<GetFeedbackListResponse>,

    getFeeds(campaignId: number, options?: RequestOptions): Promise<GetFeedsResponse>,

    getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetGoodsFeedbackCommentsResponse>,

    getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions): Promise<GetGoodsFeedbackResponse>,

    getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions): Promise<GetGoodsStatsResponse>,

    getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetHiddenOffersResponse>,

    getModel(modelId: number, regionId: number, currency?: CurrencyType, options?: RequestOptions): Promise<GetModelsResponse>,

    getModelOffers(modelId: number, regionId: number, currency?: CurrencyType, orderByPrice?: SortOrderType, count?: number, page?: number, options?: RequestOptions): Promise<GetModelsOffersResponse>,

    getModels(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, options?: RequestOptions): Promise<GetModelsResponse>,

    getModelsOffers(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, orderByPrice?: SortOrderType, options?: RequestOptions): Promise<GetModelsOffersResponse>,

    getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions): Promise<GetOfferCardsContentStatusResponse>,

    getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferMappingEntriesResponse>,

    getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions): Promise<GetOfferMappingsResponse>,

    getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferRecommendationsResponse>,

    getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetOffersResponse>,

    getOrder(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderResponse>,

    getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessBuyerInfoResponse>,

    getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessDocumentsInfoResponse>,

    getOrderBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderBuyerInfoResponse>,

    getOrderLabelsData(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderLabelsDataResponse>,

    getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOrdersResponse>,

    getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions): Promise<GetOrdersStatsResponse>,

    getOutlet(campaignId: number, outletId: number, options?: RequestOptions): Promise<GetOutletResponse>,

    getOutletLicenses(campaignId: number, outletIds?: Set<number>, ids?: Set<number>, options?: RequestOptions): Promise<GetOutletLicensesResponse>,

    getOutlets(campaignId: number, pageToken?: string, regionId?: number, shopOutletCode?: string, regionId2?: number, options?: RequestOptions): Promise<GetOutletsResponse>,

    getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions): Promise<GetPricesResponse>,

    getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions): Promise<GetPricesByOfferIdsResponse>,

    getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetPromoOffersResponse>,

    getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions): Promise<GetPromosResponse>,

    getQualityRatingDetails(campaignId: number, options?: RequestOptions): Promise<GetQualityRatingDetailsResponse>,

    getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions): Promise<GetQualityRatingResponse>,

    getReportInfo(reportId: string, options?: RequestOptions): Promise<GetReportInfoResponse>,

    getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<GetReturnResponse>,

    getReturnApplication(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<File>,

    getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions): Promise<File>,

    getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions): Promise<GetReturnsResponse>,

    getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions): Promise<GetWarehouseStocksResponse>,

    getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingEntriesResponse>,

    getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingsResponse>,

    getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions): Promise<SuggestPricesResponse>,

    getWarehouses(businessId: number, options?: RequestOptions): Promise<GetWarehousesResponse>,

    provideOrderDigitalCodes(campaignId: number, orderId: number, provideOrderDigitalCodesRequest: ProvideOrderDigitalCodesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options?: RequestOptions): Promise<ProvideOrderItemIdentifiersResponse>,

    putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    refreshFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<EmptyApiResponse>,

    searchModels(query: string, regionId: number, currency?: CurrencyType, page?: number, pageSize?: number, options?: RequestOptions): Promise<SearchModelsResponse>,

    searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetRegionWithChildrenResponse>,

    searchRegionsById(regionId: number, options?: RequestOptions): Promise<GetRegionsResponse>,

    searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetRegionsResponse>,

    sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions): Promise<EmptyApiResponse>,

    sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options?: RequestOptions): Promise<SetOrderBoxLayoutResponse>,

    setOrderDeliveryDate(campaignId: number, orderId: number, setOrderDeliveryDateRequest: SetOrderDeliveryDateRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setOrderDeliveryTrackCode(campaignId: number, orderId: number, setOrderDeliveryTrackCodeRequest: SetOrderDeliveryTrackCodeRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options?: RequestOptions): Promise<SetOrderShipmentBoxesResponse>,

    setReturnDecision(campaignId: number, orderId: number, returnId: number, setReturnDecisionRequest: SetReturnDecisionRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    submitReturnDecision(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<UpdateGoodsFeedbackCommentResponse>,

    updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions): Promise<UpdateOfferContentResponse>,

    updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions): Promise<UpdateOfferMappingsResponse>,

    updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options?: RequestOptions): Promise<Response>,

    updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options?: RequestOptions): Promise<UpdateOrderStatusResponse>,

    updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options?: RequestOptions): Promise<UpdateOrderStatusesResponse>,

    updateOrderStorageLimit(campaignId: number, orderId: number, updateOrderStorageLimitRequest: UpdateOrderStorageLimitRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateOutlet(campaignId: number, outletId: number, changeOutletRequest: ChangeOutletRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateOutletLicenses(campaignId: number, updateOutletLicenseRequest: UpdateOutletLicenseRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions): Promise<UpdatePromoOffersResponse>,

    updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * DbsApi - factory function to inject configuration 
 * @export
 */
export const DbsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): DbsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Подтверждает или отклоняет запрос покупателя на отмену заказа, который передан службе доставки.  Покупатель может отменить заказ в течение его обработки или доставки. Если заказ еще обрабатывается (имеет статус PROCESSING), вам не нужно подтверждать отмену заказа — он будет отменен автоматически.  Если заказ уже передан службе доставки (принимает статус `DELIVERY` или `PICKUP`) и пользователь отменил его, вы можете предупредить службу об отмене в течение 48 часов. Если служба доставки узнала об отмене до передачи заказа покупателю, подтвердите отмену с помощью запроса [PUT campaigns/{campaignId}/orders/{orderId}/cancellation/accept](../../reference/orders/acceptOrderCancellation.md). Если заказ уже доставлен, отклоните отмену с помощью этого же запроса. Тогда у покупателя останется заказ, и деньги за него возвращаться не будут.  Чтобы узнать, какие заказы были отменены в статусе `DELIVERY` или `PICKUP`, отправьте запрос [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md). В его URL добавьте входной параметр `onlyWaitingForCancellationApprove=true`. Вы также можете узнать об отмененных заказах в кабинете или через почту — на нее придет уведомление об отмене.  Если в течение 48 часов вы не подтвердите или отклоните отмену, заказ будет отменен автоматически.  |**⚙️ Лимит:** 500 запросов в час| |-| 
         * @summary Отмена заказа покупателем
         * @throws {RequiredError}
         */
        acceptOrderCancellation(campaignId: number, orderId: number, acceptOrderCancellationRequest: AcceptOrderCancellationRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).acceptOrderCancellation(campaignId, orderId, acceptOrderCancellationRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).addHiddenOffers(campaignId, addHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions = {}): Promise<AddOffersToArchiveResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).addOffersToArchive(businessId, addOffersToArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions = {}): Promise<CalculateTariffsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).calculateTariffs(calculateTariffsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).confirmBusinessPrices(businessId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).confirmCampaignPrices(campaignId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions = {}): Promise<CreateChatResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).createChat(businessId, createChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Создает точку продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Создание точки продаж
         * @throws {RequiredError}
         */
        createOutlet(campaignId: number, changeOutletRequest: ChangeOutletRequest, options?: RequestOptions = {}): Promise<CreateOutletResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).createOutlet(campaignId, changeOutletRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions = {}): Promise<DeleteCampaignOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).deleteCampaignOffers(campaignId, deleteCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).deleteGoodsFeedbackComment(businessId, deleteGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).deleteHiddenOffers(campaignId, deleteHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions = {}): Promise<DeleteOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).deleteOffers(businessId, deleteOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions = {}): Promise<DeleteOffersFromArchiveResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).deleteOffersFromArchive(businessId, deleteOffersFromArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет точку продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Удаление точки продаж
         * @throws {RequiredError}
         */
        deleteOutlet(campaignId: number, outletId: number, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).deleteOutlet(campaignId, outletId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет информацию о лицензиях для точек продаж.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Удаление лицензий для точек продаж
         * @throws {RequiredError}
         */
        deleteOutletLicenses(campaignId: number, ids?: Set<number>, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).deleteOutletLicenses(campaignId, ids, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions = {}): Promise<DeletePromoOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).deletePromoOffers(businessId, deletePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateBoostConsolidatedReport(generateBoostConsolidatedRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateGoodsFeedbackReport(generateGoodsFeedbackRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию PDF-файла с ярлыками для переданных заказов. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  Узнать статус генерации и получить ссылку на готовый файл можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в нескольких заказах
         * @throws {RequiredError}
         */
        generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateMassOrderLabelsReport(generateMassOrderLabelsRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Формирует ярлык‑наклейку для коробки в заказе и возвращает ярлык в PDF‑файле.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовый ярлык‑наклейка для коробки в заказе
         * @throws {RequiredError}
         */
        generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateOrderLabel(campaignId, orderId, shipmentId, boxId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает PDF-файл с ярлыками, которые нужно наклеить на коробки перед отгрузкой. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  На вход нужно передать идентификатор заказа и один необязательный параметр, который управляет версткой PDF-файла.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в одном заказе
         * @throws {RequiredError}
         */
        generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateOrderLabels(campaignId, orderId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generatePricesReport(generatePricesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateShelfsStatisticsReport(generateShelfsStatisticsRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateShowsSalesReport(generateShowsSalesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateUnitedNettingReport(generateUnitedNettingReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).generateUnitedOrdersReport(generateUnitedOrdersRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions = {}): Promise<GetAllOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getAllOffers(campaignId, feedId, chunk, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions = {}): Promise<GetBidsInfoResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getBidsInfoForBusiness(businessId, pageToken, limit, getBidsInfoRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions = {}): Promise<GetBidsRecommendationsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getBidsRecommendations(businessId, getBidsRecommendationsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getBusinessQuarantineOffers(businessId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options?: RequestOptions = {}): Promise<GetBusinessSettingsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getBusinessSettings(businessId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCampaign(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignLoginsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCampaignLogins(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetCampaignOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCampaignOffers(campaignId, getCampaignOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCampaignQuarantineOffers(campaignId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignRegionResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCampaignRegion(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignSettingsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCampaignSettings(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCampaigns(page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCampaignsByLogin(login, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions = {}): Promise<GetCategoriesMaxSaleQuantumResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions = {}): Promise<GetCategoriesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCategoriesTree(getCategoriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options?: RequestOptions = {}): Promise<GetCategoryContentParametersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getCategoryContentParameters(categoryId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatHistoryResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getChatHistory(businessId, chatId, getChatHistoryRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getChats(businessId, getChatsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает справочник служб доставки: идентификаторы и наименования. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Справочник служб доставки
         * @throws {RequiredError}
         */
        getDeliveryServices(options?: RequestOptions = {}): Promise<GetDeliveryServicesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getDeliveryServices(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<GetFeedResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions = {}): Promise<GetFeedIndexLogsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getFeedIndexLogs(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions = {}): Promise<GetFeedbackListResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getFeedbackAndCommentUpdates(campaignId, pageToken, limit, fromDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options?: RequestOptions = {}): Promise<GetFeedsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getFeeds(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetGoodsFeedbackCommentsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getGoodsFeedbackComments(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions = {}): Promise<GetGoodsFeedbackResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getGoodsFeedbacks(businessId, pageToken, limit, getGoodsFeedbackRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions = {}): Promise<GetGoodsStatsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getGoodsStats(campaignId, getGoodsStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetHiddenOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getHiddenOffers(campaignId, offerId, pageToken, limit, offset, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о модели товара.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Информация об одной модели
         * @throws {RequiredError}
         */
        getModel(modelId: number, regionId: number, currency?: CurrencyType, options?: RequestOptions = {}): Promise<GetModelsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getModel(modelId, regionId, currency, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о первых десяти предложениях, расположенных на карточке модели.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей метод не поддерживается. Идентификатор групповой модели игнорируется.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Список предложений для одной модели
         * @throws {RequiredError}
         */
        getModelOffers(modelId: number, regionId: number, currency?: CurrencyType, orderByPrice?: SortOrderType, count?: number, page?: number, options?: RequestOptions = {}): Promise<GetModelsOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getModelOffers(modelId, regionId, currency, orderByPrice, count, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о моделях товаров.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Информация о нескольких моделях
         * @throws {RequiredError}
         */
        getModels(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, options?: RequestOptions = {}): Promise<GetModelsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getModels(regionId, getModelsRequest, currency, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о первых десяти предложениях, расположенных на карточках моделей, идентификаторы которых указаны в запросе.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей выдача предложений не поддерживается. Идентификаторы групповых моделей игнорируются.  В одном запросе можно получить информацию о предложениях не более чем для 100 моделей.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Список предложений для нескольких моделей
         * @throws {RequiredError}
         */
        getModelsOffers(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, orderByPrice?: SortOrderType, options?: RequestOptions = {}): Promise<GetModelsOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getModelsOffers(regionId, getModelsRequest, currency, orderByPrice, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions = {}): Promise<GetOfferCardsContentStatusResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOfferCardsContentStatus(businessId, pageToken, limit, getOfferCardsContentStatusRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferMappingEntriesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOfferMappingEntries(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetOfferMappingsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOfferMappings(businessId, pageToken, limit, getOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferRecommendationsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOfferRecommendations(businessId, getOfferRecommendationsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOffers(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOrder(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessBuyerInfoResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOrderBusinessBuyerInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessDocumentsInfoResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOrderBusinessDocumentsInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является юридическим лицом, воспользуйтесь запросом [POST campaigns/{campaignId}/orders/{orderId}/business-buyer](../../reference/order-business-information/getOrderBusinessBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY` или `PICKUP`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — физическом лице
         * @throws {RequiredError}
         */
        getOrderBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderBuyerInfoResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOrderBuyerInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию на ярлыках, которые клеятся на коробки в заказе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Данные для самостоятельного изготовления ярлыков
         * @throws {RequiredError}
         */
        getOrderLabelsData(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderLabelsDataResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOrderLabelsData(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOrdersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOrders(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions = {}): Promise<GetOrdersStatsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOrdersStats(campaignId, pageToken, limit, getOrdersStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о точках продаж магазина.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация об одной точке продаж
         * @throws {RequiredError}
         */
        getOutlet(campaignId: number, outletId: number, options?: RequestOptions = {}): Promise<GetOutletResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOutlet(campaignId, outletId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о лицензиях для точек продаж.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация о лицензиях для точек продаж
         * @throws {RequiredError}
         */
        getOutletLicenses(campaignId: number, outletIds?: Set<number>, ids?: Set<number>, options?: RequestOptions = {}): Promise<GetOutletLicensesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOutletLicenses(campaignId, outletIds, ids, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список точек продаж магазина.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация о нескольких точках продаж
         * @throws {RequiredError}
         */
        getOutlets(campaignId: number, pageToken?: string, regionId?: number, shopOutletCode?: string, regionId2?: number, options?: RequestOptions = {}): Promise<GetOutletsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getOutlets(campaignId, pageToken, regionId, shopOutletCode, regionId2, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions = {}): Promise<GetPricesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getPrices(campaignId, pageToken, limit, archived, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions = {}): Promise<GetPricesByOfferIdsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getPricesByOfferIds(campaignId, pageToken, limit, getPricesByOfferIdsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetPromoOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getPromoOffers(businessId, getPromoOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions = {}): Promise<GetPromosResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getPromos(businessId, getPromosRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список заказов, которые повлияли на индекс качества магазина. Чтобы узнать значение индекса качества, выполните запрос [POST businesses/{businessId}/ratings/quality](../../reference/ratings/getQualityRatings.md).  |**⚙️ Лимит:** 100000 запросов в час| |-| 
         * @summary Заказы, которые повлияли на индекс качества
         * @throws {RequiredError}
         */
        getQualityRatingDetails(campaignId: number, options?: RequestOptions = {}): Promise<GetQualityRatingDetailsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getQualityRatingDetails(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions = {}): Promise<GetQualityRatingResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getQualityRatings(businessId, getQualityRatingRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options?: RequestOptions = {}): Promise<GetReportInfoResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getReportInfo(reportId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<GetReturnResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getReturn(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Загружает заявление покупателя на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение заявления на возврат
         * @throws {RequiredError}
         */
        getReturnApplication(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getReturnApplication(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getReturnPhoto(campaignId, orderId, returnId, itemId, imageHash, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions = {}): Promise<GetReturnsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getReturns(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions = {}): Promise<GetWarehouseStocksResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getStocks(campaignId, pageToken, limit, getWarehouseStocksRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingEntriesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getSuggestedOfferMappingEntries(campaignId, getSuggestedOfferMappingEntriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getSuggestedOfferMappings(businessId, getSuggestedOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions = {}): Promise<SuggestPricesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getSuggestedPrices(campaignId, suggestPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список складов и, если склады объединены, список групп складов. [Что такое группы складов и зачем они нужны](https://yandex.ru/support/marketplace/assortment/operations/stocks.html#unified-stocks)  Среди прочего запрос позволяет определить идентификатор, который нужно использовать при передаче остатков для группы складов.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Список складов и групп складов
         * @throws {RequiredError}
         */
        getWarehouses(businessId: number, options?: RequestOptions = {}): Promise<GetWarehousesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).getWarehouses(businessId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает ключи цифровых товаров, которые покупатель заказал и оплатил. После выполнения запроса Маркет отправит ему письмо с ключами и инструкциями по активации, а также переведет заказ в финальный статус `DELIVERED`.  Ключ нужно передать в течение 30 минут после перехода заказа в статус `PROCESSING`.  Если в один заказ входят несколько ключей, передавайте их все в одном запросе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача ключей цифровых товаров
         * @throws {RequiredError}
         */
        provideOrderDigitalCodes(campaignId: number, orderId: number, provideOrderDigitalCodesRequest: ProvideOrderDigitalCodesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).provideOrderDigitalCodes(campaignId, orderId, provideOrderDigitalCodesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Передает Маркету коды маркировки для единиц товара в указанном заказе.  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  {% note warning %}  Прежде чем работать с этим методом, обязательно прочтите [статью о работе с маркируемыми товарами](https://yandex.ru/support/marketplace/orders/cz.html).  {% endnote %}  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кодов маркировки единиц товара
         * @throws {RequiredError}
         */
        provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options?: RequestOptions = {}): Promise<ProvideOrderItemIdentifiersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).provideOrderItemIdentifiers(campaignId, orderId, provideOrderItemIdentifiersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).putBidsForBusiness(businessId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).putBidsForCampaign(campaignId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).refreshFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о моделях, удовлетворяющих заданным в запросе условиям поиска.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Поиск модели товара
         * @throws {RequiredError}
         */
        searchModels(query: string, regionId: number, currency?: CurrencyType, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<SearchModelsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).searchModels(query, regionId, currency, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetRegionWithChildrenResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).searchRegionChildren(regionId, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).searchRegionsById(regionId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).searchRegionsByName(name, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).sendFileToChat(businessId, chatId, file, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).sendMessageToChat(businessId, chatId, sendMessageToChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).setFeedParams(campaignId, feedId, setFeedParamsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note tip \"Подходит и для DBS\" %}  Запрос предназначен для работы с FBS-заказами, но вы можете использовать его для обработки DBS-заказов, если это удобно.  {% endnote %}  Позволяет выполнить три операции:  * передать Маркету информацию о распределении товаров по коробкам; * передать Маркету коды маркировки для товаров; * удалить товар из заказа, если его не оказалось на складе.  Если нужно что-то поправить в переданных данных, просто повторите запрос — это можно делать сколько угодно раз до перевода заказа в статус **Готов к отгрузке**. ⚠️ Если вы меняете раскладку уже после печати и расклейки ярлыков, не забудье перепечатать их и наклеить заново.  ## Как передать информацию о распределении товаров  В этом запросе вам нужно передать Маркету список коробок и указать, какие именно товары лежат в каждой из них. Коробки могут быть двух типов:  * **Содержащие товары целиком.** Такая коробка может содержать сколько угодно единиц любых товаров.  * **Содержащие часть товара.** Такие коробки содержат по одной части одного товара. Например, одна содержит внешний блок кондиционера, а другая — внутренний блок.  ⚠️ Одна коробка не может содержать и товары целиком, и части товаров.  ## Как передавать коды маркировки  Если в заказе есть товары, подлежащие маркировке, в запросе нужно передать соответствующие уникальные коды. [Что такое маркировка?](https://yandex.ru/support/marketplace/orders/cz.html)  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  Если товар едет в нескольких коробках, код маркировки нужно передать для каждой из них.  ## Как удалить товар из заказа  Чтобы удалить товар из заказа:  1. Добавьте в запрос `allowRemove: true`. 2. Передайте распределение по коробкам без товара, который нужно удалить.  {% note warning \"Удаление нельзя отменить\" %}  Эта операция необратима: покупатель сразу получит уведомление, а состав заказа изменится.  {% endnote %}  Чтобы удалить позицию целиком, не передавайте соответствующий `OrderBoxLayoutItemDTO`. Чтобы уменьшить количество товара, передайте уменьшенное значение в поле `fullCount`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если вы не можете отгрузить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  ## Примеры  {% cut \"Товар умещается в коробку\" %}  Вот как будет выглядеть запрос, если в одной коробке едут:    * три единицы одного товара, требующего маркировки;   * одна единица другого товара, не требущего маркировки.    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"fullCount\": 3,                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           },                           {                               \"cis\": \"010304109478gftJ14545762!\\u001dhGt264\"                           },                           {                               \"cis\": \"010304109478fRs28323ks23!\\u001dhet201\"                           }                       ]                   },                   {                       \"id\": 654321,                       \"fullCount\": 1                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Товар едет в разных коробках\" %}  Вот как будет выглядеть запрос, если товар едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Одинаковые товары, где каждый едет в нескольких коробках\" %}  Вот как будет выглядеть запрос, если каждый из двух одинаковых товаров едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Подготовка заказа
         * @throws {RequiredError}
         */
        setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options?: RequestOptions = {}): Promise<SetOrderBoxLayoutResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).setOrderBoxLayout(campaignId, orderId, setOrderBoxLayoutRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Метод изменяет дату доставки заказа в статусе `PROCESSING` или `DELIVERY`. Для заказов с другими статусами дату доставки изменить нельзя.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение даты доставки заказа
         * @throws {RequiredError}
         */
        setOrderDeliveryDate(campaignId: number, orderId: number, setOrderDeliveryDateRequest: SetOrderDeliveryDateRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).setOrderDeliveryDate(campaignId, orderId, setOrderDeliveryDateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Вы можете использовать запрос, чтобы повысить лояльность покупателей. Если они могут узнать, на каком этапе доставки находятся их заказы, доверие покупателей к вашему магазину может возрасти.  {% endnote %}  Передает Маркету трек‑номер, по которому покупатель может отследить посылку со своим заказом через службу доставки.  Передать трек‑номер можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY` или `PICKUP`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача трек‑номера посылки
         * @throws {RequiredError}
         */
        setOrderDeliveryTrackCode(campaignId: number, orderId: number, setOrderDeliveryTrackCodeRequest: SetOrderDeliveryTrackCodeRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).setOrderDeliveryTrackCode(campaignId, orderId, setOrderDeliveryTrackCodeRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Отгружаемый Маркету заказ может не влезть в одну коробку или упаковку — в этом случае получается, что он занимает несколько грузовых мест.  Количество грузовых мест нужно обязательно передавать Маркету, если оно не равно 1. Это делается перед переводом его в статус **Готов к отгрузке**. Подробно о том, что в какой момент нужно передавать, рассказано в [пошаговой инструкции](../../step-by-step/fbs.md).  Метод устроен немного нестандартно: количество задается длиной массива пустых объектов.  Раньше метод требовал передачи большего количества данных. Запросы, оформленные по старому образцу, работают, но лучше делать по-новому.  {% cut \"Как было раньше\" %}  Структура тела PUT-запроса:  ``` {   \"boxes\":   [     {       \"fulfilmentId\": \"{string}\",       \"weight\": {int64},       \"width\": {int64},       \"height\": {int64},       \"depth\": {int64},       \"items\":       [         {           \"id\": {int64},           \"count\": {int32}         },         ...       ]     },     ...   ] } ``` | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `boxes`       |           | Список грузовых мест.       |  **Параметры, вложенные в `boxes`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `fulfilmentId`       |  String   | Идентификатор грузового места в информационной системе магазина. Сформируйте идентификатор по шаблону: `номер заказа на Маркете-номер грузового места`. Например, `7206821‑1, 7206821‑2` и т. д. | | `weight`       | Int64        | Масса брутто грузового места (суммарная масса упаковки и содержимого) в граммах. | | `width`       | Int64   | Ширина грузового места в сантиметрах.       | | `height`       | Int64   | Высота грузового места в сантиметрах.       | | `depth`       | Int64   | Глубина грузового места в сантиметрах.        | | `items`       | Int64   | Список товаров в грузовом месте.       |  **Параметры, вложенные в `items`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `id`       | Int64     | Идентификатор товара в рамках заказа.   | | `count`    | Int32     | Количество единиц товара в грузовом месте.       |  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача количества грузовых мест в заказе
         * @throws {RequiredError}
         */
        setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options?: RequestOptions = {}): Promise<SetOrderShipmentBoxesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).setOrderShipmentBoxes(campaignId, orderId, shipmentId, setOrderShipmentBoxesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Выбирает решение по возврату от покупателя. После этого для подтверждения решения нужно выполнить запрос [POST campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit](../../reference/orders/submitReturnDecision.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Принятие или изменение решения по возврату
         * @throws {RequiredError}
         */
        setReturnDecision(campaignId: number, orderId: number, returnId: number, setReturnDecisionRequest: SetReturnDecisionRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).setReturnDecision(campaignId, orderId, returnId, setReturnDecisionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).skipGoodsFeedbacksReaction(businessId, skipGoodsFeedbackReactionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает выбранное решение по возврату, отправленное в запросе [POST campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision](../../reference/orders/setReturnDecision.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Подтверждение решения по возврату
         * @throws {RequiredError}
         */
        submitReturnDecision(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).submitReturnDecision(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateBusinessPrices(businessId, updateBusinessPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateCampaignOffers(campaignId, updateCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<UpdateGoodsFeedbackCommentResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateGoodsFeedbackComment(businessId, updateGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions = {}): Promise<UpdateOfferContentResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateOfferContent(businessId, updateOfferContentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateOfferMappingEntries(campaignId, updateOfferMappingEntryRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions = {}): Promise<UpdateOfferMappingsResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateOfferMappings(businessId, updateOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Изменяет состав заказа, если позволяет выбранная служба доставки, в случаях:  * покупатель уменьшил количество товара; * магазин не может поставить все товары в заказе.  Для этого заказ должен находится в статусе `\"status\": \"PROCESSING\"` этапа обработки `\"substatus\": \"STARTED\"`. После передачи статуса `\"substatus\": \"READY_TO_SHIP\"` изменить состав невозможно.  Если одинаковых товаров несколько, для уменьшения количества передайте обновленное значение в атрибуте `count` параметра `item`.  Чтобы полностью удалить товар из заказа:  * передайте значение `0`; или * не передавайте параметр `item`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если необходимо удалить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  **Возврат денег покупателю**  Если покупатель оплатил товар при оформлении, Маркет вернет ему деньги за удаленные из заказа товары в течение двух дней:  * при оплате банковской картой — с момента, когда магазин переведет заказ в статус `SHIPPED`;  * при оплате через Apple Pay или Google Pay — с момента, когда магазин удалит товар из заказа.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Удаление товара из заказа или уменьшение числа единиц
         * @throws {RequiredError}
         */
        updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateOrderItems(campaignId, orderId, updateOrderItemRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет статус заказа. Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статуса одного заказа
         * @throws {RequiredError}
         */
        updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options?: RequestOptions = {}): Promise<UpdateOrderStatusResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateOrderStatus(campaignId, orderId, updateOrderStatusRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет статусы нескольких заказов.  Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"`и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  Максимальное количество заказов, у которых можно изменить статус в одном запросе, — 30.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статусов нескольких заказов
         * @throws {RequiredError}
         */
        updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options?: RequestOptions = {}): Promise<UpdateOrderStatusesResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateOrderStatuses(campaignId, updateOrderStatusesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Продлевает срок хранения заказа в пункте выдачи продавца.  Заказ должен быть в статусе `PICKUP`. Продлить срок можно только один раз, не больше чем на 30 дней.  Новый срок хранения можно получить в параметре `outletStorageLimitDate` запроса [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Продление срока хранения заказа
         * @throws {RequiredError}
         */
        updateOrderStorageLimit(campaignId: number, orderId: number, updateOrderStorageLimitRequest: UpdateOrderStorageLimitRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateOrderStorageLimit(campaignId, orderId, updateOrderStorageLimitRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет информацию о точке продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Изменение информации о точке продаж
         * @throws {RequiredError}
         */
        updateOutlet(campaignId: number, outletId: number, changeOutletRequest: ChangeOutletRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateOutlet(campaignId, outletId, changeOutletRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает информацию о новых и существующих лицензиях для точек продаж. Поддерживаются только лицензии на розничную продажу алкоголя.  Чтобы размещать алкогольную продукцию на Маркете, надо также прислать гарантийное письмо (если вы еще не делали этого раньше) и правильно оформить предложения в прайс-листе. Далее информация о лицензиях проходит проверку.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Создание и изменение лицензий для точек продаж
         * @throws {RequiredError}
         */
        updateOutletLicenses(campaignId: number, updateOutletLicenseRequest: UpdateOutletLicenseRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateOutletLicenses(campaignId, updateOutletLicenseRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updatePrices(campaignId, updatePricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions = {}): Promise<UpdatePromoOffersResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updatePromoOffers(businessId, updatePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает данные об остатках товаров на витрине.  Обязательно указывайте SKU **в точности** так, как он указан в каталоге. Например, _557722_ и _0557722_ — это два разных SKU.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-| 
         * @summary Передача информации об остатках
         * @throws {RequiredError}
         */
        updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = DbsApiFetchParamCreator(configuration).updateStocks(campaignId, updateStocksRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * DeliveryServicesApi - fetch parameter creator
 * @export
 */
export const DeliveryServicesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает справочник служб доставки: идентификаторы и наименования. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Справочник служб доставки
         * @throws {RequiredError}
         */
        getDeliveryServices(options: RequestOptions): FetchArgs {
            const localVarPath = `/delivery/services`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type DeliveryServicesApiType = { 
    getDeliveryServices(options?: RequestOptions): Promise<GetDeliveryServicesResponse>,
}

/**
 * DeliveryServicesApi - factory function to inject configuration 
 * @export
 */
export const DeliveryServicesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): DeliveryServicesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает справочник служб доставки: идентификаторы и наименования. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Справочник служб доставки
         * @throws {RequiredError}
         */
        getDeliveryServices(options?: RequestOptions = {}): Promise<GetDeliveryServicesResponse> {
            const localVarFetchArgs = DeliveryServicesApiFetchParamCreator(configuration).getDeliveryServices(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ExpressApi - fetch parameter creator
 * @export
 */
export const ExpressApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling addHiddenOffers.');
            }
            // verify required parameter 'addHiddenOffersRequest' is not null or undefined
            if (addHiddenOffersRequest === null || addHiddenOffersRequest === undefined) {
                throw new RequiredError('addHiddenOffersRequest','Required parameter addHiddenOffersRequest was null or undefined when calling addHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addHiddenOffersRequest != null ? addHiddenOffersRequest : {}) : (((addHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling addOffersToArchive.');
            }
            // verify required parameter 'addOffersToArchiveRequest' is not null or undefined
            if (addOffersToArchiveRequest === null || addOffersToArchiveRequest === undefined) {
                throw new RequiredError('addOffersToArchiveRequest','Required parameter addOffersToArchiveRequest was null or undefined when calling addOffersToArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/archive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addOffersToArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addOffersToArchiveRequest != null ? addOffersToArchiveRequest : {}) : (((addOffersToArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'calculateTariffsRequest' is not null or undefined
            if (calculateTariffsRequest === null || calculateTariffsRequest === undefined) {
                throw new RequiredError('calculateTariffsRequest','Required parameter calculateTariffsRequest was null or undefined when calling calculateTariffs.');
            }
            const localVarPath = `/tariffs/calculate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof calculateTariffsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(calculateTariffsRequest != null ? calculateTariffsRequest : {}) : (((calculateTariffsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling confirmBusinessPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine/confirm`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling confirmCampaignPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmCampaignPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine/confirm`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling createChat.');
            }
            // verify required parameter 'createChatRequest' is not null or undefined
            if (createChatRequest === null || createChatRequest === undefined) {
                throw new RequiredError('createChatRequest','Required parameter createChatRequest was null or undefined when calling createChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/new`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createChatRequest != null ? createChatRequest : {}) : (((createChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteCampaignOffers.');
            }
            // verify required parameter 'deleteCampaignOffersRequest' is not null or undefined
            if (deleteCampaignOffersRequest === null || deleteCampaignOffersRequest === undefined) {
                throw new RequiredError('deleteCampaignOffersRequest','Required parameter deleteCampaignOffersRequest was null or undefined when calling deleteCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteCampaignOffersRequest != null ? deleteCampaignOffersRequest : {}) : (((deleteCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            // verify required parameter 'deleteGoodsFeedbackCommentRequest' is not null or undefined
            if (deleteGoodsFeedbackCommentRequest === null || deleteGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('deleteGoodsFeedbackCommentRequest','Required parameter deleteGoodsFeedbackCommentRequest was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteGoodsFeedbackCommentRequest != null ? deleteGoodsFeedbackCommentRequest : {}) : (((deleteGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteHiddenOffers.');
            }
            // verify required parameter 'deleteHiddenOffersRequest' is not null or undefined
            if (deleteHiddenOffersRequest === null || deleteHiddenOffersRequest === undefined) {
                throw new RequiredError('deleteHiddenOffersRequest','Required parameter deleteHiddenOffersRequest was null or undefined when calling deleteHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteHiddenOffersRequest != null ? deleteHiddenOffersRequest : {}) : (((deleteHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffers.');
            }
            // verify required parameter 'deleteOffersRequest' is not null or undefined
            if (deleteOffersRequest === null || deleteOffersRequest === undefined) {
                throw new RequiredError('deleteOffersRequest','Required parameter deleteOffersRequest was null or undefined when calling deleteOffers.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersRequest != null ? deleteOffersRequest : {}) : (((deleteOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffersFromArchive.');
            }
            // verify required parameter 'deleteOffersFromArchiveRequest' is not null or undefined
            if (deleteOffersFromArchiveRequest === null || deleteOffersFromArchiveRequest === undefined) {
                throw new RequiredError('deleteOffersFromArchiveRequest','Required parameter deleteOffersFromArchiveRequest was null or undefined when calling deleteOffersFromArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/unarchive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersFromArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersFromArchiveRequest != null ? deleteOffersFromArchiveRequest : {}) : (((deleteOffersFromArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deletePromoOffers.');
            }
            // verify required parameter 'deletePromoOffersRequest' is not null or undefined
            if (deletePromoOffersRequest === null || deletePromoOffersRequest === undefined) {
                throw new RequiredError('deletePromoOffersRequest','Required parameter deletePromoOffersRequest was null or undefined when calling deletePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deletePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deletePromoOffersRequest != null ? deletePromoOffersRequest : {}) : (((deletePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateBoostConsolidatedRequest' is not null or undefined
            if (generateBoostConsolidatedRequest === null || generateBoostConsolidatedRequest === undefined) {
                throw new RequiredError('generateBoostConsolidatedRequest','Required parameter generateBoostConsolidatedRequest was null or undefined when calling generateBoostConsolidatedReport.');
            }
            const localVarPath = `/reports/boost-consolidated/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateBoostConsolidatedRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateBoostConsolidatedRequest != null ? generateBoostConsolidatedRequest : {}) : (((generateBoostConsolidatedRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateCompetitorsPositionReportRequest' is not null or undefined
            if (generateCompetitorsPositionReportRequest === null || generateCompetitorsPositionReportRequest === undefined) {
                throw new RequiredError('generateCompetitorsPositionReportRequest','Required parameter generateCompetitorsPositionReportRequest was null or undefined when calling generateCompetitorsPositionReport.');
            }
            const localVarPath = `/reports/competitors-position/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateCompetitorsPositionReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateCompetitorsPositionReportRequest != null ? generateCompetitorsPositionReportRequest : {}) : (((generateCompetitorsPositionReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsFeedbackRequest' is not null or undefined
            if (generateGoodsFeedbackRequest === null || generateGoodsFeedbackRequest === undefined) {
                throw new RequiredError('generateGoodsFeedbackRequest','Required parameter generateGoodsFeedbackRequest was null or undefined when calling generateGoodsFeedbackReport.');
            }
            const localVarPath = `/reports/goods-feedback/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsFeedbackRequest != null ? generateGoodsFeedbackRequest : {}) : (((generateGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по реализации** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#sales-report)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по реализации
         * @throws {RequiredError}
         */
        generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsRealizationReportRequest' is not null or undefined
            if (generateGoodsRealizationReportRequest === null || generateGoodsRealizationReportRequest === undefined) {
                throw new RequiredError('generateGoodsRealizationReportRequest','Required parameter generateGoodsRealizationReportRequest was null or undefined when calling generateGoodsRealizationReport.');
            }
            const localVarPath = `/reports/goods-realization/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsRealizationReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsRealizationReportRequest != null ? generateGoodsRealizationReportRequest : {}) : (((generateGoodsRealizationReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию PDF-файла с ярлыками для переданных заказов. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  Узнать статус генерации и получить ссылку на готовый файл можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в нескольких заказах
         * @throws {RequiredError}
         */
        generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateMassOrderLabelsRequest' is not null or undefined
            if (generateMassOrderLabelsRequest === null || generateMassOrderLabelsRequest === undefined) {
                throw new RequiredError('generateMassOrderLabelsRequest','Required parameter generateMassOrderLabelsRequest was null or undefined when calling generateMassOrderLabelsReport.');
            }
            const localVarPath = `/reports/documents/labels/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateMassOrderLabelsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateMassOrderLabelsRequest != null ? generateMassOrderLabelsRequest : {}) : (((generateMassOrderLabelsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Формирует ярлык‑наклейку для коробки в заказе и возвращает ярлык в PDF‑файле.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовый ярлык‑наклейка для коробки в заказе
         * @throws {RequiredError}
         */
        generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'boxId' is not null or undefined
            if (boxId === null || boxId === undefined) {
                throw new RequiredError('boxId','Required parameter boxId was null or undefined when calling generateOrderLabel.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"boxId"}}`, encodeURIComponent(String(boxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает PDF-файл с ярлыками, которые нужно наклеить на коробки перед отгрузкой. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  На вход нужно передать идентификатор заказа и один необязательный параметр, который управляет версткой PDF-файла.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в одном заказе
         * @throws {RequiredError}
         */
        generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling generateOrderLabels.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling generateOrderLabels.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/labels`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generatePricesReportRequest' is not null or undefined
            if (generatePricesReportRequest === null || generatePricesReportRequest === undefined) {
                throw new RequiredError('generatePricesReportRequest','Required parameter generatePricesReportRequest was null or undefined when calling generatePricesReport.');
            }
            const localVarPath = `/reports/prices/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generatePricesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generatePricesReportRequest != null ? generatePricesReportRequest : {}) : (((generatePricesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShelfsStatisticsRequest' is not null or undefined
            if (generateShelfsStatisticsRequest === null || generateShelfsStatisticsRequest === undefined) {
                throw new RequiredError('generateShelfsStatisticsRequest','Required parameter generateShelfsStatisticsRequest was null or undefined when calling generateShelfsStatisticsReport.');
            }
            const localVarPath = `/reports/shelf-statistics/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShelfsStatisticsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShelfsStatisticsRequest != null ? generateShelfsStatisticsRequest : {}) : (((generateShelfsStatisticsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShowsSalesReportRequest' is not null or undefined
            if (generateShowsSalesReportRequest === null || generateShowsSalesReportRequest === undefined) {
                throw new RequiredError('generateShowsSalesReportRequest','Required parameter generateShowsSalesReportRequest was null or undefined when calling generateShowsSalesReport.');
            }
            const localVarPath = `/reports/shows-sales/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShowsSalesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShowsSalesReportRequest != null ? generateShowsSalesReportRequest : {}) : (((generateShowsSalesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateStocksOnWarehousesReportRequest' is not null or undefined
            if (generateStocksOnWarehousesReportRequest === null || generateStocksOnWarehousesReportRequest === undefined) {
                throw new RequiredError('generateStocksOnWarehousesReportRequest','Required parameter generateStocksOnWarehousesReportRequest was null or undefined when calling generateStocksOnWarehousesReport.');
            }
            const localVarPath = `/reports/stocks-on-warehouses/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateStocksOnWarehousesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateStocksOnWarehousesReportRequest != null ? generateStocksOnWarehousesReportRequest : {}) : (((generateStocksOnWarehousesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedMarketplaceServicesReportRequest' is not null or undefined
            if (generateUnitedMarketplaceServicesReportRequest === null || generateUnitedMarketplaceServicesReportRequest === undefined) {
                throw new RequiredError('generateUnitedMarketplaceServicesReportRequest','Required parameter generateUnitedMarketplaceServicesReportRequest was null or undefined when calling generateUnitedMarketplaceServicesReport.');
            }
            const localVarPath = `/reports/united-marketplace-services/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedMarketplaceServicesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedMarketplaceServicesReportRequest != null ? generateUnitedMarketplaceServicesReportRequest : {}) : (((generateUnitedMarketplaceServicesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedNettingReportRequest' is not null or undefined
            if (generateUnitedNettingReportRequest === null || generateUnitedNettingReportRequest === undefined) {
                throw new RequiredError('generateUnitedNettingReportRequest','Required parameter generateUnitedNettingReportRequest was null or undefined when calling generateUnitedNettingReport.');
            }
            const localVarPath = `/reports/united-netting/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedNettingReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedNettingReportRequest != null ? generateUnitedNettingReportRequest : {}) : (((generateUnitedNettingReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedOrdersRequest' is not null or undefined
            if (generateUnitedOrdersRequest === null || generateUnitedOrdersRequest === undefined) {
                throw new RequiredError('generateUnitedOrdersRequest','Required parameter generateUnitedOrdersRequest was null or undefined when calling generateUnitedOrdersReport.');
            }
            const localVarPath = `/reports/united-orders/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedOrdersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedOrdersRequest != null ? generateUnitedOrdersRequest : {}) : (((generateUnitedOrdersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getAllOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/all`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (chunk !== undefined) {
                localVarQueryParameter['chunk'] = ((chunk:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsInfoForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids/info`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsInfoRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsInfoRequest != null ? getBidsInfoRequest : {}) : (((getBidsInfoRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsRecommendations.');
            }
            // verify required parameter 'getBidsRecommendationsRequest' is not null or undefined
            if (getBidsRecommendationsRequest === null || getBidsRecommendationsRequest === undefined) {
                throw new RequiredError('getBidsRecommendationsRequest','Required parameter getBidsRecommendationsRequest was null or undefined when calling getBidsRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/bids/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsRecommendationsRequest != null ? getBidsRecommendationsRequest : {}) : (((getBidsRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getBusinessQuarantineOffers.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessSettings.');
            }
            const localVarPath = `/businesses/{businessId}/settings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignLogins.');
            }
            const localVarPath = `/campaigns/{campaignId}/logins`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignOffers.');
            }
            // verify required parameter 'getCampaignOffersRequest' is not null or undefined
            if (getCampaignOffersRequest === null || getCampaignOffersRequest === undefined) {
                throw new RequiredError('getCampaignOffersRequest','Required parameter getCampaignOffersRequest was null or undefined when calling getCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCampaignOffersRequest != null ? getCampaignOffersRequest : {}) : (((getCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getCampaignQuarantineOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignRegion.');
            }
            const localVarPath = `/campaigns/{campaignId}/region`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignSettings.');
            }
            const localVarPath = `/campaigns/{campaignId}/settings`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/campaigns`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling getCampaignsByLogin.');
            }
            const localVarPath = `/campaigns/by_login/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'getCategoriesMaxSaleQuantumRequest' is not null or undefined
            if (getCategoriesMaxSaleQuantumRequest === null || getCategoriesMaxSaleQuantumRequest === undefined) {
                throw new RequiredError('getCategoriesMaxSaleQuantumRequest','Required parameter getCategoriesMaxSaleQuantumRequest was null or undefined when calling getCategoriesMaxSaleQuantum.');
            }
            const localVarPath = `/categories/max-sale-quantum`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesMaxSaleQuantumRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesMaxSaleQuantumRequest != null ? getCategoriesMaxSaleQuantumRequest : {}) : (((getCategoriesMaxSaleQuantumRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options: RequestOptions): FetchArgs {
            const localVarPath = `/categories/tree`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesRequest != null ? getCategoriesRequest : {}) : (((getCategoriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getCategoryContentParameters.');
            }
            const localVarPath = `/category/{categoryId}/parameters`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'getChatHistoryRequest' is not null or undefined
            if (getChatHistoryRequest === null || getChatHistoryRequest === undefined) {
                throw new RequiredError('getChatHistoryRequest','Required parameter getChatHistoryRequest was null or undefined when calling getChatHistory.');
            }
            const localVarPath = `/businesses/{businessId}/chats/history`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatHistoryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatHistoryRequest != null ? getChatHistoryRequest : {}) : (((getChatHistoryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChats.');
            }
            // verify required parameter 'getChatsRequest' is not null or undefined
            if (getChatsRequest === null || getChatsRequest === undefined) {
                throw new RequiredError('getChatsRequest','Required parameter getChatsRequest was null or undefined when calling getChats.');
            }
            const localVarPath = `/businesses/{businessId}/chats`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatsRequest != null ? getChatsRequest : {}) : (((getChatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает справочник служб доставки: идентификаторы и наименования. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Справочник служб доставки
         * @throws {RequiredError}
         */
        getDeliveryServices(options: RequestOptions): FetchArgs {
            const localVarPath = `/delivery/services`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedIndexLogs.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeedIndexLogs.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/index-logs`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (publishedTimeFrom !== undefined) {
                localVarQueryParameter['published_time_from'] = ((publishedTimeFrom:any):Date).toISOString();
            }

            if (publishedTimeTo !== undefined) {
                localVarQueryParameter['published_time_to'] = ((publishedTimeTo:any):Date).toISOString();
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = ((status:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedbackAndCommentUpdates.');
            }
            const localVarPath = `/campaigns/{campaignId}/feedback/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeeds.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbackComments.');
            }
            // verify required parameter 'getGoodsFeedbackCommentsRequest' is not null or undefined
            if (getGoodsFeedbackCommentsRequest === null || getGoodsFeedbackCommentsRequest === undefined) {
                throw new RequiredError('getGoodsFeedbackCommentsRequest','Required parameter getGoodsFeedbackCommentsRequest was null or undefined when calling getGoodsFeedbackComments.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackCommentsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackCommentsRequest != null ? getGoodsFeedbackCommentsRequest : {}) : (((getGoodsFeedbackCommentsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbacks.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackRequest != null ? getGoodsFeedbackRequest : {}) : (((getGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getGoodsStats.');
            }
            // verify required parameter 'getGoodsStatsRequest' is not null or undefined
            if (getGoodsStatsRequest === null || getGoodsStatsRequest === undefined) {
                throw new RequiredError('getGoodsStatsRequest','Required parameter getGoodsStatsRequest was null or undefined when calling getGoodsStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/skus`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsStatsRequest != null ? getGoodsStatsRequest : {}) : (((getGoodsStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferCardsContentStatus.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferCardsContentStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferCardsContentStatusRequest != null ? getOfferCardsContentStatusRequest : {}) : (((getOfferCardsContentStatusRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (shopSku) {
                localVarQueryParameter['shop_sku'] = shopSku.join(COLLECTION_FORMATS["csv"]);
            }

            if (mappingKind !== undefined) {
                localVarQueryParameter['mapping_kind'] = ((mappingKind:any):string);
            }

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS["csv"]);
            }

            if (availability) {
                localVarQueryParameter['availability'] = availability.join(COLLECTION_FORMATS["csv"]);
            }

            if (categoryId) {
                localVarQueryParameter['category_id'] = categoryId.join(COLLECTION_FORMATS["csv"]);
            }

            if (vendor) {
                localVarQueryParameter['vendor'] = vendor.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferMappingsRequest != null ? getOfferMappingsRequest : {}) : (((getOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferRecommendations.');
            }
            // verify required parameter 'getOfferRecommendationsRequest' is not null or undefined
            if (getOfferRecommendationsRequest === null || getOfferRecommendationsRequest === undefined) {
                throw new RequiredError('getOfferRecommendationsRequest','Required parameter getOfferRecommendationsRequest was null or undefined when calling getOfferRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/offers/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferRecommendationsRequest != null ? getOfferRecommendationsRequest : {}) : (((getOfferRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = ((query:any):string);
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (shopCategoryId !== undefined) {
                localVarQueryParameter['shopCategoryId'] = ((shopCategoryId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (matched !== undefined) {
                localVarQueryParameter['matched'] = ((matched:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrder.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/business-buyer`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/documents`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию на ярлыках, которые клеятся на коробки в заказе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Данные для самостоятельного изготовления ярлыков
         * @throws {RequiredError}
         */
        getOrderLabelsData(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderLabelsData.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderLabelsData.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/labels/data`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrders.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status).join(COLLECTION_FORMATS["csv"]);
            }

            if (substatus) {
                localVarQueryParameter['substatus'] = Array.from(substatus).join(COLLECTION_FORMATS["csv"]);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateFrom !== undefined) {
                localVarQueryParameter['supplierShipmentDateFrom'] = ((supplierShipmentDateFrom:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateTo !== undefined) {
                localVarQueryParameter['supplierShipmentDateTo'] = ((supplierShipmentDateTo:any):Date).toISOString().slice(0, 10);
            }

            if (updatedAtFrom !== undefined) {
                localVarQueryParameter['updatedAtFrom'] = ((updatedAtFrom:any):Date).toISOString();
            }

            if (updatedAtTo !== undefined) {
                localVarQueryParameter['updatedAtTo'] = ((updatedAtTo:any):Date).toISOString();
            }

            if (dispatchType !== undefined) {
                localVarQueryParameter['dispatchType'] = ((dispatchType:any):string);
            }

            if (fake !== undefined) {
                localVarQueryParameter['fake'] = ((fake:any):string);
            }

            if (hasCis !== undefined) {
                localVarQueryParameter['hasCis'] = ((hasCis:any):string);
            }

            if (onlyWaitingForCancellationApprove !== undefined) {
                localVarQueryParameter['onlyWaitingForCancellationApprove'] = ((onlyWaitingForCancellationApprove:any):string);
            }

            if (onlyEstimatedDelivery !== undefined) {
                localVarQueryParameter['onlyEstimatedDelivery'] = ((onlyEstimatedDelivery:any):string);
            }

            if (buyerType !== undefined) {
                localVarQueryParameter['buyerType'] = ((buyerType:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrdersStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOrdersStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOrdersStatsRequest != null ? getOrdersStatsRequest : {}) : (((getOrdersStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = ((archived:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPricesByOfferIds.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPricesByOfferIdsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPricesByOfferIdsRequest != null ? getPricesByOfferIdsRequest : {}) : (((getPricesByOfferIdsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromoOffers.');
            }
            // verify required parameter 'getPromoOffersRequest' is not null or undefined
            if (getPromoOffersRequest === null || getPromoOffersRequest === undefined) {
                throw new RequiredError('getPromoOffersRequest','Required parameter getPromoOffersRequest was null or undefined when calling getPromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromoOffersRequest != null ? getPromoOffersRequest : {}) : (((getPromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromos.');
            }
            const localVarPath = `/businesses/{businessId}/promos`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromosRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromosRequest != null ? getPromosRequest : {}) : (((getPromosRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список заказов, которые повлияли на индекс качества магазина. Чтобы узнать значение индекса качества, выполните запрос [POST businesses/{businessId}/ratings/quality](../../reference/ratings/getQualityRatings.md).  |**⚙️ Лимит:** 100000 запросов в час| |-| 
         * @summary Заказы, которые повлияли на индекс качества
         * @throws {RequiredError}
         */
        getQualityRatingDetails(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getQualityRatingDetails.');
            }
            const localVarPath = `/campaigns/{campaignId}/ratings/quality/details`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getQualityRatings.');
            }
            // verify required parameter 'getQualityRatingRequest' is not null or undefined
            if (getQualityRatingRequest === null || getQualityRatingRequest === undefined) {
                throw new RequiredError('getQualityRatingRequest','Required parameter getQualityRatingRequest was null or undefined when calling getQualityRatings.');
            }
            const localVarPath = `/businesses/{businessId}/ratings/quality`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQualityRatingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQualityRatingRequest != null ? getQualityRatingRequest : {}) : (((getQualityRatingRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'reportId' is not null or undefined
            if (reportId === null || reportId === undefined) {
                throw new RequiredError('reportId','Required parameter reportId was null or undefined when calling getReportInfo.');
            }
            const localVarPath = `/reports/info/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturn.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Загружает заявление покупателя на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение заявления на возврат
         * @throws {RequiredError}
         */
        getReturnApplication(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturnApplication.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturnApplication.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturnApplication.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'imageHash' is not null or undefined
            if (imageHash === null || imageHash === undefined) {
                throw new RequiredError('imageHash','Required parameter imageHash was null or undefined when calling getReturnPhoto.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageHash"}}`, encodeURIComponent(String(imageHash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturns.');
            }
            const localVarPath = `/campaigns/{campaignId}/returns`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS["csv"]);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = ((type:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (fromDate2 !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate2:any):Date).toISOString().slice(0, 10);
            }

            if (toDate2 !== undefined) {
                localVarQueryParameter['to_date'] = ((toDate2:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getStocks.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/stocks`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getWarehouseStocksRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getWarehouseStocksRequest != null ? getWarehouseStocksRequest : {}) : (((getWarehouseStocksRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            // verify required parameter 'getSuggestedOfferMappingEntriesRequest' is not null or undefined
            if (getSuggestedOfferMappingEntriesRequest === null || getSuggestedOfferMappingEntriesRequest === undefined) {
                throw new RequiredError('getSuggestedOfferMappingEntriesRequest','Required parameter getSuggestedOfferMappingEntriesRequest was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingEntriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingEntriesRequest != null ? getSuggestedOfferMappingEntriesRequest : {}) : (((getSuggestedOfferMappingEntriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getSuggestedOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/suggestions`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingsRequest != null ? getSuggestedOfferMappingsRequest : {}) : (((getSuggestedOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedPrices.');
            }
            // verify required parameter 'suggestPricesRequest' is not null or undefined
            if (suggestPricesRequest === null || suggestPricesRequest === undefined) {
                throw new RequiredError('suggestPricesRequest','Required parameter suggestPricesRequest was null or undefined when calling getSuggestedPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof suggestPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(suggestPricesRequest != null ? suggestPricesRequest : {}) : (((suggestPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список складов и, если склады объединены, список групп складов. [Что такое группы складов и зачем они нужны](https://yandex.ru/support/marketplace/assortment/operations/stocks.html#unified-stocks)  Среди прочего запрос позволяет определить идентификатор, который нужно использовать при передаче остатков для группы складов.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Список складов и групп складов
         * @throws {RequiredError}
         */
        getWarehouses(businessId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getWarehouses.');
            }
            const localVarPath = `/businesses/{businessId}/warehouses`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Передает Маркету коды маркировки для единиц товара в указанном заказе.  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  {% note warning %}  Прежде чем работать с этим методом, обязательно прочтите [статью о работе с маркируемыми товарами](https://yandex.ru/support/marketplace/orders/cz.html).  {% endnote %}  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кодов маркировки единиц товара
         * @throws {RequiredError}
         */
        provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling provideOrderItemIdentifiers.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling provideOrderItemIdentifiers.');
            }
            // verify required parameter 'provideOrderItemIdentifiersRequest' is not null or undefined
            if (provideOrderItemIdentifiersRequest === null || provideOrderItemIdentifiersRequest === undefined) {
                throw new RequiredError('provideOrderItemIdentifiersRequest','Required parameter provideOrderItemIdentifiersRequest was null or undefined when calling provideOrderItemIdentifiers.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/identifiers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof provideOrderItemIdentifiersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(provideOrderItemIdentifiersRequest != null ? provideOrderItemIdentifiersRequest : {}) : (((provideOrderItemIdentifiersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling putBidsForBusiness.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling putBidsForCampaign.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}/bids`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling refreshFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling refreshFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/refresh`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionChildren.');
            }
            const localVarPath = `/regions/{regionId}/children`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionsById.');
            }
            const localVarPath = `/regions/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling searchRegionsByName.');
            }
            const localVarPath = `/regions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling sendFileToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/file/send`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'sendMessageToChatRequest' is not null or undefined
            if (sendMessageToChatRequest === null || sendMessageToChatRequest === undefined) {
                throw new RequiredError('sendMessageToChatRequest','Required parameter sendMessageToChatRequest was null or undefined when calling sendMessageToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/message`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof sendMessageToChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sendMessageToChatRequest != null ? sendMessageToChatRequest : {}) : (((sendMessageToChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'setFeedParamsRequest' is not null or undefined
            if (setFeedParamsRequest === null || setFeedParamsRequest === undefined) {
                throw new RequiredError('setFeedParamsRequest','Required parameter setFeedParamsRequest was null or undefined when calling setFeedParams.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/params`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setFeedParamsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setFeedParamsRequest != null ? setFeedParamsRequest : {}) : (((setFeedParamsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note tip \"Подходит и для DBS\" %}  Запрос предназначен для работы с FBS-заказами, но вы можете использовать его для обработки DBS-заказов, если это удобно.  {% endnote %}  Позволяет выполнить три операции:  * передать Маркету информацию о распределении товаров по коробкам; * передать Маркету коды маркировки для товаров; * удалить товар из заказа, если его не оказалось на складе.  Если нужно что-то поправить в переданных данных, просто повторите запрос — это можно делать сколько угодно раз до перевода заказа в статус **Готов к отгрузке**. ⚠️ Если вы меняете раскладку уже после печати и расклейки ярлыков, не забудье перепечатать их и наклеить заново.  ## Как передать информацию о распределении товаров  В этом запросе вам нужно передать Маркету список коробок и указать, какие именно товары лежат в каждой из них. Коробки могут быть двух типов:  * **Содержащие товары целиком.** Такая коробка может содержать сколько угодно единиц любых товаров.  * **Содержащие часть товара.** Такие коробки содержат по одной части одного товара. Например, одна содержит внешний блок кондиционера, а другая — внутренний блок.  ⚠️ Одна коробка не может содержать и товары целиком, и части товаров.  ## Как передавать коды маркировки  Если в заказе есть товары, подлежащие маркировке, в запросе нужно передать соответствующие уникальные коды. [Что такое маркировка?](https://yandex.ru/support/marketplace/orders/cz.html)  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  Если товар едет в нескольких коробках, код маркировки нужно передать для каждой из них.  ## Как удалить товар из заказа  Чтобы удалить товар из заказа:  1. Добавьте в запрос `allowRemove: true`. 2. Передайте распределение по коробкам без товара, который нужно удалить.  {% note warning \"Удаление нельзя отменить\" %}  Эта операция необратима: покупатель сразу получит уведомление, а состав заказа изменится.  {% endnote %}  Чтобы удалить позицию целиком, не передавайте соответствующий `OrderBoxLayoutItemDTO`. Чтобы уменьшить количество товара, передайте уменьшенное значение в поле `fullCount`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если вы не можете отгрузить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  ## Примеры  {% cut \"Товар умещается в коробку\" %}  Вот как будет выглядеть запрос, если в одной коробке едут:    * три единицы одного товара, требующего маркировки;   * одна единица другого товара, не требущего маркировки.    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"fullCount\": 3,                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           },                           {                               \"cis\": \"010304109478gftJ14545762!\\u001dhGt264\"                           },                           {                               \"cis\": \"010304109478fRs28323ks23!\\u001dhet201\"                           }                       ]                   },                   {                       \"id\": 654321,                       \"fullCount\": 1                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Товар едет в разных коробках\" %}  Вот как будет выглядеть запрос, если товар едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Одинаковые товары, где каждый едет в нескольких коробках\" %}  Вот как будет выглядеть запрос, если каждый из двух одинаковых товаров едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Подготовка заказа
         * @throws {RequiredError}
         */
        setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderBoxLayout.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderBoxLayout.');
            }
            // verify required parameter 'setOrderBoxLayoutRequest' is not null or undefined
            if (setOrderBoxLayoutRequest === null || setOrderBoxLayoutRequest === undefined) {
                throw new RequiredError('setOrderBoxLayoutRequest','Required parameter setOrderBoxLayoutRequest was null or undefined when calling setOrderBoxLayout.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/boxes`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderBoxLayoutRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderBoxLayoutRequest != null ? setOrderBoxLayoutRequest : {}) : (((setOrderBoxLayoutRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Отгружаемый Маркету заказ может не влезть в одну коробку или упаковку — в этом случае получается, что он занимает несколько грузовых мест.  Количество грузовых мест нужно обязательно передавать Маркету, если оно не равно 1. Это делается перед переводом его в статус **Готов к отгрузке**. Подробно о том, что в какой момент нужно передавать, рассказано в [пошаговой инструкции](../../step-by-step/fbs.md).  Метод устроен немного нестандартно: количество задается длиной массива пустых объектов.  Раньше метод требовал передачи большего количества данных. Запросы, оформленные по старому образцу, работают, но лучше делать по-новому.  {% cut \"Как было раньше\" %}  Структура тела PUT-запроса:  ``` {   \"boxes\":   [     {       \"fulfilmentId\": \"{string}\",       \"weight\": {int64},       \"width\": {int64},       \"height\": {int64},       \"depth\": {int64},       \"items\":       [         {           \"id\": {int64},           \"count\": {int32}         },         ...       ]     },     ...   ] } ``` | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `boxes`       |           | Список грузовых мест.       |  **Параметры, вложенные в `boxes`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `fulfilmentId`       |  String   | Идентификатор грузового места в информационной системе магазина. Сформируйте идентификатор по шаблону: `номер заказа на Маркете-номер грузового места`. Например, `7206821‑1, 7206821‑2` и т. д. | | `weight`       | Int64        | Масса брутто грузового места (суммарная масса упаковки и содержимого) в граммах. | | `width`       | Int64   | Ширина грузового места в сантиметрах.       | | `height`       | Int64   | Высота грузового места в сантиметрах.       | | `depth`       | Int64   | Глубина грузового места в сантиметрах.        | | `items`       | Int64   | Список товаров в грузовом месте.       |  **Параметры, вложенные в `items`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `id`       | Int64     | Идентификатор товара в рамках заказа.   | | `count`    | Int32     | Количество единиц товара в грузовом месте.       |  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача количества грузовых мест в заказе
         * @throws {RequiredError}
         */
        setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'setOrderShipmentBoxesRequest' is not null or undefined
            if (setOrderShipmentBoxesRequest === null || setOrderShipmentBoxesRequest === undefined) {
                throw new RequiredError('setOrderShipmentBoxesRequest','Required parameter setOrderShipmentBoxesRequest was null or undefined when calling setOrderShipmentBoxes.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderShipmentBoxesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderShipmentBoxesRequest != null ? setOrderShipmentBoxesRequest : {}) : (((setOrderShipmentBoxesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            // verify required parameter 'skipGoodsFeedbackReactionRequest' is not null or undefined
            if (skipGoodsFeedbackReactionRequest === null || skipGoodsFeedbackReactionRequest === undefined) {
                throw new RequiredError('skipGoodsFeedbackReactionRequest','Required parameter skipGoodsFeedbackReactionRequest was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/skip-reaction`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof skipGoodsFeedbackReactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(skipGoodsFeedbackReactionRequest != null ? skipGoodsFeedbackReactionRequest : {}) : (((skipGoodsFeedbackReactionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateBusinessPrices.');
            }
            // verify required parameter 'updateBusinessPricesRequest' is not null or undefined
            if (updateBusinessPricesRequest === null || updateBusinessPricesRequest === undefined) {
                throw new RequiredError('updateBusinessPricesRequest','Required parameter updateBusinessPricesRequest was null or undefined when calling updateBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/offer-prices/updates`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateBusinessPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateBusinessPricesRequest != null ? updateBusinessPricesRequest : {}) : (((updateBusinessPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateCampaignOffers.');
            }
            // verify required parameter 'updateCampaignOffersRequest' is not null or undefined
            if (updateCampaignOffersRequest === null || updateCampaignOffersRequest === undefined) {
                throw new RequiredError('updateCampaignOffersRequest','Required parameter updateCampaignOffersRequest was null or undefined when calling updateCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/update`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateCampaignOffersRequest != null ? updateCampaignOffersRequest : {}) : (((updateCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateGoodsFeedbackComment.');
            }
            // verify required parameter 'updateGoodsFeedbackCommentRequest' is not null or undefined
            if (updateGoodsFeedbackCommentRequest === null || updateGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('updateGoodsFeedbackCommentRequest','Required parameter updateGoodsFeedbackCommentRequest was null or undefined when calling updateGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateGoodsFeedbackCommentRequest != null ? updateGoodsFeedbackCommentRequest : {}) : (((updateGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferContent.');
            }
            // verify required parameter 'updateOfferContentRequest' is not null or undefined
            if (updateOfferContentRequest === null || updateOfferContentRequest === undefined) {
                throw new RequiredError('updateOfferContentRequest','Required parameter updateOfferContentRequest was null or undefined when calling updateOfferContent.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferContentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferContentRequest != null ? updateOfferContentRequest : {}) : (((updateOfferContentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOfferMappingEntries.');
            }
            // verify required parameter 'updateOfferMappingEntryRequest' is not null or undefined
            if (updateOfferMappingEntryRequest === null || updateOfferMappingEntryRequest === undefined) {
                throw new RequiredError('updateOfferMappingEntryRequest','Required parameter updateOfferMappingEntryRequest was null or undefined when calling updateOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingEntryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingEntryRequest != null ? updateOfferMappingEntryRequest : {}) : (((updateOfferMappingEntryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferMappings.');
            }
            // verify required parameter 'updateOfferMappingsRequest' is not null or undefined
            if (updateOfferMappingsRequest === null || updateOfferMappingsRequest === undefined) {
                throw new RequiredError('updateOfferMappingsRequest','Required parameter updateOfferMappingsRequest was null or undefined when calling updateOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingsRequest != null ? updateOfferMappingsRequest : {}) : (((updateOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Изменяет состав заказа, если позволяет выбранная служба доставки, в случаях:  * покупатель уменьшил количество товара; * магазин не может поставить все товары в заказе.  Для этого заказ должен находится в статусе `\"status\": \"PROCESSING\"` этапа обработки `\"substatus\": \"STARTED\"`. После передачи статуса `\"substatus\": \"READY_TO_SHIP\"` изменить состав невозможно.  Если одинаковых товаров несколько, для уменьшения количества передайте обновленное значение в атрибуте `count` параметра `item`.  Чтобы полностью удалить товар из заказа:  * передайте значение `0`; или * не передавайте параметр `item`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если необходимо удалить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  **Возврат денег покупателю**  Если покупатель оплатил товар при оформлении, Маркет вернет ему деньги за удаленные из заказа товары в течение двух дней:  * при оплате банковской картой — с момента, когда магазин переведет заказ в статус `SHIPPED`;  * при оплате через Apple Pay или Google Pay — с момента, когда магазин удалит товар из заказа.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Удаление товара из заказа или уменьшение числа единиц
         * @throws {RequiredError}
         */
        updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderItems.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderItems.');
            }
            // verify required parameter 'updateOrderItemRequest' is not null or undefined
            if (updateOrderItemRequest === null || updateOrderItemRequest === undefined) {
                throw new RequiredError('updateOrderItemRequest','Required parameter updateOrderItemRequest was null or undefined when calling updateOrderItems.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/items`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderItemRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderItemRequest != null ? updateOrderItemRequest : {}) : (((updateOrderItemRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет статус заказа. Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статуса одного заказа
         * @throws {RequiredError}
         */
        updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStatus.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderStatus.');
            }
            // verify required parameter 'updateOrderStatusRequest' is not null or undefined
            if (updateOrderStatusRequest === null || updateOrderStatusRequest === undefined) {
                throw new RequiredError('updateOrderStatusRequest','Required parameter updateOrderStatusRequest was null or undefined when calling updateOrderStatus.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/status`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStatusRequest != null ? updateOrderStatusRequest : {}) : (((updateOrderStatusRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет статусы нескольких заказов.  Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"`и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  Максимальное количество заказов, у которых можно изменить статус в одном запросе, — 30.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статусов нескольких заказов
         * @throws {RequiredError}
         */
        updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStatuses.');
            }
            // verify required parameter 'updateOrderStatusesRequest' is not null or undefined
            if (updateOrderStatusesRequest === null || updateOrderStatusesRequest === undefined) {
                throw new RequiredError('updateOrderStatusesRequest','Required parameter updateOrderStatusesRequest was null or undefined when calling updateOrderStatuses.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/status-update`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStatusesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStatusesRequest != null ? updateOrderStatusesRequest : {}) : (((updateOrderStatusesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updatePrices.');
            }
            // verify required parameter 'updatePricesRequest' is not null or undefined
            if (updatePricesRequest === null || updatePricesRequest === undefined) {
                throw new RequiredError('updatePricesRequest','Required parameter updatePricesRequest was null or undefined when calling updatePrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePricesRequest != null ? updatePricesRequest : {}) : (((updatePricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updatePromoOffers.');
            }
            // verify required parameter 'updatePromoOffersRequest' is not null or undefined
            if (updatePromoOffersRequest === null || updatePromoOffersRequest === undefined) {
                throw new RequiredError('updatePromoOffersRequest','Required parameter updatePromoOffersRequest was null or undefined when calling updatePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePromoOffersRequest != null ? updatePromoOffersRequest : {}) : (((updatePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает данные об остатках товаров на витрине.  Обязательно указывайте SKU **в точности** так, как он указан в каталоге. Например, _557722_ и _0557722_ — это два разных SKU.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-| 
         * @summary Передача информации об остатках
         * @throws {RequiredError}
         */
        updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateStocks.');
            }
            // verify required parameter 'updateStocksRequest' is not null or undefined
            if (updateStocksRequest === null || updateStocksRequest === undefined) {
                throw new RequiredError('updateStocksRequest','Required parameter updateStocksRequest was null or undefined when calling updateStocks.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/stocks`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateStocksRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateStocksRequest != null ? updateStocksRequest : {}) : (((updateStocksRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет Маркету код подтверждения для его проверки.  Код подтверждает передачу заказа или невыкупа:  * курьеру — курьер должен назвать магазину код; * магазину — магазин называет код курьеру.  Если магазин получает невыкупленный заказ, то ему нужно назвать курьеру код из кабинета или приложения.  Если у магазина настроена работа с кодами подтверждения, в запросах [POST order/status](../../pushapi/reference/postOrderStatus.md), [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md), [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md), [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) в параметре `delivery`, вложенном в `order` будет возвращаться параметр `eacType` с типом `Enum` — тип кода подтверждения для передачи заказа.  Возможные значения: `MERCHANT_TO_COURIER` — магазин называет код курьеру, `COURIER_TO_MERCHANT` — курьер называет код магазину.  Параметр `eacType` возвращается при статусах заказа `COURIER_FOUND`, `COURIER_ARRIVED_TO_SENDER` и `DELIVERY_SERVICE_UNDELIVERED`. Если заказ в других статусах, параметр может отсутствовать.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кода подтверждения
         * @throws {RequiredError}
         */
        verifyOrderEac(campaignId: number, orderId: number, verifyOrderEacRequest: VerifyOrderEacRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling verifyOrderEac.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling verifyOrderEac.');
            }
            // verify required parameter 'verifyOrderEacRequest' is not null or undefined
            if (verifyOrderEacRequest === null || verifyOrderEacRequest === undefined) {
                throw new RequiredError('verifyOrderEacRequest','Required parameter verifyOrderEacRequest was null or undefined when calling verifyOrderEac.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/verifyEac`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof verifyOrderEacRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(verifyOrderEacRequest != null ? verifyOrderEacRequest : {}) : (((verifyOrderEacRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ExpressApiType = { 
    addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions): Promise<AddOffersToArchiveResponse>,

    calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions): Promise<CalculateTariffsResponse>,

    confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions): Promise<CreateChatResponse>,

    deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions): Promise<DeleteCampaignOffersResponse>,

    deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions): Promise<DeleteOffersResponse>,

    deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions): Promise<DeleteOffersFromArchiveResponse>,

    deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions): Promise<DeletePromoOffersResponse>,

    generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options?: RequestOptions): Promise<File>,

    generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options?: RequestOptions): Promise<File>,

    generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions): Promise<GetAllOffersResponse>,

    getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions): Promise<GetBidsInfoResponse>,

    getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions): Promise<GetBidsRecommendationsResponse>,

    getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,

    getBusinessSettings(businessId: number, options?: RequestOptions): Promise<GetBusinessSettingsResponse>,

    getCampaign(campaignId: number, options?: RequestOptions): Promise<GetCampaignResponse>,

    getCampaignLogins(campaignId: number, options?: RequestOptions): Promise<GetCampaignLoginsResponse>,

    getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetCampaignOffersResponse>,

    getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,

    getCampaignRegion(campaignId: number, options?: RequestOptions): Promise<GetCampaignRegionResponse>,

    getCampaignSettings(campaignId: number, options?: RequestOptions): Promise<GetCampaignSettingsResponse>,

    getCampaigns(page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,

    getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,

    getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions): Promise<GetCategoriesMaxSaleQuantumResponse>,

    getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions): Promise<GetCategoriesResponse>,

    getCategoryContentParameters(categoryId: number, options?: RequestOptions): Promise<GetCategoryContentParametersResponse>,

    getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatHistoryResponse>,

    getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatsResponse>,

    getDeliveryServices(options?: RequestOptions): Promise<GetDeliveryServicesResponse>,

    getFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<GetFeedResponse>,

    getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions): Promise<GetFeedIndexLogsResponse>,

    getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions): Promise<GetFeedbackListResponse>,

    getFeeds(campaignId: number, options?: RequestOptions): Promise<GetFeedsResponse>,

    getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetGoodsFeedbackCommentsResponse>,

    getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions): Promise<GetGoodsFeedbackResponse>,

    getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions): Promise<GetGoodsStatsResponse>,

    getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetHiddenOffersResponse>,

    getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions): Promise<GetOfferCardsContentStatusResponse>,

    getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferMappingEntriesResponse>,

    getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions): Promise<GetOfferMappingsResponse>,

    getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferRecommendationsResponse>,

    getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetOffersResponse>,

    getOrder(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderResponse>,

    getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessBuyerInfoResponse>,

    getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessDocumentsInfoResponse>,

    getOrderLabelsData(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderLabelsDataResponse>,

    getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOrdersResponse>,

    getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions): Promise<GetOrdersStatsResponse>,

    getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions): Promise<GetPricesResponse>,

    getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions): Promise<GetPricesByOfferIdsResponse>,

    getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetPromoOffersResponse>,

    getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions): Promise<GetPromosResponse>,

    getQualityRatingDetails(campaignId: number, options?: RequestOptions): Promise<GetQualityRatingDetailsResponse>,

    getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions): Promise<GetQualityRatingResponse>,

    getReportInfo(reportId: string, options?: RequestOptions): Promise<GetReportInfoResponse>,

    getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<GetReturnResponse>,

    getReturnApplication(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<File>,

    getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions): Promise<File>,

    getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions): Promise<GetReturnsResponse>,

    getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions): Promise<GetWarehouseStocksResponse>,

    getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingEntriesResponse>,

    getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingsResponse>,

    getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions): Promise<SuggestPricesResponse>,

    getWarehouses(businessId: number, options?: RequestOptions): Promise<GetWarehousesResponse>,

    provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options?: RequestOptions): Promise<ProvideOrderItemIdentifiersResponse>,

    putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    refreshFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<EmptyApiResponse>,

    searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetRegionWithChildrenResponse>,

    searchRegionsById(regionId: number, options?: RequestOptions): Promise<GetRegionsResponse>,

    searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetRegionsResponse>,

    sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions): Promise<EmptyApiResponse>,

    sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options?: RequestOptions): Promise<SetOrderBoxLayoutResponse>,

    setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options?: RequestOptions): Promise<SetOrderShipmentBoxesResponse>,

    skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<UpdateGoodsFeedbackCommentResponse>,

    updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions): Promise<UpdateOfferContentResponse>,

    updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions): Promise<UpdateOfferMappingsResponse>,

    updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options?: RequestOptions): Promise<Response>,

    updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options?: RequestOptions): Promise<UpdateOrderStatusResponse>,

    updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options?: RequestOptions): Promise<UpdateOrderStatusesResponse>,

    updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions): Promise<UpdatePromoOffersResponse>,

    updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    verifyOrderEac(campaignId: number, orderId: number, verifyOrderEacRequest: VerifyOrderEacRequest, options?: RequestOptions): Promise<VerifyOrderEacResponse>,
}

/**
 * ExpressApi - factory function to inject configuration 
 * @export
 */
export const ExpressApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ExpressApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).addHiddenOffers(campaignId, addHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions = {}): Promise<AddOffersToArchiveResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).addOffersToArchive(businessId, addOffersToArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions = {}): Promise<CalculateTariffsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).calculateTariffs(calculateTariffsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).confirmBusinessPrices(businessId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).confirmCampaignPrices(campaignId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions = {}): Promise<CreateChatResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).createChat(businessId, createChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions = {}): Promise<DeleteCampaignOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).deleteCampaignOffers(campaignId, deleteCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).deleteGoodsFeedbackComment(businessId, deleteGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).deleteHiddenOffers(campaignId, deleteHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions = {}): Promise<DeleteOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).deleteOffers(businessId, deleteOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions = {}): Promise<DeleteOffersFromArchiveResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).deleteOffersFromArchive(businessId, deleteOffersFromArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions = {}): Promise<DeletePromoOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).deletePromoOffers(businessId, deletePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateBoostConsolidatedReport(generateBoostConsolidatedRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateGoodsFeedbackReport(generateGoodsFeedbackRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по реализации** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#sales-report)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по реализации
         * @throws {RequiredError}
         */
        generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateGoodsRealizationReport(generateGoodsRealizationReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию PDF-файла с ярлыками для переданных заказов. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  Узнать статус генерации и получить ссылку на готовый файл можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в нескольких заказах
         * @throws {RequiredError}
         */
        generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateMassOrderLabelsReport(generateMassOrderLabelsRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Формирует ярлык‑наклейку для коробки в заказе и возвращает ярлык в PDF‑файле.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовый ярлык‑наклейка для коробки в заказе
         * @throws {RequiredError}
         */
        generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateOrderLabel(campaignId, orderId, shipmentId, boxId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает PDF-файл с ярлыками, которые нужно наклеить на коробки перед отгрузкой. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  На вход нужно передать идентификатор заказа и один необязательный параметр, который управляет версткой PDF-файла.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в одном заказе
         * @throws {RequiredError}
         */
        generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateOrderLabels(campaignId, orderId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generatePricesReport(generatePricesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateShelfsStatisticsReport(generateShelfsStatisticsRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateShowsSalesReport(generateShowsSalesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateUnitedNettingReport(generateUnitedNettingReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).generateUnitedOrdersReport(generateUnitedOrdersRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions = {}): Promise<GetAllOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getAllOffers(campaignId, feedId, chunk, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions = {}): Promise<GetBidsInfoResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getBidsInfoForBusiness(businessId, pageToken, limit, getBidsInfoRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions = {}): Promise<GetBidsRecommendationsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getBidsRecommendations(businessId, getBidsRecommendationsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getBusinessQuarantineOffers(businessId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options?: RequestOptions = {}): Promise<GetBusinessSettingsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getBusinessSettings(businessId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCampaign(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignLoginsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCampaignLogins(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetCampaignOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCampaignOffers(campaignId, getCampaignOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCampaignQuarantineOffers(campaignId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignRegionResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCampaignRegion(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignSettingsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCampaignSettings(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCampaigns(page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCampaignsByLogin(login, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions = {}): Promise<GetCategoriesMaxSaleQuantumResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions = {}): Promise<GetCategoriesResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCategoriesTree(getCategoriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options?: RequestOptions = {}): Promise<GetCategoryContentParametersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getCategoryContentParameters(categoryId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatHistoryResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getChatHistory(businessId, chatId, getChatHistoryRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getChats(businessId, getChatsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает справочник служб доставки: идентификаторы и наименования. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Справочник служб доставки
         * @throws {RequiredError}
         */
        getDeliveryServices(options?: RequestOptions = {}): Promise<GetDeliveryServicesResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getDeliveryServices(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<GetFeedResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions = {}): Promise<GetFeedIndexLogsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getFeedIndexLogs(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions = {}): Promise<GetFeedbackListResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getFeedbackAndCommentUpdates(campaignId, pageToken, limit, fromDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options?: RequestOptions = {}): Promise<GetFeedsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getFeeds(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetGoodsFeedbackCommentsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getGoodsFeedbackComments(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions = {}): Promise<GetGoodsFeedbackResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getGoodsFeedbacks(businessId, pageToken, limit, getGoodsFeedbackRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions = {}): Promise<GetGoodsStatsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getGoodsStats(campaignId, getGoodsStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetHiddenOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getHiddenOffers(campaignId, offerId, pageToken, limit, offset, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions = {}): Promise<GetOfferCardsContentStatusResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOfferCardsContentStatus(businessId, pageToken, limit, getOfferCardsContentStatusRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferMappingEntriesResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOfferMappingEntries(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetOfferMappingsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOfferMappings(businessId, pageToken, limit, getOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferRecommendationsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOfferRecommendations(businessId, getOfferRecommendationsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOffers(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOrder(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessBuyerInfoResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOrderBusinessBuyerInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessDocumentsInfoResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOrderBusinessDocumentsInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию на ярлыках, которые клеятся на коробки в заказе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Данные для самостоятельного изготовления ярлыков
         * @throws {RequiredError}
         */
        getOrderLabelsData(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderLabelsDataResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOrderLabelsData(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOrdersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOrders(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions = {}): Promise<GetOrdersStatsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getOrdersStats(campaignId, pageToken, limit, getOrdersStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions = {}): Promise<GetPricesResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getPrices(campaignId, pageToken, limit, archived, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions = {}): Promise<GetPricesByOfferIdsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getPricesByOfferIds(campaignId, pageToken, limit, getPricesByOfferIdsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetPromoOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getPromoOffers(businessId, getPromoOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions = {}): Promise<GetPromosResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getPromos(businessId, getPromosRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список заказов, которые повлияли на индекс качества магазина. Чтобы узнать значение индекса качества, выполните запрос [POST businesses/{businessId}/ratings/quality](../../reference/ratings/getQualityRatings.md).  |**⚙️ Лимит:** 100000 запросов в час| |-| 
         * @summary Заказы, которые повлияли на индекс качества
         * @throws {RequiredError}
         */
        getQualityRatingDetails(campaignId: number, options?: RequestOptions = {}): Promise<GetQualityRatingDetailsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getQualityRatingDetails(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions = {}): Promise<GetQualityRatingResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getQualityRatings(businessId, getQualityRatingRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options?: RequestOptions = {}): Promise<GetReportInfoResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getReportInfo(reportId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<GetReturnResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getReturn(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Загружает заявление покупателя на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение заявления на возврат
         * @throws {RequiredError}
         */
        getReturnApplication(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getReturnApplication(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getReturnPhoto(campaignId, orderId, returnId, itemId, imageHash, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions = {}): Promise<GetReturnsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getReturns(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions = {}): Promise<GetWarehouseStocksResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getStocks(campaignId, pageToken, limit, getWarehouseStocksRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingEntriesResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getSuggestedOfferMappingEntries(campaignId, getSuggestedOfferMappingEntriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getSuggestedOfferMappings(businessId, getSuggestedOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions = {}): Promise<SuggestPricesResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getSuggestedPrices(campaignId, suggestPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список складов и, если склады объединены, список групп складов. [Что такое группы складов и зачем они нужны](https://yandex.ru/support/marketplace/assortment/operations/stocks.html#unified-stocks)  Среди прочего запрос позволяет определить идентификатор, который нужно использовать при передаче остатков для группы складов.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Список складов и групп складов
         * @throws {RequiredError}
         */
        getWarehouses(businessId: number, options?: RequestOptions = {}): Promise<GetWarehousesResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).getWarehouses(businessId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Передает Маркету коды маркировки для единиц товара в указанном заказе.  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  {% note warning %}  Прежде чем работать с этим методом, обязательно прочтите [статью о работе с маркируемыми товарами](https://yandex.ru/support/marketplace/orders/cz.html).  {% endnote %}  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кодов маркировки единиц товара
         * @throws {RequiredError}
         */
        provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options?: RequestOptions = {}): Promise<ProvideOrderItemIdentifiersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).provideOrderItemIdentifiers(campaignId, orderId, provideOrderItemIdentifiersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).putBidsForBusiness(businessId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).putBidsForCampaign(campaignId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).refreshFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetRegionWithChildrenResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).searchRegionChildren(regionId, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).searchRegionsById(regionId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).searchRegionsByName(name, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).sendFileToChat(businessId, chatId, file, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).sendMessageToChat(businessId, chatId, sendMessageToChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).setFeedParams(campaignId, feedId, setFeedParamsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note tip \"Подходит и для DBS\" %}  Запрос предназначен для работы с FBS-заказами, но вы можете использовать его для обработки DBS-заказов, если это удобно.  {% endnote %}  Позволяет выполнить три операции:  * передать Маркету информацию о распределении товаров по коробкам; * передать Маркету коды маркировки для товаров; * удалить товар из заказа, если его не оказалось на складе.  Если нужно что-то поправить в переданных данных, просто повторите запрос — это можно делать сколько угодно раз до перевода заказа в статус **Готов к отгрузке**. ⚠️ Если вы меняете раскладку уже после печати и расклейки ярлыков, не забудье перепечатать их и наклеить заново.  ## Как передать информацию о распределении товаров  В этом запросе вам нужно передать Маркету список коробок и указать, какие именно товары лежат в каждой из них. Коробки могут быть двух типов:  * **Содержащие товары целиком.** Такая коробка может содержать сколько угодно единиц любых товаров.  * **Содержащие часть товара.** Такие коробки содержат по одной части одного товара. Например, одна содержит внешний блок кондиционера, а другая — внутренний блок.  ⚠️ Одна коробка не может содержать и товары целиком, и части товаров.  ## Как передавать коды маркировки  Если в заказе есть товары, подлежащие маркировке, в запросе нужно передать соответствующие уникальные коды. [Что такое маркировка?](https://yandex.ru/support/marketplace/orders/cz.html)  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  Если товар едет в нескольких коробках, код маркировки нужно передать для каждой из них.  ## Как удалить товар из заказа  Чтобы удалить товар из заказа:  1. Добавьте в запрос `allowRemove: true`. 2. Передайте распределение по коробкам без товара, который нужно удалить.  {% note warning \"Удаление нельзя отменить\" %}  Эта операция необратима: покупатель сразу получит уведомление, а состав заказа изменится.  {% endnote %}  Чтобы удалить позицию целиком, не передавайте соответствующий `OrderBoxLayoutItemDTO`. Чтобы уменьшить количество товара, передайте уменьшенное значение в поле `fullCount`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если вы не можете отгрузить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  ## Примеры  {% cut \"Товар умещается в коробку\" %}  Вот как будет выглядеть запрос, если в одной коробке едут:    * три единицы одного товара, требующего маркировки;   * одна единица другого товара, не требущего маркировки.    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"fullCount\": 3,                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           },                           {                               \"cis\": \"010304109478gftJ14545762!\\u001dhGt264\"                           },                           {                               \"cis\": \"010304109478fRs28323ks23!\\u001dhet201\"                           }                       ]                   },                   {                       \"id\": 654321,                       \"fullCount\": 1                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Товар едет в разных коробках\" %}  Вот как будет выглядеть запрос, если товар едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Одинаковые товары, где каждый едет в нескольких коробках\" %}  Вот как будет выглядеть запрос, если каждый из двух одинаковых товаров едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Подготовка заказа
         * @throws {RequiredError}
         */
        setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options?: RequestOptions = {}): Promise<SetOrderBoxLayoutResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).setOrderBoxLayout(campaignId, orderId, setOrderBoxLayoutRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Отгружаемый Маркету заказ может не влезть в одну коробку или упаковку — в этом случае получается, что он занимает несколько грузовых мест.  Количество грузовых мест нужно обязательно передавать Маркету, если оно не равно 1. Это делается перед переводом его в статус **Готов к отгрузке**. Подробно о том, что в какой момент нужно передавать, рассказано в [пошаговой инструкции](../../step-by-step/fbs.md).  Метод устроен немного нестандартно: количество задается длиной массива пустых объектов.  Раньше метод требовал передачи большего количества данных. Запросы, оформленные по старому образцу, работают, но лучше делать по-новому.  {% cut \"Как было раньше\" %}  Структура тела PUT-запроса:  ``` {   \"boxes\":   [     {       \"fulfilmentId\": \"{string}\",       \"weight\": {int64},       \"width\": {int64},       \"height\": {int64},       \"depth\": {int64},       \"items\":       [         {           \"id\": {int64},           \"count\": {int32}         },         ...       ]     },     ...   ] } ``` | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `boxes`       |           | Список грузовых мест.       |  **Параметры, вложенные в `boxes`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `fulfilmentId`       |  String   | Идентификатор грузового места в информационной системе магазина. Сформируйте идентификатор по шаблону: `номер заказа на Маркете-номер грузового места`. Например, `7206821‑1, 7206821‑2` и т. д. | | `weight`       | Int64        | Масса брутто грузового места (суммарная масса упаковки и содержимого) в граммах. | | `width`       | Int64   | Ширина грузового места в сантиметрах.       | | `height`       | Int64   | Высота грузового места в сантиметрах.       | | `depth`       | Int64   | Глубина грузового места в сантиметрах.        | | `items`       | Int64   | Список товаров в грузовом месте.       |  **Параметры, вложенные в `items`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `id`       | Int64     | Идентификатор товара в рамках заказа.   | | `count`    | Int32     | Количество единиц товара в грузовом месте.       |  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача количества грузовых мест в заказе
         * @throws {RequiredError}
         */
        setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options?: RequestOptions = {}): Promise<SetOrderShipmentBoxesResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).setOrderShipmentBoxes(campaignId, orderId, shipmentId, setOrderShipmentBoxesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).skipGoodsFeedbacksReaction(businessId, skipGoodsFeedbackReactionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateBusinessPrices(businessId, updateBusinessPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateCampaignOffers(campaignId, updateCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<UpdateGoodsFeedbackCommentResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateGoodsFeedbackComment(businessId, updateGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions = {}): Promise<UpdateOfferContentResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateOfferContent(businessId, updateOfferContentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateOfferMappingEntries(campaignId, updateOfferMappingEntryRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions = {}): Promise<UpdateOfferMappingsResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateOfferMappings(businessId, updateOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Изменяет состав заказа, если позволяет выбранная служба доставки, в случаях:  * покупатель уменьшил количество товара; * магазин не может поставить все товары в заказе.  Для этого заказ должен находится в статусе `\"status\": \"PROCESSING\"` этапа обработки `\"substatus\": \"STARTED\"`. После передачи статуса `\"substatus\": \"READY_TO_SHIP\"` изменить состав невозможно.  Если одинаковых товаров несколько, для уменьшения количества передайте обновленное значение в атрибуте `count` параметра `item`.  Чтобы полностью удалить товар из заказа:  * передайте значение `0`; или * не передавайте параметр `item`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если необходимо удалить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  **Возврат денег покупателю**  Если покупатель оплатил товар при оформлении, Маркет вернет ему деньги за удаленные из заказа товары в течение двух дней:  * при оплате банковской картой — с момента, когда магазин переведет заказ в статус `SHIPPED`;  * при оплате через Apple Pay или Google Pay — с момента, когда магазин удалит товар из заказа.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Удаление товара из заказа или уменьшение числа единиц
         * @throws {RequiredError}
         */
        updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateOrderItems(campaignId, orderId, updateOrderItemRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет статус заказа. Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статуса одного заказа
         * @throws {RequiredError}
         */
        updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options?: RequestOptions = {}): Promise<UpdateOrderStatusResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateOrderStatus(campaignId, orderId, updateOrderStatusRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет статусы нескольких заказов.  Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"`и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  Максимальное количество заказов, у которых можно изменить статус в одном запросе, — 30.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статусов нескольких заказов
         * @throws {RequiredError}
         */
        updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options?: RequestOptions = {}): Promise<UpdateOrderStatusesResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateOrderStatuses(campaignId, updateOrderStatusesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updatePrices(campaignId, updatePricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions = {}): Promise<UpdatePromoOffersResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updatePromoOffers(businessId, updatePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает данные об остатках товаров на витрине.  Обязательно указывайте SKU **в точности** так, как он указан в каталоге. Например, _557722_ и _0557722_ — это два разных SKU.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-| 
         * @summary Передача информации об остатках
         * @throws {RequiredError}
         */
        updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).updateStocks(campaignId, updateStocksRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет Маркету код подтверждения для его проверки.  Код подтверждает передачу заказа или невыкупа:  * курьеру — курьер должен назвать магазину код; * магазину — магазин называет код курьеру.  Если магазин получает невыкупленный заказ, то ему нужно назвать курьеру код из кабинета или приложения.  Если у магазина настроена работа с кодами подтверждения, в запросах [POST order/status](../../pushapi/reference/postOrderStatus.md), [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md), [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md), [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) в параметре `delivery`, вложенном в `order` будет возвращаться параметр `eacType` с типом `Enum` — тип кода подтверждения для передачи заказа.  Возможные значения: `MERCHANT_TO_COURIER` — магазин называет код курьеру, `COURIER_TO_MERCHANT` — курьер называет код магазину.  Параметр `eacType` возвращается при статусах заказа `COURIER_FOUND`, `COURIER_ARRIVED_TO_SENDER` и `DELIVERY_SERVICE_UNDELIVERED`. Если заказ в других статусах, параметр может отсутствовать.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кода подтверждения
         * @throws {RequiredError}
         */
        verifyOrderEac(campaignId: number, orderId: number, verifyOrderEacRequest: VerifyOrderEacRequest, options?: RequestOptions = {}): Promise<VerifyOrderEacResponse> {
            const localVarFetchArgs = ExpressApiFetchParamCreator(configuration).verifyOrderEac(campaignId, orderId, verifyOrderEacRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * FbsApi - fetch parameter creator
 * @export
 */
export const FbsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling addHiddenOffers.');
            }
            // verify required parameter 'addHiddenOffersRequest' is not null or undefined
            if (addHiddenOffersRequest === null || addHiddenOffersRequest === undefined) {
                throw new RequiredError('addHiddenOffersRequest','Required parameter addHiddenOffersRequest was null or undefined when calling addHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addHiddenOffersRequest != null ? addHiddenOffersRequest : {}) : (((addHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling addOffersToArchive.');
            }
            // verify required parameter 'addOffersToArchiveRequest' is not null or undefined
            if (addOffersToArchiveRequest === null || addOffersToArchiveRequest === undefined) {
                throw new RequiredError('addOffersToArchiveRequest','Required parameter addOffersToArchiveRequest was null or undefined when calling addOffersToArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/archive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addOffersToArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addOffersToArchiveRequest != null ? addOffersToArchiveRequest : {}) : (((addOffersToArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'calculateTariffsRequest' is not null or undefined
            if (calculateTariffsRequest === null || calculateTariffsRequest === undefined) {
                throw new RequiredError('calculateTariffsRequest','Required parameter calculateTariffsRequest was null or undefined when calling calculateTariffs.');
            }
            const localVarPath = `/tariffs/calculate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof calculateTariffsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(calculateTariffsRequest != null ? calculateTariffsRequest : {}) : (((calculateTariffsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling confirmBusinessPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine/confirm`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling confirmCampaignPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmCampaignPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine/confirm`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает отгрузку товаров в сортировочный центр или пункт приема заказов. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Подтверждение отгрузки
         * @throws {RequiredError}
         */
        confirmShipment(campaignId: number, shipmentId: number, confirmShipmentRequest?: ConfirmShipmentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling confirmShipment.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling confirmShipment.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/confirm`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmShipmentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmShipmentRequest != null ? confirmShipmentRequest : {}) : (((confirmShipmentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling createChat.');
            }
            // verify required parameter 'createChatRequest' is not null or undefined
            if (createChatRequest === null || createChatRequest === undefined) {
                throw new RequiredError('createChatRequest','Required parameter createChatRequest was null or undefined when calling createChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/new`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createChatRequest != null ? createChatRequest : {}) : (((createChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteCampaignOffers.');
            }
            // verify required parameter 'deleteCampaignOffersRequest' is not null or undefined
            if (deleteCampaignOffersRequest === null || deleteCampaignOffersRequest === undefined) {
                throw new RequiredError('deleteCampaignOffersRequest','Required parameter deleteCampaignOffersRequest was null or undefined when calling deleteCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteCampaignOffersRequest != null ? deleteCampaignOffersRequest : {}) : (((deleteCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            // verify required parameter 'deleteGoodsFeedbackCommentRequest' is not null or undefined
            if (deleteGoodsFeedbackCommentRequest === null || deleteGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('deleteGoodsFeedbackCommentRequest','Required parameter deleteGoodsFeedbackCommentRequest was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteGoodsFeedbackCommentRequest != null ? deleteGoodsFeedbackCommentRequest : {}) : (((deleteGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteHiddenOffers.');
            }
            // verify required parameter 'deleteHiddenOffersRequest' is not null or undefined
            if (deleteHiddenOffersRequest === null || deleteHiddenOffersRequest === undefined) {
                throw new RequiredError('deleteHiddenOffersRequest','Required parameter deleteHiddenOffersRequest was null or undefined when calling deleteHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteHiddenOffersRequest != null ? deleteHiddenOffersRequest : {}) : (((deleteHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffers.');
            }
            // verify required parameter 'deleteOffersRequest' is not null or undefined
            if (deleteOffersRequest === null || deleteOffersRequest === undefined) {
                throw new RequiredError('deleteOffersRequest','Required parameter deleteOffersRequest was null or undefined when calling deleteOffers.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersRequest != null ? deleteOffersRequest : {}) : (((deleteOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffersFromArchive.');
            }
            // verify required parameter 'deleteOffersFromArchiveRequest' is not null or undefined
            if (deleteOffersFromArchiveRequest === null || deleteOffersFromArchiveRequest === undefined) {
                throw new RequiredError('deleteOffersFromArchiveRequest','Required parameter deleteOffersFromArchiveRequest was null or undefined when calling deleteOffersFromArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/unarchive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersFromArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersFromArchiveRequest != null ? deleteOffersFromArchiveRequest : {}) : (((deleteOffersFromArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deletePromoOffers.');
            }
            // verify required parameter 'deletePromoOffersRequest' is not null or undefined
            if (deletePromoOffersRequest === null || deletePromoOffersRequest === undefined) {
                throw new RequiredError('deletePromoOffersRequest','Required parameter deletePromoOffersRequest was null or undefined when calling deletePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deletePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deletePromoOffersRequest != null ? deletePromoOffersRequest : {}) : (((deletePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Экспресс‑доставка\" %}  Если ваш магазин подключен к экспресс‑доставке и вы отгружаете заказы курьерам Яндекс Go, подготавливать акт приема‑передачи не нужно.  {% endnote %}  Запрос формирует акт приема-передачи заказов, входящих в отгрузку, и возвращает акт в формате PDF. В акте содержатся собранные и готовые к отправке заказы.  При формировании акта Маркет автоматически находит и подставляет в шаблон следующие данные:  {% cut \"Данные, из которых Маркет формирует акт\" %}  | **Данные в акте**                                         | **Описание**                                                                                                                                                                                                                                                         | | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Дата                                                      | Дата запроса.                                                                                                                                                                                                                                                        | | Отправитель                                               | Название вашего юридического лица, указанное в кабинете продавца на Маркете.                                                                                                                                                                                         | | Исполнитель                                               | Название юридического лица сортировочного центра или службы доставки.                                                                                                                                                                                                | | № отправления в системе заказчика                         | Ваш идентификатор заказа, который вы указали в ответе на запрос [POST order/accept](../../pushapi/reference/orderAccept.md) от Маркета.                                                                                                                              | | № отправления в системе исполнителя (субподрядчика)       | Идентификатор заказа на Маркете, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md).                                                                                                                             | | Объявленная ценность                                      | Общая сумма заказа без учета стоимости доставки, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                       | | Вес                                                       | Масса брутто грузового места (суммарная масса упаковки и содержимого), как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md). | | Количество мест                                           | Количество грузовых мест в заказе, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                                     |  {% endcut %}  Остальные поля нужно заполнить самостоятельно в распечатанном акте. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение акта приема-передачи
         * @throws {RequiredError}
         */
        downloadShipmentAct(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentAct.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentAct.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/act`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает акт расхождений для заданной отгрузки. |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение акта расхождений
         * @throws {RequiredError}
         */
        downloadShipmentDiscrepancyAct(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentDiscrepancyAct.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentDiscrepancyAct.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/discrepancy-act`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает фактический акт приема-передачи для заданной отгрузки.  Такой акт становится доступен спустя несколько часов после завершения отгрузки. Он может понадобиться, если после отгрузки обнаружатся расхождения.  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение фактического акта приема-передачи
         * @throws {RequiredError}
         */
        downloadShipmentInboundAct(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentInboundAct.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentInboundAct.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/inbound-act`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PDF-файл с ярлыками на каждый короб или палету в отгрузке для доверительной приемки. Подробнее про доверительную приемку написано в [Справке Маркета](https://yandex.ru/support/marketplace/orders/fbs/process.html#acceptance).  Распечатайте по несколько копий каждого ярлыка: на одну тару нужно наклеить минимум 2 ярлыка с разных сторон.  Количество упаковок в отгрузке задается в запросе [PUT campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallets](../../reference/shipments/setShipmentPalletsCount.md). |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Ярлыки для доверительной приемки (FBS)
         * @throws {RequiredError}
         */
        downloadShipmentPalletLabels(campaignId: number, shipmentId: number, format?: ShipmentPalletLabelPageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentPalletLabels.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentPalletLabels.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallet/labels`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запрос подтверждает ближайшую отгрузку и возвращает акт приема-передачи в формате PDF.  {% note warning \"Экспресс‑доставка\" %}  Если ваш магазин подключен к экспресс‑доставке и вы отгружаете заказы курьерам [Яндекс Go](https://go.yandex/), подготавливать акт приема‑передачи не нужно.  {% endnote %}  В акт входят собранные и готовые к отправке заказы, которые отгружаются в сортировочный центр или пункт приема или курьерам Маркета.  При формировании акта Маркет автоматически находит и подставляет в шаблон следующие данные:  {% cut \"Данные, из которых Маркет формирует акт\" %}  | **Данные в акте**                                   | **Описание**                                                                                                                                                                                                                                                         | | --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Отправитель                                         | Название вашего юридического лица, указанное в кабинете продавца на Маркете.                                                                                                                                                                                         | | Исполнитель                                         | Название юридического лица сортировочного центра или службы доставки.                                                                                                                                                                                                | | № отправления в системе заказчика                   | Ваш идентификатор заказа, который вы указали в ответе на запрос [POST order/accept](../../pushapi/reference/orderAccept.md) от Маркета.                                                                                                                              | | № отправления в системе исполнителя (субподрядчика) | Идентификатор заказа на Маркете, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md).                                                                                                                             | | Объявленная ценность                                | Общая сумма заказа без учета стоимости доставки, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                       | | Стоимость всех товаров в заказе                     | Стоимость всех заказанных товаров.                                                                                                                                                                                                                                   | | Вес                                                 | Масса брутто грузового места (суммарная масса упаковки и содержимого), как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md). | | Количество мест                                     | Количество грузовых мест в заказе, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                                     |  {% endcut %}  Остальные поля нужно заполнить самостоятельно в распечатанном акте. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Подтверждение ближайшей отгрузки и получение акта приема-передачи для нее
         * @throws {RequiredError}
         */
        downloadShipmentReceptionTransferAct(campaignId: number, warehouseId?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentReceptionTransferAct.');
            }
            const localVarPath = `/campaigns/{campaignId}/shipments/reception-transfer-act`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouse_id'] = ((warehouseId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает транспортную накладную для заданной отгрузки.  Транспортная накладная понадобится, если вы отгружаете товары непосредственно со своего склада. [Подробно об этом способе отгрузки](https://yandex.ru/support/marketplace/orders/fbs/settings/shipment.html#at-your-warehouse)  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение транспортной накладной
         * @throws {RequiredError}
         */
        downloadShipmentTransportationWaybill(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentTransportationWaybill.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentTransportationWaybill.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/transportation-waybill`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateBoostConsolidatedRequest' is not null or undefined
            if (generateBoostConsolidatedRequest === null || generateBoostConsolidatedRequest === undefined) {
                throw new RequiredError('generateBoostConsolidatedRequest','Required parameter generateBoostConsolidatedRequest was null or undefined when calling generateBoostConsolidatedReport.');
            }
            const localVarPath = `/reports/boost-consolidated/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateBoostConsolidatedRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateBoostConsolidatedRequest != null ? generateBoostConsolidatedRequest : {}) : (((generateBoostConsolidatedRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateCompetitorsPositionReportRequest' is not null or undefined
            if (generateCompetitorsPositionReportRequest === null || generateCompetitorsPositionReportRequest === undefined) {
                throw new RequiredError('generateCompetitorsPositionReportRequest','Required parameter generateCompetitorsPositionReportRequest was null or undefined when calling generateCompetitorsPositionReport.');
            }
            const localVarPath = `/reports/competitors-position/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateCompetitorsPositionReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateCompetitorsPositionReportRequest != null ? generateCompetitorsPositionReportRequest : {}) : (((generateCompetitorsPositionReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsFeedbackRequest' is not null or undefined
            if (generateGoodsFeedbackRequest === null || generateGoodsFeedbackRequest === undefined) {
                throw new RequiredError('generateGoodsFeedbackRequest','Required parameter generateGoodsFeedbackRequest was null or undefined when calling generateGoodsFeedbackReport.');
            }
            const localVarPath = `/reports/goods-feedback/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsFeedbackRequest != null ? generateGoodsFeedbackRequest : {}) : (((generateGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по реализации** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#sales-report)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по реализации
         * @throws {RequiredError}
         */
        generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsRealizationReportRequest' is not null or undefined
            if (generateGoodsRealizationReportRequest === null || generateGoodsRealizationReportRequest === undefined) {
                throw new RequiredError('generateGoodsRealizationReportRequest','Required parameter generateGoodsRealizationReportRequest was null or undefined when calling generateGoodsRealizationReport.');
            }
            const localVarPath = `/reports/goods-realization/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsRealizationReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsRealizationReportRequest != null ? generateGoodsRealizationReportRequest : {}) : (((generateGoodsRealizationReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию PDF-файла с ярлыками для переданных заказов. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  Узнать статус генерации и получить ссылку на готовый файл можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в нескольких заказах
         * @throws {RequiredError}
         */
        generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateMassOrderLabelsRequest' is not null or undefined
            if (generateMassOrderLabelsRequest === null || generateMassOrderLabelsRequest === undefined) {
                throw new RequiredError('generateMassOrderLabelsRequest','Required parameter generateMassOrderLabelsRequest was null or undefined when calling generateMassOrderLabelsReport.');
            }
            const localVarPath = `/reports/documents/labels/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateMassOrderLabelsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateMassOrderLabelsRequest != null ? generateMassOrderLabelsRequest : {}) : (((generateMassOrderLabelsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Формирует ярлык‑наклейку для коробки в заказе и возвращает ярлык в PDF‑файле.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовый ярлык‑наклейка для коробки в заказе
         * @throws {RequiredError}
         */
        generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'boxId' is not null or undefined
            if (boxId === null || boxId === undefined) {
                throw new RequiredError('boxId','Required parameter boxId was null or undefined when calling generateOrderLabel.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"boxId"}}`, encodeURIComponent(String(boxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает PDF-файл с ярлыками, которые нужно наклеить на коробки перед отгрузкой. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  На вход нужно передать идентификатор заказа и один необязательный параметр, который управляет версткой PDF-файла.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в одном заказе
         * @throws {RequiredError}
         */
        generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling generateOrderLabels.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling generateOrderLabels.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/labels`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generatePricesReportRequest' is not null or undefined
            if (generatePricesReportRequest === null || generatePricesReportRequest === undefined) {
                throw new RequiredError('generatePricesReportRequest','Required parameter generatePricesReportRequest was null or undefined when calling generatePricesReport.');
            }
            const localVarPath = `/reports/prices/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generatePricesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generatePricesReportRequest != null ? generatePricesReportRequest : {}) : (((generatePricesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShelfsStatisticsRequest' is not null or undefined
            if (generateShelfsStatisticsRequest === null || generateShelfsStatisticsRequest === undefined) {
                throw new RequiredError('generateShelfsStatisticsRequest','Required parameter generateShelfsStatisticsRequest was null or undefined when calling generateShelfsStatisticsReport.');
            }
            const localVarPath = `/reports/shelf-statistics/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShelfsStatisticsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShelfsStatisticsRequest != null ? generateShelfsStatisticsRequest : {}) : (((generateShelfsStatisticsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **листа сборки** для отгрузки.  Узнать статус генерации и получить ссылку на готовый документ можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение листа сборки
         * @throws {RequiredError}
         */
        generateShipmentListDocumentReport(generateShipmentListDocumentReportRequest: GenerateShipmentListDocumentReportRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShipmentListDocumentReportRequest' is not null or undefined
            if (generateShipmentListDocumentReportRequest === null || generateShipmentListDocumentReportRequest === undefined) {
                throw new RequiredError('generateShipmentListDocumentReportRequest','Required parameter generateShipmentListDocumentReportRequest was null or undefined when calling generateShipmentListDocumentReport.');
            }
            const localVarPath = `/reports/documents/shipment-list/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShipmentListDocumentReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShipmentListDocumentReportRequest != null ? generateShipmentListDocumentReportRequest : {}) : (((generateShipmentListDocumentReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShowsSalesReportRequest' is not null or undefined
            if (generateShowsSalesReportRequest === null || generateShowsSalesReportRequest === undefined) {
                throw new RequiredError('generateShowsSalesReportRequest','Required parameter generateShowsSalesReportRequest was null or undefined when calling generateShowsSalesReport.');
            }
            const localVarPath = `/reports/shows-sales/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShowsSalesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShowsSalesReportRequest != null ? generateShowsSalesReportRequest : {}) : (((generateShowsSalesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateStocksOnWarehousesReportRequest' is not null or undefined
            if (generateStocksOnWarehousesReportRequest === null || generateStocksOnWarehousesReportRequest === undefined) {
                throw new RequiredError('generateStocksOnWarehousesReportRequest','Required parameter generateStocksOnWarehousesReportRequest was null or undefined when calling generateStocksOnWarehousesReport.');
            }
            const localVarPath = `/reports/stocks-on-warehouses/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateStocksOnWarehousesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateStocksOnWarehousesReportRequest != null ? generateStocksOnWarehousesReportRequest : {}) : (((generateStocksOnWarehousesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedMarketplaceServicesReportRequest' is not null or undefined
            if (generateUnitedMarketplaceServicesReportRequest === null || generateUnitedMarketplaceServicesReportRequest === undefined) {
                throw new RequiredError('generateUnitedMarketplaceServicesReportRequest','Required parameter generateUnitedMarketplaceServicesReportRequest was null or undefined when calling generateUnitedMarketplaceServicesReport.');
            }
            const localVarPath = `/reports/united-marketplace-services/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedMarketplaceServicesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedMarketplaceServicesReportRequest != null ? generateUnitedMarketplaceServicesReportRequest : {}) : (((generateUnitedMarketplaceServicesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedNettingReportRequest' is not null or undefined
            if (generateUnitedNettingReportRequest === null || generateUnitedNettingReportRequest === undefined) {
                throw new RequiredError('generateUnitedNettingReportRequest','Required parameter generateUnitedNettingReportRequest was null or undefined when calling generateUnitedNettingReport.');
            }
            const localVarPath = `/reports/united-netting/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedNettingReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedNettingReportRequest != null ? generateUnitedNettingReportRequest : {}) : (((generateUnitedNettingReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedOrdersRequest' is not null or undefined
            if (generateUnitedOrdersRequest === null || generateUnitedOrdersRequest === undefined) {
                throw new RequiredError('generateUnitedOrdersRequest','Required parameter generateUnitedOrdersRequest was null or undefined when calling generateUnitedOrdersReport.');
            }
            const localVarPath = `/reports/united-orders/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedOrdersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedOrdersRequest != null ? generateUnitedOrdersRequest : {}) : (((generateUnitedOrdersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getAllOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/all`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (chunk !== undefined) {
                localVarQueryParameter['chunk'] = ((chunk:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsInfoForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids/info`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsInfoRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsInfoRequest != null ? getBidsInfoRequest : {}) : (((getBidsInfoRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsRecommendations.');
            }
            // verify required parameter 'getBidsRecommendationsRequest' is not null or undefined
            if (getBidsRecommendationsRequest === null || getBidsRecommendationsRequest === undefined) {
                throw new RequiredError('getBidsRecommendationsRequest','Required parameter getBidsRecommendationsRequest was null or undefined when calling getBidsRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/bids/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsRecommendationsRequest != null ? getBidsRecommendationsRequest : {}) : (((getBidsRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getBusinessQuarantineOffers.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessSettings.');
            }
            const localVarPath = `/businesses/{businessId}/settings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignLogins.');
            }
            const localVarPath = `/campaigns/{campaignId}/logins`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignOffers.');
            }
            // verify required parameter 'getCampaignOffersRequest' is not null or undefined
            if (getCampaignOffersRequest === null || getCampaignOffersRequest === undefined) {
                throw new RequiredError('getCampaignOffersRequest','Required parameter getCampaignOffersRequest was null or undefined when calling getCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCampaignOffersRequest != null ? getCampaignOffersRequest : {}) : (((getCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getCampaignQuarantineOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignRegion.');
            }
            const localVarPath = `/campaigns/{campaignId}/region`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignSettings.');
            }
            const localVarPath = `/campaigns/{campaignId}/settings`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/campaigns`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling getCampaignsByLogin.');
            }
            const localVarPath = `/campaigns/by_login/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'getCategoriesMaxSaleQuantumRequest' is not null or undefined
            if (getCategoriesMaxSaleQuantumRequest === null || getCategoriesMaxSaleQuantumRequest === undefined) {
                throw new RequiredError('getCategoriesMaxSaleQuantumRequest','Required parameter getCategoriesMaxSaleQuantumRequest was null or undefined when calling getCategoriesMaxSaleQuantum.');
            }
            const localVarPath = `/categories/max-sale-quantum`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesMaxSaleQuantumRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesMaxSaleQuantumRequest != null ? getCategoriesMaxSaleQuantumRequest : {}) : (((getCategoriesMaxSaleQuantumRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options: RequestOptions): FetchArgs {
            const localVarPath = `/categories/tree`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesRequest != null ? getCategoriesRequest : {}) : (((getCategoriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getCategoryContentParameters.');
            }
            const localVarPath = `/category/{categoryId}/parameters`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'getChatHistoryRequest' is not null or undefined
            if (getChatHistoryRequest === null || getChatHistoryRequest === undefined) {
                throw new RequiredError('getChatHistoryRequest','Required parameter getChatHistoryRequest was null or undefined when calling getChatHistory.');
            }
            const localVarPath = `/businesses/{businessId}/chats/history`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatHistoryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatHistoryRequest != null ? getChatHistoryRequest : {}) : (((getChatHistoryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChats.');
            }
            // verify required parameter 'getChatsRequest' is not null or undefined
            if (getChatsRequest === null || getChatsRequest === undefined) {
                throw new RequiredError('getChatsRequest','Required parameter getChatsRequest was null or undefined when calling getChats.');
            }
            const localVarPath = `/businesses/{businessId}/chats`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatsRequest != null ? getChatsRequest : {}) : (((getChatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает справочник служб доставки: идентификаторы и наименования. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Справочник служб доставки
         * @throws {RequiredError}
         */
        getDeliveryServices(options: RequestOptions): FetchArgs {
            const localVarPath = `/delivery/services`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedIndexLogs.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeedIndexLogs.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/index-logs`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (publishedTimeFrom !== undefined) {
                localVarQueryParameter['published_time_from'] = ((publishedTimeFrom:any):Date).toISOString();
            }

            if (publishedTimeTo !== undefined) {
                localVarQueryParameter['published_time_to'] = ((publishedTimeTo:any):Date).toISOString();
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = ((status:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedbackAndCommentUpdates.');
            }
            const localVarPath = `/campaigns/{campaignId}/feedback/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeeds.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbackComments.');
            }
            // verify required parameter 'getGoodsFeedbackCommentsRequest' is not null or undefined
            if (getGoodsFeedbackCommentsRequest === null || getGoodsFeedbackCommentsRequest === undefined) {
                throw new RequiredError('getGoodsFeedbackCommentsRequest','Required parameter getGoodsFeedbackCommentsRequest was null or undefined when calling getGoodsFeedbackComments.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackCommentsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackCommentsRequest != null ? getGoodsFeedbackCommentsRequest : {}) : (((getGoodsFeedbackCommentsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbacks.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackRequest != null ? getGoodsFeedbackRequest : {}) : (((getGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getGoodsStats.');
            }
            // verify required parameter 'getGoodsStatsRequest' is not null or undefined
            if (getGoodsStatsRequest === null || getGoodsStatsRequest === undefined) {
                throw new RequiredError('getGoodsStatsRequest','Required parameter getGoodsStatsRequest was null or undefined when calling getGoodsStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/skus`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsStatsRequest != null ? getGoodsStatsRequest : {}) : (((getGoodsStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferCardsContentStatus.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferCardsContentStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferCardsContentStatusRequest != null ? getOfferCardsContentStatusRequest : {}) : (((getOfferCardsContentStatusRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (shopSku) {
                localVarQueryParameter['shop_sku'] = shopSku.join(COLLECTION_FORMATS["csv"]);
            }

            if (mappingKind !== undefined) {
                localVarQueryParameter['mapping_kind'] = ((mappingKind:any):string);
            }

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS["csv"]);
            }

            if (availability) {
                localVarQueryParameter['availability'] = availability.join(COLLECTION_FORMATS["csv"]);
            }

            if (categoryId) {
                localVarQueryParameter['category_id'] = categoryId.join(COLLECTION_FORMATS["csv"]);
            }

            if (vendor) {
                localVarQueryParameter['vendor'] = vendor.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferMappingsRequest != null ? getOfferMappingsRequest : {}) : (((getOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferRecommendations.');
            }
            // verify required parameter 'getOfferRecommendationsRequest' is not null or undefined
            if (getOfferRecommendationsRequest === null || getOfferRecommendationsRequest === undefined) {
                throw new RequiredError('getOfferRecommendationsRequest','Required parameter getOfferRecommendationsRequest was null or undefined when calling getOfferRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/offers/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferRecommendationsRequest != null ? getOfferRecommendationsRequest : {}) : (((getOfferRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = ((query:any):string);
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (shopCategoryId !== undefined) {
                localVarQueryParameter['shopCategoryId'] = ((shopCategoryId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (matched !== undefined) {
                localVarQueryParameter['matched'] = ((matched:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrder.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/business-buyer`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/documents`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию на ярлыках, которые клеятся на коробки в заказе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Данные для самостоятельного изготовления ярлыков
         * @throws {RequiredError}
         */
        getOrderLabelsData(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderLabelsData.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderLabelsData.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/labels/data`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrders.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status).join(COLLECTION_FORMATS["csv"]);
            }

            if (substatus) {
                localVarQueryParameter['substatus'] = Array.from(substatus).join(COLLECTION_FORMATS["csv"]);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateFrom !== undefined) {
                localVarQueryParameter['supplierShipmentDateFrom'] = ((supplierShipmentDateFrom:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateTo !== undefined) {
                localVarQueryParameter['supplierShipmentDateTo'] = ((supplierShipmentDateTo:any):Date).toISOString().slice(0, 10);
            }

            if (updatedAtFrom !== undefined) {
                localVarQueryParameter['updatedAtFrom'] = ((updatedAtFrom:any):Date).toISOString();
            }

            if (updatedAtTo !== undefined) {
                localVarQueryParameter['updatedAtTo'] = ((updatedAtTo:any):Date).toISOString();
            }

            if (dispatchType !== undefined) {
                localVarQueryParameter['dispatchType'] = ((dispatchType:any):string);
            }

            if (fake !== undefined) {
                localVarQueryParameter['fake'] = ((fake:any):string);
            }

            if (hasCis !== undefined) {
                localVarQueryParameter['hasCis'] = ((hasCis:any):string);
            }

            if (onlyWaitingForCancellationApprove !== undefined) {
                localVarQueryParameter['onlyWaitingForCancellationApprove'] = ((onlyWaitingForCancellationApprove:any):string);
            }

            if (onlyEstimatedDelivery !== undefined) {
                localVarQueryParameter['onlyEstimatedDelivery'] = ((onlyEstimatedDelivery:any):string);
            }

            if (buyerType !== undefined) {
                localVarQueryParameter['buyerType'] = ((buyerType:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrdersStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOrdersStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOrdersStatsRequest != null ? getOrdersStatsRequest : {}) : (((getOrdersStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = ((archived:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPricesByOfferIds.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPricesByOfferIdsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPricesByOfferIdsRequest != null ? getPricesByOfferIdsRequest : {}) : (((getPricesByOfferIdsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromoOffers.');
            }
            // verify required parameter 'getPromoOffersRequest' is not null or undefined
            if (getPromoOffersRequest === null || getPromoOffersRequest === undefined) {
                throw new RequiredError('getPromoOffersRequest','Required parameter getPromoOffersRequest was null or undefined when calling getPromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromoOffersRequest != null ? getPromoOffersRequest : {}) : (((getPromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromos.');
            }
            const localVarPath = `/businesses/{businessId}/promos`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromosRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromosRequest != null ? getPromosRequest : {}) : (((getPromosRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список заказов, которые повлияли на индекс качества магазина. Чтобы узнать значение индекса качества, выполните запрос [POST businesses/{businessId}/ratings/quality](../../reference/ratings/getQualityRatings.md).  |**⚙️ Лимит:** 100000 запросов в час| |-| 
         * @summary Заказы, которые повлияли на индекс качества
         * @throws {RequiredError}
         */
        getQualityRatingDetails(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getQualityRatingDetails.');
            }
            const localVarPath = `/campaigns/{campaignId}/ratings/quality/details`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getQualityRatings.');
            }
            // verify required parameter 'getQualityRatingRequest' is not null or undefined
            if (getQualityRatingRequest === null || getQualityRatingRequest === undefined) {
                throw new RequiredError('getQualityRatingRequest','Required parameter getQualityRatingRequest was null or undefined when calling getQualityRatings.');
            }
            const localVarPath = `/businesses/{businessId}/ratings/quality`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQualityRatingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQualityRatingRequest != null ? getQualityRatingRequest : {}) : (((getQualityRatingRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'reportId' is not null or undefined
            if (reportId === null || reportId === undefined) {
                throw new RequiredError('reportId','Required parameter reportId was null or undefined when calling getReportInfo.');
            }
            const localVarPath = `/reports/info/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturn.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Загружает заявление покупателя на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение заявления на возврат
         * @throws {RequiredError}
         */
        getReturnApplication(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturnApplication.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturnApplication.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturnApplication.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'imageHash' is not null or undefined
            if (imageHash === null || imageHash === undefined) {
                throw new RequiredError('imageHash','Required parameter imageHash was null or undefined when calling getReturnPhoto.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageHash"}}`, encodeURIComponent(String(imageHash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturns.');
            }
            const localVarPath = `/campaigns/{campaignId}/returns`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS["csv"]);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = ((type:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (fromDate2 !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate2:any):Date).toISOString().slice(0, 10);
            }

            if (toDate2 !== undefined) {
                localVarQueryParameter['to_date'] = ((toDate2:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию об отгрузке по ее идентификатору. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации об одной отгрузке
         * @throws {RequiredError}
         */
        getShipment(campaignId: number, shipmentId: number, cancelledOrders?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getShipment.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling getShipment.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (cancelledOrders !== undefined) {
                localVarQueryParameter['cancelledOrders'] = ((cancelledOrders:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о возможности печати ярлыков-наклеек для заказов в отгрузке. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации о возможности печати ярлыков (FBS)
         * @throws {RequiredError}
         */
        getShipmentOrdersInfo(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getShipmentOrdersInfo.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling getShipmentOrdersInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/orders/info`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getStocks.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/stocks`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getWarehouseStocksRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getWarehouseStocksRequest != null ? getWarehouseStocksRequest : {}) : (((getWarehouseStocksRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            // verify required parameter 'getSuggestedOfferMappingEntriesRequest' is not null or undefined
            if (getSuggestedOfferMappingEntriesRequest === null || getSuggestedOfferMappingEntriesRequest === undefined) {
                throw new RequiredError('getSuggestedOfferMappingEntriesRequest','Required parameter getSuggestedOfferMappingEntriesRequest was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingEntriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingEntriesRequest != null ? getSuggestedOfferMappingEntriesRequest : {}) : (((getSuggestedOfferMappingEntriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getSuggestedOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/suggestions`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingsRequest != null ? getSuggestedOfferMappingsRequest : {}) : (((getSuggestedOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedPrices.');
            }
            // verify required parameter 'suggestPricesRequest' is not null or undefined
            if (suggestPricesRequest === null || suggestPricesRequest === undefined) {
                throw new RequiredError('suggestPricesRequest','Required parameter suggestPricesRequest was null or undefined when calling getSuggestedPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof suggestPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(suggestPricesRequest != null ? suggestPricesRequest : {}) : (((suggestPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список складов и, если склады объединены, список групп складов. [Что такое группы складов и зачем они нужны](https://yandex.ru/support/marketplace/assortment/operations/stocks.html#unified-stocks)  Среди прочего запрос позволяет определить идентификатор, который нужно использовать при передаче остатков для группы складов.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Список складов и групп складов
         * @throws {RequiredError}
         */
        getWarehouses(businessId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getWarehouses.');
            }
            const localVarPath = `/businesses/{businessId}/warehouses`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Передает Маркету коды маркировки для единиц товара в указанном заказе.  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  {% note warning %}  Прежде чем работать с этим методом, обязательно прочтите [статью о работе с маркируемыми товарами](https://yandex.ru/support/marketplace/orders/cz.html).  {% endnote %}  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кодов маркировки единиц товара
         * @throws {RequiredError}
         */
        provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling provideOrderItemIdentifiers.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling provideOrderItemIdentifiers.');
            }
            // verify required parameter 'provideOrderItemIdentifiersRequest' is not null or undefined
            if (provideOrderItemIdentifiersRequest === null || provideOrderItemIdentifiersRequest === undefined) {
                throw new RequiredError('provideOrderItemIdentifiersRequest','Required parameter provideOrderItemIdentifiersRequest was null or undefined when calling provideOrderItemIdentifiers.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/identifiers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof provideOrderItemIdentifiersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(provideOrderItemIdentifiersRequest != null ? provideOrderItemIdentifiersRequest : {}) : (((provideOrderItemIdentifiersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling putBidsForBusiness.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling putBidsForCampaign.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}/bids`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling refreshFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling refreshFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/refresh`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionChildren.');
            }
            const localVarPath = `/regions/{regionId}/children`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionsById.');
            }
            const localVarPath = `/regions/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling searchRegionsByName.');
            }
            const localVarPath = `/regions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию об отгрузках по заданным параметрам:  * дате; * статусу; * идентификаторам заказов.  Результаты возвращаются постранично. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации о нескольких отгрузках
         * @throws {RequiredError}
         */
        searchShipments(campaignId: number, searchShipmentsRequest: SearchShipmentsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling searchShipments.');
            }
            // verify required parameter 'searchShipmentsRequest' is not null or undefined
            if (searchShipmentsRequest === null || searchShipmentsRequest === undefined) {
                throw new RequiredError('searchShipmentsRequest','Required parameter searchShipmentsRequest was null or undefined when calling searchShipments.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof searchShipmentsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchShipmentsRequest != null ? searchShipmentsRequest : {}) : (((searchShipmentsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling sendFileToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/file/send`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'sendMessageToChatRequest' is not null or undefined
            if (sendMessageToChatRequest === null || sendMessageToChatRequest === undefined) {
                throw new RequiredError('sendMessageToChatRequest','Required parameter sendMessageToChatRequest was null or undefined when calling sendMessageToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/message`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof sendMessageToChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sendMessageToChatRequest != null ? sendMessageToChatRequest : {}) : (((sendMessageToChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'setFeedParamsRequest' is not null or undefined
            if (setFeedParamsRequest === null || setFeedParamsRequest === undefined) {
                throw new RequiredError('setFeedParamsRequest','Required parameter setFeedParamsRequest was null or undefined when calling setFeedParams.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/params`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setFeedParamsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setFeedParamsRequest != null ? setFeedParamsRequest : {}) : (((setFeedParamsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note tip \"Подходит и для DBS\" %}  Запрос предназначен для работы с FBS-заказами, но вы можете использовать его для обработки DBS-заказов, если это удобно.  {% endnote %}  Позволяет выполнить три операции:  * передать Маркету информацию о распределении товаров по коробкам; * передать Маркету коды маркировки для товаров; * удалить товар из заказа, если его не оказалось на складе.  Если нужно что-то поправить в переданных данных, просто повторите запрос — это можно делать сколько угодно раз до перевода заказа в статус **Готов к отгрузке**. ⚠️ Если вы меняете раскладку уже после печати и расклейки ярлыков, не забудье перепечатать их и наклеить заново.  ## Как передать информацию о распределении товаров  В этом запросе вам нужно передать Маркету список коробок и указать, какие именно товары лежат в каждой из них. Коробки могут быть двух типов:  * **Содержащие товары целиком.** Такая коробка может содержать сколько угодно единиц любых товаров.  * **Содержащие часть товара.** Такие коробки содержат по одной части одного товара. Например, одна содержит внешний блок кондиционера, а другая — внутренний блок.  ⚠️ Одна коробка не может содержать и товары целиком, и части товаров.  ## Как передавать коды маркировки  Если в заказе есть товары, подлежащие маркировке, в запросе нужно передать соответствующие уникальные коды. [Что такое маркировка?](https://yandex.ru/support/marketplace/orders/cz.html)  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  Если товар едет в нескольких коробках, код маркировки нужно передать для каждой из них.  ## Как удалить товар из заказа  Чтобы удалить товар из заказа:  1. Добавьте в запрос `allowRemove: true`. 2. Передайте распределение по коробкам без товара, который нужно удалить.  {% note warning \"Удаление нельзя отменить\" %}  Эта операция необратима: покупатель сразу получит уведомление, а состав заказа изменится.  {% endnote %}  Чтобы удалить позицию целиком, не передавайте соответствующий `OrderBoxLayoutItemDTO`. Чтобы уменьшить количество товара, передайте уменьшенное значение в поле `fullCount`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если вы не можете отгрузить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  ## Примеры  {% cut \"Товар умещается в коробку\" %}  Вот как будет выглядеть запрос, если в одной коробке едут:    * три единицы одного товара, требующего маркировки;   * одна единица другого товара, не требущего маркировки.    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"fullCount\": 3,                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           },                           {                               \"cis\": \"010304109478gftJ14545762!\\u001dhGt264\"                           },                           {                               \"cis\": \"010304109478fRs28323ks23!\\u001dhet201\"                           }                       ]                   },                   {                       \"id\": 654321,                       \"fullCount\": 1                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Товар едет в разных коробках\" %}  Вот как будет выглядеть запрос, если товар едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Одинаковые товары, где каждый едет в нескольких коробках\" %}  Вот как будет выглядеть запрос, если каждый из двух одинаковых товаров едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Подготовка заказа
         * @throws {RequiredError}
         */
        setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderBoxLayout.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderBoxLayout.');
            }
            // verify required parameter 'setOrderBoxLayoutRequest' is not null or undefined
            if (setOrderBoxLayoutRequest === null || setOrderBoxLayoutRequest === undefined) {
                throw new RequiredError('setOrderBoxLayoutRequest','Required parameter setOrderBoxLayoutRequest was null or undefined when calling setOrderBoxLayout.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/boxes`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderBoxLayoutRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderBoxLayoutRequest != null ? setOrderBoxLayoutRequest : {}) : (((setOrderBoxLayoutRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Отгружаемый Маркету заказ может не влезть в одну коробку или упаковку — в этом случае получается, что он занимает несколько грузовых мест.  Количество грузовых мест нужно обязательно передавать Маркету, если оно не равно 1. Это делается перед переводом его в статус **Готов к отгрузке**. Подробно о том, что в какой момент нужно передавать, рассказано в [пошаговой инструкции](../../step-by-step/fbs.md).  Метод устроен немного нестандартно: количество задается длиной массива пустых объектов.  Раньше метод требовал передачи большего количества данных. Запросы, оформленные по старому образцу, работают, но лучше делать по-новому.  {% cut \"Как было раньше\" %}  Структура тела PUT-запроса:  ``` {   \"boxes\":   [     {       \"fulfilmentId\": \"{string}\",       \"weight\": {int64},       \"width\": {int64},       \"height\": {int64},       \"depth\": {int64},       \"items\":       [         {           \"id\": {int64},           \"count\": {int32}         },         ...       ]     },     ...   ] } ``` | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `boxes`       |           | Список грузовых мест.       |  **Параметры, вложенные в `boxes`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `fulfilmentId`       |  String   | Идентификатор грузового места в информационной системе магазина. Сформируйте идентификатор по шаблону: `номер заказа на Маркете-номер грузового места`. Например, `7206821‑1, 7206821‑2` и т. д. | | `weight`       | Int64        | Масса брутто грузового места (суммарная масса упаковки и содержимого) в граммах. | | `width`       | Int64   | Ширина грузового места в сантиметрах.       | | `height`       | Int64   | Высота грузового места в сантиметрах.       | | `depth`       | Int64   | Глубина грузового места в сантиметрах.        | | `items`       | Int64   | Список товаров в грузовом месте.       |  **Параметры, вложенные в `items`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `id`       | Int64     | Идентификатор товара в рамках заказа.   | | `count`    | Int32     | Количество единиц товара в грузовом месте.       |  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача количества грузовых мест в заказе
         * @throws {RequiredError}
         */
        setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'setOrderShipmentBoxesRequest' is not null or undefined
            if (setOrderShipmentBoxesRequest === null || setOrderShipmentBoxesRequest === undefined) {
                throw new RequiredError('setOrderShipmentBoxesRequest','Required parameter setOrderShipmentBoxesRequest was null or undefined when calling setOrderShipmentBoxes.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderShipmentBoxesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderShipmentBoxesRequest != null ? setOrderShipmentBoxesRequest : {}) : (((setOrderShipmentBoxesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает Маркету количество коробов или палет в отгрузке для доверительной приемки. Подробнее про доверительную приемку написано в [Справке Маркета](https://yandex.ru/support/marketplace/orders/fbs/process.html#acceptance).  Получить PDF-файл с ярлыками для упаковок можно с помощью запроса [GET campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallet/labels](../../reference/shipments/downloadShipmentPalletLabels.md). |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Передача количества упаковок в отгрузке
         * @throws {RequiredError}
         */
        setShipmentPalletsCount(campaignId: number, shipmentId: number, setShipmentPalletsCountRequest: SetShipmentPalletsCountRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setShipmentPalletsCount.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling setShipmentPalletsCount.');
            }
            // verify required parameter 'setShipmentPalletsCountRequest' is not null or undefined
            if (setShipmentPalletsCountRequest === null || setShipmentPalletsCountRequest === undefined) {
                throw new RequiredError('setShipmentPalletsCountRequest','Required parameter setShipmentPalletsCountRequest was null or undefined when calling setShipmentPalletsCount.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallets`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setShipmentPalletsCountRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setShipmentPalletsCountRequest != null ? setShipmentPalletsCountRequest : {}) : (((setShipmentPalletsCountRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            // verify required parameter 'skipGoodsFeedbackReactionRequest' is not null or undefined
            if (skipGoodsFeedbackReactionRequest === null || skipGoodsFeedbackReactionRequest === undefined) {
                throw new RequiredError('skipGoodsFeedbackReactionRequest','Required parameter skipGoodsFeedbackReactionRequest was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/skip-reaction`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof skipGoodsFeedbackReactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(skipGoodsFeedbackReactionRequest != null ? skipGoodsFeedbackReactionRequest : {}) : (((skipGoodsFeedbackReactionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Переносит указанные заказы из указанной отгрузки в следующую отгрузку. [Что такое отгрузка?](https://yandex.ru/support/marketplace/orders/fbs/process.html#ship)  Используйте этот запрос, если не успеваете собрать и упаковать заказы вовремя.  {% note warning \"Такие переносы снижают индекс качества магазина\" %}  Этот запрос предназначен для исключительных случаев. Если вы будете переносить заказы слишком часто, магазин столкнется с ограничениями. [Что за ограничения?](https://yandex.ru/support/marketplace/quality/score/fbs.html)  {% endnote %}  Переносить заказы можно, если до формирования отгрузки осталось больше получаса.  Перенос происходит не мгновенно, а занимает несколько минут.  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Перенос заказов в следующую отгрузку
         * @throws {RequiredError}
         */
        transferOrdersFromShipment(campaignId: number, shipmentId: number, transferOrdersFromShipmentRequest: TransferOrdersFromShipmentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling transferOrdersFromShipment.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling transferOrdersFromShipment.');
            }
            // verify required parameter 'transferOrdersFromShipmentRequest' is not null or undefined
            if (transferOrdersFromShipmentRequest === null || transferOrdersFromShipmentRequest === undefined) {
                throw new RequiredError('transferOrdersFromShipmentRequest','Required parameter transferOrdersFromShipmentRequest was null or undefined when calling transferOrdersFromShipment.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/orders/transfer`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof transferOrdersFromShipmentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(transferOrdersFromShipmentRequest != null ? transferOrdersFromShipmentRequest : {}) : (((transferOrdersFromShipmentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateBusinessPrices.');
            }
            // verify required parameter 'updateBusinessPricesRequest' is not null or undefined
            if (updateBusinessPricesRequest === null || updateBusinessPricesRequest === undefined) {
                throw new RequiredError('updateBusinessPricesRequest','Required parameter updateBusinessPricesRequest was null or undefined when calling updateBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/offer-prices/updates`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateBusinessPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateBusinessPricesRequest != null ? updateBusinessPricesRequest : {}) : (((updateBusinessPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateCampaignOffers.');
            }
            // verify required parameter 'updateCampaignOffersRequest' is not null or undefined
            if (updateCampaignOffersRequest === null || updateCampaignOffersRequest === undefined) {
                throw new RequiredError('updateCampaignOffersRequest','Required parameter updateCampaignOffersRequest was null or undefined when calling updateCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/update`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateCampaignOffersRequest != null ? updateCampaignOffersRequest : {}) : (((updateCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateGoodsFeedbackComment.');
            }
            // verify required parameter 'updateGoodsFeedbackCommentRequest' is not null or undefined
            if (updateGoodsFeedbackCommentRequest === null || updateGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('updateGoodsFeedbackCommentRequest','Required parameter updateGoodsFeedbackCommentRequest was null or undefined when calling updateGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateGoodsFeedbackCommentRequest != null ? updateGoodsFeedbackCommentRequest : {}) : (((updateGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferContent.');
            }
            // verify required parameter 'updateOfferContentRequest' is not null or undefined
            if (updateOfferContentRequest === null || updateOfferContentRequest === undefined) {
                throw new RequiredError('updateOfferContentRequest','Required parameter updateOfferContentRequest was null or undefined when calling updateOfferContent.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferContentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferContentRequest != null ? updateOfferContentRequest : {}) : (((updateOfferContentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOfferMappingEntries.');
            }
            // verify required parameter 'updateOfferMappingEntryRequest' is not null or undefined
            if (updateOfferMappingEntryRequest === null || updateOfferMappingEntryRequest === undefined) {
                throw new RequiredError('updateOfferMappingEntryRequest','Required parameter updateOfferMappingEntryRequest was null or undefined when calling updateOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingEntryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingEntryRequest != null ? updateOfferMappingEntryRequest : {}) : (((updateOfferMappingEntryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferMappings.');
            }
            // verify required parameter 'updateOfferMappingsRequest' is not null or undefined
            if (updateOfferMappingsRequest === null || updateOfferMappingsRequest === undefined) {
                throw new RequiredError('updateOfferMappingsRequest','Required parameter updateOfferMappingsRequest was null or undefined when calling updateOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingsRequest != null ? updateOfferMappingsRequest : {}) : (((updateOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Изменяет состав заказа, если позволяет выбранная служба доставки, в случаях:  * покупатель уменьшил количество товара; * магазин не может поставить все товары в заказе.  Для этого заказ должен находится в статусе `\"status\": \"PROCESSING\"` этапа обработки `\"substatus\": \"STARTED\"`. После передачи статуса `\"substatus\": \"READY_TO_SHIP\"` изменить состав невозможно.  Если одинаковых товаров несколько, для уменьшения количества передайте обновленное значение в атрибуте `count` параметра `item`.  Чтобы полностью удалить товар из заказа:  * передайте значение `0`; или * не передавайте параметр `item`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если необходимо удалить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  **Возврат денег покупателю**  Если покупатель оплатил товар при оформлении, Маркет вернет ему деньги за удаленные из заказа товары в течение двух дней:  * при оплате банковской картой — с момента, когда магазин переведет заказ в статус `SHIPPED`;  * при оплате через Apple Pay или Google Pay — с момента, когда магазин удалит товар из заказа.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Удаление товара из заказа или уменьшение числа единиц
         * @throws {RequiredError}
         */
        updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderItems.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderItems.');
            }
            // verify required parameter 'updateOrderItemRequest' is not null or undefined
            if (updateOrderItemRequest === null || updateOrderItemRequest === undefined) {
                throw new RequiredError('updateOrderItemRequest','Required parameter updateOrderItemRequest was null or undefined when calling updateOrderItems.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/items`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderItemRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderItemRequest != null ? updateOrderItemRequest : {}) : (((updateOrderItemRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет статус заказа. Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статуса одного заказа
         * @throws {RequiredError}
         */
        updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStatus.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderStatus.');
            }
            // verify required parameter 'updateOrderStatusRequest' is not null or undefined
            if (updateOrderStatusRequest === null || updateOrderStatusRequest === undefined) {
                throw new RequiredError('updateOrderStatusRequest','Required parameter updateOrderStatusRequest was null or undefined when calling updateOrderStatus.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/status`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStatusRequest != null ? updateOrderStatusRequest : {}) : (((updateOrderStatusRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет статусы нескольких заказов.  Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"`и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  Максимальное количество заказов, у которых можно изменить статус в одном запросе, — 30.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статусов нескольких заказов
         * @throws {RequiredError}
         */
        updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStatuses.');
            }
            // verify required parameter 'updateOrderStatusesRequest' is not null or undefined
            if (updateOrderStatusesRequest === null || updateOrderStatusesRequest === undefined) {
                throw new RequiredError('updateOrderStatusesRequest','Required parameter updateOrderStatusesRequest was null or undefined when calling updateOrderStatuses.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/status-update`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStatusesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStatusesRequest != null ? updateOrderStatusesRequest : {}) : (((updateOrderStatusesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updatePrices.');
            }
            // verify required parameter 'updatePricesRequest' is not null or undefined
            if (updatePricesRequest === null || updatePricesRequest === undefined) {
                throw new RequiredError('updatePricesRequest','Required parameter updatePricesRequest was null or undefined when calling updatePrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePricesRequest != null ? updatePricesRequest : {}) : (((updatePricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updatePromoOffers.');
            }
            // verify required parameter 'updatePromoOffersRequest' is not null or undefined
            if (updatePromoOffersRequest === null || updatePromoOffersRequest === undefined) {
                throw new RequiredError('updatePromoOffersRequest','Required parameter updatePromoOffersRequest was null or undefined when calling updatePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePromoOffersRequest != null ? updatePromoOffersRequest : {}) : (((updatePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает данные об остатках товаров на витрине.  Обязательно указывайте SKU **в точности** так, как он указан в каталоге. Например, _557722_ и _0557722_ — это два разных SKU.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-| 
         * @summary Передача информации об остатках
         * @throws {RequiredError}
         */
        updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateStocks.');
            }
            // verify required parameter 'updateStocksRequest' is not null or undefined
            if (updateStocksRequest === null || updateStocksRequest === undefined) {
                throw new RequiredError('updateStocksRequest','Required parameter updateStocksRequest was null or undefined when calling updateStocks.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/stocks`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateStocksRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateStocksRequest != null ? updateStocksRequest : {}) : (((updateStocksRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type FbsApiType = { 
    addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions): Promise<AddOffersToArchiveResponse>,

    calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions): Promise<CalculateTariffsResponse>,

    confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    confirmShipment(campaignId: number, shipmentId: number, confirmShipmentRequest?: ConfirmShipmentRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions): Promise<CreateChatResponse>,

    deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions): Promise<DeleteCampaignOffersResponse>,

    deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions): Promise<DeleteOffersResponse>,

    deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions): Promise<DeleteOffersFromArchiveResponse>,

    deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions): Promise<DeletePromoOffersResponse>,

    downloadShipmentAct(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<File>,

    downloadShipmentDiscrepancyAct(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<File>,

    downloadShipmentInboundAct(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<File>,

    downloadShipmentPalletLabels(campaignId: number, shipmentId: number, format?: ShipmentPalletLabelPageFormatType, options?: RequestOptions): Promise<File>,

    downloadShipmentReceptionTransferAct(campaignId: number, warehouseId?: number, options?: RequestOptions): Promise<File>,

    downloadShipmentTransportationWaybill(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<File>,

    generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options?: RequestOptions): Promise<File>,

    generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options?: RequestOptions): Promise<File>,

    generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShipmentListDocumentReport(generateShipmentListDocumentReportRequest: GenerateShipmentListDocumentReportRequest, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions): Promise<GetAllOffersResponse>,

    getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions): Promise<GetBidsInfoResponse>,

    getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions): Promise<GetBidsRecommendationsResponse>,

    getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,

    getBusinessSettings(businessId: number, options?: RequestOptions): Promise<GetBusinessSettingsResponse>,

    getCampaign(campaignId: number, options?: RequestOptions): Promise<GetCampaignResponse>,

    getCampaignLogins(campaignId: number, options?: RequestOptions): Promise<GetCampaignLoginsResponse>,

    getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetCampaignOffersResponse>,

    getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,

    getCampaignRegion(campaignId: number, options?: RequestOptions): Promise<GetCampaignRegionResponse>,

    getCampaignSettings(campaignId: number, options?: RequestOptions): Promise<GetCampaignSettingsResponse>,

    getCampaigns(page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,

    getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,

    getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions): Promise<GetCategoriesMaxSaleQuantumResponse>,

    getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions): Promise<GetCategoriesResponse>,

    getCategoryContentParameters(categoryId: number, options?: RequestOptions): Promise<GetCategoryContentParametersResponse>,

    getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatHistoryResponse>,

    getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatsResponse>,

    getDeliveryServices(options?: RequestOptions): Promise<GetDeliveryServicesResponse>,

    getFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<GetFeedResponse>,

    getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions): Promise<GetFeedIndexLogsResponse>,

    getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions): Promise<GetFeedbackListResponse>,

    getFeeds(campaignId: number, options?: RequestOptions): Promise<GetFeedsResponse>,

    getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetGoodsFeedbackCommentsResponse>,

    getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions): Promise<GetGoodsFeedbackResponse>,

    getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions): Promise<GetGoodsStatsResponse>,

    getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetHiddenOffersResponse>,

    getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions): Promise<GetOfferCardsContentStatusResponse>,

    getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferMappingEntriesResponse>,

    getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions): Promise<GetOfferMappingsResponse>,

    getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferRecommendationsResponse>,

    getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetOffersResponse>,

    getOrder(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderResponse>,

    getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessBuyerInfoResponse>,

    getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessDocumentsInfoResponse>,

    getOrderLabelsData(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderLabelsDataResponse>,

    getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOrdersResponse>,

    getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions): Promise<GetOrdersStatsResponse>,

    getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions): Promise<GetPricesResponse>,

    getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions): Promise<GetPricesByOfferIdsResponse>,

    getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetPromoOffersResponse>,

    getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions): Promise<GetPromosResponse>,

    getQualityRatingDetails(campaignId: number, options?: RequestOptions): Promise<GetQualityRatingDetailsResponse>,

    getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions): Promise<GetQualityRatingResponse>,

    getReportInfo(reportId: string, options?: RequestOptions): Promise<GetReportInfoResponse>,

    getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<GetReturnResponse>,

    getReturnApplication(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<File>,

    getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions): Promise<File>,

    getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions): Promise<GetReturnsResponse>,

    getShipment(campaignId: number, shipmentId: number, cancelledOrders?: boolean, options?: RequestOptions): Promise<GetShipmentResponse>,

    getShipmentOrdersInfo(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<GetShipmentOrdersInfoResponse>,

    getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions): Promise<GetWarehouseStocksResponse>,

    getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingEntriesResponse>,

    getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingsResponse>,

    getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions): Promise<SuggestPricesResponse>,

    getWarehouses(businessId: number, options?: RequestOptions): Promise<GetWarehousesResponse>,

    provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options?: RequestOptions): Promise<ProvideOrderItemIdentifiersResponse>,

    putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    refreshFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<EmptyApiResponse>,

    searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetRegionWithChildrenResponse>,

    searchRegionsById(regionId: number, options?: RequestOptions): Promise<GetRegionsResponse>,

    searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetRegionsResponse>,

    searchShipments(campaignId: number, searchShipmentsRequest: SearchShipmentsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<SearchShipmentsResponse>,

    sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions): Promise<EmptyApiResponse>,

    sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options?: RequestOptions): Promise<SetOrderBoxLayoutResponse>,

    setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options?: RequestOptions): Promise<SetOrderShipmentBoxesResponse>,

    setShipmentPalletsCount(campaignId: number, shipmentId: number, setShipmentPalletsCountRequest: SetShipmentPalletsCountRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    transferOrdersFromShipment(campaignId: number, shipmentId: number, transferOrdersFromShipmentRequest: TransferOrdersFromShipmentRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<UpdateGoodsFeedbackCommentResponse>,

    updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions): Promise<UpdateOfferContentResponse>,

    updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions): Promise<UpdateOfferMappingsResponse>,

    updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options?: RequestOptions): Promise<Response>,

    updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options?: RequestOptions): Promise<UpdateOrderStatusResponse>,

    updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options?: RequestOptions): Promise<UpdateOrderStatusesResponse>,

    updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions): Promise<UpdatePromoOffersResponse>,

    updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * FbsApi - factory function to inject configuration 
 * @export
 */
export const FbsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): FbsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).addHiddenOffers(campaignId, addHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions = {}): Promise<AddOffersToArchiveResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).addOffersToArchive(businessId, addOffersToArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions = {}): Promise<CalculateTariffsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).calculateTariffs(calculateTariffsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).confirmBusinessPrices(businessId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).confirmCampaignPrices(campaignId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает отгрузку товаров в сортировочный центр или пункт приема заказов. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Подтверждение отгрузки
         * @throws {RequiredError}
         */
        confirmShipment(campaignId: number, shipmentId: number, confirmShipmentRequest?: ConfirmShipmentRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).confirmShipment(campaignId, shipmentId, confirmShipmentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions = {}): Promise<CreateChatResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).createChat(businessId, createChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions = {}): Promise<DeleteCampaignOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).deleteCampaignOffers(campaignId, deleteCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).deleteGoodsFeedbackComment(businessId, deleteGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).deleteHiddenOffers(campaignId, deleteHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions = {}): Promise<DeleteOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).deleteOffers(businessId, deleteOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions = {}): Promise<DeleteOffersFromArchiveResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).deleteOffersFromArchive(businessId, deleteOffersFromArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions = {}): Promise<DeletePromoOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).deletePromoOffers(businessId, deletePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Экспресс‑доставка\" %}  Если ваш магазин подключен к экспресс‑доставке и вы отгружаете заказы курьерам Яндекс Go, подготавливать акт приема‑передачи не нужно.  {% endnote %}  Запрос формирует акт приема-передачи заказов, входящих в отгрузку, и возвращает акт в формате PDF. В акте содержатся собранные и готовые к отправке заказы.  При формировании акта Маркет автоматически находит и подставляет в шаблон следующие данные:  {% cut \"Данные, из которых Маркет формирует акт\" %}  | **Данные в акте**                                         | **Описание**                                                                                                                                                                                                                                                         | | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Дата                                                      | Дата запроса.                                                                                                                                                                                                                                                        | | Отправитель                                               | Название вашего юридического лица, указанное в кабинете продавца на Маркете.                                                                                                                                                                                         | | Исполнитель                                               | Название юридического лица сортировочного центра или службы доставки.                                                                                                                                                                                                | | № отправления в системе заказчика                         | Ваш идентификатор заказа, который вы указали в ответе на запрос [POST order/accept](../../pushapi/reference/orderAccept.md) от Маркета.                                                                                                                              | | № отправления в системе исполнителя (субподрядчика)       | Идентификатор заказа на Маркете, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md).                                                                                                                             | | Объявленная ценность                                      | Общая сумма заказа без учета стоимости доставки, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                       | | Вес                                                       | Масса брутто грузового места (суммарная масса упаковки и содержимого), как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md). | | Количество мест                                           | Количество грузовых мест в заказе, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                                     |  {% endcut %}  Остальные поля нужно заполнить самостоятельно в распечатанном акте. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение акта приема-передачи
         * @throws {RequiredError}
         */
        downloadShipmentAct(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).downloadShipmentAct(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает акт расхождений для заданной отгрузки. |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение акта расхождений
         * @throws {RequiredError}
         */
        downloadShipmentDiscrepancyAct(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).downloadShipmentDiscrepancyAct(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает фактический акт приема-передачи для заданной отгрузки.  Такой акт становится доступен спустя несколько часов после завершения отгрузки. Он может понадобиться, если после отгрузки обнаружатся расхождения.  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение фактического акта приема-передачи
         * @throws {RequiredError}
         */
        downloadShipmentInboundAct(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).downloadShipmentInboundAct(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * PDF-файл с ярлыками на каждый короб или палету в отгрузке для доверительной приемки. Подробнее про доверительную приемку написано в [Справке Маркета](https://yandex.ru/support/marketplace/orders/fbs/process.html#acceptance).  Распечатайте по несколько копий каждого ярлыка: на одну тару нужно наклеить минимум 2 ярлыка с разных сторон.  Количество упаковок в отгрузке задается в запросе [PUT campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallets](../../reference/shipments/setShipmentPalletsCount.md). |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Ярлыки для доверительной приемки (FBS)
         * @throws {RequiredError}
         */
        downloadShipmentPalletLabels(campaignId: number, shipmentId: number, format?: ShipmentPalletLabelPageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).downloadShipmentPalletLabels(campaignId, shipmentId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запрос подтверждает ближайшую отгрузку и возвращает акт приема-передачи в формате PDF.  {% note warning \"Экспресс‑доставка\" %}  Если ваш магазин подключен к экспресс‑доставке и вы отгружаете заказы курьерам [Яндекс Go](https://go.yandex/), подготавливать акт приема‑передачи не нужно.  {% endnote %}  В акт входят собранные и готовые к отправке заказы, которые отгружаются в сортировочный центр или пункт приема или курьерам Маркета.  При формировании акта Маркет автоматически находит и подставляет в шаблон следующие данные:  {% cut \"Данные, из которых Маркет формирует акт\" %}  | **Данные в акте**                                   | **Описание**                                                                                                                                                                                                                                                         | | --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Отправитель                                         | Название вашего юридического лица, указанное в кабинете продавца на Маркете.                                                                                                                                                                                         | | Исполнитель                                         | Название юридического лица сортировочного центра или службы доставки.                                                                                                                                                                                                | | № отправления в системе заказчика                   | Ваш идентификатор заказа, который вы указали в ответе на запрос [POST order/accept](../../pushapi/reference/orderAccept.md) от Маркета.                                                                                                                              | | № отправления в системе исполнителя (субподрядчика) | Идентификатор заказа на Маркете, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md).                                                                                                                             | | Объявленная ценность                                | Общая сумма заказа без учета стоимости доставки, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                       | | Стоимость всех товаров в заказе                     | Стоимость всех заказанных товаров.                                                                                                                                                                                                                                   | | Вес                                                 | Масса брутто грузового места (суммарная масса упаковки и содержимого), как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md). | | Количество мест                                     | Количество грузовых мест в заказе, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                                     |  {% endcut %}  Остальные поля нужно заполнить самостоятельно в распечатанном акте. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Подтверждение ближайшей отгрузки и получение акта приема-передачи для нее
         * @throws {RequiredError}
         */
        downloadShipmentReceptionTransferAct(campaignId: number, warehouseId?: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).downloadShipmentReceptionTransferAct(campaignId, warehouseId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает транспортную накладную для заданной отгрузки.  Транспортная накладная понадобится, если вы отгружаете товары непосредственно со своего склада. [Подробно об этом способе отгрузки](https://yandex.ru/support/marketplace/orders/fbs/settings/shipment.html#at-your-warehouse)  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение транспортной накладной
         * @throws {RequiredError}
         */
        downloadShipmentTransportationWaybill(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).downloadShipmentTransportationWaybill(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateBoostConsolidatedReport(generateBoostConsolidatedRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateGoodsFeedbackReport(generateGoodsFeedbackRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по реализации** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#sales-report)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по реализации
         * @throws {RequiredError}
         */
        generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateGoodsRealizationReport(generateGoodsRealizationReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию PDF-файла с ярлыками для переданных заказов. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  Узнать статус генерации и получить ссылку на готовый файл можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в нескольких заказах
         * @throws {RequiredError}
         */
        generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateMassOrderLabelsReport(generateMassOrderLabelsRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Формирует ярлык‑наклейку для коробки в заказе и возвращает ярлык в PDF‑файле.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовый ярлык‑наклейка для коробки в заказе
         * @throws {RequiredError}
         */
        generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateOrderLabel(campaignId, orderId, shipmentId, boxId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает PDF-файл с ярлыками, которые нужно наклеить на коробки перед отгрузкой. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  На вход нужно передать идентификатор заказа и один необязательный параметр, который управляет версткой PDF-файла.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в одном заказе
         * @throws {RequiredError}
         */
        generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateOrderLabels(campaignId, orderId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generatePricesReport(generatePricesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateShelfsStatisticsReport(generateShelfsStatisticsRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **листа сборки** для отгрузки.  Узнать статус генерации и получить ссылку на готовый документ можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение листа сборки
         * @throws {RequiredError}
         */
        generateShipmentListDocumentReport(generateShipmentListDocumentReportRequest: GenerateShipmentListDocumentReportRequest, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateShipmentListDocumentReport(generateShipmentListDocumentReportRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateShowsSalesReport(generateShowsSalesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateUnitedNettingReport(generateUnitedNettingReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).generateUnitedOrdersReport(generateUnitedOrdersRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions = {}): Promise<GetAllOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getAllOffers(campaignId, feedId, chunk, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions = {}): Promise<GetBidsInfoResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getBidsInfoForBusiness(businessId, pageToken, limit, getBidsInfoRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions = {}): Promise<GetBidsRecommendationsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getBidsRecommendations(businessId, getBidsRecommendationsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getBusinessQuarantineOffers(businessId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options?: RequestOptions = {}): Promise<GetBusinessSettingsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getBusinessSettings(businessId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCampaign(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignLoginsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCampaignLogins(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetCampaignOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCampaignOffers(campaignId, getCampaignOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCampaignQuarantineOffers(campaignId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignRegionResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCampaignRegion(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignSettingsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCampaignSettings(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCampaigns(page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCampaignsByLogin(login, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions = {}): Promise<GetCategoriesMaxSaleQuantumResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions = {}): Promise<GetCategoriesResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCategoriesTree(getCategoriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options?: RequestOptions = {}): Promise<GetCategoryContentParametersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getCategoryContentParameters(categoryId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatHistoryResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getChatHistory(businessId, chatId, getChatHistoryRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getChats(businessId, getChatsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает справочник служб доставки: идентификаторы и наименования. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Справочник служб доставки
         * @throws {RequiredError}
         */
        getDeliveryServices(options?: RequestOptions = {}): Promise<GetDeliveryServicesResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getDeliveryServices(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<GetFeedResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions = {}): Promise<GetFeedIndexLogsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getFeedIndexLogs(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions = {}): Promise<GetFeedbackListResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getFeedbackAndCommentUpdates(campaignId, pageToken, limit, fromDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options?: RequestOptions = {}): Promise<GetFeedsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getFeeds(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetGoodsFeedbackCommentsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getGoodsFeedbackComments(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions = {}): Promise<GetGoodsFeedbackResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getGoodsFeedbacks(businessId, pageToken, limit, getGoodsFeedbackRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions = {}): Promise<GetGoodsStatsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getGoodsStats(campaignId, getGoodsStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetHiddenOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getHiddenOffers(campaignId, offerId, pageToken, limit, offset, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions = {}): Promise<GetOfferCardsContentStatusResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOfferCardsContentStatus(businessId, pageToken, limit, getOfferCardsContentStatusRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferMappingEntriesResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOfferMappingEntries(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetOfferMappingsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOfferMappings(businessId, pageToken, limit, getOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferRecommendationsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOfferRecommendations(businessId, getOfferRecommendationsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOffers(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOrder(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessBuyerInfoResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOrderBusinessBuyerInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessDocumentsInfoResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOrderBusinessDocumentsInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию на ярлыках, которые клеятся на коробки в заказе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Данные для самостоятельного изготовления ярлыков
         * @throws {RequiredError}
         */
        getOrderLabelsData(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderLabelsDataResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOrderLabelsData(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOrdersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOrders(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions = {}): Promise<GetOrdersStatsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getOrdersStats(campaignId, pageToken, limit, getOrdersStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions = {}): Promise<GetPricesResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getPrices(campaignId, pageToken, limit, archived, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions = {}): Promise<GetPricesByOfferIdsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getPricesByOfferIds(campaignId, pageToken, limit, getPricesByOfferIdsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetPromoOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getPromoOffers(businessId, getPromoOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions = {}): Promise<GetPromosResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getPromos(businessId, getPromosRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список заказов, которые повлияли на индекс качества магазина. Чтобы узнать значение индекса качества, выполните запрос [POST businesses/{businessId}/ratings/quality](../../reference/ratings/getQualityRatings.md).  |**⚙️ Лимит:** 100000 запросов в час| |-| 
         * @summary Заказы, которые повлияли на индекс качества
         * @throws {RequiredError}
         */
        getQualityRatingDetails(campaignId: number, options?: RequestOptions = {}): Promise<GetQualityRatingDetailsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getQualityRatingDetails(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions = {}): Promise<GetQualityRatingResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getQualityRatings(businessId, getQualityRatingRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options?: RequestOptions = {}): Promise<GetReportInfoResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getReportInfo(reportId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<GetReturnResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getReturn(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Загружает заявление покупателя на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение заявления на возврат
         * @throws {RequiredError}
         */
        getReturnApplication(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getReturnApplication(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getReturnPhoto(campaignId, orderId, returnId, itemId, imageHash, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions = {}): Promise<GetReturnsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getReturns(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию об отгрузке по ее идентификатору. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации об одной отгрузке
         * @throws {RequiredError}
         */
        getShipment(campaignId: number, shipmentId: number, cancelledOrders?: boolean, options?: RequestOptions = {}): Promise<GetShipmentResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getShipment(campaignId, shipmentId, cancelledOrders, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о возможности печати ярлыков-наклеек для заказов в отгрузке. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации о возможности печати ярлыков (FBS)
         * @throws {RequiredError}
         */
        getShipmentOrdersInfo(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<GetShipmentOrdersInfoResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getShipmentOrdersInfo(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions = {}): Promise<GetWarehouseStocksResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getStocks(campaignId, pageToken, limit, getWarehouseStocksRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingEntriesResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getSuggestedOfferMappingEntries(campaignId, getSuggestedOfferMappingEntriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getSuggestedOfferMappings(businessId, getSuggestedOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions = {}): Promise<SuggestPricesResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getSuggestedPrices(campaignId, suggestPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список складов и, если склады объединены, список групп складов. [Что такое группы складов и зачем они нужны](https://yandex.ru/support/marketplace/assortment/operations/stocks.html#unified-stocks)  Среди прочего запрос позволяет определить идентификатор, который нужно использовать при передаче остатков для группы складов.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Список складов и групп складов
         * @throws {RequiredError}
         */
        getWarehouses(businessId: number, options?: RequestOptions = {}): Promise<GetWarehousesResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).getWarehouses(businessId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Передает Маркету коды маркировки для единиц товара в указанном заказе.  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  {% note warning %}  Прежде чем работать с этим методом, обязательно прочтите [статью о работе с маркируемыми товарами](https://yandex.ru/support/marketplace/orders/cz.html).  {% endnote %}  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кодов маркировки единиц товара
         * @throws {RequiredError}
         */
        provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options?: RequestOptions = {}): Promise<ProvideOrderItemIdentifiersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).provideOrderItemIdentifiers(campaignId, orderId, provideOrderItemIdentifiersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).putBidsForBusiness(businessId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).putBidsForCampaign(campaignId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).refreshFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetRegionWithChildrenResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).searchRegionChildren(regionId, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).searchRegionsById(regionId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).searchRegionsByName(name, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию об отгрузках по заданным параметрам:  * дате; * статусу; * идентификаторам заказов.  Результаты возвращаются постранично. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации о нескольких отгрузках
         * @throws {RequiredError}
         */
        searchShipments(campaignId: number, searchShipmentsRequest: SearchShipmentsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<SearchShipmentsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).searchShipments(campaignId, searchShipmentsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).sendFileToChat(businessId, chatId, file, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).sendMessageToChat(businessId, chatId, sendMessageToChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).setFeedParams(campaignId, feedId, setFeedParamsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note tip \"Подходит и для DBS\" %}  Запрос предназначен для работы с FBS-заказами, но вы можете использовать его для обработки DBS-заказов, если это удобно.  {% endnote %}  Позволяет выполнить три операции:  * передать Маркету информацию о распределении товаров по коробкам; * передать Маркету коды маркировки для товаров; * удалить товар из заказа, если его не оказалось на складе.  Если нужно что-то поправить в переданных данных, просто повторите запрос — это можно делать сколько угодно раз до перевода заказа в статус **Готов к отгрузке**. ⚠️ Если вы меняете раскладку уже после печати и расклейки ярлыков, не забудье перепечатать их и наклеить заново.  ## Как передать информацию о распределении товаров  В этом запросе вам нужно передать Маркету список коробок и указать, какие именно товары лежат в каждой из них. Коробки могут быть двух типов:  * **Содержащие товары целиком.** Такая коробка может содержать сколько угодно единиц любых товаров.  * **Содержащие часть товара.** Такие коробки содержат по одной части одного товара. Например, одна содержит внешний блок кондиционера, а другая — внутренний блок.  ⚠️ Одна коробка не может содержать и товары целиком, и части товаров.  ## Как передавать коды маркировки  Если в заказе есть товары, подлежащие маркировке, в запросе нужно передать соответствующие уникальные коды. [Что такое маркировка?](https://yandex.ru/support/marketplace/orders/cz.html)  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  Если товар едет в нескольких коробках, код маркировки нужно передать для каждой из них.  ## Как удалить товар из заказа  Чтобы удалить товар из заказа:  1. Добавьте в запрос `allowRemove: true`. 2. Передайте распределение по коробкам без товара, который нужно удалить.  {% note warning \"Удаление нельзя отменить\" %}  Эта операция необратима: покупатель сразу получит уведомление, а состав заказа изменится.  {% endnote %}  Чтобы удалить позицию целиком, не передавайте соответствующий `OrderBoxLayoutItemDTO`. Чтобы уменьшить количество товара, передайте уменьшенное значение в поле `fullCount`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если вы не можете отгрузить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  ## Примеры  {% cut \"Товар умещается в коробку\" %}  Вот как будет выглядеть запрос, если в одной коробке едут:    * три единицы одного товара, требующего маркировки;   * одна единица другого товара, не требущего маркировки.    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"fullCount\": 3,                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           },                           {                               \"cis\": \"010304109478gftJ14545762!\\u001dhGt264\"                           },                           {                               \"cis\": \"010304109478fRs28323ks23!\\u001dhet201\"                           }                       ]                   },                   {                       \"id\": 654321,                       \"fullCount\": 1                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Товар едет в разных коробках\" %}  Вот как будет выглядеть запрос, если товар едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Одинаковые товары, где каждый едет в нескольких коробках\" %}  Вот как будет выглядеть запрос, если каждый из двух одинаковых товаров едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Подготовка заказа
         * @throws {RequiredError}
         */
        setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options?: RequestOptions = {}): Promise<SetOrderBoxLayoutResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).setOrderBoxLayout(campaignId, orderId, setOrderBoxLayoutRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Отгружаемый Маркету заказ может не влезть в одну коробку или упаковку — в этом случае получается, что он занимает несколько грузовых мест.  Количество грузовых мест нужно обязательно передавать Маркету, если оно не равно 1. Это делается перед переводом его в статус **Готов к отгрузке**. Подробно о том, что в какой момент нужно передавать, рассказано в [пошаговой инструкции](../../step-by-step/fbs.md).  Метод устроен немного нестандартно: количество задается длиной массива пустых объектов.  Раньше метод требовал передачи большего количества данных. Запросы, оформленные по старому образцу, работают, но лучше делать по-новому.  {% cut \"Как было раньше\" %}  Структура тела PUT-запроса:  ``` {   \"boxes\":   [     {       \"fulfilmentId\": \"{string}\",       \"weight\": {int64},       \"width\": {int64},       \"height\": {int64},       \"depth\": {int64},       \"items\":       [         {           \"id\": {int64},           \"count\": {int32}         },         ...       ]     },     ...   ] } ``` | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `boxes`       |           | Список грузовых мест.       |  **Параметры, вложенные в `boxes`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `fulfilmentId`       |  String   | Идентификатор грузового места в информационной системе магазина. Сформируйте идентификатор по шаблону: `номер заказа на Маркете-номер грузового места`. Например, `7206821‑1, 7206821‑2` и т. д. | | `weight`       | Int64        | Масса брутто грузового места (суммарная масса упаковки и содержимого) в граммах. | | `width`       | Int64   | Ширина грузового места в сантиметрах.       | | `height`       | Int64   | Высота грузового места в сантиметрах.       | | `depth`       | Int64   | Глубина грузового места в сантиметрах.        | | `items`       | Int64   | Список товаров в грузовом месте.       |  **Параметры, вложенные в `items`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `id`       | Int64     | Идентификатор товара в рамках заказа.   | | `count`    | Int32     | Количество единиц товара в грузовом месте.       |  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача количества грузовых мест в заказе
         * @throws {RequiredError}
         */
        setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options?: RequestOptions = {}): Promise<SetOrderShipmentBoxesResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).setOrderShipmentBoxes(campaignId, orderId, shipmentId, setOrderShipmentBoxesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает Маркету количество коробов или палет в отгрузке для доверительной приемки. Подробнее про доверительную приемку написано в [Справке Маркета](https://yandex.ru/support/marketplace/orders/fbs/process.html#acceptance).  Получить PDF-файл с ярлыками для упаковок можно с помощью запроса [GET campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallet/labels](../../reference/shipments/downloadShipmentPalletLabels.md). |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Передача количества упаковок в отгрузке
         * @throws {RequiredError}
         */
        setShipmentPalletsCount(campaignId: number, shipmentId: number, setShipmentPalletsCountRequest: SetShipmentPalletsCountRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).setShipmentPalletsCount(campaignId, shipmentId, setShipmentPalletsCountRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).skipGoodsFeedbacksReaction(businessId, skipGoodsFeedbackReactionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Переносит указанные заказы из указанной отгрузки в следующую отгрузку. [Что такое отгрузка?](https://yandex.ru/support/marketplace/orders/fbs/process.html#ship)  Используйте этот запрос, если не успеваете собрать и упаковать заказы вовремя.  {% note warning \"Такие переносы снижают индекс качества магазина\" %}  Этот запрос предназначен для исключительных случаев. Если вы будете переносить заказы слишком часто, магазин столкнется с ограничениями. [Что за ограничения?](https://yandex.ru/support/marketplace/quality/score/fbs.html)  {% endnote %}  Переносить заказы можно, если до формирования отгрузки осталось больше получаса.  Перенос происходит не мгновенно, а занимает несколько минут.  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Перенос заказов в следующую отгрузку
         * @throws {RequiredError}
         */
        transferOrdersFromShipment(campaignId: number, shipmentId: number, transferOrdersFromShipmentRequest: TransferOrdersFromShipmentRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).transferOrdersFromShipment(campaignId, shipmentId, transferOrdersFromShipmentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateBusinessPrices(businessId, updateBusinessPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateCampaignOffers(campaignId, updateCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<UpdateGoodsFeedbackCommentResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateGoodsFeedbackComment(businessId, updateGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions = {}): Promise<UpdateOfferContentResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateOfferContent(businessId, updateOfferContentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateOfferMappingEntries(campaignId, updateOfferMappingEntryRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions = {}): Promise<UpdateOfferMappingsResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateOfferMappings(businessId, updateOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Изменяет состав заказа, если позволяет выбранная служба доставки, в случаях:  * покупатель уменьшил количество товара; * магазин не может поставить все товары в заказе.  Для этого заказ должен находится в статусе `\"status\": \"PROCESSING\"` этапа обработки `\"substatus\": \"STARTED\"`. После передачи статуса `\"substatus\": \"READY_TO_SHIP\"` изменить состав невозможно.  Если одинаковых товаров несколько, для уменьшения количества передайте обновленное значение в атрибуте `count` параметра `item`.  Чтобы полностью удалить товар из заказа:  * передайте значение `0`; или * не передавайте параметр `item`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если необходимо удалить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  **Возврат денег покупателю**  Если покупатель оплатил товар при оформлении, Маркет вернет ему деньги за удаленные из заказа товары в течение двух дней:  * при оплате банковской картой — с момента, когда магазин переведет заказ в статус `SHIPPED`;  * при оплате через Apple Pay или Google Pay — с момента, когда магазин удалит товар из заказа.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Удаление товара из заказа или уменьшение числа единиц
         * @throws {RequiredError}
         */
        updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateOrderItems(campaignId, orderId, updateOrderItemRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет статус заказа. Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статуса одного заказа
         * @throws {RequiredError}
         */
        updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options?: RequestOptions = {}): Promise<UpdateOrderStatusResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateOrderStatus(campaignId, orderId, updateOrderStatusRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет статусы нескольких заказов.  Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"`и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  Максимальное количество заказов, у которых можно изменить статус в одном запросе, — 30.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статусов нескольких заказов
         * @throws {RequiredError}
         */
        updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options?: RequestOptions = {}): Promise<UpdateOrderStatusesResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateOrderStatuses(campaignId, updateOrderStatusesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updatePrices(campaignId, updatePricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions = {}): Promise<UpdatePromoOffersResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updatePromoOffers(businessId, updatePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает данные об остатках товаров на витрине.  Обязательно указывайте SKU **в точности** так, как он указан в каталоге. Например, _557722_ и _0557722_ — это два разных SKU.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-| 
         * @summary Передача информации об остатках
         * @throws {RequiredError}
         */
        updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbsApiFetchParamCreator(configuration).updateStocks(campaignId, updateStocksRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * FbyApi - fetch parameter creator
 * @export
 */
export const FbyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling addHiddenOffers.');
            }
            // verify required parameter 'addHiddenOffersRequest' is not null or undefined
            if (addHiddenOffersRequest === null || addHiddenOffersRequest === undefined) {
                throw new RequiredError('addHiddenOffersRequest','Required parameter addHiddenOffersRequest was null or undefined when calling addHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addHiddenOffersRequest != null ? addHiddenOffersRequest : {}) : (((addHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling addOffersToArchive.');
            }
            // verify required parameter 'addOffersToArchiveRequest' is not null or undefined
            if (addOffersToArchiveRequest === null || addOffersToArchiveRequest === undefined) {
                throw new RequiredError('addOffersToArchiveRequest','Required parameter addOffersToArchiveRequest was null or undefined when calling addOffersToArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/archive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addOffersToArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addOffersToArchiveRequest != null ? addOffersToArchiveRequest : {}) : (((addOffersToArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'calculateTariffsRequest' is not null or undefined
            if (calculateTariffsRequest === null || calculateTariffsRequest === undefined) {
                throw new RequiredError('calculateTariffsRequest','Required parameter calculateTariffsRequest was null or undefined when calling calculateTariffs.');
            }
            const localVarPath = `/tariffs/calculate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof calculateTariffsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(calculateTariffsRequest != null ? calculateTariffsRequest : {}) : (((calculateTariffsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling confirmBusinessPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine/confirm`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling confirmCampaignPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmCampaignPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine/confirm`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling createChat.');
            }
            // verify required parameter 'createChatRequest' is not null or undefined
            if (createChatRequest === null || createChatRequest === undefined) {
                throw new RequiredError('createChatRequest','Required parameter createChatRequest was null or undefined when calling createChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/new`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createChatRequest != null ? createChatRequest : {}) : (((createChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteCampaignOffers.');
            }
            // verify required parameter 'deleteCampaignOffersRequest' is not null or undefined
            if (deleteCampaignOffersRequest === null || deleteCampaignOffersRequest === undefined) {
                throw new RequiredError('deleteCampaignOffersRequest','Required parameter deleteCampaignOffersRequest was null or undefined when calling deleteCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteCampaignOffersRequest != null ? deleteCampaignOffersRequest : {}) : (((deleteCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            // verify required parameter 'deleteGoodsFeedbackCommentRequest' is not null or undefined
            if (deleteGoodsFeedbackCommentRequest === null || deleteGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('deleteGoodsFeedbackCommentRequest','Required parameter deleteGoodsFeedbackCommentRequest was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteGoodsFeedbackCommentRequest != null ? deleteGoodsFeedbackCommentRequest : {}) : (((deleteGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteHiddenOffers.');
            }
            // verify required parameter 'deleteHiddenOffersRequest' is not null or undefined
            if (deleteHiddenOffersRequest === null || deleteHiddenOffersRequest === undefined) {
                throw new RequiredError('deleteHiddenOffersRequest','Required parameter deleteHiddenOffersRequest was null or undefined when calling deleteHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteHiddenOffersRequest != null ? deleteHiddenOffersRequest : {}) : (((deleteHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffers.');
            }
            // verify required parameter 'deleteOffersRequest' is not null or undefined
            if (deleteOffersRequest === null || deleteOffersRequest === undefined) {
                throw new RequiredError('deleteOffersRequest','Required parameter deleteOffersRequest was null or undefined when calling deleteOffers.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersRequest != null ? deleteOffersRequest : {}) : (((deleteOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteOffersFromArchive.');
            }
            // verify required parameter 'deleteOffersFromArchiveRequest' is not null or undefined
            if (deleteOffersFromArchiveRequest === null || deleteOffersFromArchiveRequest === undefined) {
                throw new RequiredError('deleteOffersFromArchiveRequest','Required parameter deleteOffersFromArchiveRequest was null or undefined when calling deleteOffersFromArchive.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/unarchive`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteOffersFromArchiveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteOffersFromArchiveRequest != null ? deleteOffersFromArchiveRequest : {}) : (((deleteOffersFromArchiveRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deletePromoOffers.');
            }
            // verify required parameter 'deletePromoOffersRequest' is not null or undefined
            if (deletePromoOffersRequest === null || deletePromoOffersRequest === undefined) {
                throw new RequiredError('deletePromoOffersRequest','Required parameter deletePromoOffersRequest was null or undefined when calling deletePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deletePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deletePromoOffersRequest != null ? deletePromoOffersRequest : {}) : (((deletePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateBoostConsolidatedRequest' is not null or undefined
            if (generateBoostConsolidatedRequest === null || generateBoostConsolidatedRequest === undefined) {
                throw new RequiredError('generateBoostConsolidatedRequest','Required parameter generateBoostConsolidatedRequest was null or undefined when calling generateBoostConsolidatedReport.');
            }
            const localVarPath = `/reports/boost-consolidated/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateBoostConsolidatedRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateBoostConsolidatedRequest != null ? generateBoostConsolidatedRequest : {}) : (((generateBoostConsolidatedRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateCompetitorsPositionReportRequest' is not null or undefined
            if (generateCompetitorsPositionReportRequest === null || generateCompetitorsPositionReportRequest === undefined) {
                throw new RequiredError('generateCompetitorsPositionReportRequest','Required parameter generateCompetitorsPositionReportRequest was null or undefined when calling generateCompetitorsPositionReport.');
            }
            const localVarPath = `/reports/competitors-position/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateCompetitorsPositionReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateCompetitorsPositionReportRequest != null ? generateCompetitorsPositionReportRequest : {}) : (((generateCompetitorsPositionReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsFeedbackRequest' is not null or undefined
            if (generateGoodsFeedbackRequest === null || generateGoodsFeedbackRequest === undefined) {
                throw new RequiredError('generateGoodsFeedbackRequest','Required parameter generateGoodsFeedbackRequest was null or undefined when calling generateGoodsFeedbackReport.');
            }
            const localVarPath = `/reports/goods-feedback/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsFeedbackRequest != null ? generateGoodsFeedbackRequest : {}) : (((generateGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по движению товаров**. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#flow)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по движению товаров
         * @throws {RequiredError}
         */
        generateGoodsMovementReport(generateGoodsMovementReportRequest: GenerateGoodsMovementReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsMovementReportRequest' is not null or undefined
            if (generateGoodsMovementReportRequest === null || generateGoodsMovementReportRequest === undefined) {
                throw new RequiredError('generateGoodsMovementReportRequest','Required parameter generateGoodsMovementReportRequest was null or undefined when calling generateGoodsMovementReport.');
            }
            const localVarPath = `/reports/goods-movement/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsMovementReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsMovementReportRequest != null ? generateGoodsMovementReportRequest : {}) : (((generateGoodsMovementReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по реализации** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#sales-report)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по реализации
         * @throws {RequiredError}
         */
        generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsRealizationReportRequest' is not null or undefined
            if (generateGoodsRealizationReportRequest === null || generateGoodsRealizationReportRequest === undefined) {
                throw new RequiredError('generateGoodsRealizationReportRequest','Required parameter generateGoodsRealizationReportRequest was null or undefined when calling generateGoodsRealizationReport.');
            }
            const localVarPath = `/reports/goods-realization/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsRealizationReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsRealizationReportRequest != null ? generateGoodsRealizationReportRequest : {}) : (((generateGoodsRealizationReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по оборачиваемости** за заданную дату.  [Что это за отчет](https://yandex.ru/support/marketplace/analytics/turnover.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по оборачиваемости
         * @throws {RequiredError}
         */
        generateGoodsTurnoverReport(generateGoodsTurnoverRequest: GenerateGoodsTurnoverRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsTurnoverRequest' is not null or undefined
            if (generateGoodsTurnoverRequest === null || generateGoodsTurnoverRequest === undefined) {
                throw new RequiredError('generateGoodsTurnoverRequest','Required parameter generateGoodsTurnoverRequest was null or undefined when calling generateGoodsTurnoverReport.');
            }
            const localVarPath = `/reports/goods-turnover/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsTurnoverRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsTurnoverRequest != null ? generateGoodsTurnoverRequest : {}) : (((generateGoodsTurnoverRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generatePricesReportRequest' is not null or undefined
            if (generatePricesReportRequest === null || generatePricesReportRequest === undefined) {
                throw new RequiredError('generatePricesReportRequest','Required parameter generatePricesReportRequest was null or undefined when calling generatePricesReport.');
            }
            const localVarPath = `/reports/prices/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generatePricesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generatePricesReportRequest != null ? generatePricesReportRequest : {}) : (((generatePricesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShelfsStatisticsRequest' is not null or undefined
            if (generateShelfsStatisticsRequest === null || generateShelfsStatisticsRequest === undefined) {
                throw new RequiredError('generateShelfsStatisticsRequest','Required parameter generateShelfsStatisticsRequest was null or undefined when calling generateShelfsStatisticsReport.');
            }
            const localVarPath = `/reports/shelf-statistics/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShelfsStatisticsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShelfsStatisticsRequest != null ? generateShelfsStatisticsRequest : {}) : (((generateShelfsStatisticsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShowsSalesReportRequest' is not null or undefined
            if (generateShowsSalesReportRequest === null || generateShowsSalesReportRequest === undefined) {
                throw new RequiredError('generateShowsSalesReportRequest','Required parameter generateShowsSalesReportRequest was null or undefined when calling generateShowsSalesReport.');
            }
            const localVarPath = `/reports/shows-sales/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShowsSalesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShowsSalesReportRequest != null ? generateShowsSalesReportRequest : {}) : (((generateShowsSalesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateStocksOnWarehousesReportRequest' is not null or undefined
            if (generateStocksOnWarehousesReportRequest === null || generateStocksOnWarehousesReportRequest === undefined) {
                throw new RequiredError('generateStocksOnWarehousesReportRequest','Required parameter generateStocksOnWarehousesReportRequest was null or undefined when calling generateStocksOnWarehousesReport.');
            }
            const localVarPath = `/reports/stocks-on-warehouses/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateStocksOnWarehousesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateStocksOnWarehousesReportRequest != null ? generateStocksOnWarehousesReportRequest : {}) : (((generateStocksOnWarehousesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedMarketplaceServicesReportRequest' is not null or undefined
            if (generateUnitedMarketplaceServicesReportRequest === null || generateUnitedMarketplaceServicesReportRequest === undefined) {
                throw new RequiredError('generateUnitedMarketplaceServicesReportRequest','Required parameter generateUnitedMarketplaceServicesReportRequest was null or undefined when calling generateUnitedMarketplaceServicesReport.');
            }
            const localVarPath = `/reports/united-marketplace-services/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedMarketplaceServicesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedMarketplaceServicesReportRequest != null ? generateUnitedMarketplaceServicesReportRequest : {}) : (((generateUnitedMarketplaceServicesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedNettingReportRequest' is not null or undefined
            if (generateUnitedNettingReportRequest === null || generateUnitedNettingReportRequest === undefined) {
                throw new RequiredError('generateUnitedNettingReportRequest','Required parameter generateUnitedNettingReportRequest was null or undefined when calling generateUnitedNettingReport.');
            }
            const localVarPath = `/reports/united-netting/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedNettingReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedNettingReportRequest != null ? generateUnitedNettingReportRequest : {}) : (((generateUnitedNettingReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedOrdersRequest' is not null or undefined
            if (generateUnitedOrdersRequest === null || generateUnitedOrdersRequest === undefined) {
                throw new RequiredError('generateUnitedOrdersRequest','Required parameter generateUnitedOrdersRequest was null or undefined when calling generateUnitedOrdersReport.');
            }
            const localVarPath = `/reports/united-orders/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedOrdersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedOrdersRequest != null ? generateUnitedOrdersRequest : {}) : (((generateUnitedOrdersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getAllOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/all`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (chunk !== undefined) {
                localVarQueryParameter['chunk'] = ((chunk:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsInfoForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids/info`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsInfoRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsInfoRequest != null ? getBidsInfoRequest : {}) : (((getBidsInfoRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBidsRecommendations.');
            }
            // verify required parameter 'getBidsRecommendationsRequest' is not null or undefined
            if (getBidsRecommendationsRequest === null || getBidsRecommendationsRequest === undefined) {
                throw new RequiredError('getBidsRecommendationsRequest','Required parameter getBidsRecommendationsRequest was null or undefined when calling getBidsRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/bids/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getBidsRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getBidsRecommendationsRequest != null ? getBidsRecommendationsRequest : {}) : (((getBidsRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getBusinessQuarantineOffers.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessSettings.');
            }
            const localVarPath = `/businesses/{businessId}/settings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignLogins.');
            }
            const localVarPath = `/campaigns/{campaignId}/logins`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignOffers.');
            }
            // verify required parameter 'getCampaignOffersRequest' is not null or undefined
            if (getCampaignOffersRequest === null || getCampaignOffersRequest === undefined) {
                throw new RequiredError('getCampaignOffersRequest','Required parameter getCampaignOffersRequest was null or undefined when calling getCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCampaignOffersRequest != null ? getCampaignOffersRequest : {}) : (((getCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getCampaignQuarantineOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignRegion.');
            }
            const localVarPath = `/campaigns/{campaignId}/region`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignSettings.');
            }
            const localVarPath = `/campaigns/{campaignId}/settings`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/campaigns`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling getCampaignsByLogin.');
            }
            const localVarPath = `/campaigns/by_login/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'getCategoriesMaxSaleQuantumRequest' is not null or undefined
            if (getCategoriesMaxSaleQuantumRequest === null || getCategoriesMaxSaleQuantumRequest === undefined) {
                throw new RequiredError('getCategoriesMaxSaleQuantumRequest','Required parameter getCategoriesMaxSaleQuantumRequest was null or undefined when calling getCategoriesMaxSaleQuantum.');
            }
            const localVarPath = `/categories/max-sale-quantum`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesMaxSaleQuantumRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesMaxSaleQuantumRequest != null ? getCategoriesMaxSaleQuantumRequest : {}) : (((getCategoriesMaxSaleQuantumRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options: RequestOptions): FetchArgs {
            const localVarPath = `/categories/tree`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCategoriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCategoriesRequest != null ? getCategoriesRequest : {}) : (((getCategoriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getCategoryContentParameters.');
            }
            const localVarPath = `/category/{categoryId}/parameters`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling getChatHistory.');
            }
            // verify required parameter 'getChatHistoryRequest' is not null or undefined
            if (getChatHistoryRequest === null || getChatHistoryRequest === undefined) {
                throw new RequiredError('getChatHistoryRequest','Required parameter getChatHistoryRequest was null or undefined when calling getChatHistory.');
            }
            const localVarPath = `/businesses/{businessId}/chats/history`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatHistoryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatHistoryRequest != null ? getChatHistoryRequest : {}) : (((getChatHistoryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getChats.');
            }
            // verify required parameter 'getChatsRequest' is not null or undefined
            if (getChatsRequest === null || getChatsRequest === undefined) {
                throw new RequiredError('getChatsRequest','Required parameter getChatsRequest was null or undefined when calling getChats.');
            }
            const localVarPath = `/businesses/{businessId}/chats`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getChatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getChatsRequest != null ? getChatsRequest : {}) : (((getChatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedIndexLogs.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeedIndexLogs.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/index-logs`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (publishedTimeFrom !== undefined) {
                localVarQueryParameter['published_time_from'] = ((publishedTimeFrom:any):Date).toISOString();
            }

            if (publishedTimeTo !== undefined) {
                localVarQueryParameter['published_time_to'] = ((publishedTimeTo:any):Date).toISOString();
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = ((status:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedbackAndCommentUpdates.');
            }
            const localVarPath = `/campaigns/{campaignId}/feedback/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeeds.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список складов Маркета с их идентификаторами.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Идентификаторы складов Маркета (FBY)
         * @throws {RequiredError}
         */
        getFulfillmentWarehouses(options: RequestOptions): FetchArgs {
            const localVarPath = `/warehouses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbackComments.');
            }
            // verify required parameter 'getGoodsFeedbackCommentsRequest' is not null or undefined
            if (getGoodsFeedbackCommentsRequest === null || getGoodsFeedbackCommentsRequest === undefined) {
                throw new RequiredError('getGoodsFeedbackCommentsRequest','Required parameter getGoodsFeedbackCommentsRequest was null or undefined when calling getGoodsFeedbackComments.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackCommentsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackCommentsRequest != null ? getGoodsFeedbackCommentsRequest : {}) : (((getGoodsFeedbackCommentsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbacks.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackRequest != null ? getGoodsFeedbackRequest : {}) : (((getGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getGoodsStats.');
            }
            // verify required parameter 'getGoodsStatsRequest' is not null or undefined
            if (getGoodsStatsRequest === null || getGoodsStatsRequest === undefined) {
                throw new RequiredError('getGoodsStatsRequest','Required parameter getGoodsStatsRequest was null or undefined when calling getGoodsStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/skus`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsStatsRequest != null ? getGoodsStatsRequest : {}) : (((getGoodsStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferCardsContentStatus.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferCardsContentStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferCardsContentStatusRequest != null ? getOfferCardsContentStatusRequest : {}) : (((getOfferCardsContentStatusRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (shopSku) {
                localVarQueryParameter['shop_sku'] = shopSku.join(COLLECTION_FORMATS["csv"]);
            }

            if (mappingKind !== undefined) {
                localVarQueryParameter['mapping_kind'] = ((mappingKind:any):string);
            }

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS["csv"]);
            }

            if (availability) {
                localVarQueryParameter['availability'] = availability.join(COLLECTION_FORMATS["csv"]);
            }

            if (categoryId) {
                localVarQueryParameter['category_id'] = categoryId.join(COLLECTION_FORMATS["csv"]);
            }

            if (vendor) {
                localVarQueryParameter['vendor'] = vendor.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferMappingsRequest != null ? getOfferMappingsRequest : {}) : (((getOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferRecommendations.');
            }
            // verify required parameter 'getOfferRecommendationsRequest' is not null or undefined
            if (getOfferRecommendationsRequest === null || getOfferRecommendationsRequest === undefined) {
                throw new RequiredError('getOfferRecommendationsRequest','Required parameter getOfferRecommendationsRequest was null or undefined when calling getOfferRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/offers/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferRecommendationsRequest != null ? getOfferRecommendationsRequest : {}) : (((getOfferRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = ((query:any):string);
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (shopCategoryId !== undefined) {
                localVarQueryParameter['shopCategoryId'] = ((shopCategoryId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (matched !== undefined) {
                localVarQueryParameter['matched'] = ((matched:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrder.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/business-buyer`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/documents`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrders.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status).join(COLLECTION_FORMATS["csv"]);
            }

            if (substatus) {
                localVarQueryParameter['substatus'] = Array.from(substatus).join(COLLECTION_FORMATS["csv"]);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateFrom !== undefined) {
                localVarQueryParameter['supplierShipmentDateFrom'] = ((supplierShipmentDateFrom:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateTo !== undefined) {
                localVarQueryParameter['supplierShipmentDateTo'] = ((supplierShipmentDateTo:any):Date).toISOString().slice(0, 10);
            }

            if (updatedAtFrom !== undefined) {
                localVarQueryParameter['updatedAtFrom'] = ((updatedAtFrom:any):Date).toISOString();
            }

            if (updatedAtTo !== undefined) {
                localVarQueryParameter['updatedAtTo'] = ((updatedAtTo:any):Date).toISOString();
            }

            if (dispatchType !== undefined) {
                localVarQueryParameter['dispatchType'] = ((dispatchType:any):string);
            }

            if (fake !== undefined) {
                localVarQueryParameter['fake'] = ((fake:any):string);
            }

            if (hasCis !== undefined) {
                localVarQueryParameter['hasCis'] = ((hasCis:any):string);
            }

            if (onlyWaitingForCancellationApprove !== undefined) {
                localVarQueryParameter['onlyWaitingForCancellationApprove'] = ((onlyWaitingForCancellationApprove:any):string);
            }

            if (onlyEstimatedDelivery !== undefined) {
                localVarQueryParameter['onlyEstimatedDelivery'] = ((onlyEstimatedDelivery:any):string);
            }

            if (buyerType !== undefined) {
                localVarQueryParameter['buyerType'] = ((buyerType:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrdersStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOrdersStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOrdersStatsRequest != null ? getOrdersStatsRequest : {}) : (((getOrdersStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = ((archived:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPricesByOfferIds.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPricesByOfferIdsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPricesByOfferIdsRequest != null ? getPricesByOfferIdsRequest : {}) : (((getPricesByOfferIdsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromoOffers.');
            }
            // verify required parameter 'getPromoOffersRequest' is not null or undefined
            if (getPromoOffersRequest === null || getPromoOffersRequest === undefined) {
                throw new RequiredError('getPromoOffersRequest','Required parameter getPromoOffersRequest was null or undefined when calling getPromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromoOffersRequest != null ? getPromoOffersRequest : {}) : (((getPromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromos.');
            }
            const localVarPath = `/businesses/{businessId}/promos`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromosRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromosRequest != null ? getPromosRequest : {}) : (((getPromosRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getQualityRatings.');
            }
            // verify required parameter 'getQualityRatingRequest' is not null or undefined
            if (getQualityRatingRequest === null || getQualityRatingRequest === undefined) {
                throw new RequiredError('getQualityRatingRequest','Required parameter getQualityRatingRequest was null or undefined when calling getQualityRatings.');
            }
            const localVarPath = `/businesses/{businessId}/ratings/quality`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQualityRatingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQualityRatingRequest != null ? getQualityRatingRequest : {}) : (((getQualityRatingRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'reportId' is not null or undefined
            if (reportId === null || reportId === undefined) {
                throw new RequiredError('reportId','Required parameter reportId was null or undefined when calling getReportInfo.');
            }
            const localVarPath = `/reports/info/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturn.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'imageHash' is not null or undefined
            if (imageHash === null || imageHash === undefined) {
                throw new RequiredError('imageHash','Required parameter imageHash was null or undefined when calling getReturnPhoto.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageHash"}}`, encodeURIComponent(String(imageHash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturns.');
            }
            const localVarPath = `/campaigns/{campaignId}/returns`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS["csv"]);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = ((type:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (fromDate2 !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate2:any):Date).toISOString().slice(0, 10);
            }

            if (toDate2 !== undefined) {
                localVarQueryParameter['to_date'] = ((toDate2:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getStocks.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/stocks`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getWarehouseStocksRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getWarehouseStocksRequest != null ? getWarehouseStocksRequest : {}) : (((getWarehouseStocksRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            // verify required parameter 'getSuggestedOfferMappingEntriesRequest' is not null or undefined
            if (getSuggestedOfferMappingEntriesRequest === null || getSuggestedOfferMappingEntriesRequest === undefined) {
                throw new RequiredError('getSuggestedOfferMappingEntriesRequest','Required parameter getSuggestedOfferMappingEntriesRequest was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingEntriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingEntriesRequest != null ? getSuggestedOfferMappingEntriesRequest : {}) : (((getSuggestedOfferMappingEntriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getSuggestedOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/suggestions`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingsRequest != null ? getSuggestedOfferMappingsRequest : {}) : (((getSuggestedOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedPrices.');
            }
            // verify required parameter 'suggestPricesRequest' is not null or undefined
            if (suggestPricesRequest === null || suggestPricesRequest === undefined) {
                throw new RequiredError('suggestPricesRequest','Required parameter suggestPricesRequest was null or undefined when calling getSuggestedPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof suggestPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(suggestPricesRequest != null ? suggestPricesRequest : {}) : (((suggestPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling putBidsForBusiness.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForBusiness.');
            }
            const localVarPath = `/businesses/{businessId}/bids`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling putBidsForCampaign.');
            }
            // verify required parameter 'putSkuBidsRequest' is not null or undefined
            if (putSkuBidsRequest === null || putSkuBidsRequest === undefined) {
                throw new RequiredError('putSkuBidsRequest','Required parameter putSkuBidsRequest was null or undefined when calling putBidsForCampaign.');
            }
            const localVarPath = `/campaigns/{campaignId}/bids`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof putSkuBidsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(putSkuBidsRequest != null ? putSkuBidsRequest : {}) : (((putSkuBidsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling refreshFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling refreshFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/refresh`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionChildren.');
            }
            const localVarPath = `/regions/{regionId}/children`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionsById.');
            }
            const localVarPath = `/regions/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling searchRegionsByName.');
            }
            const localVarPath = `/regions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendFileToChat.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling sendFileToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/file/send`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'chatId' is not null or undefined
            if (chatId === null || chatId === undefined) {
                throw new RequiredError('chatId','Required parameter chatId was null or undefined when calling sendMessageToChat.');
            }
            // verify required parameter 'sendMessageToChatRequest' is not null or undefined
            if (sendMessageToChatRequest === null || sendMessageToChatRequest === undefined) {
                throw new RequiredError('sendMessageToChatRequest','Required parameter sendMessageToChatRequest was null or undefined when calling sendMessageToChat.');
            }
            const localVarPath = `/businesses/{businessId}/chats/message`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = ((chatId:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof sendMessageToChatRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sendMessageToChatRequest != null ? sendMessageToChatRequest : {}) : (((sendMessageToChatRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'setFeedParamsRequest' is not null or undefined
            if (setFeedParamsRequest === null || setFeedParamsRequest === undefined) {
                throw new RequiredError('setFeedParamsRequest','Required parameter setFeedParamsRequest was null or undefined when calling setFeedParams.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/params`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setFeedParamsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setFeedParamsRequest != null ? setFeedParamsRequest : {}) : (((setFeedParamsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            // verify required parameter 'skipGoodsFeedbackReactionRequest' is not null or undefined
            if (skipGoodsFeedbackReactionRequest === null || skipGoodsFeedbackReactionRequest === undefined) {
                throw new RequiredError('skipGoodsFeedbackReactionRequest','Required parameter skipGoodsFeedbackReactionRequest was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/skip-reaction`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof skipGoodsFeedbackReactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(skipGoodsFeedbackReactionRequest != null ? skipGoodsFeedbackReactionRequest : {}) : (((skipGoodsFeedbackReactionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateBusinessPrices.');
            }
            // verify required parameter 'updateBusinessPricesRequest' is not null or undefined
            if (updateBusinessPricesRequest === null || updateBusinessPricesRequest === undefined) {
                throw new RequiredError('updateBusinessPricesRequest','Required parameter updateBusinessPricesRequest was null or undefined when calling updateBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/offer-prices/updates`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateBusinessPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateBusinessPricesRequest != null ? updateBusinessPricesRequest : {}) : (((updateBusinessPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateCampaignOffers.');
            }
            // verify required parameter 'updateCampaignOffersRequest' is not null or undefined
            if (updateCampaignOffersRequest === null || updateCampaignOffersRequest === undefined) {
                throw new RequiredError('updateCampaignOffersRequest','Required parameter updateCampaignOffersRequest was null or undefined when calling updateCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/update`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateCampaignOffersRequest != null ? updateCampaignOffersRequest : {}) : (((updateCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateGoodsFeedbackComment.');
            }
            // verify required parameter 'updateGoodsFeedbackCommentRequest' is not null or undefined
            if (updateGoodsFeedbackCommentRequest === null || updateGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('updateGoodsFeedbackCommentRequest','Required parameter updateGoodsFeedbackCommentRequest was null or undefined when calling updateGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateGoodsFeedbackCommentRequest != null ? updateGoodsFeedbackCommentRequest : {}) : (((updateGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferContent.');
            }
            // verify required parameter 'updateOfferContentRequest' is not null or undefined
            if (updateOfferContentRequest === null || updateOfferContentRequest === undefined) {
                throw new RequiredError('updateOfferContentRequest','Required parameter updateOfferContentRequest was null or undefined when calling updateOfferContent.');
            }
            const localVarPath = `/businesses/{businessId}/offer-cards/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferContentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferContentRequest != null ? updateOfferContentRequest : {}) : (((updateOfferContentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOfferMappingEntries.');
            }
            // verify required parameter 'updateOfferMappingEntryRequest' is not null or undefined
            if (updateOfferMappingEntryRequest === null || updateOfferMappingEntryRequest === undefined) {
                throw new RequiredError('updateOfferMappingEntryRequest','Required parameter updateOfferMappingEntryRequest was null or undefined when calling updateOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingEntryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingEntryRequest != null ? updateOfferMappingEntryRequest : {}) : (((updateOfferMappingEntryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateOfferMappings.');
            }
            // verify required parameter 'updateOfferMappingsRequest' is not null or undefined
            if (updateOfferMappingsRequest === null || updateOfferMappingsRequest === undefined) {
                throw new RequiredError('updateOfferMappingsRequest','Required parameter updateOfferMappingsRequest was null or undefined when calling updateOfferMappings.');
            }
            const localVarPath = `/businesses/{businessId}/offer-mappings/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingsRequest != null ? updateOfferMappingsRequest : {}) : (((updateOfferMappingsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updatePrices.');
            }
            // verify required parameter 'updatePricesRequest' is not null or undefined
            if (updatePricesRequest === null || updatePricesRequest === undefined) {
                throw new RequiredError('updatePricesRequest','Required parameter updatePricesRequest was null or undefined when calling updatePrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePricesRequest != null ? updatePricesRequest : {}) : (((updatePricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updatePromoOffers.');
            }
            // verify required parameter 'updatePromoOffersRequest' is not null or undefined
            if (updatePromoOffersRequest === null || updatePromoOffersRequest === undefined) {
                throw new RequiredError('updatePromoOffersRequest','Required parameter updatePromoOffersRequest was null or undefined when calling updatePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePromoOffersRequest != null ? updatePromoOffersRequest : {}) : (((updatePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type FbyApiType = { 
    addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions): Promise<AddOffersToArchiveResponse>,

    calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions): Promise<CalculateTariffsResponse>,

    confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions): Promise<CreateChatResponse>,

    deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions): Promise<DeleteCampaignOffersResponse>,

    deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions): Promise<DeleteOffersResponse>,

    deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions): Promise<DeleteOffersFromArchiveResponse>,

    deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions): Promise<DeletePromoOffersResponse>,

    generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsMovementReport(generateGoodsMovementReportRequest: GenerateGoodsMovementReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsTurnoverReport(generateGoodsTurnoverRequest: GenerateGoodsTurnoverRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions): Promise<GetAllOffersResponse>,

    getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions): Promise<GetBidsInfoResponse>,

    getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions): Promise<GetBidsRecommendationsResponse>,

    getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,

    getBusinessSettings(businessId: number, options?: RequestOptions): Promise<GetBusinessSettingsResponse>,

    getCampaign(campaignId: number, options?: RequestOptions): Promise<GetCampaignResponse>,

    getCampaignLogins(campaignId: number, options?: RequestOptions): Promise<GetCampaignLoginsResponse>,

    getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetCampaignOffersResponse>,

    getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,

    getCampaignRegion(campaignId: number, options?: RequestOptions): Promise<GetCampaignRegionResponse>,

    getCampaignSettings(campaignId: number, options?: RequestOptions): Promise<GetCampaignSettingsResponse>,

    getCampaigns(page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,

    getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetCampaignsResponse>,

    getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions): Promise<GetCategoriesMaxSaleQuantumResponse>,

    getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions): Promise<GetCategoriesResponse>,

    getCategoryContentParameters(categoryId: number, options?: RequestOptions): Promise<GetCategoryContentParametersResponse>,

    getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatHistoryResponse>,

    getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetChatsResponse>,

    getFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<GetFeedResponse>,

    getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions): Promise<GetFeedIndexLogsResponse>,

    getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions): Promise<GetFeedbackListResponse>,

    getFeeds(campaignId: number, options?: RequestOptions): Promise<GetFeedsResponse>,

    getFulfillmentWarehouses(options?: RequestOptions): Promise<GetFulfillmentWarehousesResponse>,

    getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetGoodsFeedbackCommentsResponse>,

    getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions): Promise<GetGoodsFeedbackResponse>,

    getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions): Promise<GetGoodsStatsResponse>,

    getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetHiddenOffersResponse>,

    getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions): Promise<GetOfferCardsContentStatusResponse>,

    getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferMappingEntriesResponse>,

    getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions): Promise<GetOfferMappingsResponse>,

    getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferRecommendationsResponse>,

    getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetOffersResponse>,

    getOrder(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderResponse>,

    getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessBuyerInfoResponse>,

    getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessDocumentsInfoResponse>,

    getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOrdersResponse>,

    getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions): Promise<GetOrdersStatsResponse>,

    getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions): Promise<GetPricesResponse>,

    getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions): Promise<GetPricesByOfferIdsResponse>,

    getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetPromoOffersResponse>,

    getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions): Promise<GetPromosResponse>,

    getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions): Promise<GetQualityRatingResponse>,

    getReportInfo(reportId: string, options?: RequestOptions): Promise<GetReportInfoResponse>,

    getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<GetReturnResponse>,

    getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions): Promise<File>,

    getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions): Promise<GetReturnsResponse>,

    getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions): Promise<GetWarehouseStocksResponse>,

    getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingEntriesResponse>,

    getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingsResponse>,

    getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions): Promise<SuggestPricesResponse>,

    putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    refreshFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<EmptyApiResponse>,

    searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetRegionWithChildrenResponse>,

    searchRegionsById(regionId: number, options?: RequestOptions): Promise<GetRegionsResponse>,

    searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetRegionsResponse>,

    sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions): Promise<EmptyApiResponse>,

    sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<UpdateGoodsFeedbackCommentResponse>,

    updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions): Promise<UpdateOfferContentResponse>,

    updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions): Promise<UpdateOfferMappingsResponse>,

    updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions): Promise<UpdatePromoOffersResponse>,
}

/**
 * FbyApi - factory function to inject configuration 
 * @export
 */
export const FbyApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): FbyApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).addHiddenOffers(campaignId, addHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Помещает товары в архив. Товары, помещенные в архив, скрыты с витрины во всех магазинах кабинета.  {% note warning \"В архив нельзя отправить товар, который хранится на складе Маркета\" %}  Вначале такой товар нужно распродать или вывезти.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Добавление товаров в архив
         * @throws {RequiredError}
         */
        addOffersToArchive(businessId: number, addOffersToArchiveRequest: AddOffersToArchiveRequest, options?: RequestOptions = {}): Promise<AddOffersToArchiveResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).addOffersToArchive(businessId, addOffersToArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions = {}): Promise<CalculateTariffsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).calculateTariffs(calculateTariffsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).confirmBusinessPrices(businessId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).confirmCampaignPrices(campaignId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Создание нового чата с покупателем
         * @throws {RequiredError}
         */
        createChat(businessId: number, createChatRequest: CreateChatRequest, options?: RequestOptions = {}): Promise<CreateChatResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).createChat(businessId, createChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions = {}): Promise<DeleteCampaignOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).deleteCampaignOffers(campaignId, deleteCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).deleteGoodsFeedbackComment(businessId, deleteGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).deleteHiddenOffers(campaignId, deleteHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет товары из каталога.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из каталога
         * @throws {RequiredError}
         */
        deleteOffers(businessId: number, deleteOffersRequest: DeleteOffersRequest, options?: RequestOptions = {}): Promise<DeleteOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).deleteOffers(businessId, deleteOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Восстанавливает товары из архива.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товаров из архива
         * @throws {RequiredError}
         */
        deleteOffersFromArchive(businessId: number, deleteOffersFromArchiveRequest: DeleteOffersFromArchiveRequest, options?: RequestOptions = {}): Promise<DeleteOffersFromArchiveResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).deleteOffersFromArchive(businessId, deleteOffersFromArchiveRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions = {}): Promise<DeletePromoOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).deletePromoOffers(businessId, deletePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateBoostConsolidatedReport(generateBoostConsolidatedRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateGoodsFeedbackReport(generateGoodsFeedbackRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по движению товаров**. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#flow)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по движению товаров
         * @throws {RequiredError}
         */
        generateGoodsMovementReport(generateGoodsMovementReportRequest: GenerateGoodsMovementReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateGoodsMovementReport(generateGoodsMovementReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по реализации** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#sales-report)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по реализации
         * @throws {RequiredError}
         */
        generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateGoodsRealizationReport(generateGoodsRealizationReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по оборачиваемости** за заданную дату.  [Что это за отчет](https://yandex.ru/support/marketplace/analytics/turnover.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по оборачиваемости
         * @throws {RequiredError}
         */
        generateGoodsTurnoverReport(generateGoodsTurnoverRequest: GenerateGoodsTurnoverRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateGoodsTurnoverReport(generateGoodsTurnoverRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generatePricesReport(generatePricesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateShelfsStatisticsReport(generateShelfsStatisticsRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateShowsSalesReport(generateShowsSalesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateUnitedNettingReport(generateUnitedNettingReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).generateUnitedOrdersReport(generateUnitedOrdersRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions = {}): Promise<GetAllOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getAllOffers(campaignId, feedId, chunk, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает значения ставок для заданных товаров.  {% note warning \"\" %}  В ответе возвращаются значения только тех ставок, которые вы установили через запрос [PUT businesses/{businessId}/bids](../../reference/bids/putBidsForBusiness.md). Получить информацию по кампаниям, созданным в кабинете, не получится.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Информация об установленных ставках
         * @throws {RequiredError}
         */
        getBidsInfoForBusiness(businessId: number, pageToken?: string, limit?: number, getBidsInfoRequest?: GetBidsInfoRequest, options?: RequestOptions = {}): Promise<GetBidsInfoResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getBidsInfoForBusiness(businessId, pageToken, limit, getBidsInfoRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает рекомендованные ставки для заданных товаров — такие ставки обеспечивают вашим предложениям определенную долю показов, если цена не превышает рекомендованную.  Для одного товара может возвращаться одна рекомендованная ставка или несколько. Во втором случае разные ставки предназначены для достижения разной доли показов.  Если товар только добавлен в каталог, но пока не продается, рекомендованной ставки для него не будет.  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Рекомендованные ставки для заданных товаров
         * @throws {RequiredError}
         */
        getBidsRecommendations(businessId: number, getBidsRecommendationsRequest: GetBidsRecommendationsRequest, options?: RequestOptions = {}): Promise<GetBidsRecommendationsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getBidsRecommendations(businessId, getBidsRecommendationsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getBusinessQuarantineOffers(businessId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о настройках кабинета, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки кабинета
         * @throws {RequiredError}
         */
        getBusinessSettings(businessId: number, options?: RequestOptions = {}): Promise<GetBusinessSettingsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getBusinessSettings(businessId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о магазине. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о магазине
         * @throws {RequiredError}
         */
        getCampaign(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCampaign(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список логинов, у которых есть доступ к магазину. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Логины, связанные с магазином
         * @throws {RequiredError}
         */
        getCampaignLogins(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignLoginsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCampaignLogins(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetCampaignOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCampaignOffers(campaignId, getCampaignOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCampaignQuarantineOffers(campaignId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [GET campaigns/{campaignId}/settings](../../reference/campaigns/getCampaignSettings.md).  {% endnote %}  Возвращает регион, в котором находится магазин. |**⚙️ Лимит:** 5 000 запросов в час| |-| 
         * @summary Регион магазина
         * @throws {RequiredError}
         */
        getCampaignRegion(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignRegionResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCampaignRegion(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о настройках магазина, идентификатор которого указан в запросе. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Настройки магазина
         * @throws {RequiredError}
         */
        getCampaignSettings(campaignId: number, options?: RequestOptions = {}): Promise<GetCampaignSettingsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCampaignSettings(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым имеет доступ пользователь — владелец авторизационного токена, использованного в запросе. Для агентских пользователей список состоит из подагентских магазинов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список магазинов пользователя
         * @throws {RequiredError}
         */
        getCampaigns(page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCampaigns(page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список магазинов, к которым у пользователя с указанным логином есть доступ. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Магазины, доступные логину
         * @throws {RequiredError}
         */
        getCampaignsByLogin(login: string, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetCampaignsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCampaignsByLogin(login, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает лимит на установку [кванта](*quantum) и минимального количества товаров в заказе, которые вы можете задать для товаров указанных категорий.  Если вы передадите значение кванта или минимального количества товаров выше установленного Маркетом ограничения, товар будет скрыт с витрины.  Подробнее о том, как продавать товары по несколько штук, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/fields/quantum).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Лимит на установку кванта продажи и минимального количества товаров в заказе
         * @throws {RequiredError}
         */
        getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest: GetCategoriesMaxSaleQuantumRequest, options?: RequestOptions = {}): Promise<GetCategoriesMaxSaleQuantumResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCategoriesMaxSaleQuantum(getCategoriesMaxSaleQuantumRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает дерево категорий Маркета.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Дерево категорий
         * @throws {RequiredError}
         */
        getCategoriesTree(getCategoriesRequest?: GetCategoriesRequest, options?: RequestOptions = {}): Promise<GetCategoriesResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCategoriesTree(getCategoriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список характеристик с допустимыми значениями для заданной категории.  |**⚙️ Лимит:** 50 категорий в минуту | |-| 
         * @summary Списки характеристик товаров по категориям
         * @throws {RequiredError}
         */
        getCategoryContentParameters(categoryId: number, options?: RequestOptions = {}): Promise<GetCategoryContentParametersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getCategoryContentParameters(categoryId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение истории сообщений в чате
         * @throws {RequiredError}
         */
        getChatHistory(businessId: number, chatId: number, getChatHistoryRequest: GetChatHistoryRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatHistoryResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getChatHistory(businessId, chatId, getChatHistoryRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение доступных чатов
         * @throws {RequiredError}
         */
        getChats(businessId: number, getChatsRequest: GetChatsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetChatsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getChats(businessId, getChatsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<GetFeedResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions = {}): Promise<GetFeedIndexLogsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getFeedIndexLogs(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions = {}): Promise<GetFeedbackListResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getFeedbackAndCommentUpdates(campaignId, pageToken, limit, fromDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options?: RequestOptions = {}): Promise<GetFeedsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getFeeds(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список складов Маркета с их идентификаторами.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Идентификаторы складов Маркета (FBY)
         * @throws {RequiredError}
         */
        getFulfillmentWarehouses(options?: RequestOptions = {}): Promise<GetFulfillmentWarehousesResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getFulfillmentWarehouses(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetGoodsFeedbackCommentsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getGoodsFeedbackComments(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions = {}): Promise<GetGoodsFeedbackResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getGoodsFeedbacks(businessId, pageToken, limit, getGoodsFeedbackRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions = {}): Promise<GetGoodsStatsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getGoodsStats(campaignId, getGoodsStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetHiddenOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getHiddenOffers(campaignId, offerId, pageToken, limit, offset, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает сведения о состоянии контента для заданных товаров:  * создана ли карточка товара и в каком она статусе; * заполненность карточки в процентах; * переданные характеристики товаров; * есть ли ошибки или предупреждения, связанные с контентом; * рекомендации по заполнению карточки.  |**⚙️ Лимит:** 600 запросов в минуту| |-| 
         * @summary Получение информации о заполненности карточек магазина
         * @throws {RequiredError}
         */
        getOfferCardsContentStatus(businessId: number, pageToken?: string, limit?: number, getOfferCardsContentStatusRequest?: GetOfferCardsContentStatusRequest, options?: RequestOptions = {}): Promise<GetOfferCardsContentStatusResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOfferCardsContentStatus(businessId, pageToken, limit, getOfferCardsContentStatusRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferMappingEntriesResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOfferMappingEntries(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров в каталоге, их категории на Маркете и характеристики каждого товара.  Можно использовать тремя способами: * задать список интересующих SKU; * задать фильтр — в этом случае результаты возвращаются постранично; * не передавать тело запроса, чтобы получить список всех товаров в каталоге.  |**⚙️ Лимит:** 600 запросов в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Информация о товарах в каталоге
         * @throws {RequiredError}
         */
        getOfferMappings(businessId: number, pageToken?: string, limit?: number, getOfferMappingsRequest?: GetOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetOfferMappingsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOfferMappings(businessId, pageToken, limit, getOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferRecommendationsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOfferRecommendations(businessId, getOfferRecommendationsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOffers(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOrder(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessBuyerInfoResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOrderBusinessBuyerInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessDocumentsInfoResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOrderBusinessDocumentsInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOrdersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOrders(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions = {}): Promise<GetOrdersStatsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getOrdersStats(campaignId, pageToken, limit, getOrdersStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions = {}): Promise<GetPricesResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getPrices(campaignId, pageToken, limit, archived, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions = {}): Promise<GetPricesByOfferIdsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getPricesByOfferIds(campaignId, pageToken, limit, getPricesByOfferIdsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetPromoOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getPromoOffers(businessId, getPromoOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions = {}): Promise<GetPromosResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getPromos(businessId, getPromosRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions = {}): Promise<GetQualityRatingResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getQualityRatings(businessId, getQualityRatingRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options?: RequestOptions = {}): Promise<GetReportInfoResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getReportInfo(reportId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<GetReturnResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getReturn(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getReturnPhoto(campaignId, orderId, returnId, itemId, imageHash, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions = {}): Promise<GetReturnsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getReturns(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions = {}): Promise<GetWarehouseStocksResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getStocks(campaignId, pageToken, limit, getWarehouseStocksRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingEntriesResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getSuggestedOfferMappingEntries(campaignId, getSuggestedOfferMappingEntriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает идентификаторы карточек на Маркете, которые соответствуют товарам с заданными параметрами.  Пользоваться этим запросом необязательно: он просто помогает заранее убедиться, что Маркет верно определяет карточки по предоставленным вами данным.  **Как пользоваться запросом**  1. Передайте Маркету список товаров, которые нужно проверить. 2. В ответ вы получите список SKU на Маркете с расшифровкой: названием, идентификатором модели, категорией. 3. Если расшифровки мало, вы можете открыть карточку. Для этого перейдите по ссылке вида `https://market.yandex.ru/product/<marketModelId>?sku=<marketSku>`. 4. Если карточка соответствует товару, значит его можно добавлять в каталог с теми данными, что вы указали. Если карточка определилась неправильно — проверьте данные о товаре. Возможно, их нужно уточнить или дополнить. Кроме того, на этапе добавления товара вы можете указать `marketSKU`, который ему подходит по вашему мнению.  {% note info \"𝓠 Как определить `marketSku` товара, найденного на Маркете?\" %}  𝓐 Он есть в адресе страницы товара — расположен после `sku=`.  Например, `https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016`  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Просмотр карточек на Маркете, которые подходят вашим товарам
         * @throws {RequiredError}
         */
        getSuggestedOfferMappings(businessId: number, getSuggestedOfferMappingsRequest?: GetSuggestedOfferMappingsRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getSuggestedOfferMappings(businessId, getSuggestedOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions = {}): Promise<SuggestPricesResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).getSuggestedPrices(campaignId, suggestPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  {% cut \"Как в кабинете выглядит кампания, созданная через API\" %}  ![](../../_images/api-boost.png)  {% endcut %}  При первом использовании запроса Маркет: создаст единую на все магазины бизнес-аккаунта кампанию, добавит в нее товары с указанными ставками, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же созданной через API кампанией. Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. Другими кампаниями управлять через API не получится. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок
         * @throws {RequiredError}
         */
        putBidsForBusiness(businessId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).putBidsForBusiness(businessId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает буст продаж в указанном магазине — создает и включает кампанию, добавляет в нее товары и назначает на них ставки.  При первом использовании запроса Маркет: создаст кампанию, добавит в нее товары с указанными ставками для заданного магазина, включит для них ценовую стратегию и запустит продвижение. Повторное использование запроса позволит обновить ставки на товары в этой кампании или добавить новые. Подробнее о ценовой стратегии читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html#price-strategy).  Если товара с указанным SKU нет, он будет проигнорирован. Если в будущем в каталоге появится товар с таким SKU, он автоматически будет добавлен в кампанию с указанной ставкой.  Запрос всегда работает с одной и той же кампанией, созданной через этот запрос или [PUT businesses/{businessId}/bids](/reference/bids/putBidsForBusiness). Если в кабинете удалить ее, при следующем выполнении запроса Маркет создаст новую. У созданной через API кампании всегда наибольший приоритет над остальными — изменить его нельзя.  Выполнение запроса включает кампанию и ценовую стратегию, если они были отключены.  Внести другие изменения в созданную через API кампанию можно в кабинете:  * выключить или включить кампанию; * изменить ее название; * выключить или включить ценовую стратегию.  Чтобы остановить продвижение отдельных товаров и удалить их из кампании, передайте для них нулевую ставку в параметре `bid`.  Подробнее о том, как работает буст продаж, читайте в [Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/campaigns.html).  {% note info \"𝓠 Как посмотреть расходы на буст продаж?\" %}  𝓐 Фактические расходы на буст указаны в отчете по заказам ([POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md)). Сумма содержится в поле `bidFee`.  {% endnote %}  В одном запросе может быть максимум 1500 товаров.  |**⚙️ Лимит:** 1000 запросов в минуту| |-| 
         * @summary Включение буста продаж и установка ставок для магазина
         * @throws {RequiredError}
         */
        putBidsForCampaign(campaignId: number, putSkuBidsRequest: PutSkuBidsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).putBidsForCampaign(campaignId, putSkuBidsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).refreshFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetRegionWithChildrenResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).searchRegionChildren(regionId, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).searchRegionsById(regionId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).searchRegionsByName(name, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка файла в чат
         * @throws {RequiredError}
         */
        sendFileToChat(businessId: number, chatId: number, file: File, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).sendFileToChat(businessId, chatId, file, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Отправка сообщения в чат
         * @throws {RequiredError}
         */
        sendMessageToChat(businessId: number, chatId: number, sendMessageToChatRequest: SendMessageToChatRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).sendMessageToChat(businessId, chatId, sendMessageToChatRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).setFeedParams(campaignId, feedId, setFeedParamsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).skipGoodsFeedbacksReaction(businessId, skipGoodsFeedbackReactionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).updateBusinessPrices(businessId, updateBusinessPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).updateCampaignOffers(campaignId, updateCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<UpdateGoodsFeedbackCommentResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).updateGoodsFeedbackComment(businessId, updateGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Редактирует характеристики товара, которые специфичны для категории, к которой он относится.  {% note warning \"Здесь только то, что относится к конкретной категории\" %}  Если вам нужно изменить основные параметры товара (название, описание, изображения, видео, производитель, штрихкод), воспользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Чтобы удалить характеристики, которые заданы в параметрах с типом `string`, передайте пустое значение.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Редактирование категорийных характеристик товара
         * @throws {RequiredError}
         */
        updateOfferContent(businessId: number, updateOfferContentRequest: UpdateOfferContentRequest, options?: RequestOptions = {}): Promise<UpdateOfferContentResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).updateOfferContent(businessId, updateOfferContentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).updateOfferMappingEntries(campaignId, updateOfferMappingEntryRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в каталог, передает их категории на Маркете и характеристики, необходимые для этих категории. Также редактирует информацию об уже имеющихся товарах.  Список категорий Маркета можно получить с помощью запроса [POST categories/tree](../../reference/categories/getCategoriesTree.md), а характеристики товаров по категориям с помощью [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md).  Чтобы **добавить новый товар**, передайте его с новым идентификатором, который раньше никогда не использовался в каталоге. Старайтесь сразу передать как можно больше информации — она потребуется Маркету для подбора подходящей карточки или создания новой. Если известно, какой карточке на Маркете соответствует товар, можно сразу указать идентификатор этой карточки (**SKU на Маркете**) в поле `marketSKU`.  Для **новых товаров** обязательно укажите параметры: `offerId`, `name`, `marketCategoryId` или `category`, `pictures`, `vendor`, `description`.  Чтобы **отредактировать информацию о товаре**, передайте новые данные, указав в `offerId` соответствующий **ваш SKU**. Поля, в которых ничего не меняется, можно не передавать.  Чтобы **удалить характеристики**, которые заданы в параметрах с типом `string`, передайте пустое значение.  Параметр `offerId` должен быть **уникальным** для всех товаров, которые вы передаете.  {% note warning \"Правила использования SKU\" %}  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Добавление товаров в каталог и изменение информации о них
         * @throws {RequiredError}
         */
        updateOfferMappings(businessId: number, updateOfferMappingsRequest: UpdateOfferMappingsRequest, options?: RequestOptions = {}): Promise<UpdateOfferMappingsResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).updateOfferMappings(businessId, updateOfferMappingsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).updatePrices(campaignId, updatePricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions = {}): Promise<UpdatePromoOffersResponse> {
            const localVarFetchArgs = FbyApiFetchParamCreator(configuration).updatePromoOffers(businessId, updatePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * FeedbacksApi - fetch parameter creator
 * @export
 */
export const FeedbacksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedbackAndCommentUpdates.');
            }
            const localVarPath = `/campaigns/{campaignId}/feedback/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type FeedbacksApiType = { 
    getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions): Promise<GetFeedbackListResponse>,
}

/**
 * FeedbacksApi - factory function to inject configuration 
 * @export
 */
export const FeedbacksApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): FeedbacksApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает новые и обновленные отзывы о магазине на Маркете.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов. Выходные данные содержат идентификатор следующей страницы.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Новые и обновленные отзывы о магазине
         * @throws {RequiredError}
         */
        getFeedbackAndCommentUpdates(campaignId: number, pageToken?: string, limit?: number, fromDate?: Date, options?: RequestOptions = {}): Promise<GetFeedbackListResponse> {
            const localVarFetchArgs = FeedbacksApiFetchParamCreator(configuration).getFeedbackAndCommentUpdates(campaignId, pageToken, limit, fromDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * FeedsApi - fetch parameter creator
 * @export
 */
export const FeedsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeedIndexLogs.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeedIndexLogs.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/index-logs`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (publishedTimeFrom !== undefined) {
                localVarQueryParameter['published_time_from'] = ((publishedTimeFrom:any):Date).toISOString();
            }

            if (publishedTimeTo !== undefined) {
                localVarQueryParameter['published_time_to'] = ((publishedTimeTo:any):Date).toISOString();
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = ((status:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getFeeds.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling refreshFeed.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling refreshFeed.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/refresh`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling setFeedParams.');
            }
            // verify required parameter 'setFeedParamsRequest' is not null or undefined
            if (setFeedParamsRequest === null || setFeedParamsRequest === undefined) {
                throw new RequiredError('setFeedParamsRequest','Required parameter setFeedParamsRequest was null or undefined when calling setFeedParams.');
            }
            const localVarPath = `/campaigns/{campaignId}/feeds/{feedId}/params`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setFeedParamsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setFeedParamsRequest != null ? setFeedParamsRequest : {}) : (((setFeedParamsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type FeedsApiType = { 
    getFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<GetFeedResponse>,

    getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions): Promise<GetFeedIndexLogsResponse>,

    getFeeds(campaignId: number, options?: RequestOptions): Promise<GetFeedsResponse>,

    refreshFeed(campaignId: number, feedId: number, options?: RequestOptions): Promise<EmptyApiResponse>,

    setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * FeedsApi - factory function to inject configuration 
 * @export
 */
export const FeedsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): FeedsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает информацию о прайс-листе, размещенном на Маркете для заданного магазина. Также ресурс возвращает результаты автоматических проверок прайс-листа. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Информация о прайс-листе
         * @throws {RequiredError}
         */
        getFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<GetFeedResponse> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).getFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает отчет по индексации прайс-листа для заданного магазина. Отчет позволяет получить статистику загрузки прайс-листа и результаты его автоматических проверок.  Данные в отчете возвращаются в порядке убывания значений параметра `generationId`.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отчет по индексации прайс-листа
         * @throws {RequiredError}
         */
        getFeedIndexLogs(campaignId: number, feedId: number, limit?: number, publishedTimeFrom?: Date, publishedTimeTo?: Date, status?: FeedIndexLogsStatusType, options?: RequestOptions = {}): Promise<GetFeedIndexLogsResponse> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).getFeedIndexLogs(campaignId, feedId, limit, publishedTimeFrom, publishedTimeTo, status, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Возвращает список прайс-листов, размещенных на Маркете для магазина. Также ресурс возвращает результаты автоматических проверок прайс-листов. |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Список прайс-листов магазина
         * @throws {RequiredError}
         */
        getFeeds(campaignId: number, options?: RequestOptions = {}): Promise<GetFeedsResponse> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).getFeeds(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет сообщить, что магазин обновил прайс-лист. После этого Маркет начнет обновление данных на сервисе. 1. Магазин обновляет прайс-лист, ссылку на который он указал в кабинете. 2. Магазин отправляет Маркету запрос методом `POST campaigns/{campaignId}/feeds/{feedId}/refresh`. 3. Маркет начинает обновление данных магазина на сервисе.  {% note alert %}  Запрос работает только для включенных магазинов. Если магазин выключен, данные на Маркете не обновятся, даже если HTTP-код — `200 OK`. Проверить статус магазина можно с помощью базовых запросов или на странице бизнес-аккаунта.  {% endnote %}  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Сообщить, что прайс-лист обновился
         * @throws {RequiredError}
         */
        refreshFeed(campaignId: number, feedId: number, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).refreshFeed(campaignId, feedId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет магазину изменить параметры прайс-листа.  Чтобы отредактировать параметр прайс-листа, передайте в теле запроса: `name` (название параметра) и `value` (значение параметра).  Чтобы отменить установленное значение, передайте в теле запроса: `name` (название параметра) и `delete=true` (удалить значение).  |**⚙️ Лимит:** 3 запроса в час для одного прайс-листа| |-| 
         * @summary Изменение параметров прайс-листа
         * @throws {RequiredError}
         */
        setFeedParams(campaignId: number, feedId: number, setFeedParamsRequest: SetFeedParamsRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).setFeedParams(campaignId, feedId, setFeedParamsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * GoodsFeedbackApi - fetch parameter creator
 * @export
 */
export const GoodsFeedbackApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            // verify required parameter 'deleteGoodsFeedbackCommentRequest' is not null or undefined
            if (deleteGoodsFeedbackCommentRequest === null || deleteGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('deleteGoodsFeedbackCommentRequest','Required parameter deleteGoodsFeedbackCommentRequest was null or undefined when calling deleteGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteGoodsFeedbackCommentRequest != null ? deleteGoodsFeedbackCommentRequest : {}) : (((deleteGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbackComments.');
            }
            // verify required parameter 'getGoodsFeedbackCommentsRequest' is not null or undefined
            if (getGoodsFeedbackCommentsRequest === null || getGoodsFeedbackCommentsRequest === undefined) {
                throw new RequiredError('getGoodsFeedbackCommentsRequest','Required parameter getGoodsFeedbackCommentsRequest was null or undefined when calling getGoodsFeedbackComments.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackCommentsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackCommentsRequest != null ? getGoodsFeedbackCommentsRequest : {}) : (((getGoodsFeedbackCommentsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getGoodsFeedbacks.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsFeedbackRequest != null ? getGoodsFeedbackRequest : {}) : (((getGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            // verify required parameter 'skipGoodsFeedbackReactionRequest' is not null or undefined
            if (skipGoodsFeedbackReactionRequest === null || skipGoodsFeedbackReactionRequest === undefined) {
                throw new RequiredError('skipGoodsFeedbackReactionRequest','Required parameter skipGoodsFeedbackReactionRequest was null or undefined when calling skipGoodsFeedbacksReaction.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/skip-reaction`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof skipGoodsFeedbackReactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(skipGoodsFeedbackReactionRequest != null ? skipGoodsFeedbackReactionRequest : {}) : (((skipGoodsFeedbackReactionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateGoodsFeedbackComment.');
            }
            // verify required parameter 'updateGoodsFeedbackCommentRequest' is not null or undefined
            if (updateGoodsFeedbackCommentRequest === null || updateGoodsFeedbackCommentRequest === undefined) {
                throw new RequiredError('updateGoodsFeedbackCommentRequest','Required parameter updateGoodsFeedbackCommentRequest was null or undefined when calling updateGoodsFeedbackComment.');
            }
            const localVarPath = `/businesses/{businessId}/goods-feedback/comments/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateGoodsFeedbackCommentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateGoodsFeedbackCommentRequest != null ? updateGoodsFeedbackCommentRequest : {}) : (((updateGoodsFeedbackCommentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type GoodsFeedbackApiType = { 
    deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetGoodsFeedbackCommentsResponse>,

    getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions): Promise<GetGoodsFeedbackResponse>,

    skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions): Promise<UpdateGoodsFeedbackCommentResponse>,
}

/**
 * GoodsFeedbackApi - factory function to inject configuration 
 * @export
 */
export const GoodsFeedbackApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): GoodsFeedbackApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Удаляет комментарий магазина.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Удаление комментария к отзыву
         * @throws {RequiredError}
         */
        deleteGoodsFeedbackComment(businessId: number, deleteGoodsFeedbackCommentRequest: DeleteGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = GoodsFeedbackApiFetchParamCreator(configuration).deleteGoodsFeedbackComment(businessId, deleteGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает комментарии к отзыву.  Результаты возвращаются постранично, одна страница содержит не более 20 комментариев.  Комментарии расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение комментариев к отзыву
         * @throws {RequiredError}
         */
        getGoodsFeedbackComments(businessId: number, getGoodsFeedbackCommentsRequest: GetGoodsFeedbackCommentsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetGoodsFeedbackCommentsResponse> {
            const localVarFetchArgs = GoodsFeedbackApiFetchParamCreator(configuration).getGoodsFeedbackComments(businessId, getGoodsFeedbackCommentsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает все отзывы о товарах продавца по указанным фильтрам.  Результаты возвращаются постранично, одна страница содержит не более 20 отзывов.  Отзывы расположены в порядке публикации, поэтому вы можете передавать определенный идентификатор страницы в `page_token`, если вы получали его ранее.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Получение отзывов о товарах продавца
         * @throws {RequiredError}
         */
        getGoodsFeedbacks(businessId: number, pageToken?: string, limit?: number, getGoodsFeedbackRequest?: GetGoodsFeedbackRequest, options?: RequestOptions = {}): Promise<GetGoodsFeedbackResponse> {
            const localVarFetchArgs = GoodsFeedbackApiFetchParamCreator(configuration).getGoodsFeedbacks(businessId, pageToken, limit, getGoodsFeedbackRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Пропускает отзывы — они больше не будут возвращаться в методе получения всех отзывов [POST businesses/{businessId}/goods-feedback](../../reference/goods-feedback/getGoodsFeedbacks.md).  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Отказ от ответа на отзывы
         * @throws {RequiredError}
         */
        skipGoodsFeedbacksReaction(businessId: number, skipGoodsFeedbackReactionRequest: SkipGoodsFeedbackReactionRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = GoodsFeedbackApiFetchParamCreator(configuration).skipGoodsFeedbacksReaction(businessId, skipGoodsFeedbackReactionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет новый комментарий магазина или изменяет комментарий, который магазин оставлял ранее.  Для создания комментария к отзыву передайте только идентификатор отзыва `feedbackId`.  Чтобы добавить комментарий к другому комментарию, передайте:  * `feedbackId` — идентификатор отзыва; * `comment.parentId` — идентификатор родительского комментария.  Чтобы изменить комментарий, передайте:  * `feedbackId`— идентификатор отзыва; * `comment.id` — идентификатор комментария, который нужно изменить.  Если передать одновременно `comment.parentId` и `comment.id`, будет изменен существующий комментарий.  |**⚙️ Лимит:** 1 000 запросов в час| |-| 
         * @summary Добавление нового или изменение созданного комментария
         * @throws {RequiredError}
         */
        updateGoodsFeedbackComment(businessId: number, updateGoodsFeedbackCommentRequest: UpdateGoodsFeedbackCommentRequest, options?: RequestOptions = {}): Promise<UpdateGoodsFeedbackCommentResponse> {
            const localVarFetchArgs = GoodsFeedbackApiFetchParamCreator(configuration).updateGoodsFeedbackComment(businessId, updateGoodsFeedbackCommentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * GoodsStatsApi - fetch parameter creator
 * @export
 */
export const GoodsStatsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getGoodsStats.');
            }
            // verify required parameter 'getGoodsStatsRequest' is not null or undefined
            if (getGoodsStatsRequest === null || getGoodsStatsRequest === undefined) {
                throw new RequiredError('getGoodsStatsRequest','Required parameter getGoodsStatsRequest was null or undefined when calling getGoodsStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/skus`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getGoodsStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getGoodsStatsRequest != null ? getGoodsStatsRequest : {}) : (((getGoodsStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type GoodsStatsApiType = { 
    getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions): Promise<GetGoodsStatsResponse>,
}

/**
 * GoodsStatsApi - factory function to inject configuration 
 * @export
 */
export const GoodsStatsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): GoodsStatsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает подробный отчет по товарам, которые вы разместили на Маркете. С помощью отчета вы можете узнать, например, об остатках на складе, об условиях хранения ваших товаров и т. д.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Отчет по товарам
         * @throws {RequiredError}
         */
        getGoodsStats(campaignId: number, getGoodsStatsRequest: GetGoodsStatsRequest, options?: RequestOptions = {}): Promise<GetGoodsStatsResponse> {
            const localVarFetchArgs = GoodsStatsApiFetchParamCreator(configuration).getGoodsStats(campaignId, getGoodsStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * HiddenOffersApi - fetch parameter creator
 * @export
 */
export const HiddenOffersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling addHiddenOffers.');
            }
            // verify required parameter 'addHiddenOffersRequest' is not null or undefined
            if (addHiddenOffersRequest === null || addHiddenOffersRequest === undefined) {
                throw new RequiredError('addHiddenOffersRequest','Required parameter addHiddenOffersRequest was null or undefined when calling addHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof addHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addHiddenOffersRequest != null ? addHiddenOffersRequest : {}) : (((addHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteHiddenOffers.');
            }
            // verify required parameter 'deleteHiddenOffersRequest' is not null or undefined
            if (deleteHiddenOffersRequest === null || deleteHiddenOffersRequest === undefined) {
                throw new RequiredError('deleteHiddenOffersRequest','Required parameter deleteHiddenOffersRequest was null or undefined when calling deleteHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteHiddenOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteHiddenOffersRequest != null ? deleteHiddenOffersRequest : {}) : (((deleteHiddenOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getHiddenOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/hidden-offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type HiddenOffersApiType = { 
    addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetHiddenOffersResponse>,
}

/**
 * HiddenOffersApi - factory function to inject configuration 
 * @export
 */
export const HiddenOffersApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): HiddenOffersApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Скрывает товары магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Скрытие товаров и настройки скрытия
         * @throws {RequiredError}
         */
        addHiddenOffers(campaignId: number, addHiddenOffersRequest: AddHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = HiddenOffersApiFetchParamCreator(configuration).addHiddenOffers(campaignId, addHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возобновляет показ скрытых вами товаров магазина на Маркете.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Возобновление показа товаров
         * @throws {RequiredError}
         */
        deleteHiddenOffers(campaignId: number, deleteHiddenOffersRequest: DeleteHiddenOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = HiddenOffersApiFetchParamCreator(configuration).deleteHiddenOffers(campaignId, deleteHiddenOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список скрытых вами товаров для заданного магазина.  В списке будут товары, скрытые любым способом — по API, с помощью YML-фида, в кабинете и так далее.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Информация о скрытых вами товарах
         * @throws {RequiredError}
         */
        getHiddenOffers(campaignId: number, offerId?: Array<string>, pageToken?: string, limit?: number, offset?: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetHiddenOffersResponse> {
            const localVarFetchArgs = HiddenOffersApiFetchParamCreator(configuration).getHiddenOffers(campaignId, offerId, pageToken, limit, offset, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ModelsApi - fetch parameter creator
 * @export
 */
export const ModelsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информацию о модели товара.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Информация об одной модели
         * @throws {RequiredError}
         */
        getModel(modelId: number, regionId: number, currency?: CurrencyType, options: RequestOptions): FetchArgs {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling getModel.');
            }
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getModel.');
            }
            const localVarPath = `/models/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о первых десяти предложениях, расположенных на карточке модели.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей метод не поддерживается. Идентификатор групповой модели игнорируется.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Список предложений для одной модели
         * @throws {RequiredError}
         */
        getModelOffers(modelId: number, regionId: number, currency?: CurrencyType, orderByPrice?: SortOrderType, count?: number, page?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling getModelOffers.');
            }
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getModelOffers.');
            }
            const localVarPath = `/models/{modelId}/offers`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (orderByPrice !== undefined) {
                localVarQueryParameter['orderByPrice'] = ((orderByPrice:any):string);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = ((count:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о моделях товаров.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Информация о нескольких моделях
         * @throws {RequiredError}
         */
        getModels(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getModels.');
            }
            // verify required parameter 'getModelsRequest' is not null or undefined
            if (getModelsRequest === null || getModelsRequest === undefined) {
                throw new RequiredError('getModelsRequest','Required parameter getModelsRequest was null or undefined when calling getModels.');
            }
            const localVarPath = `/models`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getModelsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getModelsRequest != null ? getModelsRequest : {}) : (((getModelsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о первых десяти предложениях, расположенных на карточках моделей, идентификаторы которых указаны в запросе.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей выдача предложений не поддерживается. Идентификаторы групповых моделей игнорируются.  В одном запросе можно получить информацию о предложениях не более чем для 100 моделей.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Список предложений для нескольких моделей
         * @throws {RequiredError}
         */
        getModelsOffers(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, orderByPrice?: SortOrderType, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getModelsOffers.');
            }
            // verify required parameter 'getModelsRequest' is not null or undefined
            if (getModelsRequest === null || getModelsRequest === undefined) {
                throw new RequiredError('getModelsRequest','Required parameter getModelsRequest was null or undefined when calling getModelsOffers.');
            }
            const localVarPath = `/models/offers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (orderByPrice !== undefined) {
                localVarQueryParameter['orderByPrice'] = ((orderByPrice:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getModelsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getModelsRequest != null ? getModelsRequest : {}) : (((getModelsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о моделях, удовлетворяющих заданным в запросе условиям поиска.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Поиск модели товара
         * @throws {RequiredError}
         */
        searchModels(query: string, regionId: number, currency?: CurrencyType, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling searchModels.');
            }
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchModels.');
            }
            const localVarPath = `/models`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = ((query:any):string);
            }

            if (regionId !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ModelsApiType = { 
    getModel(modelId: number, regionId: number, currency?: CurrencyType, options?: RequestOptions): Promise<GetModelsResponse>,

    getModelOffers(modelId: number, regionId: number, currency?: CurrencyType, orderByPrice?: SortOrderType, count?: number, page?: number, options?: RequestOptions): Promise<GetModelsOffersResponse>,

    getModels(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, options?: RequestOptions): Promise<GetModelsResponse>,

    getModelsOffers(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, orderByPrice?: SortOrderType, options?: RequestOptions): Promise<GetModelsOffersResponse>,

    searchModels(query: string, regionId: number, currency?: CurrencyType, page?: number, pageSize?: number, options?: RequestOptions): Promise<SearchModelsResponse>,
}

/**
 * ModelsApi - factory function to inject configuration 
 * @export
 */
export const ModelsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ModelsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает информацию о модели товара.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Информация об одной модели
         * @throws {RequiredError}
         */
        getModel(modelId: number, regionId: number, currency?: CurrencyType, options?: RequestOptions = {}): Promise<GetModelsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).getModel(modelId, regionId, currency, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о первых десяти предложениях, расположенных на карточке модели.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей метод не поддерживается. Идентификатор групповой модели игнорируется.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Список предложений для одной модели
         * @throws {RequiredError}
         */
        getModelOffers(modelId: number, regionId: number, currency?: CurrencyType, orderByPrice?: SortOrderType, count?: number, page?: number, options?: RequestOptions = {}): Promise<GetModelsOffersResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).getModelOffers(modelId, regionId, currency, orderByPrice, count, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о моделях товаров.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Информация о нескольких моделях
         * @throws {RequiredError}
         */
        getModels(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, options?: RequestOptions = {}): Promise<GetModelsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).getModels(regionId, getModelsRequest, currency, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о первых десяти предложениях, расположенных на карточках моделей, идентификаторы которых указаны в запросе.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей выдача предложений не поддерживается. Идентификаторы групповых моделей игнорируются.  В одном запросе можно получить информацию о предложениях не более чем для 100 моделей.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Список предложений для нескольких моделей
         * @throws {RequiredError}
         */
        getModelsOffers(regionId: number, getModelsRequest: GetModelsRequest, currency?: CurrencyType, orderByPrice?: SortOrderType, options?: RequestOptions = {}): Promise<GetModelsOffersResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).getModelsOffers(regionId, getModelsRequest, currency, orderByPrice, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о моделях, удовлетворяющих заданным в запросе условиям поиска.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
         * @summary Поиск модели товара
         * @throws {RequiredError}
         */
        searchModels(query: string, regionId: number, currency?: CurrencyType, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<SearchModelsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).searchModels(query, regionId, currency, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OfferMappingsApi - fetch parameter creator
 * @export
 */
export const OfferMappingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offerId) {
                localVarQueryParameter['offer_id'] = offerId.join(COLLECTION_FORMATS["csv"]);
            }

            if (shopSku) {
                localVarQueryParameter['shop_sku'] = shopSku.join(COLLECTION_FORMATS["csv"]);
            }

            if (mappingKind !== undefined) {
                localVarQueryParameter['mapping_kind'] = ((mappingKind:any):string);
            }

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS["csv"]);
            }

            if (availability) {
                localVarQueryParameter['availability'] = availability.join(COLLECTION_FORMATS["csv"]);
            }

            if (categoryId) {
                localVarQueryParameter['category_id'] = categoryId.join(COLLECTION_FORMATS["csv"]);
            }

            if (vendor) {
                localVarQueryParameter['vendor'] = vendor.join(COLLECTION_FORMATS["csv"]);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            // verify required parameter 'getSuggestedOfferMappingEntriesRequest' is not null or undefined
            if (getSuggestedOfferMappingEntriesRequest === null || getSuggestedOfferMappingEntriesRequest === undefined) {
                throw new RequiredError('getSuggestedOfferMappingEntriesRequest','Required parameter getSuggestedOfferMappingEntriesRequest was null or undefined when calling getSuggestedOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getSuggestedOfferMappingEntriesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getSuggestedOfferMappingEntriesRequest != null ? getSuggestedOfferMappingEntriesRequest : {}) : (((getSuggestedOfferMappingEntriesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOfferMappingEntries.');
            }
            // verify required parameter 'updateOfferMappingEntryRequest' is not null or undefined
            if (updateOfferMappingEntryRequest === null || updateOfferMappingEntryRequest === undefined) {
                throw new RequiredError('updateOfferMappingEntryRequest','Required parameter updateOfferMappingEntryRequest was null or undefined when calling updateOfferMappingEntries.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-mapping-entries/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOfferMappingEntryRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOfferMappingEntryRequest != null ? updateOfferMappingEntryRequest : {}) : (((updateOfferMappingEntryRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OfferMappingsApiType = { 
    getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferMappingEntriesResponse>,

    getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions): Promise<GetSuggestedOfferMappingEntriesResponse>,

    updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * OfferMappingsApi - factory function to inject configuration 
 * @export
 */
export const OfferMappingsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OfferMappingsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  Для каждого товара, который вы размещаете на Маркете, возвращается информация о карточках Маркета, к которым привязан этот товар:  * Идентификатор текущей карточки (marketSku), карточки, которая проходит модерацию и последней отклоненной карточки. * Описание товара, которое указано на карточке Маркета. Например, размер упаковки и вес товара.  Результаты возвращаются постранично. Выходные данные содержат идентификатор следующей страницы.  {% note info %}  Количество товаров в каталоге магазина считается по данным за последние семь дней (не включая сегодня).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров в каталоге магазина * 25) 
         * @summary Список товаров в каталоге
         * @throws {RequiredError}
         */
        getOfferMappingEntries(campaignId: number, offerId?: Array<string>, shopSku?: Array<string>, mappingKind?: OfferMappingKindType, status?: Array<OfferProcessingStatusType>, availability?: Array<OfferAvailabilityStatusType>, categoryId?: Array<number>, vendor?: Array<string>, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferMappingEntriesResponse> {
            const localVarFetchArgs = OfferMappingsApiFetchParamCreator(configuration).getOfferMappingEntries(campaignId, offerId, shopSku, mappingKind, status, availability, categoryId, vendor, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/suggestions](../../reference/business-assortment/getSuggestedOfferMappings.md).  {% endnote %}  Возвращает идентификаторы карточек товаров на Маркете, рекомендованных для ваших товаров.  Каждому товару, который вы размещаете, должна соответствовать карточка товара на Маркете со своим идентификатором — SKU на Маркете. Он указывается в URL карточки товара, после «...sku=», например:  ##https://market.yandex.ru/product--yandex-kniga/484830016?sku=484830016…##  Чтобы получить для товаров рекомендованные SKU на Маркете, передайте в теле POST-запроса как можно больше информации о них: названия, производителей, штрихкоды, цены и т. д.  Полученные SKU можно передать вместе с информацией о ваших товарах с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md).  В одном запросе можно получить не более 500 рекомендаций.  |**⚙️ Лимит:** 100 000 рекомендаций в час| |-| 
         * @summary Рекомендованные карточки для товаров
         * @throws {RequiredError}
         */
        getSuggestedOfferMappingEntries(campaignId: number, getSuggestedOfferMappingEntriesRequest: GetSuggestedOfferMappingEntriesRequest, options?: RequestOptions = {}): Promise<GetSuggestedOfferMappingEntriesResponse> {
            const localVarFetchArgs = OfferMappingsApiFetchParamCreator(configuration).getSuggestedOfferMappingEntries(campaignId, getSuggestedOfferMappingEntriesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  {% endnote %}  Добавляет товары, указанные в запросе, в ваш каталог товаров и редактирует уже имеющиеся товары.  Информацию о товарах нужно передать в теле POST-запроса.  У каждого товара должен быть ваш SKU — уникальный код, который вы используете для идентификации товара:  * Чтобы добавить в каталог новый товар, укажите в параметре `shopSku` ваш SKU, которого еще нет в каталоге. * Чтобы отредактировать товар из каталога, укажите в параметре `shopSku` ваш SKU этого товара в каталоге.  В обоих случаях в запросе нужно передать полное описание товара, даже если вы хотите изменить только несколько характеристик.  Если вы знаете, какой карточке товара на Маркете соответствует ваш товар, укажите ее идентификатор (SKU на Маркете) во входном параметре mapping. Получить SKU на Маркете рекомендованной карточки товара можно с помощью запроса [POST campaigns/{campaignId}/offer-mapping-entries/suggestions](../../reference/offer-mappings/getSuggestedOfferMappingEntries.md) или через кабинет. Если SKU на Маркете не указан, сотрудники Маркета сами подберут или создадут подходящую карточку товара, либо у него появится статус `NEED_CONTENT` (нужно найти карточку или создать ее самостоятельно) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  Перед публикацией товары проходят модерацию. Если в одном из отправленных товаров найдена ошибка, ответ на запрос будет иметь HTTP-код 400 Bad Request, и ни один из товаров не отправится на модерацию. При этом если вы не передадите все обязательные параметры для какого‑либо товара, после модерации у него появится статус `NEED_INFO` (в описании товара не хватает информации) в выходных данных запроса [GET campaigns/{campaignId}/offer-mapping-entries](../../reference/offer-mappings/getOfferMappingEntries.md).  В одном запросе можно добавить не более 500 товаров.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5 000 товаров в минуту| |-| 
         * @summary Добавление и редактирование товаров в каталоге
         * @throws {RequiredError}
         */
        updateOfferMappingEntries(campaignId: number, updateOfferMappingEntryRequest: UpdateOfferMappingEntryRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OfferMappingsApiFetchParamCreator(configuration).updateOfferMappingEntries(campaignId, updateOfferMappingEntryRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OffersApi - fetch parameter creator
 * @export
 */
export const OffersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteCampaignOffers.');
            }
            // verify required parameter 'deleteCampaignOffersRequest' is not null or undefined
            if (deleteCampaignOffersRequest === null || deleteCampaignOffersRequest === undefined) {
                throw new RequiredError('deleteCampaignOffersRequest','Required parameter deleteCampaignOffersRequest was null or undefined when calling deleteCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/delete`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deleteCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deleteCampaignOffersRequest != null ? deleteCampaignOffersRequest : {}) : (((deleteCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getAllOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/all`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (chunk !== undefined) {
                localVarQueryParameter['chunk'] = ((chunk:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignOffers.');
            }
            // verify required parameter 'getCampaignOffersRequest' is not null or undefined
            if (getCampaignOffersRequest === null || getCampaignOffersRequest === undefined) {
                throw new RequiredError('getCampaignOffersRequest','Required parameter getCampaignOffersRequest was null or undefined when calling getCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getCampaignOffersRequest != null ? getCampaignOffersRequest : {}) : (((getCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getOfferRecommendations.');
            }
            // verify required parameter 'getOfferRecommendationsRequest' is not null or undefined
            if (getOfferRecommendationsRequest === null || getOfferRecommendationsRequest === undefined) {
                throw new RequiredError('getOfferRecommendationsRequest','Required parameter getOfferRecommendationsRequest was null or undefined when calling getOfferRecommendations.');
            }
            const localVarPath = `/businesses/{businessId}/offers/recommendations`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOfferRecommendationsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOfferRecommendationsRequest != null ? getOfferRecommendationsRequest : {}) : (((getOfferRecommendationsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = ((query:any):string);
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feedId'] = ((feedId:any):string);
            }

            if (shopCategoryId !== undefined) {
                localVarQueryParameter['shopCategoryId'] = ((shopCategoryId:any):string);
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = ((currency:any):string);
            }

            if (matched !== undefined) {
                localVarQueryParameter['matched'] = ((matched:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateCampaignOffers.');
            }
            // verify required parameter 'updateCampaignOffersRequest' is not null or undefined
            if (updateCampaignOffersRequest === null || updateCampaignOffersRequest === undefined) {
                throw new RequiredError('updateCampaignOffersRequest','Required parameter updateCampaignOffersRequest was null or undefined when calling updateCampaignOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/update`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateCampaignOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateCampaignOffersRequest != null ? updateCampaignOffersRequest : {}) : (((updateCampaignOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OffersApiType = { 
    deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions): Promise<DeleteCampaignOffersResponse>,

    getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions): Promise<GetAllOffersResponse>,

    getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetCampaignOffersResponse>,

    getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOfferRecommendationsResponse>,

    getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetOffersResponse>,

    updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * OffersApi - factory function to inject configuration 
 * @export
 */
export const OffersApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OffersApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товаров из ассортимента магазина
         * @throws {RequiredError}
         */
        deleteCampaignOffers(campaignId: number, deleteCampaignOffersRequest: DeleteCampaignOffersRequest, options?: RequestOptions = {}): Promise<DeleteCampaignOffersResponse> {
            const localVarFetchArgs = OffersApiFetchParamCreator(configuration).deleteCampaignOffers(campaignId, deleteCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Все предложения магазина
         * @throws {RequiredError}
         */
        getAllOffers(campaignId: number, feedId?: number, chunk?: number, options?: RequestOptions = {}): Promise<GetAllOffersResponse> {
            const localVarFetchArgs = OffersApiFetchParamCreator(configuration).getAllOffers(campaignId, feedId, chunk, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Информация о товарах, которые размещены в заданном магазине
         * @throws {RequiredError}
         */
        getCampaignOffers(campaignId: number, getCampaignOffersRequest: GetCampaignOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetCampaignOffersResponse> {
            const localVarFetchArgs = OffersApiFetchParamCreator(configuration).getCampaignOffers(campaignId, getCampaignOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Рекомендации Маркета, касающиеся цен
         * @throws {RequiredError}
         */
        getOfferRecommendations(businessId: number, getOfferRecommendationsRequest: GetOfferRecommendationsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOfferRecommendationsResponse> {
            const localVarFetchArgs = OffersApiFetchParamCreator(configuration).getOfferRecommendations(businessId, getOfferRecommendationsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
         * @summary Предложения магазина
         * @throws {RequiredError}
         */
        getOffers(campaignId: number, query?: string, feedId?: number, shopCategoryId?: string, currency?: CurrencyType, matched?: boolean, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetOffersResponse> {
            const localVarFetchArgs = OffersApiFetchParamCreator(configuration).getOffers(campaignId, query, feedId, shopCategoryId, currency, matched, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Изменение условий продажи товаров в магазине
         * @throws {RequiredError}
         */
        updateCampaignOffers(campaignId: number, updateCampaignOffersRequest: UpdateCampaignOffersRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OffersApiFetchParamCreator(configuration).updateCampaignOffers(campaignId, updateCampaignOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OrderBusinessInformationApi - fetch parameter creator
 * @export
 */
export const OrderBusinessInformationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessBuyerInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/business-buyer`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBusinessDocumentsInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/documents`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OrderBusinessInformationApiType = { 
    getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessBuyerInfoResponse>,

    getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetBusinessDocumentsInfoResponse>,
}

/**
 * OrderBusinessInformationApi - factory function to inject configuration 
 * @export
 */
export const OrderBusinessInformationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OrderBusinessInformationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является физическим лицом, воспользуйтесь запросом [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY`, `PICKUP` или `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — юридическом лице
         * @throws {RequiredError}
         */
        getOrderBusinessBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessBuyerInfoResponse> {
            const localVarFetchArgs = OrderBusinessInformationApiFetchParamCreator(configuration).getOrderBusinessBuyerInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о документах по идентификатору заказа.  Получить данные можно после того, как заказ перейдет в статус `DELIVERED`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о документах
         * @throws {RequiredError}
         */
        getOrderBusinessDocumentsInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetBusinessDocumentsInfoResponse> {
            const localVarFetchArgs = OrderBusinessInformationApiFetchParamCreator(configuration).getOrderBusinessDocumentsInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OrderDeliveryApi - fetch parameter creator
 * @export
 */
export const OrderDeliveryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является юридическим лицом, воспользуйтесь запросом [POST campaigns/{campaignId}/orders/{orderId}/business-buyer](../../reference/order-business-information/getOrderBusinessBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY` или `PICKUP`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — физическом лице
         * @throws {RequiredError}
         */
        getOrderBuyerInfo(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderBuyerInfo.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderBuyerInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/buyer`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод изменяет дату доставки заказа в статусе `PROCESSING` или `DELIVERY`. Для заказов с другими статусами дату доставки изменить нельзя.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение даты доставки заказа
         * @throws {RequiredError}
         */
        setOrderDeliveryDate(campaignId: number, orderId: number, setOrderDeliveryDateRequest: SetOrderDeliveryDateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderDeliveryDate.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderDeliveryDate.');
            }
            // verify required parameter 'setOrderDeliveryDateRequest' is not null or undefined
            if (setOrderDeliveryDateRequest === null || setOrderDeliveryDateRequest === undefined) {
                throw new RequiredError('setOrderDeliveryDateRequest','Required parameter setOrderDeliveryDateRequest was null or undefined when calling setOrderDeliveryDate.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/date`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderDeliveryDateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderDeliveryDateRequest != null ? setOrderDeliveryDateRequest : {}) : (((setOrderDeliveryDateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Вы можете использовать запрос, чтобы повысить лояльность покупателей. Если они могут узнать, на каком этапе доставки находятся их заказы, доверие покупателей к вашему магазину может возрасти.  {% endnote %}  Передает Маркету трек‑номер, по которому покупатель может отследить посылку со своим заказом через службу доставки.  Передать трек‑номер можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY` или `PICKUP`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача трек‑номера посылки
         * @throws {RequiredError}
         */
        setOrderDeliveryTrackCode(campaignId: number, orderId: number, setOrderDeliveryTrackCodeRequest: SetOrderDeliveryTrackCodeRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderDeliveryTrackCode.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderDeliveryTrackCode.');
            }
            // verify required parameter 'setOrderDeliveryTrackCodeRequest' is not null or undefined
            if (setOrderDeliveryTrackCodeRequest === null || setOrderDeliveryTrackCodeRequest === undefined) {
                throw new RequiredError('setOrderDeliveryTrackCodeRequest','Required parameter setOrderDeliveryTrackCodeRequest was null or undefined when calling setOrderDeliveryTrackCode.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/track`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderDeliveryTrackCodeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderDeliveryTrackCodeRequest != null ? setOrderDeliveryTrackCodeRequest : {}) : (((setOrderDeliveryTrackCodeRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Продлевает срок хранения заказа в пункте выдачи продавца.  Заказ должен быть в статусе `PICKUP`. Продлить срок можно только один раз, не больше чем на 30 дней.  Новый срок хранения можно получить в параметре `outletStorageLimitDate` запроса [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Продление срока хранения заказа
         * @throws {RequiredError}
         */
        updateOrderStorageLimit(campaignId: number, orderId: number, updateOrderStorageLimitRequest: UpdateOrderStorageLimitRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStorageLimit.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderStorageLimit.');
            }
            // verify required parameter 'updateOrderStorageLimitRequest' is not null or undefined
            if (updateOrderStorageLimitRequest === null || updateOrderStorageLimitRequest === undefined) {
                throw new RequiredError('updateOrderStorageLimitRequest','Required parameter updateOrderStorageLimitRequest was null or undefined when calling updateOrderStorageLimit.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/storage-limit`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStorageLimitRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStorageLimitRequest != null ? updateOrderStorageLimitRequest : {}) : (((updateOrderStorageLimitRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет Маркету код подтверждения для его проверки.  Код подтверждает передачу заказа или невыкупа:  * курьеру — курьер должен назвать магазину код; * магазину — магазин называет код курьеру.  Если магазин получает невыкупленный заказ, то ему нужно назвать курьеру код из кабинета или приложения.  Если у магазина настроена работа с кодами подтверждения, в запросах [POST order/status](../../pushapi/reference/postOrderStatus.md), [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md), [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md), [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) в параметре `delivery`, вложенном в `order` будет возвращаться параметр `eacType` с типом `Enum` — тип кода подтверждения для передачи заказа.  Возможные значения: `MERCHANT_TO_COURIER` — магазин называет код курьеру, `COURIER_TO_MERCHANT` — курьер называет код магазину.  Параметр `eacType` возвращается при статусах заказа `COURIER_FOUND`, `COURIER_ARRIVED_TO_SENDER` и `DELIVERY_SERVICE_UNDELIVERED`. Если заказ в других статусах, параметр может отсутствовать.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кода подтверждения
         * @throws {RequiredError}
         */
        verifyOrderEac(campaignId: number, orderId: number, verifyOrderEacRequest: VerifyOrderEacRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling verifyOrderEac.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling verifyOrderEac.');
            }
            // verify required parameter 'verifyOrderEacRequest' is not null or undefined
            if (verifyOrderEacRequest === null || verifyOrderEacRequest === undefined) {
                throw new RequiredError('verifyOrderEacRequest','Required parameter verifyOrderEacRequest was null or undefined when calling verifyOrderEac.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/verifyEac`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof verifyOrderEacRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(verifyOrderEacRequest != null ? verifyOrderEacRequest : {}) : (((verifyOrderEacRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OrderDeliveryApiType = { 
    getOrderBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderBuyerInfoResponse>,

    setOrderDeliveryDate(campaignId: number, orderId: number, setOrderDeliveryDateRequest: SetOrderDeliveryDateRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    setOrderDeliveryTrackCode(campaignId: number, orderId: number, setOrderDeliveryTrackCodeRequest: SetOrderDeliveryTrackCodeRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updateOrderStorageLimit(campaignId: number, orderId: number, updateOrderStorageLimitRequest: UpdateOrderStorageLimitRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    verifyOrderEac(campaignId: number, orderId: number, verifyOrderEacRequest: VerifyOrderEacRequest, options?: RequestOptions): Promise<VerifyOrderEacResponse>,
}

/**
 * OrderDeliveryApi - factory function to inject configuration 
 * @export
 */
export const OrderDeliveryApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OrderDeliveryApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает информацию о покупателе по идентификатору заказа.  {% note info \"\" %}  Чтобы получить информацию о покупателе, который является юридическим лицом, воспользуйтесь запросом [POST campaigns/{campaignId}/orders/{orderId}/business-buyer](../../reference/order-business-information/getOrderBusinessBuyerInfo.md).  {% endnote %}  Получить данные можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY` или `PICKUP`.  Если у вас настроена работа с push-компонентом, Маркет отправит уведомление о смене статуса заказа с помощью запроса [POST order/status](../../pushapi/reference/postOrderStatus.md).  |**⚙️ Лимит:** 3 000 запросов в час| |-| 
         * @summary Информация о покупателе — физическом лице
         * @throws {RequiredError}
         */
        getOrderBuyerInfo(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderBuyerInfoResponse> {
            const localVarFetchArgs = OrderDeliveryApiFetchParamCreator(configuration).getOrderBuyerInfo(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Метод изменяет дату доставки заказа в статусе `PROCESSING` или `DELIVERY`. Для заказов с другими статусами дату доставки изменить нельзя.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение даты доставки заказа
         * @throws {RequiredError}
         */
        setOrderDeliveryDate(campaignId: number, orderId: number, setOrderDeliveryDateRequest: SetOrderDeliveryDateRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OrderDeliveryApiFetchParamCreator(configuration).setOrderDeliveryDate(campaignId, orderId, setOrderDeliveryDateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Вы можете использовать запрос, чтобы повысить лояльность покупателей. Если они могут узнать, на каком этапе доставки находятся их заказы, доверие покупателей к вашему магазину может возрасти.  {% endnote %}  Передает Маркету трек‑номер, по которому покупатель может отследить посылку со своим заказом через службу доставки.  Передать трек‑номер можно, только если заказ находится в статусе `PROCESSING`, `DELIVERY` или `PICKUP`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача трек‑номера посылки
         * @throws {RequiredError}
         */
        setOrderDeliveryTrackCode(campaignId: number, orderId: number, setOrderDeliveryTrackCodeRequest: SetOrderDeliveryTrackCodeRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OrderDeliveryApiFetchParamCreator(configuration).setOrderDeliveryTrackCode(campaignId, orderId, setOrderDeliveryTrackCodeRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Продлевает срок хранения заказа в пункте выдачи продавца.  Заказ должен быть в статусе `PICKUP`. Продлить срок можно только один раз, не больше чем на 30 дней.  Новый срок хранения можно получить в параметре `outletStorageLimitDate` запроса [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Продление срока хранения заказа
         * @throws {RequiredError}
         */
        updateOrderStorageLimit(campaignId: number, orderId: number, updateOrderStorageLimitRequest: UpdateOrderStorageLimitRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OrderDeliveryApiFetchParamCreator(configuration).updateOrderStorageLimit(campaignId, orderId, updateOrderStorageLimitRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Отправляет Маркету код подтверждения для его проверки.  Код подтверждает передачу заказа или невыкупа:  * курьеру — курьер должен назвать магазину код; * магазину — магазин называет код курьеру.  Если магазин получает невыкупленный заказ, то ему нужно назвать курьеру код из кабинета или приложения.  Если у магазина настроена работа с кодами подтверждения, в запросах [POST order/status](../../pushapi/reference/postOrderStatus.md), [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md), [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md), [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) в параметре `delivery`, вложенном в `order` будет возвращаться параметр `eacType` с типом `Enum` — тип кода подтверждения для передачи заказа.  Возможные значения: `MERCHANT_TO_COURIER` — магазин называет код курьеру, `COURIER_TO_MERCHANT` — курьер называет код магазину.  Параметр `eacType` возвращается при статусах заказа `COURIER_FOUND`, `COURIER_ARRIVED_TO_SENDER` и `DELIVERY_SERVICE_UNDELIVERED`. Если заказ в других статусах, параметр может отсутствовать.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кода подтверждения
         * @throws {RequiredError}
         */
        verifyOrderEac(campaignId: number, orderId: number, verifyOrderEacRequest: VerifyOrderEacRequest, options?: RequestOptions = {}): Promise<VerifyOrderEacResponse> {
            const localVarFetchArgs = OrderDeliveryApiFetchParamCreator(configuration).verifyOrderEac(campaignId, orderId, verifyOrderEacRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OrderLabelsApi - fetch parameter creator
 * @export
 */
export const OrderLabelsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Формирует ярлык‑наклейку для коробки в заказе и возвращает ярлык в PDF‑файле.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовый ярлык‑наклейка для коробки в заказе
         * @throws {RequiredError}
         */
        generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling generateOrderLabel.');
            }
            // verify required parameter 'boxId' is not null or undefined
            if (boxId === null || boxId === undefined) {
                throw new RequiredError('boxId','Required parameter boxId was null or undefined when calling generateOrderLabel.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"boxId"}}`, encodeURIComponent(String(boxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает PDF-файл с ярлыками, которые нужно наклеить на коробки перед отгрузкой. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  На вход нужно передать идентификатор заказа и один необязательный параметр, который управляет версткой PDF-файла.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в одном заказе
         * @throws {RequiredError}
         */
        generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling generateOrderLabels.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling generateOrderLabels.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/labels`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию на ярлыках, которые клеятся на коробки в заказе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Данные для самостоятельного изготовления ярлыков
         * @throws {RequiredError}
         */
        getOrderLabelsData(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrderLabelsData.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderLabelsData.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/labels/data`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OrderLabelsApiType = { 
    generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options?: RequestOptions): Promise<File>,

    generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options?: RequestOptions): Promise<File>,

    getOrderLabelsData(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderLabelsDataResponse>,
}

/**
 * OrderLabelsApi - factory function to inject configuration 
 * @export
 */
export const OrderLabelsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OrderLabelsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Формирует ярлык‑наклейку для коробки в заказе и возвращает ярлык в PDF‑файле.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовый ярлык‑наклейка для коробки в заказе
         * @throws {RequiredError}
         */
        generateOrderLabel(campaignId: number, orderId: number, shipmentId: number, boxId: number, format?: PageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = OrderLabelsApiFetchParamCreator(configuration).generateOrderLabel(campaignId, orderId, shipmentId, boxId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает PDF-файл с ярлыками, которые нужно наклеить на коробки перед отгрузкой. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  На вход нужно передать идентификатор заказа и один необязательный параметр, который управляет версткой PDF-файла.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в одном заказе
         * @throws {RequiredError}
         */
        generateOrderLabels(campaignId: number, orderId: number, format?: PageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = OrderLabelsApiFetchParamCreator(configuration).generateOrderLabels(campaignId, orderId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию на ярлыках, которые клеятся на коробки в заказе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Данные для самостоятельного изготовления ярлыков
         * @throws {RequiredError}
         */
        getOrderLabelsData(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderLabelsDataResponse> {
            const localVarFetchArgs = OrderLabelsApiFetchParamCreator(configuration).getOrderLabelsData(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OrdersApi - fetch parameter creator
 * @export
 */
export const OrdersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Подтверждает или отклоняет запрос покупателя на отмену заказа, который передан службе доставки.  Покупатель может отменить заказ в течение его обработки или доставки. Если заказ еще обрабатывается (имеет статус PROCESSING), вам не нужно подтверждать отмену заказа — он будет отменен автоматически.  Если заказ уже передан службе доставки (принимает статус `DELIVERY` или `PICKUP`) и пользователь отменил его, вы можете предупредить службу об отмене в течение 48 часов. Если служба доставки узнала об отмене до передачи заказа покупателю, подтвердите отмену с помощью запроса [PUT campaigns/{campaignId}/orders/{orderId}/cancellation/accept](../../reference/orders/acceptOrderCancellation.md). Если заказ уже доставлен, отклоните отмену с помощью этого же запроса. Тогда у покупателя останется заказ, и деньги за него возвращаться не будут.  Чтобы узнать, какие заказы были отменены в статусе `DELIVERY` или `PICKUP`, отправьте запрос [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md). В его URL добавьте входной параметр `onlyWaitingForCancellationApprove=true`. Вы также можете узнать об отмененных заказах в кабинете или через почту — на нее придет уведомление об отмене.  Если в течение 48 часов вы не подтвердите или отклоните отмену, заказ будет отменен автоматически.  |**⚙️ Лимит:** 500 запросов в час| |-| 
         * @summary Отмена заказа покупателем
         * @throws {RequiredError}
         */
        acceptOrderCancellation(campaignId: number, orderId: number, acceptOrderCancellationRequest: AcceptOrderCancellationRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling acceptOrderCancellation.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling acceptOrderCancellation.');
            }
            // verify required parameter 'acceptOrderCancellationRequest' is not null or undefined
            if (acceptOrderCancellationRequest === null || acceptOrderCancellationRequest === undefined) {
                throw new RequiredError('acceptOrderCancellationRequest','Required parameter acceptOrderCancellationRequest was null or undefined when calling acceptOrderCancellation.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/cancellation/accept`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof acceptOrderCancellationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(acceptOrderCancellationRequest != null ? acceptOrderCancellationRequest : {}) : (((acceptOrderCancellationRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrder.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrders.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status).join(COLLECTION_FORMATS["csv"]);
            }

            if (substatus) {
                localVarQueryParameter['substatus'] = Array.from(substatus).join(COLLECTION_FORMATS["csv"]);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateFrom !== undefined) {
                localVarQueryParameter['supplierShipmentDateFrom'] = ((supplierShipmentDateFrom:any):Date).toISOString().slice(0, 10);
            }

            if (supplierShipmentDateTo !== undefined) {
                localVarQueryParameter['supplierShipmentDateTo'] = ((supplierShipmentDateTo:any):Date).toISOString().slice(0, 10);
            }

            if (updatedAtFrom !== undefined) {
                localVarQueryParameter['updatedAtFrom'] = ((updatedAtFrom:any):Date).toISOString();
            }

            if (updatedAtTo !== undefined) {
                localVarQueryParameter['updatedAtTo'] = ((updatedAtTo:any):Date).toISOString();
            }

            if (dispatchType !== undefined) {
                localVarQueryParameter['dispatchType'] = ((dispatchType:any):string);
            }

            if (fake !== undefined) {
                localVarQueryParameter['fake'] = ((fake:any):string);
            }

            if (hasCis !== undefined) {
                localVarQueryParameter['hasCis'] = ((hasCis:any):string);
            }

            if (onlyWaitingForCancellationApprove !== undefined) {
                localVarQueryParameter['onlyWaitingForCancellationApprove'] = ((onlyWaitingForCancellationApprove:any):string);
            }

            if (onlyEstimatedDelivery !== undefined) {
                localVarQueryParameter['onlyEstimatedDelivery'] = ((onlyEstimatedDelivery:any):string);
            }

            if (buyerType !== undefined) {
                localVarQueryParameter['buyerType'] = ((buyerType:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает ключи цифровых товаров, которые покупатель заказал и оплатил. После выполнения запроса Маркет отправит ему письмо с ключами и инструкциями по активации, а также переведет заказ в финальный статус `DELIVERED`.  Ключ нужно передать в течение 30 минут после перехода заказа в статус `PROCESSING`.  Если в один заказ входят несколько ключей, передавайте их все в одном запросе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача ключей цифровых товаров
         * @throws {RequiredError}
         */
        provideOrderDigitalCodes(campaignId: number, orderId: number, provideOrderDigitalCodesRequest: ProvideOrderDigitalCodesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling provideOrderDigitalCodes.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling provideOrderDigitalCodes.');
            }
            // verify required parameter 'provideOrderDigitalCodesRequest' is not null or undefined
            if (provideOrderDigitalCodesRequest === null || provideOrderDigitalCodesRequest === undefined) {
                throw new RequiredError('provideOrderDigitalCodesRequest','Required parameter provideOrderDigitalCodesRequest was null or undefined when calling provideOrderDigitalCodes.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/deliverDigitalGoods`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof provideOrderDigitalCodesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(provideOrderDigitalCodesRequest != null ? provideOrderDigitalCodesRequest : {}) : (((provideOrderDigitalCodesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Передает Маркету коды маркировки для единиц товара в указанном заказе.  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  {% note warning %}  Прежде чем работать с этим методом, обязательно прочтите [статью о работе с маркируемыми товарами](https://yandex.ru/support/marketplace/orders/cz.html).  {% endnote %}  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кодов маркировки единиц товара
         * @throws {RequiredError}
         */
        provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling provideOrderItemIdentifiers.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling provideOrderItemIdentifiers.');
            }
            // verify required parameter 'provideOrderItemIdentifiersRequest' is not null or undefined
            if (provideOrderItemIdentifiersRequest === null || provideOrderItemIdentifiersRequest === undefined) {
                throw new RequiredError('provideOrderItemIdentifiersRequest','Required parameter provideOrderItemIdentifiersRequest was null or undefined when calling provideOrderItemIdentifiers.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/identifiers`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof provideOrderItemIdentifiersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(provideOrderItemIdentifiersRequest != null ? provideOrderItemIdentifiersRequest : {}) : (((provideOrderItemIdentifiersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note tip \"Подходит и для DBS\" %}  Запрос предназначен для работы с FBS-заказами, но вы можете использовать его для обработки DBS-заказов, если это удобно.  {% endnote %}  Позволяет выполнить три операции:  * передать Маркету информацию о распределении товаров по коробкам; * передать Маркету коды маркировки для товаров; * удалить товар из заказа, если его не оказалось на складе.  Если нужно что-то поправить в переданных данных, просто повторите запрос — это можно делать сколько угодно раз до перевода заказа в статус **Готов к отгрузке**. ⚠️ Если вы меняете раскладку уже после печати и расклейки ярлыков, не забудье перепечатать их и наклеить заново.  ## Как передать информацию о распределении товаров  В этом запросе вам нужно передать Маркету список коробок и указать, какие именно товары лежат в каждой из них. Коробки могут быть двух типов:  * **Содержащие товары целиком.** Такая коробка может содержать сколько угодно единиц любых товаров.  * **Содержащие часть товара.** Такие коробки содержат по одной части одного товара. Например, одна содержит внешний блок кондиционера, а другая — внутренний блок.  ⚠️ Одна коробка не может содержать и товары целиком, и части товаров.  ## Как передавать коды маркировки  Если в заказе есть товары, подлежащие маркировке, в запросе нужно передать соответствующие уникальные коды. [Что такое маркировка?](https://yandex.ru/support/marketplace/orders/cz.html)  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  Если товар едет в нескольких коробках, код маркировки нужно передать для каждой из них.  ## Как удалить товар из заказа  Чтобы удалить товар из заказа:  1. Добавьте в запрос `allowRemove: true`. 2. Передайте распределение по коробкам без товара, который нужно удалить.  {% note warning \"Удаление нельзя отменить\" %}  Эта операция необратима: покупатель сразу получит уведомление, а состав заказа изменится.  {% endnote %}  Чтобы удалить позицию целиком, не передавайте соответствующий `OrderBoxLayoutItemDTO`. Чтобы уменьшить количество товара, передайте уменьшенное значение в поле `fullCount`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если вы не можете отгрузить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  ## Примеры  {% cut \"Товар умещается в коробку\" %}  Вот как будет выглядеть запрос, если в одной коробке едут:    * три единицы одного товара, требующего маркировки;   * одна единица другого товара, не требущего маркировки.    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"fullCount\": 3,                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           },                           {                               \"cis\": \"010304109478gftJ14545762!\\u001dhGt264\"                           },                           {                               \"cis\": \"010304109478fRs28323ks23!\\u001dhet201\"                           }                       ]                   },                   {                       \"id\": 654321,                       \"fullCount\": 1                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Товар едет в разных коробках\" %}  Вот как будет выглядеть запрос, если товар едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Одинаковые товары, где каждый едет в нескольких коробках\" %}  Вот как будет выглядеть запрос, если каждый из двух одинаковых товаров едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Подготовка заказа
         * @throws {RequiredError}
         */
        setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderBoxLayout.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderBoxLayout.');
            }
            // verify required parameter 'setOrderBoxLayoutRequest' is not null or undefined
            if (setOrderBoxLayoutRequest === null || setOrderBoxLayoutRequest === undefined) {
                throw new RequiredError('setOrderBoxLayoutRequest','Required parameter setOrderBoxLayoutRequest was null or undefined when calling setOrderBoxLayout.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/boxes`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderBoxLayoutRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderBoxLayoutRequest != null ? setOrderBoxLayoutRequest : {}) : (((setOrderBoxLayoutRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Отгружаемый Маркету заказ может не влезть в одну коробку или упаковку — в этом случае получается, что он занимает несколько грузовых мест.  Количество грузовых мест нужно обязательно передавать Маркету, если оно не равно 1. Это делается перед переводом его в статус **Готов к отгрузке**. Подробно о том, что в какой момент нужно передавать, рассказано в [пошаговой инструкции](../../step-by-step/fbs.md).  Метод устроен немного нестандартно: количество задается длиной массива пустых объектов.  Раньше метод требовал передачи большего количества данных. Запросы, оформленные по старому образцу, работают, но лучше делать по-новому.  {% cut \"Как было раньше\" %}  Структура тела PUT-запроса:  ``` {   \"boxes\":   [     {       \"fulfilmentId\": \"{string}\",       \"weight\": {int64},       \"width\": {int64},       \"height\": {int64},       \"depth\": {int64},       \"items\":       [         {           \"id\": {int64},           \"count\": {int32}         },         ...       ]     },     ...   ] } ``` | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `boxes`       |           | Список грузовых мест.       |  **Параметры, вложенные в `boxes`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `fulfilmentId`       |  String   | Идентификатор грузового места в информационной системе магазина. Сформируйте идентификатор по шаблону: `номер заказа на Маркете-номер грузового места`. Например, `7206821‑1, 7206821‑2` и т. д. | | `weight`       | Int64        | Масса брутто грузового места (суммарная масса упаковки и содержимого) в граммах. | | `width`       | Int64   | Ширина грузового места в сантиметрах.       | | `height`       | Int64   | Высота грузового места в сантиметрах.       | | `depth`       | Int64   | Глубина грузового места в сантиметрах.        | | `items`       | Int64   | Список товаров в грузовом месте.       |  **Параметры, вложенные в `items`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `id`       | Int64     | Идентификатор товара в рамках заказа.   | | `count`    | Int32     | Количество единиц товара в грузовом месте.       |  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача количества грузовых мест в заказе
         * @throws {RequiredError}
         */
        setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling setOrderShipmentBoxes.');
            }
            // verify required parameter 'setOrderShipmentBoxesRequest' is not null or undefined
            if (setOrderShipmentBoxesRequest === null || setOrderShipmentBoxesRequest === undefined) {
                throw new RequiredError('setOrderShipmentBoxesRequest','Required parameter setOrderShipmentBoxesRequest was null or undefined when calling setOrderShipmentBoxes.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setOrderShipmentBoxesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setOrderShipmentBoxesRequest != null ? setOrderShipmentBoxesRequest : {}) : (((setOrderShipmentBoxesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Изменяет состав заказа, если позволяет выбранная служба доставки, в случаях:  * покупатель уменьшил количество товара; * магазин не может поставить все товары в заказе.  Для этого заказ должен находится в статусе `\"status\": \"PROCESSING\"` этапа обработки `\"substatus\": \"STARTED\"`. После передачи статуса `\"substatus\": \"READY_TO_SHIP\"` изменить состав невозможно.  Если одинаковых товаров несколько, для уменьшения количества передайте обновленное значение в атрибуте `count` параметра `item`.  Чтобы полностью удалить товар из заказа:  * передайте значение `0`; или * не передавайте параметр `item`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если необходимо удалить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  **Возврат денег покупателю**  Если покупатель оплатил товар при оформлении, Маркет вернет ему деньги за удаленные из заказа товары в течение двух дней:  * при оплате банковской картой — с момента, когда магазин переведет заказ в статус `SHIPPED`;  * при оплате через Apple Pay или Google Pay — с момента, когда магазин удалит товар из заказа.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Удаление товара из заказа или уменьшение числа единиц
         * @throws {RequiredError}
         */
        updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderItems.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderItems.');
            }
            // verify required parameter 'updateOrderItemRequest' is not null or undefined
            if (updateOrderItemRequest === null || updateOrderItemRequest === undefined) {
                throw new RequiredError('updateOrderItemRequest','Required parameter updateOrderItemRequest was null or undefined when calling updateOrderItems.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/items`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderItemRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderItemRequest != null ? updateOrderItemRequest : {}) : (((updateOrderItemRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет статус заказа. Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статуса одного заказа
         * @throws {RequiredError}
         */
        updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStatus.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderStatus.');
            }
            // verify required parameter 'updateOrderStatusRequest' is not null or undefined
            if (updateOrderStatusRequest === null || updateOrderStatusRequest === undefined) {
                throw new RequiredError('updateOrderStatusRequest','Required parameter updateOrderStatusRequest was null or undefined when calling updateOrderStatus.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/status`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStatusRequest != null ? updateOrderStatusRequest : {}) : (((updateOrderStatusRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет статусы нескольких заказов.  Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"`и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  Максимальное количество заказов, у которых можно изменить статус в одном запросе, — 30.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статусов нескольких заказов
         * @throws {RequiredError}
         */
        updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOrderStatuses.');
            }
            // verify required parameter 'updateOrderStatusesRequest' is not null or undefined
            if (updateOrderStatusesRequest === null || updateOrderStatusesRequest === undefined) {
                throw new RequiredError('updateOrderStatusesRequest','Required parameter updateOrderStatusesRequest was null or undefined when calling updateOrderStatuses.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/status-update`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOrderStatusesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOrderStatusesRequest != null ? updateOrderStatusesRequest : {}) : (((updateOrderStatusesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OrdersApiType = { 
    acceptOrderCancellation(campaignId: number, orderId: number, acceptOrderCancellationRequest: AcceptOrderCancellationRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    getOrder(campaignId: number, orderId: number, options?: RequestOptions): Promise<GetOrderResponse>,

    getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetOrdersResponse>,

    provideOrderDigitalCodes(campaignId: number, orderId: number, provideOrderDigitalCodesRequest: ProvideOrderDigitalCodesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options?: RequestOptions): Promise<ProvideOrderItemIdentifiersResponse>,

    setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options?: RequestOptions): Promise<SetOrderBoxLayoutResponse>,

    setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options?: RequestOptions): Promise<SetOrderShipmentBoxesResponse>,

    updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options?: RequestOptions): Promise<Response>,

    updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options?: RequestOptions): Promise<UpdateOrderStatusResponse>,

    updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options?: RequestOptions): Promise<UpdateOrderStatusesResponse>,
}

/**
 * OrdersApi - factory function to inject configuration 
 * @export
 */
export const OrdersApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OrdersApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Подтверждает или отклоняет запрос покупателя на отмену заказа, который передан службе доставки.  Покупатель может отменить заказ в течение его обработки или доставки. Если заказ еще обрабатывается (имеет статус PROCESSING), вам не нужно подтверждать отмену заказа — он будет отменен автоматически.  Если заказ уже передан службе доставки (принимает статус `DELIVERY` или `PICKUP`) и пользователь отменил его, вы можете предупредить службу об отмене в течение 48 часов. Если служба доставки узнала об отмене до передачи заказа покупателю, подтвердите отмену с помощью запроса [PUT campaigns/{campaignId}/orders/{orderId}/cancellation/accept](../../reference/orders/acceptOrderCancellation.md). Если заказ уже доставлен, отклоните отмену с помощью этого же запроса. Тогда у покупателя останется заказ, и деньги за него возвращаться не будут.  Чтобы узнать, какие заказы были отменены в статусе `DELIVERY` или `PICKUP`, отправьте запрос [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md). В его URL добавьте входной параметр `onlyWaitingForCancellationApprove=true`. Вы также можете узнать об отмененных заказах в кабинете или через почту — на нее придет уведомление об отмене.  Если в течение 48 часов вы не подтвердите или отклоните отмену, заказ будет отменен автоматически.  |**⚙️ Лимит:** 500 запросов в час| |-| 
         * @summary Отмена заказа покупателем
         * @throws {RequiredError}
         */
        acceptOrderCancellation(campaignId: number, orderId: number, acceptOrderCancellationRequest: AcceptOrderCancellationRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).acceptOrderCancellation(campaignId, orderId, acceptOrderCancellationRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация об одном заказе
         * @throws {RequiredError}
         */
        getOrder(campaignId: number, orderId: number, options?: RequestOptions = {}): Promise<GetOrderResponse> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).getOrder(campaignId, orderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Информация о нескольких заказах
         * @throws {RequiredError}
         */
        getOrders(campaignId: number, orderIds?: Array<number>, status?: Set<OrderStatusType>, substatus?: Set<OrderSubstatusType>, fromDate?: Date, toDate?: Date, supplierShipmentDateFrom?: Date, supplierShipmentDateTo?: Date, updatedAtFrom?: Date, updatedAtTo?: Date, dispatchType?: OrderDeliveryDispatchType, fake?: boolean, hasCis?: boolean, onlyWaitingForCancellationApprove?: boolean, onlyEstimatedDelivery?: boolean, buyerType?: OrderBuyerType, page?: number, pageSize?: number, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetOrdersResponse> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).getOrders(campaignId, orderIds, status, substatus, fromDate, toDate, supplierShipmentDateFrom, supplierShipmentDateTo, updatedAtFrom, updatedAtTo, dispatchType, fake, hasCis, onlyWaitingForCancellationApprove, onlyEstimatedDelivery, buyerType, page, pageSize, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает ключи цифровых товаров, которые покупатель заказал и оплатил. После выполнения запроса Маркет отправит ему письмо с ключами и инструкциями по активации, а также переведет заказ в финальный статус `DELIVERED`.  Ключ нужно передать в течение 30 минут после перехода заказа в статус `PROCESSING`.  Если в один заказ входят несколько ключей, передавайте их все в одном запросе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача ключей цифровых товаров
         * @throws {RequiredError}
         */
        provideOrderDigitalCodes(campaignId: number, orderId: number, provideOrderDigitalCodesRequest: ProvideOrderDigitalCodesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).provideOrderDigitalCodes(campaignId, orderId, provideOrderDigitalCodesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Передает Маркету коды маркировки для единиц товара в указанном заказе.  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  {% note warning %}  Прежде чем работать с этим методом, обязательно прочтите [статью о работе с маркируемыми товарами](https://yandex.ru/support/marketplace/orders/cz.html).  {% endnote %}  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача кодов маркировки единиц товара
         * @throws {RequiredError}
         */
        provideOrderItemIdentifiers(campaignId: number, orderId: number, provideOrderItemIdentifiersRequest: ProvideOrderItemIdentifiersRequest, options?: RequestOptions = {}): Promise<ProvideOrderItemIdentifiersResponse> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).provideOrderItemIdentifiers(campaignId, orderId, provideOrderItemIdentifiersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note tip \"Подходит и для DBS\" %}  Запрос предназначен для работы с FBS-заказами, но вы можете использовать его для обработки DBS-заказов, если это удобно.  {% endnote %}  Позволяет выполнить три операции:  * передать Маркету информацию о распределении товаров по коробкам; * передать Маркету коды маркировки для товаров; * удалить товар из заказа, если его не оказалось на складе.  Если нужно что-то поправить в переданных данных, просто повторите запрос — это можно делать сколько угодно раз до перевода заказа в статус **Готов к отгрузке**. ⚠️ Если вы меняете раскладку уже после печати и расклейки ярлыков, не забудье перепечатать их и наклеить заново.  ## Как передать информацию о распределении товаров  В этом запросе вам нужно передать Маркету список коробок и указать, какие именно товары лежат в каждой из них. Коробки могут быть двух типов:  * **Содержащие товары целиком.** Такая коробка может содержать сколько угодно единиц любых товаров.  * **Содержащие часть товара.** Такие коробки содержат по одной части одного товара. Например, одна содержит внешний блок кондиционера, а другая — внутренний блок.  ⚠️ Одна коробка не может содержать и товары целиком, и части товаров.  ## Как передавать коды маркировки  Если в заказе есть товары, подлежащие маркировке, в запросе нужно передать соответствующие уникальные коды. [Что такое маркировка?](https://yandex.ru/support/marketplace/orders/cz.html)  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  Если товар едет в нескольких коробках, код маркировки нужно передать для каждой из них.  ## Как удалить товар из заказа  Чтобы удалить товар из заказа:  1. Добавьте в запрос `allowRemove: true`. 2. Передайте распределение по коробкам без товара, который нужно удалить.  {% note warning \"Удаление нельзя отменить\" %}  Эта операция необратима: покупатель сразу получит уведомление, а состав заказа изменится.  {% endnote %}  Чтобы удалить позицию целиком, не передавайте соответствующий `OrderBoxLayoutItemDTO`. Чтобы уменьшить количество товара, передайте уменьшенное значение в поле `fullCount`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если вы не можете отгрузить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  ## Примеры  {% cut \"Товар умещается в коробку\" %}  Вот как будет выглядеть запрос, если в одной коробке едут:    * три единицы одного товара, требующего маркировки;   * одна единица другого товара, не требущего маркировки.    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"fullCount\": 3,                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           },                           {                               \"cis\": \"010304109478gftJ14545762!\\u001dhGt264\"                           },                           {                               \"cis\": \"010304109478fRs28323ks23!\\u001dhet201\"                           }                       ]                   },                   {                       \"id\": 654321,                       \"fullCount\": 1                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Товар едет в разных коробках\" %}  Вот как будет выглядеть запрос, если товар едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Одинаковые товары, где каждый едет в нескольких коробках\" %}  Вот как будет выглядеть запрос, если каждый из двух одинаковых товаров едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Подготовка заказа
         * @throws {RequiredError}
         */
        setOrderBoxLayout(campaignId: number, orderId: number, setOrderBoxLayoutRequest: SetOrderBoxLayoutRequest, options?: RequestOptions = {}): Promise<SetOrderBoxLayoutResponse> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).setOrderBoxLayout(campaignId, orderId, setOrderBoxLayoutRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Отгружаемый Маркету заказ может не влезть в одну коробку или упаковку — в этом случае получается, что он занимает несколько грузовых мест.  Количество грузовых мест нужно обязательно передавать Маркету, если оно не равно 1. Это делается перед переводом его в статус **Готов к отгрузке**. Подробно о том, что в какой момент нужно передавать, рассказано в [пошаговой инструкции](../../step-by-step/fbs.md).  Метод устроен немного нестандартно: количество задается длиной массива пустых объектов.  Раньше метод требовал передачи большего количества данных. Запросы, оформленные по старому образцу, работают, но лучше делать по-новому.  {% cut \"Как было раньше\" %}  Структура тела PUT-запроса:  ``` {   \"boxes\":   [     {       \"fulfilmentId\": \"{string}\",       \"weight\": {int64},       \"width\": {int64},       \"height\": {int64},       \"depth\": {int64},       \"items\":       [         {           \"id\": {int64},           \"count\": {int32}         },         ...       ]     },     ...   ] } ``` | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `boxes`       |           | Список грузовых мест.       |  **Параметры, вложенные в `boxes`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `fulfilmentId`       |  String   | Идентификатор грузового места в информационной системе магазина. Сформируйте идентификатор по шаблону: `номер заказа на Маркете-номер грузового места`. Например, `7206821‑1, 7206821‑2` и т. д. | | `weight`       | Int64        | Масса брутто грузового места (суммарная масса упаковки и содержимого) в граммах. | | `width`       | Int64   | Ширина грузового места в сантиметрах.       | | `height`       | Int64   | Высота грузового места в сантиметрах.       | | `depth`       | Int64   | Глубина грузового места в сантиметрах.        | | `items`       | Int64   | Список товаров в грузовом месте.       |  **Параметры, вложенные в `items`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `id`       | Int64     | Идентификатор товара в рамках заказа.   | | `count`    | Int32     | Количество единиц товара в грузовом месте.       |  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Передача количества грузовых мест в заказе
         * @throws {RequiredError}
         */
        setOrderShipmentBoxes(campaignId: number, orderId: number, shipmentId: number, setOrderShipmentBoxesRequest: SetOrderShipmentBoxesRequest, options?: RequestOptions = {}): Promise<SetOrderShipmentBoxesResponse> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).setOrderShipmentBoxes(campaignId, orderId, shipmentId, setOrderShipmentBoxesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Изменяет состав заказа, если позволяет выбранная служба доставки, в случаях:  * покупатель уменьшил количество товара; * магазин не может поставить все товары в заказе.  Для этого заказ должен находится в статусе `\"status\": \"PROCESSING\"` этапа обработки `\"substatus\": \"STARTED\"`. После передачи статуса `\"substatus\": \"READY_TO_SHIP\"` изменить состав невозможно.  Если одинаковых товаров несколько, для уменьшения количества передайте обновленное значение в атрибуте `count` параметра `item`.  Чтобы полностью удалить товар из заказа:  * передайте значение `0`; или * не передавайте параметр `item`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если необходимо удалить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  **Возврат денег покупателю**  Если покупатель оплатил товар при оформлении, Маркет вернет ему деньги за удаленные из заказа товары в течение двух дней:  * при оплате банковской картой — с момента, когда магазин переведет заказ в статус `SHIPPED`;  * при оплате через Apple Pay или Google Pay — с момента, когда магазин удалит товар из заказа.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Удаление товара из заказа или уменьшение числа единиц
         * @throws {RequiredError}
         */
        updateOrderItems(campaignId: number, orderId: number, updateOrderItemRequest: UpdateOrderItemRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).updateOrderItems(campaignId, orderId, updateOrderItemRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет статус заказа. Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статуса одного заказа
         * @throws {RequiredError}
         */
        updateOrderStatus(campaignId: number, orderId: number, updateOrderStatusRequest: UpdateOrderStatusRequest, options?: RequestOptions = {}): Promise<UpdateOrderStatusResponse> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).updateOrderStatus(campaignId, orderId, updateOrderStatusRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет статусы нескольких заказов.  Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"`и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  Максимальное количество заказов, у которых можно изменить статус в одном запросе, — 30.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Изменение статусов нескольких заказов
         * @throws {RequiredError}
         */
        updateOrderStatuses(campaignId: number, updateOrderStatusesRequest: UpdateOrderStatusesRequest, options?: RequestOptions = {}): Promise<UpdateOrderStatusesResponse> {
            const localVarFetchArgs = OrdersApiFetchParamCreator(configuration).updateOrderStatuses(campaignId, updateOrderStatusesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OrdersStatsApi - fetch parameter creator
 * @export
 */
export const OrdersStatsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOrdersStats.');
            }
            const localVarPath = `/campaigns/{campaignId}/stats/orders`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getOrdersStatsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getOrdersStatsRequest != null ? getOrdersStatsRequest : {}) : (((getOrdersStatsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OrdersStatsApiType = { 
    getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions): Promise<GetOrdersStatsResponse>,
}

/**
 * OrdersStatsApi - factory function to inject configuration 
 * @export
 */
export const OrdersStatsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OrdersStatsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает информацию по заказам на Маркете, в которых есть ваши товары. С помощью нее вы можете собрать статистику по вашим заказам и узнать, например, какие из товаров чаще всего возвращаются покупателями, какие, наоборот, пользуются большим спросом, какая комиссия начисляется за заказы и т. п.  {% note info \"\" %}  Раньше генерация детальной информации по заказам называлась **Отчет по заказам**. Сейчас это новый отчет. [Подробнее об отчете](../../reference/reports/generateUnitedOrdersReport.md)  {% endnote %}  В одном запросе можно получить информацию не более чем по 200 заказам.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 
         * @summary Детальная информация по заказам
         * @throws {RequiredError}
         */
        getOrdersStats(campaignId: number, pageToken?: string, limit?: number, getOrdersStatsRequest?: GetOrdersStatsRequest, options?: RequestOptions = {}): Promise<GetOrdersStatsResponse> {
            const localVarFetchArgs = OrdersStatsApiFetchParamCreator(configuration).getOrdersStats(campaignId, pageToken, limit, getOrdersStatsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OutletLicensesApi - fetch parameter creator
 * @export
 */
export const OutletLicensesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаляет информацию о лицензиях для точек продаж.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Удаление лицензий для точек продаж
         * @throws {RequiredError}
         */
        deleteOutletLicenses(campaignId: number, ids?: Set<number>, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteOutletLicenses.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/licenses`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids) {
                localVarQueryParameter['ids'] = Array.from(ids).join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о лицензиях для точек продаж.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация о лицензиях для точек продаж
         * @throws {RequiredError}
         */
        getOutletLicenses(campaignId: number, outletIds?: Set<number>, ids?: Set<number>, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOutletLicenses.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/licenses`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (outletIds) {
                localVarQueryParameter['outletIds'] = Array.from(outletIds).join(COLLECTION_FORMATS["csv"]);
            }

            if (ids) {
                localVarQueryParameter['ids'] = Array.from(ids).join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает информацию о новых и существующих лицензиях для точек продаж. Поддерживаются только лицензии на розничную продажу алкоголя.  Чтобы размещать алкогольную продукцию на Маркете, надо также прислать гарантийное письмо (если вы еще не делали этого раньше) и правильно оформить предложения в прайс-листе. Далее информация о лицензиях проходит проверку.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Создание и изменение лицензий для точек продаж
         * @throws {RequiredError}
         */
        updateOutletLicenses(campaignId: number, updateOutletLicenseRequest: UpdateOutletLicenseRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOutletLicenses.');
            }
            // verify required parameter 'updateOutletLicenseRequest' is not null or undefined
            if (updateOutletLicenseRequest === null || updateOutletLicenseRequest === undefined) {
                throw new RequiredError('updateOutletLicenseRequest','Required parameter updateOutletLicenseRequest was null or undefined when calling updateOutletLicenses.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/licenses`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateOutletLicenseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateOutletLicenseRequest != null ? updateOutletLicenseRequest : {}) : (((updateOutletLicenseRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OutletLicensesApiType = { 
    deleteOutletLicenses(campaignId: number, ids?: Set<number>, options?: RequestOptions): Promise<EmptyApiResponse>,

    getOutletLicenses(campaignId: number, outletIds?: Set<number>, ids?: Set<number>, options?: RequestOptions): Promise<GetOutletLicensesResponse>,

    updateOutletLicenses(campaignId: number, updateOutletLicenseRequest: UpdateOutletLicenseRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * OutletLicensesApi - factory function to inject configuration 
 * @export
 */
export const OutletLicensesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OutletLicensesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Удаляет информацию о лицензиях для точек продаж.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Удаление лицензий для точек продаж
         * @throws {RequiredError}
         */
        deleteOutletLicenses(campaignId: number, ids?: Set<number>, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OutletLicensesApiFetchParamCreator(configuration).deleteOutletLicenses(campaignId, ids, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о лицензиях для точек продаж.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация о лицензиях для точек продаж
         * @throws {RequiredError}
         */
        getOutletLicenses(campaignId: number, outletIds?: Set<number>, ids?: Set<number>, options?: RequestOptions = {}): Promise<GetOutletLicensesResponse> {
            const localVarFetchArgs = OutletLicensesApiFetchParamCreator(configuration).getOutletLicenses(campaignId, outletIds, ids, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает информацию о новых и существующих лицензиях для точек продаж. Поддерживаются только лицензии на розничную продажу алкоголя.  Чтобы размещать алкогольную продукцию на Маркете, надо также прислать гарантийное письмо (если вы еще не делали этого раньше) и правильно оформить предложения в прайс-листе. Далее информация о лицензиях проходит проверку.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Создание и изменение лицензий для точек продаж
         * @throws {RequiredError}
         */
        updateOutletLicenses(campaignId: number, updateOutletLicenseRequest: UpdateOutletLicenseRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OutletLicensesApiFetchParamCreator(configuration).updateOutletLicenses(campaignId, updateOutletLicenseRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OutletsApi - fetch parameter creator
 * @export
 */
export const OutletsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Создает точку продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Создание точки продаж
         * @throws {RequiredError}
         */
        createOutlet(campaignId: number, changeOutletRequest: ChangeOutletRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling createOutlet.');
            }
            // verify required parameter 'changeOutletRequest' is not null or undefined
            if (changeOutletRequest === null || changeOutletRequest === undefined) {
                throw new RequiredError('changeOutletRequest','Required parameter changeOutletRequest was null or undefined when calling createOutlet.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof changeOutletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(changeOutletRequest != null ? changeOutletRequest : {}) : (((changeOutletRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет точку продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Удаление точки продаж
         * @throws {RequiredError}
         */
        deleteOutlet(campaignId: number, outletId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling deleteOutlet.');
            }
            // verify required parameter 'outletId' is not null or undefined
            if (outletId === null || outletId === undefined) {
                throw new RequiredError('outletId','Required parameter outletId was null or undefined when calling deleteOutlet.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/{outletId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о точках продаж магазина.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация об одной точке продаж
         * @throws {RequiredError}
         */
        getOutlet(campaignId: number, outletId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOutlet.');
            }
            // verify required parameter 'outletId' is not null or undefined
            if (outletId === null || outletId === undefined) {
                throw new RequiredError('outletId','Required parameter outletId was null or undefined when calling getOutlet.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/{outletId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список точек продаж магазина.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация о нескольких точках продаж
         * @throws {RequiredError}
         */
        getOutlets(campaignId: number, pageToken?: string, regionId?: number, shopOutletCode?: string, regionId2?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getOutlets.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = ((regionId:any):string);
            }

            if (shopOutletCode !== undefined) {
                localVarQueryParameter['shop_outlet_code'] = ((shopOutletCode:any):string);
            }

            if (regionId2 !== undefined) {
                localVarQueryParameter['regionId'] = ((regionId2:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет информацию о точке продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Изменение информации о точке продаж
         * @throws {RequiredError}
         */
        updateOutlet(campaignId: number, outletId: number, changeOutletRequest: ChangeOutletRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateOutlet.');
            }
            // verify required parameter 'outletId' is not null or undefined
            if (outletId === null || outletId === undefined) {
                throw new RequiredError('outletId','Required parameter outletId was null or undefined when calling updateOutlet.');
            }
            // verify required parameter 'changeOutletRequest' is not null or undefined
            if (changeOutletRequest === null || changeOutletRequest === undefined) {
                throw new RequiredError('changeOutletRequest','Required parameter changeOutletRequest was null or undefined when calling updateOutlet.');
            }
            const localVarPath = `/campaigns/{campaignId}/outlets/{outletId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof changeOutletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(changeOutletRequest != null ? changeOutletRequest : {}) : (((changeOutletRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OutletsApiType = { 
    createOutlet(campaignId: number, changeOutletRequest: ChangeOutletRequest, options?: RequestOptions): Promise<CreateOutletResponse>,

    deleteOutlet(campaignId: number, outletId: number, options?: RequestOptions): Promise<EmptyApiResponse>,

    getOutlet(campaignId: number, outletId: number, options?: RequestOptions): Promise<GetOutletResponse>,

    getOutlets(campaignId: number, pageToken?: string, regionId?: number, shopOutletCode?: string, regionId2?: number, options?: RequestOptions): Promise<GetOutletsResponse>,

    updateOutlet(campaignId: number, outletId: number, changeOutletRequest: ChangeOutletRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * OutletsApi - factory function to inject configuration 
 * @export
 */
export const OutletsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OutletsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Создает точку продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Создание точки продаж
         * @throws {RequiredError}
         */
        createOutlet(campaignId: number, changeOutletRequest: ChangeOutletRequest, options?: RequestOptions = {}): Promise<CreateOutletResponse> {
            const localVarFetchArgs = OutletsApiFetchParamCreator(configuration).createOutlet(campaignId, changeOutletRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Удаляет точку продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Удаление точки продаж
         * @throws {RequiredError}
         */
        deleteOutlet(campaignId: number, outletId: number, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OutletsApiFetchParamCreator(configuration).deleteOutlet(campaignId, outletId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о точках продаж магазина.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация об одной точке продаж
         * @throws {RequiredError}
         */
        getOutlet(campaignId: number, outletId: number, options?: RequestOptions = {}): Promise<GetOutletResponse> {
            const localVarFetchArgs = OutletsApiFetchParamCreator(configuration).getOutlet(campaignId, outletId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список точек продаж магазина.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Информация о нескольких точках продаж
         * @throws {RequiredError}
         */
        getOutlets(campaignId: number, pageToken?: string, regionId?: number, shopOutletCode?: string, regionId2?: number, options?: RequestOptions = {}): Promise<GetOutletsResponse> {
            const localVarFetchArgs = OutletsApiFetchParamCreator(configuration).getOutlets(campaignId, pageToken, regionId, shopOutletCode, regionId2, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Изменяет информацию о точке продаж магазина на Маркете.  В течение суток этим и другими запросами о точках продаж, кроме запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md), можно получить и изменить информацию об определенном суммарном количестве точек продаж. Оно зависит от количества точек продаж магазина.  |**⚙️ Лимит:** 100 000 запросов в час| |-| 
         * @summary Изменение информации о точке продаж
         * @throws {RequiredError}
         */
        updateOutlet(campaignId: number, outletId: number, changeOutletRequest: ChangeOutletRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = OutletsApiFetchParamCreator(configuration).updateOutlet(campaignId, outletId, changeOutletRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * PriceQuarantineApi - fetch parameter creator
 * @export
 */
export const PriceQuarantineApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling confirmBusinessPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine/confirm`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling confirmCampaignPrices.');
            }
            // verify required parameter 'confirmPricesRequest' is not null or undefined
            if (confirmPricesRequest === null || confirmPricesRequest === undefined) {
                throw new RequiredError('confirmPricesRequest','Required parameter confirmPricesRequest was null or undefined when calling confirmCampaignPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine/confirm`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmPricesRequest != null ? confirmPricesRequest : {}) : (((confirmPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getBusinessQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getBusinessQuarantineOffers.');
            }
            const localVarPath = `/businesses/{businessId}/price-quarantine`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getCampaignQuarantineOffers.');
            }
            // verify required parameter 'getQuarantineOffersRequest' is not null or undefined
            if (getQuarantineOffersRequest === null || getQuarantineOffersRequest === undefined) {
                throw new RequiredError('getQuarantineOffersRequest','Required parameter getQuarantineOffersRequest was null or undefined when calling getCampaignQuarantineOffers.');
            }
            const localVarPath = `/campaigns/{campaignId}/price-quarantine`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQuarantineOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQuarantineOffersRequest != null ? getQuarantineOffersRequest : {}) : (((getQuarantineOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type PriceQuarantineApiType = { 
    confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,

    getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetQuarantineOffersResponse>,
}

/**
 * PriceQuarantineApi - factory function to inject configuration 
 * @export
 */
export const PriceQuarantineApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): PriceQuarantineApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Подтверждает основную цену на товары, которые попали в карантин, и удаляет их из карантина.  Основная цена задается в каталоге и действует во всех магазинах кабинета.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST businesses/{businessId}/price-quarantine](getBusinessQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту, не более 200 товаров в одном запросе| |-| 
         * @summary Удаление товара из карантина по цене в кабинете
         * @throws {RequiredError}
         */
        confirmBusinessPrices(businessId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = PriceQuarantineApiFetchParamCreator(configuration).confirmBusinessPrices(businessId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает в заданном магазине цену на товары, которые попали в карантин, и удаляет их из карантина.  Товар попадает в карантин, если его цена меняется слишком резко. [Как настроить карантин](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  Чтобы увидеть список товаров, которые попали в карантин, используйте запрос [POST campaigns/{campaignId}/price-quarantine](getCampaignQuarantineOffers.md).  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Удаление товара из карантина по цене в магазине
         * @throws {RequiredError}
         */
        confirmCampaignPrices(campaignId: number, confirmPricesRequest: ConfirmPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = PriceQuarantineApiFetchParamCreator(configuration).confirmCampaignPrices(campaignId, confirmPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по **основной цене**. Основная цена задается в каталоге и действует во всех магазинах кабинета.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST businesses/{businessId}/price-quarantine/confirm](../../reference/business-assortment/confirmBusinessPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Список товаров, находящихся в карантине по цене в кабинете
         * @throws {RequiredError}
         */
        getBusinessQuarantineOffers(businessId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = PriceQuarantineApiFetchParamCreator(configuration).getBusinessQuarantineOffers(businessId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые находятся в карантине по цене, установленной в заданном магазине.  Проверьте цену каждого из товаров, который попал в карантин. Если ошибки нет и цена правильная, подтвердите ее с помощью запроса [POST campaigns/{campaignId}/price-quarantine/confirm](../../reference/assortment/confirmCampaignPrices.md). Если цена в самом деле ошибочная, установите верную с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md).  {% note info \"𝓠 Что такое карантин?\" %}  𝓐 Товар попадает в карантин, если его цена меняется слишком резко или слишком сильно отличается от рыночной. [Подробнее](https://yandex.ru/support/marketplace/assortment/operations/prices.html#quarantine)  {% endnote %}  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Список товаров, находящихся в карантине по цене в магазине
         * @throws {RequiredError}
         */
        getCampaignQuarantineOffers(campaignId: number, getQuarantineOffersRequest: GetQuarantineOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetQuarantineOffersResponse> {
            const localVarFetchArgs = PriceQuarantineApiFetchParamCreator(configuration).getCampaignQuarantineOffers(campaignId, getQuarantineOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * PricesApi - fetch parameter creator
 * @export
 */
export const PricesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = ((archived:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getPricesByOfferIds.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPricesByOfferIdsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPricesByOfferIdsRequest != null ? getPricesByOfferIdsRequest : {}) : (((getPricesByOfferIdsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getSuggestedPrices.');
            }
            // verify required parameter 'suggestPricesRequest' is not null or undefined
            if (suggestPricesRequest === null || suggestPricesRequest === undefined) {
                throw new RequiredError('suggestPricesRequest','Required parameter suggestPricesRequest was null or undefined when calling getSuggestedPrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/suggestions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof suggestPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(suggestPricesRequest != null ? suggestPricesRequest : {}) : (((suggestPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updateBusinessPrices.');
            }
            // verify required parameter 'updateBusinessPricesRequest' is not null or undefined
            if (updateBusinessPricesRequest === null || updateBusinessPricesRequest === undefined) {
                throw new RequiredError('updateBusinessPricesRequest','Required parameter updateBusinessPricesRequest was null or undefined when calling updateBusinessPrices.');
            }
            const localVarPath = `/businesses/{businessId}/offer-prices/updates`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateBusinessPricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateBusinessPricesRequest != null ? updateBusinessPricesRequest : {}) : (((updateBusinessPricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updatePrices.');
            }
            // verify required parameter 'updatePricesRequest' is not null or undefined
            if (updatePricesRequest === null || updatePricesRequest === undefined) {
                throw new RequiredError('updatePricesRequest','Required parameter updatePricesRequest was null or undefined when calling updatePrices.');
            }
            const localVarPath = `/campaigns/{campaignId}/offer-prices/updates`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePricesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePricesRequest != null ? updatePricesRequest : {}) : (((updatePricesRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type PricesApiType = { 
    getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions): Promise<GetPricesResponse>,

    getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions): Promise<GetPricesByOfferIdsResponse>,

    getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions): Promise<SuggestPricesResponse>,

    updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * PricesApi - factory function to inject configuration 
 * @export
 */
export const PricesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): PricesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [POST campaigns/{campaignId}/offer-prices](../../reference/assortment/getPricesByOfferIds.md).  {% endnote %}  Возвращает список цен, установленных вами на товары любым способом: например, через партнерский API или в файле с каталогом.  {% note info %}  Общее количество товаров считается по данным за последние семь дней (не включая сегодня) и не может быть выше 2 миллионов.  {% endnote %}  Способы установки цен описаны [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/assortment/operations/prices.html).  |**⚙️ Лимит:** ```(количество товаров партнера на витрине) * 25``` товаров в сутки| |-| 
         * @summary Список цен
         * @throws {RequiredError}
         */
        getPrices(campaignId: number, pageToken?: string, limit?: number, archived?: boolean, options?: RequestOptions = {}): Promise<GetPricesResponse> {
            const localVarFetchArgs = PricesApiFetchParamCreator(configuration).getPrices(campaignId, pageToken, limit, archived, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список цен на указанные товары в магазине.  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для просмотра базовых цен используйте [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md).  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — количество товаров на витрине * 25) 
         * @summary Просмотр цен на указанные товары в магазине
         * @throws {RequiredError}
         */
        getPricesByOfferIds(campaignId: number, pageToken?: string, limit?: number, getPricesByOfferIdsRequest?: GetPricesByOfferIdsRequest, options?: RequestOptions = {}): Promise<GetPricesByOfferIdsResponse> {
            const localVarFetchArgs = PricesApiFetchParamCreator(configuration).getPricesByOfferIds(campaignId, pageToken, limit, getPricesByOfferIdsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"\" %}  Этот метод устарел. Вместо него используйте [отчет «Цены на рынке»](../../reference/reports/generatePricesReport.md).  {% endnote %}  {% note warning \"\" %}  Этот метод подходит только тем магазинам, которые устанавливают цены на товары в рублях.  {% endnote %}  Возвращает цены для продвижения товаров, которые вы размещаете на Маркете.  Товары, для которых нужно получить цены, передаются в теле POST-запроса.  Цены для продвижения зависят от цен, установленных на товары другими партнерами. Если один товар поставляют несколько партнеров, на Маркете сначала продается товар с более низкой ценой. Когда закончится товар по низкой цене, начнет продаваться товар по более высокой цене.  Выходные данные содержат для каждого товара несколько цен, соответствующих разным типам продвижения.  Установить цены на товары можно с помощью запроса [POST campaigns/{campaignId}/offer-prices/updates](../../reference/assortment/updatePrices.md) или другими способами: например, указать их в файле с каталогом. Также вы можете использовать стратегии для автоматической установки рекомендованных цен или минимальных цен на Маркете.  Подробно об автоматическом управлении ценами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/marketing/prices.html).  |**⚙️ Лимит:** 100 000 товаров в час| |-| 
         * @summary Цены для продвижения товаров
         * @throws {RequiredError}
         */
        getSuggestedPrices(campaignId: number, suggestPricesRequest: SuggestPricesRequest, options?: RequestOptions = {}): Promise<SuggestPricesResponse> {
            const localVarFetchArgs = PricesApiFetchParamCreator(configuration).getSuggestedPrices(campaignId, suggestPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает [базовые цены](*default-price). Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту, не более 500 товаров в одном запросе| |-| 
         * @summary Установка цен на товары во всех магазинах
         * @throws {RequiredError}
         */
        updateBusinessPrices(businessId: number, updateBusinessPricesRequest: UpdateBusinessPricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = PricesApiFetchParamCreator(configuration).updateBusinessPrices(businessId, updateBusinessPricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Устанавливает цены на товары в магазине. Чтобы получить рекомендации Маркета, касающиеся цен, выполните запрос [POST businesses/{businessId}/offers/recommendations](../../reference/business-assortment/getOfferRecommendations.md).  {% note warning \"Метод только для отдельных магазинов\" %}  Используйте этот метод, только если в кабинете установлены уникальные цены в отдельных магазинах.  Для управления базовыми ценами используйте [POST businesses/{businessId}/offer-prices/updates](../../reference/business-assortment/updateBusinessPrices.md).  {% endnote %}  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
         * @summary Установка цен на товары в конкретном магазине
         * @throws {RequiredError}
         */
        updatePrices(campaignId: number, updatePricesRequest: UpdatePricesRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = PricesApiFetchParamCreator(configuration).updatePrices(campaignId, updatePricesRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * PromosApi - fetch parameter creator
 * @export
 */
export const PromosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling deletePromoOffers.');
            }
            // verify required parameter 'deletePromoOffersRequest' is not null or undefined
            if (deletePromoOffersRequest === null || deletePromoOffersRequest === undefined) {
                throw new RequiredError('deletePromoOffersRequest','Required parameter deletePromoOffersRequest was null or undefined when calling deletePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/delete`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof deletePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deletePromoOffersRequest != null ? deletePromoOffersRequest : {}) : (((deletePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromoOffers.');
            }
            // verify required parameter 'getPromoOffersRequest' is not null or undefined
            if (getPromoOffersRequest === null || getPromoOffersRequest === undefined) {
                throw new RequiredError('getPromoOffersRequest','Required parameter getPromoOffersRequest was null or undefined when calling getPromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromoOffersRequest != null ? getPromoOffersRequest : {}) : (((getPromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getPromos.');
            }
            const localVarPath = `/businesses/{businessId}/promos`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getPromosRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getPromosRequest != null ? getPromosRequest : {}) : (((getPromosRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling updatePromoOffers.');
            }
            // verify required parameter 'updatePromoOffersRequest' is not null or undefined
            if (updatePromoOffersRequest === null || updatePromoOffersRequest === undefined) {
                throw new RequiredError('updatePromoOffersRequest','Required parameter updatePromoOffersRequest was null or undefined when calling updatePromoOffers.');
            }
            const localVarPath = `/businesses/{businessId}/promos/offers/update`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updatePromoOffersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updatePromoOffersRequest != null ? updatePromoOffersRequest : {}) : (((updatePromoOffersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type PromosApiType = { 
    deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions): Promise<DeletePromoOffersResponse>,

    getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetPromoOffersResponse>,

    getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions): Promise<GetPromosResponse>,

    updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions): Promise<UpdatePromoOffersResponse>,
}

/**
 * PromosApi - factory function to inject configuration 
 * @export
 */
export const PromosApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): PromosApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Убирает товары из акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Удаление товаров из акции
         * @throws {RequiredError}
         */
        deletePromoOffers(businessId: number, deletePromoOffersRequest: DeletePromoOffersRequest, options?: RequestOptions = {}): Promise<DeletePromoOffersResponse> {
            const localVarFetchArgs = PromosApiFetchParamCreator(configuration).deletePromoOffers(businessId, deletePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список товаров, которые участвуют или могут участвовать в акции.  {% note warning %}  В параметре `limit` не передавайте значение больше 500.  {% endnote %}  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Получение списка товаров, которые участвуют или могут участвовать в акции
         * @throws {RequiredError}
         */
        getPromoOffers(businessId: number, getPromoOffersRequest: GetPromoOffersRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetPromoOffersResponse> {
            const localVarFetchArgs = PromosApiFetchParamCreator(configuration).getPromoOffers(businessId, getPromoOffersRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию об акциях Маркета.  По умолчанию возвращаются акции, в которых продавец участвует или может принять участие.  Чтобы получить текущие или завершенные акции, передайте параметр `participation`.  Типы акций, которые возвращаются в ответе:  * прямая скидка; * флеш-акция; * скидка по промокоду.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Получение списка акций
         * @throws {RequiredError}
         */
        getPromos(businessId: number, getPromosRequest?: GetPromosRequest, options?: RequestOptions = {}): Promise<GetPromosResponse> {
            const localVarFetchArgs = PromosApiFetchParamCreator(configuration).getPromos(businessId, getPromosRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Добавляет товары в акцию или изменяет цены на товары, которые участвуют в акции.  Изменения начинают действовать в течение 4–6 часов.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Добавление товаров в акцию или изменение их цен
         * @throws {RequiredError}
         */
        updatePromoOffers(businessId: number, updatePromoOffersRequest: UpdatePromoOffersRequest, options?: RequestOptions = {}): Promise<UpdatePromoOffersResponse> {
            const localVarFetchArgs = PromosApiFetchParamCreator(configuration).updatePromoOffers(businessId, updatePromoOffersRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * RatingsApi - fetch parameter creator
 * @export
 */
export const RatingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список заказов, которые повлияли на индекс качества магазина. Чтобы узнать значение индекса качества, выполните запрос [POST businesses/{businessId}/ratings/quality](../../reference/ratings/getQualityRatings.md).  |**⚙️ Лимит:** 100000 запросов в час| |-| 
         * @summary Заказы, которые повлияли на индекс качества
         * @throws {RequiredError}
         */
        getQualityRatingDetails(campaignId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getQualityRatingDetails.');
            }
            const localVarPath = `/campaigns/{campaignId}/ratings/quality/details`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getQualityRatings.');
            }
            // verify required parameter 'getQualityRatingRequest' is not null or undefined
            if (getQualityRatingRequest === null || getQualityRatingRequest === undefined) {
                throw new RequiredError('getQualityRatingRequest','Required parameter getQualityRatingRequest was null or undefined when calling getQualityRatings.');
            }
            const localVarPath = `/businesses/{businessId}/ratings/quality`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getQualityRatingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getQualityRatingRequest != null ? getQualityRatingRequest : {}) : (((getQualityRatingRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type RatingsApiType = { 
    getQualityRatingDetails(campaignId: number, options?: RequestOptions): Promise<GetQualityRatingDetailsResponse>,

    getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions): Promise<GetQualityRatingResponse>,
}

/**
 * RatingsApi - factory function to inject configuration 
 * @export
 */
export const RatingsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): RatingsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает список заказов, которые повлияли на индекс качества магазина. Чтобы узнать значение индекса качества, выполните запрос [POST businesses/{businessId}/ratings/quality](../../reference/ratings/getQualityRatings.md).  |**⚙️ Лимит:** 100000 запросов в час| |-| 
         * @summary Заказы, которые повлияли на индекс качества
         * @throws {RequiredError}
         */
        getQualityRatingDetails(campaignId: number, options?: RequestOptions = {}): Promise<GetQualityRatingDetailsResponse> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).getQualityRatingDetails(campaignId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает значение индекса качества магазинов и его составляющие.  Подробнее об индексе качества читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/score/).  |**⚙️ Лимит:** 10000 запросов в час| |-| 
         * @summary Индекс качества магазинов
         * @throws {RequiredError}
         */
        getQualityRatings(businessId: number, getQualityRatingRequest: GetQualityRatingRequest, options?: RequestOptions = {}): Promise<GetQualityRatingResponse> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).getQualityRatings(businessId, getQualityRatingRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * RegionsApi - fetch parameter creator
 * @export
 */
export const RegionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionChildren.');
            }
            const localVarPath = `/regions/{regionId}/children`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = ((pageSize:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling searchRegionsById.');
            }
            const localVarPath = `/regions/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling searchRegionsByName.');
            }
            const localVarPath = `/regions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type RegionsApiType = { 
    searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions): Promise<GetRegionWithChildrenResponse>,

    searchRegionsById(regionId: number, options?: RequestOptions): Promise<GetRegionsResponse>,

    searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions): Promise<GetRegionsResponse>,
}

/**
 * RegionsApi - factory function to inject configuration 
 * @export
 */
export const RegionsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): RegionsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает информацию о регионах, являющихся дочерними по отношению к региону, идентификатор которого указан в запросе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о дочерних регионах
         * @throws {RequiredError}
         */
        searchRegionChildren(regionId: number, page?: number, pageSize?: number, options?: RequestOptions = {}): Promise<GetRegionWithChildrenResponse> {
            const localVarFetchArgs = RegionsApiFetchParamCreator(configuration).searchRegionChildren(regionId, page, pageSize, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Информация о регионе
         * @throws {RequiredError}
         */
        searchRegionsById(regionId: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = RegionsApiFetchParamCreator(configuration).searchRegionsById(regionId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о регионе, удовлетворяющем заданным в запросе условиям поиска.  Если найдено несколько регионов, удовлетворяющих условиям поиска, возвращается информация по каждому найденному региону (но не более десяти регионов) для возможности определения нужного региона по родительским регионам.  Для методов `GET regions`, `GET regions/{regionId}` и `GET regions/{regionId}/children` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество регионов, информация о которых запрошена при помощи этих методов (не более 100 000 регионов).  Объем запросов к ресурсу, который возможно выполнить в течение суток, зависит от суммарного количества регионов.  |**⚙️ Лимит:** 50 000 запросов в час| |-| 
         * @summary Поиск регионов по их имени
         * @throws {RequiredError}
         */
        searchRegionsByName(name: string, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<GetRegionsResponse> {
            const localVarFetchArgs = RegionsApiFetchParamCreator(configuration).searchRegionsByName(name, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ReportsApi - fetch parameter creator
 * @export
 */
export const ReportsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateBoostConsolidatedRequest' is not null or undefined
            if (generateBoostConsolidatedRequest === null || generateBoostConsolidatedRequest === undefined) {
                throw new RequiredError('generateBoostConsolidatedRequest','Required parameter generateBoostConsolidatedRequest was null or undefined when calling generateBoostConsolidatedReport.');
            }
            const localVarPath = `/reports/boost-consolidated/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateBoostConsolidatedRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateBoostConsolidatedRequest != null ? generateBoostConsolidatedRequest : {}) : (((generateBoostConsolidatedRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateCompetitorsPositionReportRequest' is not null or undefined
            if (generateCompetitorsPositionReportRequest === null || generateCompetitorsPositionReportRequest === undefined) {
                throw new RequiredError('generateCompetitorsPositionReportRequest','Required parameter generateCompetitorsPositionReportRequest was null or undefined when calling generateCompetitorsPositionReport.');
            }
            const localVarPath = `/reports/competitors-position/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateCompetitorsPositionReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateCompetitorsPositionReportRequest != null ? generateCompetitorsPositionReportRequest : {}) : (((generateCompetitorsPositionReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsFeedbackRequest' is not null or undefined
            if (generateGoodsFeedbackRequest === null || generateGoodsFeedbackRequest === undefined) {
                throw new RequiredError('generateGoodsFeedbackRequest','Required parameter generateGoodsFeedbackRequest was null or undefined when calling generateGoodsFeedbackReport.');
            }
            const localVarPath = `/reports/goods-feedback/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsFeedbackRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsFeedbackRequest != null ? generateGoodsFeedbackRequest : {}) : (((generateGoodsFeedbackRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по движению товаров**. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#flow)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по движению товаров
         * @throws {RequiredError}
         */
        generateGoodsMovementReport(generateGoodsMovementReportRequest: GenerateGoodsMovementReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsMovementReportRequest' is not null or undefined
            if (generateGoodsMovementReportRequest === null || generateGoodsMovementReportRequest === undefined) {
                throw new RequiredError('generateGoodsMovementReportRequest','Required parameter generateGoodsMovementReportRequest was null or undefined when calling generateGoodsMovementReport.');
            }
            const localVarPath = `/reports/goods-movement/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsMovementReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsMovementReportRequest != null ? generateGoodsMovementReportRequest : {}) : (((generateGoodsMovementReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по реализации** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#sales-report)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по реализации
         * @throws {RequiredError}
         */
        generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsRealizationReportRequest' is not null or undefined
            if (generateGoodsRealizationReportRequest === null || generateGoodsRealizationReportRequest === undefined) {
                throw new RequiredError('generateGoodsRealizationReportRequest','Required parameter generateGoodsRealizationReportRequest was null or undefined when calling generateGoodsRealizationReport.');
            }
            const localVarPath = `/reports/goods-realization/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsRealizationReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsRealizationReportRequest != null ? generateGoodsRealizationReportRequest : {}) : (((generateGoodsRealizationReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по оборачиваемости** за заданную дату.  [Что это за отчет](https://yandex.ru/support/marketplace/analytics/turnover.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по оборачиваемости
         * @throws {RequiredError}
         */
        generateGoodsTurnoverReport(generateGoodsTurnoverRequest: GenerateGoodsTurnoverRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateGoodsTurnoverRequest' is not null or undefined
            if (generateGoodsTurnoverRequest === null || generateGoodsTurnoverRequest === undefined) {
                throw new RequiredError('generateGoodsTurnoverRequest','Required parameter generateGoodsTurnoverRequest was null or undefined when calling generateGoodsTurnoverReport.');
            }
            const localVarPath = `/reports/goods-turnover/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateGoodsTurnoverRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateGoodsTurnoverRequest != null ? generateGoodsTurnoverRequest : {}) : (((generateGoodsTurnoverRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию PDF-файла с ярлыками для переданных заказов. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  Узнать статус генерации и получить ссылку на готовый файл можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в нескольких заказах
         * @throws {RequiredError}
         */
        generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateMassOrderLabelsRequest' is not null or undefined
            if (generateMassOrderLabelsRequest === null || generateMassOrderLabelsRequest === undefined) {
                throw new RequiredError('generateMassOrderLabelsRequest','Required parameter generateMassOrderLabelsRequest was null or undefined when calling generateMassOrderLabelsReport.');
            }
            const localVarPath = `/reports/documents/labels/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateMassOrderLabelsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateMassOrderLabelsRequest != null ? generateMassOrderLabelsRequest : {}) : (((generateMassOrderLabelsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generatePricesReportRequest' is not null or undefined
            if (generatePricesReportRequest === null || generatePricesReportRequest === undefined) {
                throw new RequiredError('generatePricesReportRequest','Required parameter generatePricesReportRequest was null or undefined when calling generatePricesReport.');
            }
            const localVarPath = `/reports/prices/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generatePricesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generatePricesReportRequest != null ? generatePricesReportRequest : {}) : (((generatePricesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShelfsStatisticsRequest' is not null or undefined
            if (generateShelfsStatisticsRequest === null || generateShelfsStatisticsRequest === undefined) {
                throw new RequiredError('generateShelfsStatisticsRequest','Required parameter generateShelfsStatisticsRequest was null or undefined when calling generateShelfsStatisticsReport.');
            }
            const localVarPath = `/reports/shelf-statistics/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShelfsStatisticsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShelfsStatisticsRequest != null ? generateShelfsStatisticsRequest : {}) : (((generateShelfsStatisticsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **листа сборки** для отгрузки.  Узнать статус генерации и получить ссылку на готовый документ можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение листа сборки
         * @throws {RequiredError}
         */
        generateShipmentListDocumentReport(generateShipmentListDocumentReportRequest: GenerateShipmentListDocumentReportRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShipmentListDocumentReportRequest' is not null or undefined
            if (generateShipmentListDocumentReportRequest === null || generateShipmentListDocumentReportRequest === undefined) {
                throw new RequiredError('generateShipmentListDocumentReportRequest','Required parameter generateShipmentListDocumentReportRequest was null or undefined when calling generateShipmentListDocumentReport.');
            }
            const localVarPath = `/reports/documents/shipment-list/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShipmentListDocumentReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShipmentListDocumentReportRequest != null ? generateShipmentListDocumentReportRequest : {}) : (((generateShipmentListDocumentReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateShowsSalesReportRequest' is not null or undefined
            if (generateShowsSalesReportRequest === null || generateShowsSalesReportRequest === undefined) {
                throw new RequiredError('generateShowsSalesReportRequest','Required parameter generateShowsSalesReportRequest was null or undefined when calling generateShowsSalesReport.');
            }
            const localVarPath = `/reports/shows-sales/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateShowsSalesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateShowsSalesReportRequest != null ? generateShowsSalesReportRequest : {}) : (((generateShowsSalesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateStocksOnWarehousesReportRequest' is not null or undefined
            if (generateStocksOnWarehousesReportRequest === null || generateStocksOnWarehousesReportRequest === undefined) {
                throw new RequiredError('generateStocksOnWarehousesReportRequest','Required parameter generateStocksOnWarehousesReportRequest was null or undefined when calling generateStocksOnWarehousesReport.');
            }
            const localVarPath = `/reports/stocks-on-warehouses/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateStocksOnWarehousesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateStocksOnWarehousesReportRequest != null ? generateStocksOnWarehousesReportRequest : {}) : (((generateStocksOnWarehousesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedMarketplaceServicesReportRequest' is not null or undefined
            if (generateUnitedMarketplaceServicesReportRequest === null || generateUnitedMarketplaceServicesReportRequest === undefined) {
                throw new RequiredError('generateUnitedMarketplaceServicesReportRequest','Required parameter generateUnitedMarketplaceServicesReportRequest was null or undefined when calling generateUnitedMarketplaceServicesReport.');
            }
            const localVarPath = `/reports/united-marketplace-services/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedMarketplaceServicesReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedMarketplaceServicesReportRequest != null ? generateUnitedMarketplaceServicesReportRequest : {}) : (((generateUnitedMarketplaceServicesReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedNettingReportRequest' is not null or undefined
            if (generateUnitedNettingReportRequest === null || generateUnitedNettingReportRequest === undefined) {
                throw new RequiredError('generateUnitedNettingReportRequest','Required parameter generateUnitedNettingReportRequest was null or undefined when calling generateUnitedNettingReport.');
            }
            const localVarPath = `/reports/united-netting/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedNettingReportRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedNettingReportRequest != null ? generateUnitedNettingReportRequest : {}) : (((generateUnitedNettingReportRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'generateUnitedOrdersRequest' is not null or undefined
            if (generateUnitedOrdersRequest === null || generateUnitedOrdersRequest === undefined) {
                throw new RequiredError('generateUnitedOrdersRequest','Required parameter generateUnitedOrdersRequest was null or undefined when calling generateUnitedOrdersReport.');
            }
            const localVarPath = `/reports/united-orders/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof generateUnitedOrdersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(generateUnitedOrdersRequest != null ? generateUnitedOrdersRequest : {}) : (((generateUnitedOrdersRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'reportId' is not null or undefined
            if (reportId === null || reportId === undefined) {
                throw new RequiredError('reportId','Required parameter reportId was null or undefined when calling getReportInfo.');
            }
            const localVarPath = `/reports/info/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ReportsApiType = { 
    generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsMovementReport(generateGoodsMovementReportRequest: GenerateGoodsMovementReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateGoodsTurnoverReport(generateGoodsTurnoverRequest: GenerateGoodsTurnoverRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShipmentListDocumentReport(generateShipmentListDocumentReportRequest: GenerateShipmentListDocumentReportRequest, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions): Promise<GenerateReportResponse>,

    getReportInfo(reportId: string, options?: RequestOptions): Promise<GetReportInfoResponse>,
}

/**
 * ReportsApi - factory function to inject configuration 
 * @export
 */
export const ReportsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ReportsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Запускает генерацию **сводного отчета по бусту продаж** за заданный период. Отчет содержит информацию по всем кампаниям, созданным и через API, и в кабинете.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по бусту продаж
         * @throws {RequiredError}
         */
        generateBoostConsolidatedReport(generateBoostConsolidatedRequest: GenerateBoostConsolidatedRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateBoostConsolidatedReport(generateBoostConsolidatedRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Конкурентная позиция»** за заданный период. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/analytics/competitors.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  {% note info \"Значение -1 в отчете\" %}  Если в CSV-файле в столбце **POSITION** стоит -1, в этот день не было заказов с товарами в указанной категории.  {% endnote %}  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Конкурентная позиция»
         * @throws {RequiredError}
         */
        generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest: GenerateCompetitorsPositionReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateCompetitorsPositionReport(generateCompetitorsPositionReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по отзывам о товарах**. [Что это за отчет](https://yandex.ru/support2/marketplace/ru/marketing/plus-reviews#stat)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по отзывам о товарах
         * @throws {RequiredError}
         */
        generateGoodsFeedbackReport(generateGoodsFeedbackRequest: GenerateGoodsFeedbackRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateGoodsFeedbackReport(generateGoodsFeedbackRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по движению товаров**. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#flow)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по движению товаров
         * @throws {RequiredError}
         */
        generateGoodsMovementReport(generateGoodsMovementReportRequest: GenerateGoodsMovementReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateGoodsMovementReport(generateGoodsMovementReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по реализации** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports-fby-fbs.html#sales-report)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по реализации
         * @throws {RequiredError}
         */
        generateGoodsRealizationReport(generateGoodsRealizationReportRequest: GenerateGoodsRealizationReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateGoodsRealizationReport(generateGoodsRealizationReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по оборачиваемости** за заданную дату.  [Что это за отчет](https://yandex.ru/support/marketplace/analytics/turnover.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по оборачиваемости
         * @throws {RequiredError}
         */
        generateGoodsTurnoverReport(generateGoodsTurnoverRequest: GenerateGoodsTurnoverRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateGoodsTurnoverReport(generateGoodsTurnoverRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию PDF-файла с ярлыками для переданных заказов. Подробно о том, зачем они нужны и как выглядят, рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/fbs/packaging/marking.html).  Узнать статус генерации и получить ссылку на готовый файл можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 1000 запросов в час| |-| 
         * @summary Готовые ярлыки‑наклейки на все коробки в нескольких заказах
         * @throws {RequiredError}
         */
        generateMassOrderLabelsReport(generateMassOrderLabelsRequest: GenerateMassOrderLabelsRequest, format?: PageFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateMassOrderLabelsReport(generateMassOrderLabelsRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Цены на рынке»**.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет «Цены на рынке»
         * @throws {RequiredError}
         */
        generatePricesReport(generatePricesReportRequest: GeneratePricesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generatePricesReport(generatePricesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **сводного отчета по полкам** — рекламным блокам с баннером или видео и набором товаров. Подробнее о них читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf).  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по полкам
         * @throws {RequiredError}
         */
        generateShelfsStatisticsReport(generateShelfsStatisticsRequest: GenerateShelfsStatisticsRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateShelfsStatisticsReport(generateShelfsStatisticsRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **листа сборки** для отгрузки.  Узнать статус генерации и получить ссылку на готовый документ можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение листа сборки
         * @throws {RequiredError}
         */
        generateShipmentListDocumentReport(generateShipmentListDocumentReportRequest: GenerateShipmentListDocumentReportRequest, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateShipmentListDocumentReport(generateShipmentListDocumentReportRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета «Аналитика продаж»** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/shows-sales.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 10 запросов в час| |-| 
         * @summary Отчет «Аналитика продаж»
         * @throws {RequiredError}
         */
        generateShowsSalesReport(generateShowsSalesReportRequest: GenerateShowsSalesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateShowsSalesReport(generateShowsSalesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по остаткам на складах**. Отчет содержит данные:  * Для модели FBY — об остатках на складах Маркета. * Для остальных моделей — об остатках на соответствующем складе магазина.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по остаткам на складах
         * @throws {RequiredError}
         */
        generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest: GenerateStocksOnWarehousesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateStocksOnWarehousesReport(generateStocksOnWarehousesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по стоимости услуг** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/reports.html)  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**               |**Какие поля нужны**             | |-----------------------------|---------------------------------| |По дате начисления услуги    |`dateFrom` и `dateTo`            | |По дате формирования акта    |`year` и `month`                 |  Заказать отчеты обоих типов одним запросом нельзя.  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по стоимости услуг
         * @throws {RequiredError}
         */
        generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest: GenerateUnitedMarketplaceServicesReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateUnitedMarketplaceServicesReport(generateUnitedMarketplaceServicesReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по платежам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/transactions.html)  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  Тип отчета зависит от того, какие поля заполнены в запросе:  |**Тип отчета**           |**Какие поля нужны**                   | |-------------------------|---------------------------------------| |О платежах за период     |`dateFrom` и `dateTo`                  | |О платежном поручении    |`bankOrderId` и `bankOrderDateTime`    |  Заказать отчеты обоих типов одним запросом нельзя.  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по платежам
         * @throws {RequiredError}
         */
        generateUnitedNettingReport(generateUnitedNettingReportRequest: GenerateUnitedNettingReportRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateUnitedNettingReport(generateUnitedNettingReportRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запускает генерацию **отчета по заказам** за заданный период. [Что это за отчет](https://yandex.ru/support/marketplace/analytics/orders.html)  {% note info \"\" %}  Это новый отчет. Раньше мы так называли генерацию детальной информации по заказам. [Как получить детальную информацию по заказам](../../reference/stats/getOrdersStats.md)  {% endnote %}  Узнать статус генерации и получить ссылку на готовый отчет можно с помощью запроса [GET reports/info/{reportId}](../../reference/reports/getReportInfo.md).  |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Отчет по заказам
         * @throws {RequiredError}
         */
        generateUnitedOrdersReport(generateUnitedOrdersRequest: GenerateUnitedOrdersRequest, format?: ReportFormatType, options?: RequestOptions = {}): Promise<GenerateReportResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).generateUnitedOrdersReport(generateUnitedOrdersRequest, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает статус генерации заданного отчета и, если отчет готов, ссылку для скачивания.  Чтобы воспользоваться этим запросом, вначале нужно запустить генерацию отчета. [Инструкция](../../step-by-step/reports.md)  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Получение заданного отчета
         * @throws {RequiredError}
         */
        getReportInfo(reportId: string, options?: RequestOptions = {}): Promise<GetReportInfoResponse> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).getReportInfo(reportId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ReturnsApi - fetch parameter creator
 * @export
 */
export const ReturnsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturn.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturn.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Загружает заявление покупателя на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение заявления на возврат
         * @throws {RequiredError}
         */
        getReturnApplication(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturnApplication.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturnApplication.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturnApplication.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getReturnPhoto.');
            }
            // verify required parameter 'imageHash' is not null or undefined
            if (imageHash === null || imageHash === undefined) {
                throw new RequiredError('imageHash','Required parameter imageHash was null or undefined when calling getReturnPhoto.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageHash"}}`, encodeURIComponent(String(imageHash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getReturns.');
            }
            const localVarPath = `/campaigns/{campaignId}/returns`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS["csv"]);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = ((type:any):string);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = ((fromDate:any):Date).toISOString().slice(0, 10);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = ((toDate:any):Date).toISOString().slice(0, 10);
            }

            if (fromDate2 !== undefined) {
                localVarQueryParameter['from_date'] = ((fromDate2:any):Date).toISOString().slice(0, 10);
            }

            if (toDate2 !== undefined) {
                localVarQueryParameter['to_date'] = ((toDate2:any):Date).toISOString().slice(0, 10);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Выбирает решение по возврату от покупателя. После этого для подтверждения решения нужно выполнить запрос [POST campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit](../../reference/orders/submitReturnDecision.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Принятие или изменение решения по возврату
         * @throws {RequiredError}
         */
        setReturnDecision(campaignId: number, orderId: number, returnId: number, setReturnDecisionRequest: SetReturnDecisionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setReturnDecision.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling setReturnDecision.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling setReturnDecision.');
            }
            // verify required parameter 'setReturnDecisionRequest' is not null or undefined
            if (setReturnDecisionRequest === null || setReturnDecisionRequest === undefined) {
                throw new RequiredError('setReturnDecisionRequest','Required parameter setReturnDecisionRequest was null or undefined when calling setReturnDecision.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setReturnDecisionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setReturnDecisionRequest != null ? setReturnDecisionRequest : {}) : (((setReturnDecisionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подтверждает выбранное решение по возврату, отправленное в запросе [POST campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision](../../reference/orders/setReturnDecision.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Подтверждение решения по возврату
         * @throws {RequiredError}
         */
        submitReturnDecision(campaignId: number, orderId: number, returnId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling submitReturnDecision.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling submitReturnDecision.');
            }
            // verify required parameter 'returnId' is not null or undefined
            if (returnId === null || returnId === undefined) {
                throw new RequiredError('returnId','Required parameter returnId was null or undefined when calling submitReturnDecision.');
            }
            const localVarPath = `/campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"returnId"}}`, encodeURIComponent(String(returnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ReturnsApiType = { 
    getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<GetReturnResponse>,

    getReturnApplication(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<File>,

    getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions): Promise<File>,

    getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions): Promise<GetReturnsResponse>,

    setReturnDecision(campaignId: number, orderId: number, returnId: number, setReturnDecisionRequest: SetReturnDecisionRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    submitReturnDecision(campaignId: number, orderId: number, returnId: number, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * ReturnsApi - factory function to inject configuration 
 * @export
 */
export const ReturnsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ReturnsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Получает информацию по одному невыкупу или возврату.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Информация о невыкупе или возврате
         * @throws {RequiredError}
         */
        getReturn(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<GetReturnResponse> {
            const localVarFetchArgs = ReturnsApiFetchParamCreator(configuration).getReturn(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Загружает заявление покупателя на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение заявления на возврат
         * @throws {RequiredError}
         */
        getReturnApplication(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ReturnsApiFetchParamCreator(configuration).getReturnApplication(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает фотографии, которые покупатель приложил к заявлению на возврат товара.  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Получение фотографии возврата
         * @throws {RequiredError}
         */
        getReturnPhoto(campaignId: number, orderId: number, returnId: number, itemId: number, imageHash: string, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ReturnsApiFetchParamCreator(configuration).getReturnPhoto(campaignId, orderId, returnId, itemId, imageHash, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Получает список невыкупов и возвратов.  Чтобы получить информацию по одному возврату или невыкупу, выполните запрос [GET campaigns/{campaignId}/orders/{orderId}/returns/{returnId}](../../reference/orders/getReturn.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Список невыкупов и возвратов
         * @throws {RequiredError}
         */
        getReturns(campaignId: number, pageToken?: string, limit?: number, orderIds?: Array<number>, statuses?: Array<RefundStatusType>, type?: ReturnType, fromDate?: Date, toDate?: Date, fromDate2?: Date, toDate2?: Date, options?: RequestOptions = {}): Promise<GetReturnsResponse> {
            const localVarFetchArgs = ReturnsApiFetchParamCreator(configuration).getReturns(campaignId, pageToken, limit, orderIds, statuses, type, fromDate, toDate, fromDate2, toDate2, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Выбирает решение по возврату от покупателя. После этого для подтверждения решения нужно выполнить запрос [POST campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit](../../reference/orders/submitReturnDecision.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Принятие или изменение решения по возврату
         * @throws {RequiredError}
         */
        setReturnDecision(campaignId: number, orderId: number, returnId: number, setReturnDecisionRequest: SetReturnDecisionRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ReturnsApiFetchParamCreator(configuration).setReturnDecision(campaignId, orderId, returnId, setReturnDecisionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Подтверждает выбранное решение по возврату, отправленное в запросе [POST campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision](../../reference/orders/setReturnDecision.md).  |**⚙️ Лимит:** 10 000 запросов в час| |-| 
         * @summary Подтверждение решения по возврату
         * @throws {RequiredError}
         */
        submitReturnDecision(campaignId: number, orderId: number, returnId: number, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ReturnsApiFetchParamCreator(configuration).submitReturnDecision(campaignId, orderId, returnId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ShipmentsApi - fetch parameter creator
 * @export
 */
export const ShipmentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Подтверждает отгрузку товаров в сортировочный центр или пункт приема заказов. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Подтверждение отгрузки
         * @throws {RequiredError}
         */
        confirmShipment(campaignId: number, shipmentId: number, confirmShipmentRequest?: ConfirmShipmentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling confirmShipment.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling confirmShipment.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/confirm`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof confirmShipmentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmShipmentRequest != null ? confirmShipmentRequest : {}) : (((confirmShipmentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {% note warning \"Экспресс‑доставка\" %}  Если ваш магазин подключен к экспресс‑доставке и вы отгружаете заказы курьерам Яндекс Go, подготавливать акт приема‑передачи не нужно.  {% endnote %}  Запрос формирует акт приема-передачи заказов, входящих в отгрузку, и возвращает акт в формате PDF. В акте содержатся собранные и готовые к отправке заказы.  При формировании акта Маркет автоматически находит и подставляет в шаблон следующие данные:  {% cut \"Данные, из которых Маркет формирует акт\" %}  | **Данные в акте**                                         | **Описание**                                                                                                                                                                                                                                                         | | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Дата                                                      | Дата запроса.                                                                                                                                                                                                                                                        | | Отправитель                                               | Название вашего юридического лица, указанное в кабинете продавца на Маркете.                                                                                                                                                                                         | | Исполнитель                                               | Название юридического лица сортировочного центра или службы доставки.                                                                                                                                                                                                | | № отправления в системе заказчика                         | Ваш идентификатор заказа, который вы указали в ответе на запрос [POST order/accept](../../pushapi/reference/orderAccept.md) от Маркета.                                                                                                                              | | № отправления в системе исполнителя (субподрядчика)       | Идентификатор заказа на Маркете, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md).                                                                                                                             | | Объявленная ценность                                      | Общая сумма заказа без учета стоимости доставки, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                       | | Вес                                                       | Масса брутто грузового места (суммарная масса упаковки и содержимого), как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md). | | Количество мест                                           | Количество грузовых мест в заказе, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                                     |  {% endcut %}  Остальные поля нужно заполнить самостоятельно в распечатанном акте. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение акта приема-передачи
         * @throws {RequiredError}
         */
        downloadShipmentAct(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentAct.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentAct.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/act`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает акт расхождений для заданной отгрузки. |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение акта расхождений
         * @throws {RequiredError}
         */
        downloadShipmentDiscrepancyAct(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentDiscrepancyAct.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentDiscrepancyAct.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/discrepancy-act`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает фактический акт приема-передачи для заданной отгрузки.  Такой акт становится доступен спустя несколько часов после завершения отгрузки. Он может понадобиться, если после отгрузки обнаружатся расхождения.  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение фактического акта приема-передачи
         * @throws {RequiredError}
         */
        downloadShipmentInboundAct(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentInboundAct.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentInboundAct.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/inbound-act`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PDF-файл с ярлыками на каждый короб или палету в отгрузке для доверительной приемки. Подробнее про доверительную приемку написано в [Справке Маркета](https://yandex.ru/support/marketplace/orders/fbs/process.html#acceptance).  Распечатайте по несколько копий каждого ярлыка: на одну тару нужно наклеить минимум 2 ярлыка с разных сторон.  Количество упаковок в отгрузке задается в запросе [PUT campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallets](../../reference/shipments/setShipmentPalletsCount.md). |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Ярлыки для доверительной приемки (FBS)
         * @throws {RequiredError}
         */
        downloadShipmentPalletLabels(campaignId: number, shipmentId: number, format?: ShipmentPalletLabelPageFormatType, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentPalletLabels.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentPalletLabels.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallet/labels`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = ((format:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запрос подтверждает ближайшую отгрузку и возвращает акт приема-передачи в формате PDF.  {% note warning \"Экспресс‑доставка\" %}  Если ваш магазин подключен к экспресс‑доставке и вы отгружаете заказы курьерам [Яндекс Go](https://go.yandex/), подготавливать акт приема‑передачи не нужно.  {% endnote %}  В акт входят собранные и готовые к отправке заказы, которые отгружаются в сортировочный центр или пункт приема или курьерам Маркета.  При формировании акта Маркет автоматически находит и подставляет в шаблон следующие данные:  {% cut \"Данные, из которых Маркет формирует акт\" %}  | **Данные в акте**                                   | **Описание**                                                                                                                                                                                                                                                         | | --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Отправитель                                         | Название вашего юридического лица, указанное в кабинете продавца на Маркете.                                                                                                                                                                                         | | Исполнитель                                         | Название юридического лица сортировочного центра или службы доставки.                                                                                                                                                                                                | | № отправления в системе заказчика                   | Ваш идентификатор заказа, который вы указали в ответе на запрос [POST order/accept](../../pushapi/reference/orderAccept.md) от Маркета.                                                                                                                              | | № отправления в системе исполнителя (субподрядчика) | Идентификатор заказа на Маркете, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md).                                                                                                                             | | Объявленная ценность                                | Общая сумма заказа без учета стоимости доставки, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                       | | Стоимость всех товаров в заказе                     | Стоимость всех заказанных товаров.                                                                                                                                                                                                                                   | | Вес                                                 | Масса брутто грузового места (суммарная масса упаковки и содержимого), как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md). | | Количество мест                                     | Количество грузовых мест в заказе, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                                     |  {% endcut %}  Остальные поля нужно заполнить самостоятельно в распечатанном акте. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Подтверждение ближайшей отгрузки и получение акта приема-передачи для нее
         * @throws {RequiredError}
         */
        downloadShipmentReceptionTransferAct(campaignId: number, warehouseId?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentReceptionTransferAct.');
            }
            const localVarPath = `/campaigns/{campaignId}/shipments/reception-transfer-act`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouse_id'] = ((warehouseId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает транспортную накладную для заданной отгрузки.  Транспортная накладная понадобится, если вы отгружаете товары непосредственно со своего склада. [Подробно об этом способе отгрузки](https://yandex.ru/support/marketplace/orders/fbs/settings/shipment.html#at-your-warehouse)  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение транспортной накладной
         * @throws {RequiredError}
         */
        downloadShipmentTransportationWaybill(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling downloadShipmentTransportationWaybill.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling downloadShipmentTransportationWaybill.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/transportation-waybill`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию об отгрузке по ее идентификатору. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации об одной отгрузке
         * @throws {RequiredError}
         */
        getShipment(campaignId: number, shipmentId: number, cancelledOrders?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getShipment.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling getShipment.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (cancelledOrders !== undefined) {
                localVarQueryParameter['cancelledOrders'] = ((cancelledOrders:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о возможности печати ярлыков-наклеек для заказов в отгрузке. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации о возможности печати ярлыков (FBS)
         * @throws {RequiredError}
         */
        getShipmentOrdersInfo(campaignId: number, shipmentId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getShipmentOrdersInfo.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling getShipmentOrdersInfo.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/orders/info`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию об отгрузках по заданным параметрам:  * дате; * статусу; * идентификаторам заказов.  Результаты возвращаются постранично. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации о нескольких отгрузках
         * @throws {RequiredError}
         */
        searchShipments(campaignId: number, searchShipmentsRequest: SearchShipmentsRequest, pageToken?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling searchShipments.');
            }
            // verify required parameter 'searchShipmentsRequest' is not null or undefined
            if (searchShipmentsRequest === null || searchShipmentsRequest === undefined) {
                throw new RequiredError('searchShipmentsRequest','Required parameter searchShipmentsRequest was null or undefined when calling searchShipments.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof searchShipmentsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchShipmentsRequest != null ? searchShipmentsRequest : {}) : (((searchShipmentsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает Маркету количество коробов или палет в отгрузке для доверительной приемки. Подробнее про доверительную приемку написано в [Справке Маркета](https://yandex.ru/support/marketplace/orders/fbs/process.html#acceptance).  Получить PDF-файл с ярлыками для упаковок можно с помощью запроса [GET campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallet/labels](../../reference/shipments/downloadShipmentPalletLabels.md). |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Передача количества упаковок в отгрузке
         * @throws {RequiredError}
         */
        setShipmentPalletsCount(campaignId: number, shipmentId: number, setShipmentPalletsCountRequest: SetShipmentPalletsCountRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling setShipmentPalletsCount.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling setShipmentPalletsCount.');
            }
            // verify required parameter 'setShipmentPalletsCountRequest' is not null or undefined
            if (setShipmentPalletsCountRequest === null || setShipmentPalletsCountRequest === undefined) {
                throw new RequiredError('setShipmentPalletsCountRequest','Required parameter setShipmentPalletsCountRequest was null or undefined when calling setShipmentPalletsCount.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallets`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof setShipmentPalletsCountRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setShipmentPalletsCountRequest != null ? setShipmentPalletsCountRequest : {}) : (((setShipmentPalletsCountRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Переносит указанные заказы из указанной отгрузки в следующую отгрузку. [Что такое отгрузка?](https://yandex.ru/support/marketplace/orders/fbs/process.html#ship)  Используйте этот запрос, если не успеваете собрать и упаковать заказы вовремя.  {% note warning \"Такие переносы снижают индекс качества магазина\" %}  Этот запрос предназначен для исключительных случаев. Если вы будете переносить заказы слишком часто, магазин столкнется с ограничениями. [Что за ограничения?](https://yandex.ru/support/marketplace/quality/score/fbs.html)  {% endnote %}  Переносить заказы можно, если до формирования отгрузки осталось больше получаса.  Перенос происходит не мгновенно, а занимает несколько минут.  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Перенос заказов в следующую отгрузку
         * @throws {RequiredError}
         */
        transferOrdersFromShipment(campaignId: number, shipmentId: number, transferOrdersFromShipmentRequest: TransferOrdersFromShipmentRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling transferOrdersFromShipment.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling transferOrdersFromShipment.');
            }
            // verify required parameter 'transferOrdersFromShipmentRequest' is not null or undefined
            if (transferOrdersFromShipmentRequest === null || transferOrdersFromShipmentRequest === undefined) {
                throw new RequiredError('transferOrdersFromShipmentRequest','Required parameter transferOrdersFromShipmentRequest was null or undefined when calling transferOrdersFromShipment.');
            }
            const localVarPath = `/campaigns/{campaignId}/first-mile/shipments/{shipmentId}/orders/transfer`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof transferOrdersFromShipmentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(transferOrdersFromShipmentRequest != null ? transferOrdersFromShipmentRequest : {}) : (((transferOrdersFromShipmentRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ShipmentsApiType = { 
    confirmShipment(campaignId: number, shipmentId: number, confirmShipmentRequest?: ConfirmShipmentRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    downloadShipmentAct(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<File>,

    downloadShipmentDiscrepancyAct(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<File>,

    downloadShipmentInboundAct(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<File>,

    downloadShipmentPalletLabels(campaignId: number, shipmentId: number, format?: ShipmentPalletLabelPageFormatType, options?: RequestOptions): Promise<File>,

    downloadShipmentReceptionTransferAct(campaignId: number, warehouseId?: number, options?: RequestOptions): Promise<File>,

    downloadShipmentTransportationWaybill(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<File>,

    getShipment(campaignId: number, shipmentId: number, cancelledOrders?: boolean, options?: RequestOptions): Promise<GetShipmentResponse>,

    getShipmentOrdersInfo(campaignId: number, shipmentId: number, options?: RequestOptions): Promise<GetShipmentOrdersInfoResponse>,

    searchShipments(campaignId: number, searchShipmentsRequest: SearchShipmentsRequest, pageToken?: string, limit?: number, options?: RequestOptions): Promise<SearchShipmentsResponse>,

    setShipmentPalletsCount(campaignId: number, shipmentId: number, setShipmentPalletsCountRequest: SetShipmentPalletsCountRequest, options?: RequestOptions): Promise<EmptyApiResponse>,

    transferOrdersFromShipment(campaignId: number, shipmentId: number, transferOrdersFromShipmentRequest: TransferOrdersFromShipmentRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * ShipmentsApi - factory function to inject configuration 
 * @export
 */
export const ShipmentsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ShipmentsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Подтверждает отгрузку товаров в сортировочный центр или пункт приема заказов. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Подтверждение отгрузки
         * @throws {RequiredError}
         */
        confirmShipment(campaignId: number, shipmentId: number, confirmShipmentRequest?: ConfirmShipmentRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).confirmShipment(campaignId, shipmentId, confirmShipmentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {% note warning \"Экспресс‑доставка\" %}  Если ваш магазин подключен к экспресс‑доставке и вы отгружаете заказы курьерам Яндекс Go, подготавливать акт приема‑передачи не нужно.  {% endnote %}  Запрос формирует акт приема-передачи заказов, входящих в отгрузку, и возвращает акт в формате PDF. В акте содержатся собранные и готовые к отправке заказы.  При формировании акта Маркет автоматически находит и подставляет в шаблон следующие данные:  {% cut \"Данные, из которых Маркет формирует акт\" %}  | **Данные в акте**                                         | **Описание**                                                                                                                                                                                                                                                         | | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Дата                                                      | Дата запроса.                                                                                                                                                                                                                                                        | | Отправитель                                               | Название вашего юридического лица, указанное в кабинете продавца на Маркете.                                                                                                                                                                                         | | Исполнитель                                               | Название юридического лица сортировочного центра или службы доставки.                                                                                                                                                                                                | | № отправления в системе заказчика                         | Ваш идентификатор заказа, который вы указали в ответе на запрос [POST order/accept](../../pushapi/reference/orderAccept.md) от Маркета.                                                                                                                              | | № отправления в системе исполнителя (субподрядчика)       | Идентификатор заказа на Маркете, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md).                                                                                                                             | | Объявленная ценность                                      | Общая сумма заказа без учета стоимости доставки, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                       | | Вес                                                       | Масса брутто грузового места (суммарная масса упаковки и содержимого), как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md). | | Количество мест                                           | Количество грузовых мест в заказе, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                                     |  {% endcut %}  Остальные поля нужно заполнить самостоятельно в распечатанном акте. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение акта приема-передачи
         * @throws {RequiredError}
         */
        downloadShipmentAct(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).downloadShipmentAct(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает акт расхождений для заданной отгрузки. |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение акта расхождений
         * @throws {RequiredError}
         */
        downloadShipmentDiscrepancyAct(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).downloadShipmentDiscrepancyAct(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает фактический акт приема-передачи для заданной отгрузки.  Такой акт становится доступен спустя несколько часов после завершения отгрузки. Он может понадобиться, если после отгрузки обнаружатся расхождения.  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение фактического акта приема-передачи
         * @throws {RequiredError}
         */
        downloadShipmentInboundAct(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).downloadShipmentInboundAct(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * PDF-файл с ярлыками на каждый короб или палету в отгрузке для доверительной приемки. Подробнее про доверительную приемку написано в [Справке Маркета](https://yandex.ru/support/marketplace/orders/fbs/process.html#acceptance).  Распечатайте по несколько копий каждого ярлыка: на одну тару нужно наклеить минимум 2 ярлыка с разных сторон.  Количество упаковок в отгрузке задается в запросе [PUT campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallets](../../reference/shipments/setShipmentPalletsCount.md). |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Ярлыки для доверительной приемки (FBS)
         * @throws {RequiredError}
         */
        downloadShipmentPalletLabels(campaignId: number, shipmentId: number, format?: ShipmentPalletLabelPageFormatType, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).downloadShipmentPalletLabels(campaignId, shipmentId, format, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Запрос подтверждает ближайшую отгрузку и возвращает акт приема-передачи в формате PDF.  {% note warning \"Экспресс‑доставка\" %}  Если ваш магазин подключен к экспресс‑доставке и вы отгружаете заказы курьерам [Яндекс Go](https://go.yandex/), подготавливать акт приема‑передачи не нужно.  {% endnote %}  В акт входят собранные и готовые к отправке заказы, которые отгружаются в сортировочный центр или пункт приема или курьерам Маркета.  При формировании акта Маркет автоматически находит и подставляет в шаблон следующие данные:  {% cut \"Данные, из которых Маркет формирует акт\" %}  | **Данные в акте**                                   | **Описание**                                                                                                                                                                                                                                                         | | --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Отправитель                                         | Название вашего юридического лица, указанное в кабинете продавца на Маркете.                                                                                                                                                                                         | | Исполнитель                                         | Название юридического лица сортировочного центра или службы доставки.                                                                                                                                                                                                | | № отправления в системе заказчика                   | Ваш идентификатор заказа, который вы указали в ответе на запрос [POST order/accept](../../pushapi/reference/orderAccept.md) от Маркета.                                                                                                                              | | № отправления в системе исполнителя (субподрядчика) | Идентификатор заказа на Маркете, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md).                                                                                                                             | | Объявленная ценность                                | Общая сумма заказа без учета стоимости доставки, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                       | | Стоимость всех товаров в заказе                     | Стоимость всех заказанных товаров.                                                                                                                                                                                                                                   | | Вес                                                 | Масса брутто грузового места (суммарная масса упаковки и содержимого), как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md). | | Количество мест                                     | Количество грузовых мест в заказе, как в выходных данных запроса [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).                                     |  {% endcut %}  Остальные поля нужно заполнить самостоятельно в распечатанном акте. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Подтверждение ближайшей отгрузки и получение акта приема-передачи для нее
         * @throws {RequiredError}
         */
        downloadShipmentReceptionTransferAct(campaignId: number, warehouseId?: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).downloadShipmentReceptionTransferAct(campaignId, warehouseId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает транспортную накладную для заданной отгрузки.  Транспортная накладная понадобится, если вы отгружаете товары непосредственно со своего склада. [Подробно об этом способе отгрузки](https://yandex.ru/support/marketplace/orders/fbs/settings/shipment.html#at-your-warehouse)  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Получение транспортной накладной
         * @throws {RequiredError}
         */
        downloadShipmentTransportationWaybill(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).downloadShipmentTransportationWaybill(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию об отгрузке по ее идентификатору. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации об одной отгрузке
         * @throws {RequiredError}
         */
        getShipment(campaignId: number, shipmentId: number, cancelledOrders?: boolean, options?: RequestOptions = {}): Promise<GetShipmentResponse> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).getShipment(campaignId, shipmentId, cancelledOrders, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию о возможности печати ярлыков-наклеек для заказов в отгрузке. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации о возможности печати ярлыков (FBS)
         * @throws {RequiredError}
         */
        getShipmentOrdersInfo(campaignId: number, shipmentId: number, options?: RequestOptions = {}): Promise<GetShipmentOrdersInfoResponse> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).getShipmentOrdersInfo(campaignId, shipmentId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает информацию об отгрузках по заданным параметрам:  * дате; * статусу; * идентификаторам заказов.  Результаты возвращаются постранично. |**⚙️ Лимит:** 100 запросов в час| |-| 
         * @summary Получение информации о нескольких отгрузках
         * @throws {RequiredError}
         */
        searchShipments(campaignId: number, searchShipmentsRequest: SearchShipmentsRequest, pageToken?: string, limit?: number, options?: RequestOptions = {}): Promise<SearchShipmentsResponse> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).searchShipments(campaignId, searchShipmentsRequest, pageToken, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает Маркету количество коробов или палет в отгрузке для доверительной приемки. Подробнее про доверительную приемку написано в [Справке Маркета](https://yandex.ru/support/marketplace/orders/fbs/process.html#acceptance).  Получить PDF-файл с ярлыками для упаковок можно с помощью запроса [GET campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallet/labels](../../reference/shipments/downloadShipmentPalletLabels.md). |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Передача количества упаковок в отгрузке
         * @throws {RequiredError}
         */
        setShipmentPalletsCount(campaignId: number, shipmentId: number, setShipmentPalletsCountRequest: SetShipmentPalletsCountRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).setShipmentPalletsCount(campaignId, shipmentId, setShipmentPalletsCountRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Переносит указанные заказы из указанной отгрузки в следующую отгрузку. [Что такое отгрузка?](https://yandex.ru/support/marketplace/orders/fbs/process.html#ship)  Используйте этот запрос, если не успеваете собрать и упаковать заказы вовремя.  {% note warning \"Такие переносы снижают индекс качества магазина\" %}  Этот запрос предназначен для исключительных случаев. Если вы будете переносить заказы слишком часто, магазин столкнется с ограничениями. [Что за ограничения?](https://yandex.ru/support/marketplace/quality/score/fbs.html)  {% endnote %}  Переносить заказы можно, если до формирования отгрузки осталось больше получаса.  Перенос происходит не мгновенно, а занимает несколько минут.  |**⚙️ Лимит:** 200 запросов в час| |-| 
         * @summary Перенос заказов в следующую отгрузку
         * @throws {RequiredError}
         */
        transferOrdersFromShipment(campaignId: number, shipmentId: number, transferOrdersFromShipmentRequest: TransferOrdersFromShipmentRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).transferOrdersFromShipment(campaignId, shipmentId, transferOrdersFromShipmentRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * StocksApi - fetch parameter creator
 * @export
 */
export const StocksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling getStocks.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/stocks`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = ((pageToken:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof getWarehouseStocksRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(getWarehouseStocksRequest != null ? getWarehouseStocksRequest : {}) : (((getWarehouseStocksRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Передает данные об остатках товаров на витрине.  Обязательно указывайте SKU **в точности** так, как он указан в каталоге. Например, _557722_ и _0557722_ — это два разных SKU.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-| 
         * @summary Передача информации об остатках
         * @throws {RequiredError}
         */
        updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'campaignId' is not null or undefined
            if (campaignId === null || campaignId === undefined) {
                throw new RequiredError('campaignId','Required parameter campaignId was null or undefined when calling updateStocks.');
            }
            // verify required parameter 'updateStocksRequest' is not null or undefined
            if (updateStocksRequest === null || updateStocksRequest === undefined) {
                throw new RequiredError('updateStocksRequest','Required parameter updateStocksRequest was null or undefined when calling updateStocks.');
            }
            const localVarPath = `/campaigns/{campaignId}/offers/stocks`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateStocksRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateStocksRequest != null ? updateStocksRequest : {}) : (((updateStocksRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type StocksApiType = { 
    getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions): Promise<GetWarehouseStocksResponse>,

    updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options?: RequestOptions): Promise<EmptyApiResponse>,
}

/**
 * StocksApi - factory function to inject configuration 
 * @export
 */
export const StocksApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): StocksApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает данные об остатках товаров (для всех моделей) и об [оборачиваемости](*turnover) товаров (для модели FBY).  {% note info \"По умолчанию данные по оборачивамости не возращаются\" %}  Чтобы они были в ответе, передавайте `true` в поле `withTurnover`.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-|  [//]: <> (turnover: Среднее количество дней, за которое товар продается. Подробно об оборачиваемости рассказано в Справке Маркета для продавцов https://yandex.ru/support/marketplace/analytics/turnover.html.) 
         * @summary Информация об остатках и оборачиваемости
         * @throws {RequiredError}
         */
        getStocks(campaignId: number, pageToken?: string, limit?: number, getWarehouseStocksRequest?: GetWarehouseStocksRequest, options?: RequestOptions = {}): Promise<GetWarehouseStocksResponse> {
            const localVarFetchArgs = StocksApiFetchParamCreator(configuration).getStocks(campaignId, pageToken, limit, getWarehouseStocksRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Передает данные об остатках товаров на витрине.  Обязательно указывайте SKU **в точности** так, как он указан в каталоге. Например, _557722_ и _0557722_ — это два разных SKU.  {% note info \"Данные в каталоге обновляются не мгновенно\" %}  Это занимает до нескольких минут.  {% endnote %}  |**⚙️ Лимит:** 100 000 товаров в минуту| |-| 
         * @summary Передача информации об остатках
         * @throws {RequiredError}
         */
        updateStocks(campaignId: number, updateStocksRequest: UpdateStocksRequest, options?: RequestOptions = {}): Promise<EmptyApiResponse> {
            const localVarFetchArgs = StocksApiFetchParamCreator(configuration).updateStocks(campaignId, updateStocksRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * TariffsApi - fetch parameter creator
 * @export
 */
export const TariffsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'calculateTariffsRequest' is not null or undefined
            if (calculateTariffsRequest === null || calculateTariffsRequest === undefined) {
                throw new RequiredError('calculateTariffsRequest','Required parameter calculateTariffsRequest was null or undefined when calling calculateTariffs.');
            }
            const localVarPath = `/tariffs/calculate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof calculateTariffsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(calculateTariffsRequest != null ? calculateTariffsRequest : {}) : (((calculateTariffsRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TariffsApiType = { 
    calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions): Promise<CalculateTariffsResponse>,
}

/**
 * TariffsApi - factory function to inject configuration 
 * @export
 */
export const TariffsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TariffsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Рассчитывает стоимость услуг Маркета для товаров с заданными параметрами. Порядок товаров в запросе и ответе сохраняется, чтобы определить, для какого товара рассчитана стоимость услуги.  Обратите внимание: калькулятор осуществляет примерные расчеты. Финальная стоимость для каждого заказа зависит от предоставленных услуг.  В запросе можно указать либо параметр `campaignId`, либо `sellingProgram`. Совместное использование параметров приведет к ошибке.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Калькулятор стоимости услуг
         * @throws {RequiredError}
         */
        calculateTariffs(calculateTariffsRequest: CalculateTariffsRequest, options?: RequestOptions = {}): Promise<CalculateTariffsResponse> {
            const localVarFetchArgs = TariffsApiFetchParamCreator(configuration).calculateTariffs(calculateTariffsRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * WarehousesApi - fetch parameter creator
 * @export
 */
export const WarehousesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список складов Маркета с их идентификаторами.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Идентификаторы складов Маркета (FBY)
         * @throws {RequiredError}
         */
        getFulfillmentWarehouses(options: RequestOptions): FetchArgs {
            const localVarPath = `/warehouses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список складов и, если склады объединены, список групп складов. [Что такое группы складов и зачем они нужны](https://yandex.ru/support/marketplace/assortment/operations/stocks.html#unified-stocks)  Среди прочего запрос позволяет определить идентификатор, который нужно использовать при передаче остатков для группы складов.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Список складов и групп складов
         * @throws {RequiredError}
         */
        getWarehouses(businessId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'businessId' is not null or undefined
            if (businessId === null || businessId === undefined) {
                throw new RequiredError('businessId','Required parameter businessId was null or undefined when calling getWarehouses.');
            }
            const localVarPath = `/businesses/{businessId}/warehouses`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication OAuth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth", ["market:partner-api"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type WarehousesApiType = { 
    getFulfillmentWarehouses(options?: RequestOptions): Promise<GetFulfillmentWarehousesResponse>,

    getWarehouses(businessId: number, options?: RequestOptions): Promise<GetWarehousesResponse>,
}

/**
 * WarehousesApi - factory function to inject configuration 
 * @export
 */
export const WarehousesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): WarehousesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Возвращает список складов Маркета с их идентификаторами.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Идентификаторы складов Маркета (FBY)
         * @throws {RequiredError}
         */
        getFulfillmentWarehouses(options?: RequestOptions = {}): Promise<GetFulfillmentWarehousesResponse> {
            const localVarFetchArgs = WarehousesApiFetchParamCreator(configuration).getFulfillmentWarehouses(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Возвращает список складов и, если склады объединены, список групп складов. [Что такое группы складов и зачем они нужны](https://yandex.ru/support/marketplace/assortment/operations/stocks.html#unified-stocks)  Среди прочего запрос позволяет определить идентификатор, который нужно использовать при передаче остатков для группы складов.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
         * @summary Список складов и групп складов
         * @throws {RequiredError}
         */
        getWarehouses(businessId: number, options?: RequestOptions = {}): Promise<GetWarehousesResponse> {
            const localVarFetchArgs = WarehousesApiFetchParamCreator(configuration).getWarehouses(businessId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    BidsApi: BidsApiType,

    BusinessOfferMappingsApi: BusinessOfferMappingsApiType,

    BusinessesApi: BusinessesApiType,

    CampaignsApi: CampaignsApiType,

    CategoriesApi: CategoriesApiType,

    ChatsApi: ChatsApiType,

    ContentApi: ContentApiType,

    DbsApi: DbsApiType,

    DeliveryServicesApi: DeliveryServicesApiType,

    ExpressApi: ExpressApiType,

    FbsApi: FbsApiType,

    FbyApi: FbyApiType,

    FeedbacksApi: FeedbacksApiType,

    FeedsApi: FeedsApiType,

    GoodsFeedbackApi: GoodsFeedbackApiType,

    GoodsStatsApi: GoodsStatsApiType,

    HiddenOffersApi: HiddenOffersApiType,

    ModelsApi: ModelsApiType,

    OfferMappingsApi: OfferMappingsApiType,

    OffersApi: OffersApiType,

    OrderBusinessInformationApi: OrderBusinessInformationApiType,

    OrderDeliveryApi: OrderDeliveryApiType,

    OrderLabelsApi: OrderLabelsApiType,

    OrdersApi: OrdersApiType,

    OrdersStatsApi: OrdersStatsApiType,

    OutletLicensesApi: OutletLicensesApiType,

    OutletsApi: OutletsApiType,

    PriceQuarantineApi: PriceQuarantineApiType,

    PricesApi: PricesApiType,

    PromosApi: PromosApiType,

    RatingsApi: RatingsApiType,

    RegionsApi: RegionsApiType,

    ReportsApi: ReportsApiType,

    ReturnsApi: ReturnsApiType,

    ShipmentsApi: ShipmentsApiType,

    StocksApi: StocksApiType,

    TariffsApi: TariffsApiType,

    WarehousesApi: WarehousesApiType,
 }
