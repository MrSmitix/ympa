/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "ympa_cpp_restsdk_client/model/CategoryParameterDTO.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {



CategoryParameterDTO::CategoryParameterDTO()
{
    m_Id = 0L;
    m_IdIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_TypeIsSet = false;
    m_UnitIsSet = false;
    m_Description = utility::conversions::to_string_t("");
    m_DescriptionIsSet = false;
    m_RecommendationTypesIsSet = false;
    m_Required = false;
    m_RequiredIsSet = false;
    m_Filtering = false;
    m_FilteringIsSet = false;
    m_Distinctive = false;
    m_DistinctiveIsSet = false;
    m_Multivalue = false;
    m_MultivalueIsSet = false;
    m_AllowCustomValues = false;
    m_AllowCustomValuesIsSet = false;
    m_ValuesIsSet = false;
    m_ConstraintsIsSet = false;
    m_ValueRestrictionsIsSet = false;
}

CategoryParameterDTO::~CategoryParameterDTO()
{
}

void CategoryParameterDTO::validate()
{
    // TODO: implement validation
}

web::json::value CategoryParameterDTO::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_IdIsSet)
    {
        val[utility::conversions::to_string_t(U("id"))] = ModelBase::toJson(m_Id);
    }
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t(U("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_TypeIsSet)
    {
        val[utility::conversions::to_string_t(U("type"))] = ModelBase::toJson(m_Type);
    }
    if(m_UnitIsSet)
    {
        val[utility::conversions::to_string_t(U("unit"))] = ModelBase::toJson(m_Unit);
    }
    if(m_DescriptionIsSet)
    {
        val[utility::conversions::to_string_t(U("description"))] = ModelBase::toJson(m_Description);
    }
    if(m_RecommendationTypesIsSet)
    {
        val[utility::conversions::to_string_t(U("recommendationTypes"))] = ModelBase::toJson(m_RecommendationTypes);
    }
    if(m_RequiredIsSet)
    {
        val[utility::conversions::to_string_t(U("required"))] = ModelBase::toJson(m_Required);
    }
    if(m_FilteringIsSet)
    {
        val[utility::conversions::to_string_t(U("filtering"))] = ModelBase::toJson(m_Filtering);
    }
    if(m_DistinctiveIsSet)
    {
        val[utility::conversions::to_string_t(U("distinctive"))] = ModelBase::toJson(m_Distinctive);
    }
    if(m_MultivalueIsSet)
    {
        val[utility::conversions::to_string_t(U("multivalue"))] = ModelBase::toJson(m_Multivalue);
    }
    if(m_AllowCustomValuesIsSet)
    {
        val[utility::conversions::to_string_t(U("allowCustomValues"))] = ModelBase::toJson(m_AllowCustomValues);
    }
    if(m_ValuesIsSet)
    {
        val[utility::conversions::to_string_t(U("values"))] = ModelBase::toJson(m_Values);
    }
    if(m_ConstraintsIsSet)
    {
        val[utility::conversions::to_string_t(U("constraints"))] = ModelBase::toJson(m_Constraints);
    }
    if(m_ValueRestrictionsIsSet)
    {
        val[utility::conversions::to_string_t(U("valueRestrictions"))] = ModelBase::toJson(m_ValueRestrictions);
    }

    return val;
}

bool CategoryParameterDTO::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("id")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setId);
            setId(refVal_setId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("type"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("type")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ParameterType> refVal_setType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setType);
            setType(refVal_setType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unit"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unit")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<CategoryParameterUnitDTO> refVal_setUnit;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUnit);
            setUnit(refVal_setUnit);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("description"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("description")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setDescription;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDescription);
            setDescription(refVal_setDescription);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("recommendationTypes"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("recommendationTypes")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<OfferCardRecommendationType>> refVal_setRecommendationTypes;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRecommendationTypes);
            setRecommendationTypes(refVal_setRecommendationTypes);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("required"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("required")));
        if(!fieldValue.is_null())
        {
            bool refVal_setRequired;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRequired);
            setRequired(refVal_setRequired);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("filtering"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("filtering")));
        if(!fieldValue.is_null())
        {
            bool refVal_setFiltering;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFiltering);
            setFiltering(refVal_setFiltering);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("distinctive"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("distinctive")));
        if(!fieldValue.is_null())
        {
            bool refVal_setDistinctive;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDistinctive);
            setDistinctive(refVal_setDistinctive);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("multivalue"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("multivalue")));
        if(!fieldValue.is_null())
        {
            bool refVal_setMultivalue;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMultivalue);
            setMultivalue(refVal_setMultivalue);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("allowCustomValues"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("allowCustomValues")));
        if(!fieldValue.is_null())
        {
            bool refVal_setAllowCustomValues;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAllowCustomValues);
            setAllowCustomValues(refVal_setAllowCustomValues);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("values"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("values")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<ParameterValueOptionDTO>> refVal_setValues;
            ok &= ModelBase::fromJson(fieldValue, refVal_setValues);
            setValues(refVal_setValues);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("constraints"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("constraints")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ParameterValueConstraintsDTO> refVal_setConstraints;
            ok &= ModelBase::fromJson(fieldValue, refVal_setConstraints);
            setConstraints(refVal_setConstraints);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("valueRestrictions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("valueRestrictions")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<ValueRestrictionDTO>> refVal_setValueRestrictions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setValueRestrictions);
            setValueRestrictions(refVal_setValueRestrictions);
        }
    }
    return ok;
}

void CategoryParameterDTO::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("id")), m_Id));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
    }
    if(m_TypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("type")), m_Type));
    }
    if(m_UnitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unit")), m_Unit));
    }
    if(m_DescriptionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("description")), m_Description));
    }
    if(m_RecommendationTypesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("recommendationTypes")), m_RecommendationTypes));
    }
    if(m_RequiredIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("required")), m_Required));
    }
    if(m_FilteringIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("filtering")), m_Filtering));
    }
    if(m_DistinctiveIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("distinctive")), m_Distinctive));
    }
    if(m_MultivalueIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("multivalue")), m_Multivalue));
    }
    if(m_AllowCustomValuesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("allowCustomValues")), m_AllowCustomValues));
    }
    if(m_ValuesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("values")), m_Values));
    }
    if(m_ConstraintsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("constraints")), m_Constraints));
    }
    if(m_ValueRestrictionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("valueRestrictions")), m_ValueRestrictions));
    }
}

bool CategoryParameterDTO::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("id"))))
    {
        int64_t refVal_setId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("id"))), refVal_setId );
        setId(refVal_setId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("type"))))
    {
        std::shared_ptr<ParameterType> refVal_setType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("type"))), refVal_setType );
        setType(refVal_setType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unit"))))
    {
        std::shared_ptr<CategoryParameterUnitDTO> refVal_setUnit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unit"))), refVal_setUnit );
        setUnit(refVal_setUnit);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("description"))))
    {
        utility::string_t refVal_setDescription;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("description"))), refVal_setDescription );
        setDescription(refVal_setDescription);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("recommendationTypes"))))
    {
        std::vector<std::shared_ptr<OfferCardRecommendationType>> refVal_setRecommendationTypes;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("recommendationTypes"))), refVal_setRecommendationTypes );
        setRecommendationTypes(refVal_setRecommendationTypes);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("required"))))
    {
        bool refVal_setRequired;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("required"))), refVal_setRequired );
        setRequired(refVal_setRequired);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("filtering"))))
    {
        bool refVal_setFiltering;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("filtering"))), refVal_setFiltering );
        setFiltering(refVal_setFiltering);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("distinctive"))))
    {
        bool refVal_setDistinctive;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("distinctive"))), refVal_setDistinctive );
        setDistinctive(refVal_setDistinctive);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("multivalue"))))
    {
        bool refVal_setMultivalue;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("multivalue"))), refVal_setMultivalue );
        setMultivalue(refVal_setMultivalue);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("allowCustomValues"))))
    {
        bool refVal_setAllowCustomValues;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("allowCustomValues"))), refVal_setAllowCustomValues );
        setAllowCustomValues(refVal_setAllowCustomValues);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("values"))))
    {
        std::vector<std::shared_ptr<ParameterValueOptionDTO>> refVal_setValues;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("values"))), refVal_setValues );
        setValues(refVal_setValues);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("constraints"))))
    {
        std::shared_ptr<ParameterValueConstraintsDTO> refVal_setConstraints;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("constraints"))), refVal_setConstraints );
        setConstraints(refVal_setConstraints);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("valueRestrictions"))))
    {
        std::vector<std::shared_ptr<ValueRestrictionDTO>> refVal_setValueRestrictions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("valueRestrictions"))), refVal_setValueRestrictions );
        setValueRestrictions(refVal_setValueRestrictions);
    }
    return ok;
}

int64_t CategoryParameterDTO::getId() const
{
    return m_Id;
}

void CategoryParameterDTO::setId(int64_t value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool CategoryParameterDTO::idIsSet() const
{
    return m_IdIsSet;
}

void CategoryParameterDTO::unsetId()
{
    m_IdIsSet = false;
}
utility::string_t CategoryParameterDTO::getName() const
{
    return m_Name;
}

void CategoryParameterDTO::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool CategoryParameterDTO::nameIsSet() const
{
    return m_NameIsSet;
}

void CategoryParameterDTO::unsetName()
{
    m_NameIsSet = false;
}
std::shared_ptr<ParameterType> CategoryParameterDTO::getType() const
{
    return m_Type;
}

void CategoryParameterDTO::setType(const std::shared_ptr<ParameterType>& value)
{
    m_Type = value;
    m_TypeIsSet = true;
}

bool CategoryParameterDTO::typeIsSet() const
{
    return m_TypeIsSet;
}

void CategoryParameterDTO::unsetType()
{
    m_TypeIsSet = false;
}
std::shared_ptr<CategoryParameterUnitDTO> CategoryParameterDTO::getUnit() const
{
    return m_Unit;
}

void CategoryParameterDTO::setUnit(const std::shared_ptr<CategoryParameterUnitDTO>& value)
{
    m_Unit = value;
    m_UnitIsSet = true;
}

bool CategoryParameterDTO::unitIsSet() const
{
    return m_UnitIsSet;
}

void CategoryParameterDTO::unsetUnit()
{
    m_UnitIsSet = false;
}
utility::string_t CategoryParameterDTO::getDescription() const
{
    return m_Description;
}

void CategoryParameterDTO::setDescription(const utility::string_t& value)
{
    m_Description = value;
    m_DescriptionIsSet = true;
}

bool CategoryParameterDTO::descriptionIsSet() const
{
    return m_DescriptionIsSet;
}

void CategoryParameterDTO::unsetDescription()
{
    m_DescriptionIsSet = false;
}
std::vector<std::shared_ptr<OfferCardRecommendationType>>& CategoryParameterDTO::getRecommendationTypes()
{
    return m_RecommendationTypes;
}

void CategoryParameterDTO::setRecommendationTypes(const std::vector<std::shared_ptr<OfferCardRecommendationType>>& value)
{
    m_RecommendationTypes = value;
    m_RecommendationTypesIsSet = true;
}

bool CategoryParameterDTO::recommendationTypesIsSet() const
{
    return m_RecommendationTypesIsSet;
}

void CategoryParameterDTO::unsetRecommendationTypes()
{
    m_RecommendationTypesIsSet = false;
}
bool CategoryParameterDTO::isRequired() const
{
    return m_Required;
}

void CategoryParameterDTO::setRequired(bool value)
{
    m_Required = value;
    m_RequiredIsSet = true;
}

bool CategoryParameterDTO::requiredIsSet() const
{
    return m_RequiredIsSet;
}

void CategoryParameterDTO::unsetRequired()
{
    m_RequiredIsSet = false;
}
bool CategoryParameterDTO::isFiltering() const
{
    return m_Filtering;
}

void CategoryParameterDTO::setFiltering(bool value)
{
    m_Filtering = value;
    m_FilteringIsSet = true;
}

bool CategoryParameterDTO::filteringIsSet() const
{
    return m_FilteringIsSet;
}

void CategoryParameterDTO::unsetFiltering()
{
    m_FilteringIsSet = false;
}
bool CategoryParameterDTO::isDistinctive() const
{
    return m_Distinctive;
}

void CategoryParameterDTO::setDistinctive(bool value)
{
    m_Distinctive = value;
    m_DistinctiveIsSet = true;
}

bool CategoryParameterDTO::distinctiveIsSet() const
{
    return m_DistinctiveIsSet;
}

void CategoryParameterDTO::unsetDistinctive()
{
    m_DistinctiveIsSet = false;
}
bool CategoryParameterDTO::isMultivalue() const
{
    return m_Multivalue;
}

void CategoryParameterDTO::setMultivalue(bool value)
{
    m_Multivalue = value;
    m_MultivalueIsSet = true;
}

bool CategoryParameterDTO::multivalueIsSet() const
{
    return m_MultivalueIsSet;
}

void CategoryParameterDTO::unsetMultivalue()
{
    m_MultivalueIsSet = false;
}
bool CategoryParameterDTO::isAllowCustomValues() const
{
    return m_AllowCustomValues;
}

void CategoryParameterDTO::setAllowCustomValues(bool value)
{
    m_AllowCustomValues = value;
    m_AllowCustomValuesIsSet = true;
}

bool CategoryParameterDTO::allowCustomValuesIsSet() const
{
    return m_AllowCustomValuesIsSet;
}

void CategoryParameterDTO::unsetAllowCustomValues()
{
    m_AllowCustomValuesIsSet = false;
}
std::vector<std::shared_ptr<ParameterValueOptionDTO>>& CategoryParameterDTO::getValues()
{
    return m_Values;
}

void CategoryParameterDTO::setValues(const std::vector<std::shared_ptr<ParameterValueOptionDTO>>& value)
{
    m_Values = value;
    m_ValuesIsSet = true;
}

bool CategoryParameterDTO::valuesIsSet() const
{
    return m_ValuesIsSet;
}

void CategoryParameterDTO::unsetValues()
{
    m_ValuesIsSet = false;
}
std::shared_ptr<ParameterValueConstraintsDTO> CategoryParameterDTO::getConstraints() const
{
    return m_Constraints;
}

void CategoryParameterDTO::setConstraints(const std::shared_ptr<ParameterValueConstraintsDTO>& value)
{
    m_Constraints = value;
    m_ConstraintsIsSet = true;
}

bool CategoryParameterDTO::constraintsIsSet() const
{
    return m_ConstraintsIsSet;
}

void CategoryParameterDTO::unsetConstraints()
{
    m_ConstraintsIsSet = false;
}
std::vector<std::shared_ptr<ValueRestrictionDTO>>& CategoryParameterDTO::getValueRestrictions()
{
    return m_ValueRestrictions;
}

void CategoryParameterDTO::setValueRestrictions(const std::vector<std::shared_ptr<ValueRestrictionDTO>>& value)
{
    m_ValueRestrictions = value;
    m_ValueRestrictionsIsSet = true;
}

bool CategoryParameterDTO::valueRestrictionsIsSet() const
{
    return m_ValueRestrictionsIsSet;
}

void CategoryParameterDTO::unsetValueRestrictions()
{
    m_ValueRestrictionsIsSet = false;
}
}
}
}
}


