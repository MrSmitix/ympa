/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "ympa_cpp_restsdk_client/model/FeedbackDTO.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {



FeedbackDTO::FeedbackDTO()
{
    m_Id = 0L;
    m_IdIsSet = false;
    m_CreatedAt = utility::datetime();
    m_CreatedAtIsSet = false;
    m_Text = utility::conversions::to_string_t("");
    m_TextIsSet = false;
    m_StateIsSet = false;
    m_AuthorIsSet = false;
    m_Pro = utility::conversions::to_string_t("");
    m_ProIsSet = false;
    m_Contra = utility::conversions::to_string_t("");
    m_ContraIsSet = false;
    m_CommentsIsSet = false;
    m_ShopIsSet = false;
    m_Resolved = false;
    m_ResolvedIsSet = false;
    m_Verified = false;
    m_VerifiedIsSet = false;
    m_Recommend = false;
    m_RecommendIsSet = false;
    m_GradesIsSet = false;
    m_OrderIsSet = false;
}

FeedbackDTO::~FeedbackDTO()
{
}

void FeedbackDTO::validate()
{
    // TODO: implement validation
}

web::json::value FeedbackDTO::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_IdIsSet)
    {
        val[utility::conversions::to_string_t(U("id"))] = ModelBase::toJson(m_Id);
    }
    if(m_CreatedAtIsSet)
    {
        val[utility::conversions::to_string_t(U("createdAt"))] = ModelBase::toJson(m_CreatedAt);
    }
    if(m_TextIsSet)
    {
        val[utility::conversions::to_string_t(U("text"))] = ModelBase::toJson(m_Text);
    }
    if(m_StateIsSet)
    {
        val[utility::conversions::to_string_t(U("state"))] = ModelBase::toJson(m_State);
    }
    if(m_AuthorIsSet)
    {
        val[utility::conversions::to_string_t(U("author"))] = ModelBase::toJson(m_Author);
    }
    if(m_ProIsSet)
    {
        val[utility::conversions::to_string_t(U("pro"))] = ModelBase::toJson(m_Pro);
    }
    if(m_ContraIsSet)
    {
        val[utility::conversions::to_string_t(U("contra"))] = ModelBase::toJson(m_Contra);
    }
    if(m_CommentsIsSet)
    {
        val[utility::conversions::to_string_t(U("comments"))] = ModelBase::toJson(m_Comments);
    }
    if(m_ShopIsSet)
    {
        val[utility::conversions::to_string_t(U("shop"))] = ModelBase::toJson(m_Shop);
    }
    if(m_ResolvedIsSet)
    {
        val[utility::conversions::to_string_t(U("resolved"))] = ModelBase::toJson(m_Resolved);
    }
    if(m_VerifiedIsSet)
    {
        val[utility::conversions::to_string_t(U("verified"))] = ModelBase::toJson(m_Verified);
    }
    if(m_RecommendIsSet)
    {
        val[utility::conversions::to_string_t(U("recommend"))] = ModelBase::toJson(m_Recommend);
    }
    if(m_GradesIsSet)
    {
        val[utility::conversions::to_string_t(U("grades"))] = ModelBase::toJson(m_Grades);
    }
    if(m_OrderIsSet)
    {
        val[utility::conversions::to_string_t(U("order"))] = ModelBase::toJson(m_Order);
    }

    return val;
}

bool FeedbackDTO::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("id")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setId);
            setId(refVal_setId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("createdAt"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("createdAt")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setCreatedAt;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCreatedAt);
            setCreatedAt(refVal_setCreatedAt);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("text"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("text")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setText;
            ok &= ModelBase::fromJson(fieldValue, refVal_setText);
            setText(refVal_setText);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("state"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("state")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<FeedbackStateType> refVal_setState;
            ok &= ModelBase::fromJson(fieldValue, refVal_setState);
            setState(refVal_setState);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("author"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("author")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<FeedbackAuthorDTO> refVal_setAuthor;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAuthor);
            setAuthor(refVal_setAuthor);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("pro"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("pro")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setPro;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPro);
            setPro(refVal_setPro);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("contra"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("contra")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setContra;
            ok &= ModelBase::fromJson(fieldValue, refVal_setContra);
            setContra(refVal_setContra);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("comments"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("comments")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<FeedbackCommentDTO>> refVal_setComments;
            ok &= ModelBase::fromJson(fieldValue, refVal_setComments);
            setComments(refVal_setComments);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("shop"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("shop")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<FeedbackShopDTO> refVal_setShop;
            ok &= ModelBase::fromJson(fieldValue, refVal_setShop);
            setShop(refVal_setShop);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("resolved"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("resolved")));
        if(!fieldValue.is_null())
        {
            bool refVal_setResolved;
            ok &= ModelBase::fromJson(fieldValue, refVal_setResolved);
            setResolved(refVal_setResolved);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("verified"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("verified")));
        if(!fieldValue.is_null())
        {
            bool refVal_setVerified;
            ok &= ModelBase::fromJson(fieldValue, refVal_setVerified);
            setVerified(refVal_setVerified);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("recommend"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("recommend")));
        if(!fieldValue.is_null())
        {
            bool refVal_setRecommend;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRecommend);
            setRecommend(refVal_setRecommend);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("grades"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("grades")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<FeedbackGradesDTO> refVal_setGrades;
            ok &= ModelBase::fromJson(fieldValue, refVal_setGrades);
            setGrades(refVal_setGrades);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("order"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("order")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<FeedbackOrderDTO> refVal_setOrder;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOrder);
            setOrder(refVal_setOrder);
        }
    }
    return ok;
}

void FeedbackDTO::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("id")), m_Id));
    }
    if(m_CreatedAtIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("createdAt")), m_CreatedAt));
    }
    if(m_TextIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("text")), m_Text));
    }
    if(m_StateIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("state")), m_State));
    }
    if(m_AuthorIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("author")), m_Author));
    }
    if(m_ProIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("pro")), m_Pro));
    }
    if(m_ContraIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("contra")), m_Contra));
    }
    if(m_CommentsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("comments")), m_Comments));
    }
    if(m_ShopIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("shop")), m_Shop));
    }
    if(m_ResolvedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("resolved")), m_Resolved));
    }
    if(m_VerifiedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("verified")), m_Verified));
    }
    if(m_RecommendIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("recommend")), m_Recommend));
    }
    if(m_GradesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("grades")), m_Grades));
    }
    if(m_OrderIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("order")), m_Order));
    }
}

bool FeedbackDTO::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("id"))))
    {
        int64_t refVal_setId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("id"))), refVal_setId );
        setId(refVal_setId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("createdAt"))))
    {
        utility::datetime refVal_setCreatedAt;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("createdAt"))), refVal_setCreatedAt );
        setCreatedAt(refVal_setCreatedAt);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("text"))))
    {
        utility::string_t refVal_setText;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("text"))), refVal_setText );
        setText(refVal_setText);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("state"))))
    {
        std::shared_ptr<FeedbackStateType> refVal_setState;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("state"))), refVal_setState );
        setState(refVal_setState);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("author"))))
    {
        std::shared_ptr<FeedbackAuthorDTO> refVal_setAuthor;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("author"))), refVal_setAuthor );
        setAuthor(refVal_setAuthor);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("pro"))))
    {
        utility::string_t refVal_setPro;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("pro"))), refVal_setPro );
        setPro(refVal_setPro);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("contra"))))
    {
        utility::string_t refVal_setContra;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("contra"))), refVal_setContra );
        setContra(refVal_setContra);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("comments"))))
    {
        std::vector<std::shared_ptr<FeedbackCommentDTO>> refVal_setComments;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("comments"))), refVal_setComments );
        setComments(refVal_setComments);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("shop"))))
    {
        std::shared_ptr<FeedbackShopDTO> refVal_setShop;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("shop"))), refVal_setShop );
        setShop(refVal_setShop);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("resolved"))))
    {
        bool refVal_setResolved;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("resolved"))), refVal_setResolved );
        setResolved(refVal_setResolved);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("verified"))))
    {
        bool refVal_setVerified;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("verified"))), refVal_setVerified );
        setVerified(refVal_setVerified);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("recommend"))))
    {
        bool refVal_setRecommend;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("recommend"))), refVal_setRecommend );
        setRecommend(refVal_setRecommend);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("grades"))))
    {
        std::shared_ptr<FeedbackGradesDTO> refVal_setGrades;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("grades"))), refVal_setGrades );
        setGrades(refVal_setGrades);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("order"))))
    {
        std::shared_ptr<FeedbackOrderDTO> refVal_setOrder;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("order"))), refVal_setOrder );
        setOrder(refVal_setOrder);
    }
    return ok;
}

int64_t FeedbackDTO::getId() const
{
    return m_Id;
}

void FeedbackDTO::setId(int64_t value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool FeedbackDTO::idIsSet() const
{
    return m_IdIsSet;
}

void FeedbackDTO::unsetId()
{
    m_IdIsSet = false;
}
utility::datetime FeedbackDTO::getCreatedAt() const
{
    return m_CreatedAt;
}

void FeedbackDTO::setCreatedAt(const utility::datetime& value)
{
    m_CreatedAt = value;
    m_CreatedAtIsSet = true;
}

bool FeedbackDTO::createdAtIsSet() const
{
    return m_CreatedAtIsSet;
}

void FeedbackDTO::unsetCreatedAt()
{
    m_CreatedAtIsSet = false;
}
utility::string_t FeedbackDTO::getText() const
{
    return m_Text;
}

void FeedbackDTO::setText(const utility::string_t& value)
{
    m_Text = value;
    m_TextIsSet = true;
}

bool FeedbackDTO::textIsSet() const
{
    return m_TextIsSet;
}

void FeedbackDTO::unsetText()
{
    m_TextIsSet = false;
}
std::shared_ptr<FeedbackStateType> FeedbackDTO::getState() const
{
    return m_State;
}

void FeedbackDTO::setState(const std::shared_ptr<FeedbackStateType>& value)
{
    m_State = value;
    m_StateIsSet = true;
}

bool FeedbackDTO::stateIsSet() const
{
    return m_StateIsSet;
}

void FeedbackDTO::unsetState()
{
    m_StateIsSet = false;
}
std::shared_ptr<FeedbackAuthorDTO> FeedbackDTO::getAuthor() const
{
    return m_Author;
}

void FeedbackDTO::setAuthor(const std::shared_ptr<FeedbackAuthorDTO>& value)
{
    m_Author = value;
    m_AuthorIsSet = true;
}

bool FeedbackDTO::authorIsSet() const
{
    return m_AuthorIsSet;
}

void FeedbackDTO::unsetAuthor()
{
    m_AuthorIsSet = false;
}
utility::string_t FeedbackDTO::getPro() const
{
    return m_Pro;
}

void FeedbackDTO::setPro(const utility::string_t& value)
{
    m_Pro = value;
    m_ProIsSet = true;
}

bool FeedbackDTO::proIsSet() const
{
    return m_ProIsSet;
}

void FeedbackDTO::unsetPro()
{
    m_ProIsSet = false;
}
utility::string_t FeedbackDTO::getContra() const
{
    return m_Contra;
}

void FeedbackDTO::setContra(const utility::string_t& value)
{
    m_Contra = value;
    m_ContraIsSet = true;
}

bool FeedbackDTO::contraIsSet() const
{
    return m_ContraIsSet;
}

void FeedbackDTO::unsetContra()
{
    m_ContraIsSet = false;
}
std::vector<std::shared_ptr<FeedbackCommentDTO>>& FeedbackDTO::getComments()
{
    return m_Comments;
}

void FeedbackDTO::setComments(const std::vector<std::shared_ptr<FeedbackCommentDTO>>& value)
{
    m_Comments = value;
    m_CommentsIsSet = true;
}

bool FeedbackDTO::commentsIsSet() const
{
    return m_CommentsIsSet;
}

void FeedbackDTO::unsetComments()
{
    m_CommentsIsSet = false;
}
std::shared_ptr<FeedbackShopDTO> FeedbackDTO::getShop() const
{
    return m_Shop;
}

void FeedbackDTO::setShop(const std::shared_ptr<FeedbackShopDTO>& value)
{
    m_Shop = value;
    m_ShopIsSet = true;
}

bool FeedbackDTO::shopIsSet() const
{
    return m_ShopIsSet;
}

void FeedbackDTO::unsetShop()
{
    m_ShopIsSet = false;
}
bool FeedbackDTO::isResolved() const
{
    return m_Resolved;
}

void FeedbackDTO::setResolved(bool value)
{
    m_Resolved = value;
    m_ResolvedIsSet = true;
}

bool FeedbackDTO::resolvedIsSet() const
{
    return m_ResolvedIsSet;
}

void FeedbackDTO::unsetResolved()
{
    m_ResolvedIsSet = false;
}
bool FeedbackDTO::isVerified() const
{
    return m_Verified;
}

void FeedbackDTO::setVerified(bool value)
{
    m_Verified = value;
    m_VerifiedIsSet = true;
}

bool FeedbackDTO::verifiedIsSet() const
{
    return m_VerifiedIsSet;
}

void FeedbackDTO::unsetVerified()
{
    m_VerifiedIsSet = false;
}
bool FeedbackDTO::isRecommend() const
{
    return m_Recommend;
}

void FeedbackDTO::setRecommend(bool value)
{
    m_Recommend = value;
    m_RecommendIsSet = true;
}

bool FeedbackDTO::recommendIsSet() const
{
    return m_RecommendIsSet;
}

void FeedbackDTO::unsetRecommend()
{
    m_RecommendIsSet = false;
}
std::shared_ptr<FeedbackGradesDTO> FeedbackDTO::getGrades() const
{
    return m_Grades;
}

void FeedbackDTO::setGrades(const std::shared_ptr<FeedbackGradesDTO>& value)
{
    m_Grades = value;
    m_GradesIsSet = true;
}

bool FeedbackDTO::gradesIsSet() const
{
    return m_GradesIsSet;
}

void FeedbackDTO::unsetGrades()
{
    m_GradesIsSet = false;
}
std::shared_ptr<FeedbackOrderDTO> FeedbackDTO::getOrder() const
{
    return m_Order;
}

void FeedbackDTO::setOrder(const std::shared_ptr<FeedbackOrderDTO>& value)
{
    m_Order = value;
    m_OrderIsSet = true;
}

bool FeedbackDTO::orderIsSet() const
{
    return m_OrderIsSet;
}

void FeedbackDTO::unsetOrder()
{
    m_OrderIsSet = false;
}
}
}
}
}


