// tslint:disable
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    ApiClientDataErrorResponse,
    ApiClientDataErrorResponseFromJSON,
    ApiClientDataErrorResponseToJSON,
    ApiForbiddenErrorResponse,
    ApiForbiddenErrorResponseFromJSON,
    ApiForbiddenErrorResponseToJSON,
    ApiLimitErrorResponse,
    ApiLimitErrorResponseFromJSON,
    ApiLimitErrorResponseToJSON,
    ApiNotFoundErrorResponse,
    ApiNotFoundErrorResponseFromJSON,
    ApiNotFoundErrorResponseToJSON,
    ApiServerErrorResponse,
    ApiServerErrorResponseFromJSON,
    ApiServerErrorResponseToJSON,
    ApiUnauthorizedErrorResponse,
    ApiUnauthorizedErrorResponseFromJSON,
    ApiUnauthorizedErrorResponseToJSON,
    CurrencyType,
    CurrencyTypeFromJSON,
    CurrencyTypeToJSON,
    GetModelsOffersResponse,
    GetModelsOffersResponseFromJSON,
    GetModelsOffersResponseToJSON,
    GetModelsRequest,
    GetModelsRequestFromJSON,
    GetModelsRequestToJSON,
    GetModelsResponse,
    GetModelsResponseFromJSON,
    GetModelsResponseToJSON,
    SearchModelsResponse,
    SearchModelsResponseFromJSON,
    SearchModelsResponseToJSON,
    SortOrderType,
    SortOrderTypeFromJSON,
    SortOrderTypeToJSON,
} from '../models';

export interface GetModelRequest {
    modelId: number;
    regionId: number;
    currency?: CurrencyType;
}

export interface GetModelOffersRequest {
    modelId: number;
    regionId: number;
    currency?: CurrencyType;
    orderByPrice?: SortOrderType;
    count?: number;
    page?: number;
}

export interface GetModelsRequest {
    regionId: number;
    getModelsRequest: GetModelsRequest;
    currency?: CurrencyType;
}

export interface GetModelsOffersRequest {
    regionId: number;
    getModelsRequest: GetModelsRequest;
    currency?: CurrencyType;
    orderByPrice?: SortOrderType;
}

export interface SearchModelsRequest {
    query: string;
    regionId: number;
    currency?: CurrencyType;
    page?: number;
    pageSize?: number;
}


/**
 * Возвращает информацию о модели товара.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
 * Информация об одной модели
 */
function getModelRaw<T>(requestParameters: GetModelRequest, requestConfig: runtime.TypedQueryConfig<T, GetModelsResponse> = {}): QueryConfig<T> {
    if (requestParameters.modelId === null || requestParameters.modelId === undefined) {
        throw new runtime.RequiredError('modelId','Required parameter requestParameters.modelId was null or undefined when calling getModel.');
    }

    if (requestParameters.regionId === null || requestParameters.regionId === undefined) {
        throw new runtime.RequiredError('regionId','Required parameter requestParameters.regionId was null or undefined when calling getModel.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.regionId !== undefined) {
        queryParameters['regionId'] = requestParameters.regionId;
    }


    if (requestParameters.currency !== undefined) {
        queryParameters['currency'] = requestParameters.currency;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/models/{modelId}`.replace(`{${"modelId"}}`, encodeURIComponent(String(requestParameters.modelId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetModelsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Возвращает информацию о модели товара.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
* Информация об одной модели
*/
export function getModel<T>(requestParameters: GetModelRequest, requestConfig?: runtime.TypedQueryConfig<T, GetModelsResponse>): QueryConfig<T> {
    return getModelRaw(requestParameters, requestConfig);
}

/**
 * Возвращает информацию о первых десяти предложениях, расположенных на карточке модели.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей метод не поддерживается. Идентификатор групповой модели игнорируется.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
 * Список предложений для одной модели
 */
function getModelOffersRaw<T>(requestParameters: GetModelOffersRequest, requestConfig: runtime.TypedQueryConfig<T, GetModelsOffersResponse> = {}): QueryConfig<T> {
    if (requestParameters.modelId === null || requestParameters.modelId === undefined) {
        throw new runtime.RequiredError('modelId','Required parameter requestParameters.modelId was null or undefined when calling getModelOffers.');
    }

    if (requestParameters.regionId === null || requestParameters.regionId === undefined) {
        throw new runtime.RequiredError('regionId','Required parameter requestParameters.regionId was null or undefined when calling getModelOffers.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.regionId !== undefined) {
        queryParameters['regionId'] = requestParameters.regionId;
    }


    if (requestParameters.currency !== undefined) {
        queryParameters['currency'] = requestParameters.currency;
    }


    if (requestParameters.orderByPrice !== undefined) {
        queryParameters['orderByPrice'] = requestParameters.orderByPrice;
    }


    if (requestParameters.count !== undefined) {
        queryParameters['count'] = requestParameters.count;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/models/{modelId}/offers`.replace(`{${"modelId"}}`, encodeURIComponent(String(requestParameters.modelId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetModelsOffersResponseFromJSON(body), text);
    }

    return config;
}

/**
* Возвращает информацию о первых десяти предложениях, расположенных на карточке модели.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей метод не поддерживается. Идентификатор групповой модели игнорируется.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
* Список предложений для одной модели
*/
export function getModelOffers<T>(requestParameters: GetModelOffersRequest, requestConfig?: runtime.TypedQueryConfig<T, GetModelsOffersResponse>): QueryConfig<T> {
    return getModelOffersRaw(requestParameters, requestConfig);
}

/**
 * Возвращает информацию о моделях товаров.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
 * Информация о нескольких моделях
 */
function getModelsRaw<T>(requestParameters: GetModelsRequest, requestConfig: runtime.TypedQueryConfig<T, GetModelsResponse> = {}): QueryConfig<T> {
    if (requestParameters.regionId === null || requestParameters.regionId === undefined) {
        throw new runtime.RequiredError('regionId','Required parameter requestParameters.regionId was null or undefined when calling getModels.');
    }

    if (requestParameters.getModelsRequest === null || requestParameters.getModelsRequest === undefined) {
        throw new runtime.RequiredError('getModelsRequest','Required parameter requestParameters.getModelsRequest was null or undefined when calling getModels.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.regionId !== undefined) {
        queryParameters['regionId'] = requestParameters.regionId;
    }


    if (requestParameters.currency !== undefined) {
        queryParameters['currency'] = requestParameters.currency;
    }

    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/models`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || GetModelsRequestToJSON(requestParameters.getModelsRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetModelsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Возвращает информацию о моделях товаров.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
* Информация о нескольких моделях
*/
export function getModels<T>(requestParameters: GetModelsRequest, requestConfig?: runtime.TypedQueryConfig<T, GetModelsResponse>): QueryConfig<T> {
    return getModelsRaw(requestParameters, requestConfig);
}

/**
 * Возвращает информацию о первых десяти предложениях, расположенных на карточках моделей, идентификаторы которых указаны в запросе.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей выдача предложений не поддерживается. Идентификаторы групповых моделей игнорируются.  В одном запросе можно получить информацию о предложениях не более чем для 100 моделей.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
 * Список предложений для нескольких моделей
 */
function getModelsOffersRaw<T>(requestParameters: GetModelsOffersRequest, requestConfig: runtime.TypedQueryConfig<T, GetModelsOffersResponse> = {}): QueryConfig<T> {
    if (requestParameters.regionId === null || requestParameters.regionId === undefined) {
        throw new runtime.RequiredError('regionId','Required parameter requestParameters.regionId was null or undefined when calling getModelsOffers.');
    }

    if (requestParameters.getModelsRequest === null || requestParameters.getModelsRequest === undefined) {
        throw new runtime.RequiredError('getModelsRequest','Required parameter requestParameters.getModelsRequest was null or undefined when calling getModelsOffers.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.regionId !== undefined) {
        queryParameters['regionId'] = requestParameters.regionId;
    }


    if (requestParameters.currency !== undefined) {
        queryParameters['currency'] = requestParameters.currency;
    }


    if (requestParameters.orderByPrice !== undefined) {
        queryParameters['orderByPrice'] = requestParameters.orderByPrice;
    }

    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/models/offers`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || GetModelsRequestToJSON(requestParameters.getModelsRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetModelsOffersResponseFromJSON(body), text);
    }

    return config;
}

/**
* Возвращает информацию о первых десяти предложениях, расположенных на карточках моделей, идентификаторы которых указаны в запросе.  Предложения выдаются для определенного региона и располагаются в том же порядке, в котором они показываются в выдаче Маркета на карточке модели.  Для групповых моделей выдача предложений не поддерживается. Идентификаторы групповых моделей игнорируются.  В одном запросе можно получить информацию о предложениях не более чем для 100 моделей.  Для методов `GET models/{modelId}/offers` и `POST models/offers` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
* Список предложений для нескольких моделей
*/
export function getModelsOffers<T>(requestParameters: GetModelsOffersRequest, requestConfig?: runtime.TypedQueryConfig<T, GetModelsOffersResponse>): QueryConfig<T> {
    return getModelsOffersRaw(requestParameters, requestConfig);
}

/**
 * Возвращает информацию о моделях, удовлетворяющих заданным в запросе условиям поиска.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
 * Поиск модели товара
 */
function searchModelsRaw<T>(requestParameters: SearchModelsRequest, requestConfig: runtime.TypedQueryConfig<T, SearchModelsResponse> = {}): QueryConfig<T> {
    if (requestParameters.query === null || requestParameters.query === undefined) {
        throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling searchModels.');
    }

    if (requestParameters.regionId === null || requestParameters.regionId === undefined) {
        throw new runtime.RequiredError('regionId','Required parameter requestParameters.regionId was null or undefined when calling searchModels.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.query !== undefined) {
        queryParameters['query'] = requestParameters.query;
    }


    if (requestParameters.regionId !== undefined) {
        queryParameters['regionId'] = requestParameters.regionId;
    }


    if (requestParameters.currency !== undefined) {
        queryParameters['currency'] = requestParameters.currency;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['pageSize'] = requestParameters.pageSize;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/models`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(SearchModelsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Возвращает информацию о моделях, удовлетворяющих заданным в запросе условиям поиска.  В одном запросе можно получить информацию не более чем о 100 моделях.  Для методов `GET models`, `GET models/{modelId}` и `POST models` действует групповое ресурсное ограничение. Ограничение вводится на суммарное количество моделей, информация о которых запрошена при помощи этих методов.  |**⚙️ Лимит:** [рассчитывается индивидуально](*rule)| |-|  [//]: <> (rule: Суточный лимит зависит от количества предложений на карточках моделей и активных магазинов клиента. Количество предложений считается по данным за последние семь дней, не включая сегодня. Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений. Для клиентов с несколькими магазинами ограничение рассчитывается с учетом количества предложений, являющегося максимальным среди всех магазинов клиента. Для агентств ограничение суммируется по всем субклиентам агентства.) 
* Поиск модели товара
*/
export function searchModels<T>(requestParameters: SearchModelsRequest, requestConfig?: runtime.TypedQueryConfig<T, SearchModelsResponse>): QueryConfig<T> {
    return searchModelsRaw(requestParameters, requestConfig);
}

