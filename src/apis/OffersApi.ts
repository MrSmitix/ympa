// tslint:disable
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    ApiClientDataErrorResponse,
    ApiClientDataErrorResponseFromJSON,
    ApiClientDataErrorResponseToJSON,
    ApiForbiddenErrorResponse,
    ApiForbiddenErrorResponseFromJSON,
    ApiForbiddenErrorResponseToJSON,
    ApiLimitErrorResponse,
    ApiLimitErrorResponseFromJSON,
    ApiLimitErrorResponseToJSON,
    ApiLockedErrorResponse,
    ApiLockedErrorResponseFromJSON,
    ApiLockedErrorResponseToJSON,
    ApiNotFoundErrorResponse,
    ApiNotFoundErrorResponseFromJSON,
    ApiNotFoundErrorResponseToJSON,
    ApiServerErrorResponse,
    ApiServerErrorResponseFromJSON,
    ApiServerErrorResponseToJSON,
    ApiUnauthorizedErrorResponse,
    ApiUnauthorizedErrorResponseFromJSON,
    ApiUnauthorizedErrorResponseToJSON,
    CurrencyType,
    CurrencyTypeFromJSON,
    CurrencyTypeToJSON,
    DeleteCampaignOffersRequest,
    DeleteCampaignOffersRequestFromJSON,
    DeleteCampaignOffersRequestToJSON,
    DeleteCampaignOffersResponse,
    DeleteCampaignOffersResponseFromJSON,
    DeleteCampaignOffersResponseToJSON,
    EmptyApiResponse,
    EmptyApiResponseFromJSON,
    EmptyApiResponseToJSON,
    GetAllOffersResponse,
    GetAllOffersResponseFromJSON,
    GetAllOffersResponseToJSON,
    GetCampaignOffersRequest,
    GetCampaignOffersRequestFromJSON,
    GetCampaignOffersRequestToJSON,
    GetCampaignOffersResponse,
    GetCampaignOffersResponseFromJSON,
    GetCampaignOffersResponseToJSON,
    GetOfferRecommendationsRequest,
    GetOfferRecommendationsRequestFromJSON,
    GetOfferRecommendationsRequestToJSON,
    GetOfferRecommendationsResponse,
    GetOfferRecommendationsResponseFromJSON,
    GetOfferRecommendationsResponseToJSON,
    GetOffersResponse,
    GetOffersResponseFromJSON,
    GetOffersResponseToJSON,
    UpdateCampaignOffersRequest,
    UpdateCampaignOffersRequestFromJSON,
    UpdateCampaignOffersRequestToJSON,
} from '../models';

export interface DeleteCampaignOffersRequest {
    campaignId: number;
    deleteCampaignOffersRequest: DeleteCampaignOffersRequest;
}

export interface GetAllOffersRequest {
    campaignId: number;
    feedId?: number;
    chunk?: number;
}

export interface GetCampaignOffersRequest {
    campaignId: number;
    getCampaignOffersRequest: GetCampaignOffersRequest;
    pageToken?: string;
    limit?: number;
}

export interface GetOfferRecommendationsRequest {
    businessId: number;
    getOfferRecommendationsRequest: GetOfferRecommendationsRequest;
    pageToken?: string;
    limit?: number;
}

export interface GetOffersRequest {
    campaignId: number;
    query?: string;
    feedId?: number;
    shopCategoryId?: string;
    currency?: CurrencyType;
    matched?: boolean;
    page?: number;
    pageSize?: number;
}

export interface UpdateCampaignOffersRequest {
    campaignId: number;
    updateCampaignOffersRequest: UpdateCampaignOffersRequest;
}


/**
 * Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
 * Удаление товаров из ассортимента магазина
 */
function deleteCampaignOffersRaw<T>(requestParameters: DeleteCampaignOffersRequest, requestConfig: runtime.TypedQueryConfig<T, DeleteCampaignOffersResponse> = {}): QueryConfig<T> {
    if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
        throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling deleteCampaignOffers.');
    }

    if (requestParameters.deleteCampaignOffersRequest === null || requestParameters.deleteCampaignOffersRequest === undefined) {
        throw new runtime.RequiredError('deleteCampaignOffersRequest','Required parameter requestParameters.deleteCampaignOffersRequest was null or undefined when calling deleteCampaignOffers.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/campaigns/{campaignId}/offers/delete`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DeleteCampaignOffersRequestToJSON(requestParameters.deleteCampaignOffersRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DeleteCampaignOffersResponseFromJSON(body), text);
    }

    return config;
}

/**
* Удаляет заданные товары из заданного магазина.  {% note warning \"Запрос удаляет товары именно из конкретного магазина\" %}  На продажи в других магазинах и на наличие товара в общем каталоге он не влияет.  {% endnote %}  Товар не получится удалить, если он хранится на складах Маркета.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
* Удаление товаров из ассортимента магазина
*/
export function deleteCampaignOffers<T>(requestParameters: DeleteCampaignOffersRequest, requestConfig?: runtime.TypedQueryConfig<T, DeleteCampaignOffersResponse>): QueryConfig<T> {
    return deleteCampaignOffersRaw(requestParameters, requestConfig);
}

/**
 * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
 * Все предложения магазина
 */
function getAllOffersRaw<T>(requestParameters: GetAllOffersRequest, requestConfig: runtime.TypedQueryConfig<T, GetAllOffersResponse> = {}): QueryConfig<T> {
    if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
        throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling getAllOffers.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.feedId !== undefined) {
        queryParameters['feedId'] = requestParameters.feedId;
    }


    if (requestParameters.chunk !== undefined) {
        queryParameters['chunk'] = requestParameters.chunk;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/campaigns/{campaignId}/offers/all`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetAllOffersResponseFromJSON(body), text);
    }

    return config;
}

/**
* {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет максимально быстро получить информацию обо всех предложениях магазина, размещенных на Маркете. Возвращает результат в виде сегментов нефиксированного размера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Яндекс Маркета, с которой соотнесено предложение, а также аукционные ставки на него.  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лимит товаров — среднее количество таваров в каталоге за неделю * 25) 
* Все предложения магазина
*/
export function getAllOffers<T>(requestParameters: GetAllOffersRequest, requestConfig?: runtime.TypedQueryConfig<T, GetAllOffersResponse>): QueryConfig<T> {
    return getAllOffersRaw(requestParameters, requestConfig);
}

/**
 * Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
 * Информация о товарах, которые размещены в заданном магазине
 */
function getCampaignOffersRaw<T>(requestParameters: GetCampaignOffersRequest, requestConfig: runtime.TypedQueryConfig<T, GetCampaignOffersResponse> = {}): QueryConfig<T> {
    if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
        throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling getCampaignOffers.');
    }

    if (requestParameters.getCampaignOffersRequest === null || requestParameters.getCampaignOffersRequest === undefined) {
        throw new runtime.RequiredError('getCampaignOffersRequest','Required parameter requestParameters.getCampaignOffersRequest was null or undefined when calling getCampaignOffers.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.pageToken !== undefined) {
        queryParameters['page_token'] = requestParameters.pageToken;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/campaigns/{campaignId}/offers`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || GetCampaignOffersRequestToJSON(requestParameters.getCampaignOffersRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetCampaignOffersResponseFromJSON(body), text);
    }

    return config;
}

/**
* Возвращает список товаров, которые размещены в заданном магазине. Для каждого товара указываются параметры размещения.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
* Информация о товарах, которые размещены в заданном магазине
*/
export function getCampaignOffers<T>(requestParameters: GetCampaignOffersRequest, requestConfig?: runtime.TypedQueryConfig<T, GetCampaignOffersResponse>): QueryConfig<T> {
    return getCampaignOffersRaw(requestParameters, requestConfig);
}

/**
 * Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
 * Рекомендации Маркета, касающиеся цен
 */
function getOfferRecommendationsRaw<T>(requestParameters: GetOfferRecommendationsRequest, requestConfig: runtime.TypedQueryConfig<T, GetOfferRecommendationsResponse> = {}): QueryConfig<T> {
    if (requestParameters.businessId === null || requestParameters.businessId === undefined) {
        throw new runtime.RequiredError('businessId','Required parameter requestParameters.businessId was null or undefined when calling getOfferRecommendations.');
    }

    if (requestParameters.getOfferRecommendationsRequest === null || requestParameters.getOfferRecommendationsRequest === undefined) {
        throw new runtime.RequiredError('getOfferRecommendationsRequest','Required parameter requestParameters.getOfferRecommendationsRequest was null or undefined when calling getOfferRecommendations.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.pageToken !== undefined) {
        queryParameters['page_token'] = requestParameters.pageToken;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/businesses/{businessId}/offers/recommendations`.replace(`{${"businessId"}}`, encodeURIComponent(String(requestParameters.businessId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || GetOfferRecommendationsRequestToJSON(requestParameters.getOfferRecommendationsRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetOfferRecommendationsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Метод возвращает рекомендации нескольких типов.  **1. Порог для привлекательной цены. Он нужен для участия в софинансировании скидок.**  Показывает, какие **цены для участия** нужно установить, чтобы получить максимальные шансы на срабатывание скидок, софинансируемых Маркетом. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  **2. Оценка привлекательности цен на витрине.**  Привлекательность влияет на вероятность срабатывания скидок за счет Маркета. [Как это устроено](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#validation)  В запросе можно использовать фильтры.  Результаты возвращаются постранично.  |**⚙️ Лимит:** 100 запросов в минуту| |-| 
* Рекомендации Маркета, касающиеся цен
*/
export function getOfferRecommendations<T>(requestParameters: GetOfferRecommendationsRequest, requestConfig?: runtime.TypedQueryConfig<T, GetOfferRecommendationsResponse>): QueryConfig<T> {
    return getOfferRecommendationsRaw(requestParameters, requestConfig);
}

/**
 * {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
 * Предложения магазина
 */
function getOffersRaw<T>(requestParameters: GetOffersRequest, requestConfig: runtime.TypedQueryConfig<T, GetOffersResponse> = {}): QueryConfig<T> {
    if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
        throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling getOffers.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.query !== undefined) {
        queryParameters['query'] = requestParameters.query;
    }


    if (requestParameters.feedId !== undefined) {
        queryParameters['feedId'] = requestParameters.feedId;
    }


    if (requestParameters.shopCategoryId !== undefined) {
        queryParameters['shopCategoryId'] = requestParameters.shopCategoryId;
    }


    if (requestParameters.currency !== undefined) {
        queryParameters['currency'] = requestParameters.currency;
    }


    if (requestParameters.matched !== undefined) {
        queryParameters['matched'] = requestParameters.matched;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['pageSize'] = requestParameters.pageSize;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/campaigns/{campaignId}/offers`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetOffersResponseFromJSON(body), text);
    }

    return config;
}

/**
* {% note warning \"\" %}  Этот метод устарел. Не используйте его.  {% endnote %}  Позволяет фильтровать информацию о предложениях магазина, размещенных на Маркете, и искать предложения по заданному поисковому запросу.  Поиск предложений, размещенных на Маркете, работает по поисковому запросу аналогично поиску Маркета. Результаты возвращаются с использованием пейджера.  В ответе на запрос для каждого найденного предложения указывается URL и наименование этого предложения, его цена и валюта, в которой она указана, карточка модели Маркета, с которой соотнесено предложение, и аукционные ставки на него.  {% note info %}  Из-за особенностей поиска Маркета иногда на последних страницах пейджера фактическое количество результатов оказывается меньше количества, указанного ранее на предыдущих страницах.  В связи с этим настоятельно рекомендуется анализировать содержимое параметра pager для каждой полученной страницы.  {% endnote %}  {% note info %}  Количество предложений считается по данным за последние семь дней (не включая сегодня).  Для новых магазинов, еще не разместивших предложения, ограничение равно 0 и пересчитывается на следующий день после размещения первых предложений.  {% endnote %}  |**⚙️ Лимит:** рассчитывается по [формуле](*rule)| |-|  [//]: <> (rule: суточный лисит товаров — среднее количество таваров в каталоге за неделю * 25) 
* Предложения магазина
*/
export function getOffers<T>(requestParameters: GetOffersRequest, requestConfig?: runtime.TypedQueryConfig<T, GetOffersResponse>): QueryConfig<T> {
    return getOffersRaw(requestParameters, requestConfig);
}

/**
 * Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
 * Изменение условий продажи товаров в магазине
 */
function updateCampaignOffersRaw<T>(requestParameters: UpdateCampaignOffersRequest, requestConfig: runtime.TypedQueryConfig<T, EmptyApiResponse> = {}): QueryConfig<T> {
    if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
        throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling updateCampaignOffers.');
    }

    if (requestParameters.updateCampaignOffersRequest === null || requestParameters.updateCampaignOffersRequest === undefined) {
        throw new runtime.RequiredError('updateCampaignOffersRequest','Required parameter requestParameters.updateCampaignOffersRequest was null or undefined when calling updateCampaignOffers.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/campaigns/{campaignId}/offers/update`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || UpdateCampaignOffersRequestToJSON(requestParameters.updateCampaignOffersRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(EmptyApiResponseFromJSON(body), text);
    }

    return config;
}

/**
* Изменяет параметры продажи товаров в конкретном магазине: доступность товара, условия доставки и самовывоза, применяемую ставку НДС.  |**⚙️ Лимит:** 5000 товаров в минуту| |-| 
* Изменение условий продажи товаров в магазине
*/
export function updateCampaignOffers<T>(requestParameters: UpdateCampaignOffersRequest, requestConfig?: runtime.TypedQueryConfig<T, EmptyApiResponse>): QueryConfig<T> {
    return updateCampaignOffersRaw(requestParameters, requestConfig);
}

