# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct OrdersApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `OrdersApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ OrdersApi }) = "https://api.partner.market.yandex.ru"

const _returntypes_accept_order_cancellation_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => EmptyApiResponse,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_accept_order_cancellation(_api::OrdersApi, campaign_id::Int64, order_id::Int64, accept_order_cancellation_request::AcceptOrderCancellationRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_accept_order_cancellation_OrdersApi, "/campaigns/{campaignId}/orders/{orderId}/cancellation/accept", ["OAuth", ], accept_order_cancellation_request)
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.path, "orderId", order_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Отмена заказа покупателем

Подтверждает или отклоняет запрос покупателя на отмену заказа, который передан службе доставки.  Покупатель может отменить заказ в течение его обработки или доставки. Если заказ еще обрабатывается (имеет статус PROCESSING), вам не нужно подтверждать отмену заказа — он будет отменен автоматически.  Если заказ уже передан службе доставки (принимает статус `DELIVERY` или `PICKUP`) и пользователь отменил его, вы можете предупредить службу об отмене в течение 48 часов. Если служба доставки узнала об отмене до передачи заказа покупателю, подтвердите отмену с помощью запроса [PUT campaigns/{campaignId}/orders/{orderId}/cancellation/accept](../../reference/orders/acceptOrderCancellation.md). Если заказ уже доставлен, отклоните отмену с помощью этого же запроса. Тогда у покупателя останется заказ, и деньги за него возвращаться не будут.  Чтобы узнать, какие заказы были отменены в статусе `DELIVERY` или `PICKUP`, отправьте запрос [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md). В его URL добавьте входной параметр `onlyWaitingForCancellationApprove=true`. Вы также можете узнать об отмененных заказах в кабинете или через почту — на нее придет уведомление об отмене.  Если в течение 48 часов вы не подтвердите или отклоните отмену, заказ будет отменен автоматически.  |**⚙️ Лимит:** 500 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- order_id::Int64 (required)
- accept_order_cancellation_request::AcceptOrderCancellationRequest (required)

Return: EmptyApiResponse, OpenAPI.Clients.ApiResponse
"""
function accept_order_cancellation(_api::OrdersApi, campaign_id::Int64, order_id::Int64, accept_order_cancellation_request::AcceptOrderCancellationRequest; _mediaType=nothing)
    _ctx = _oacinternal_accept_order_cancellation(_api, campaign_id, order_id, accept_order_cancellation_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function accept_order_cancellation(_api::OrdersApi, response_stream::Channel, campaign_id::Int64, order_id::Int64, accept_order_cancellation_request::AcceptOrderCancellationRequest; _mediaType=nothing)
    _ctx = _oacinternal_accept_order_cancellation(_api, campaign_id, order_id, accept_order_cancellation_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_order_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => GetOrderResponse,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_get_order(_api::OrdersApi, campaign_id::Int64, order_id::Int64; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_order_OrdersApi, "/campaigns/{campaignId}/orders/{orderId}", ["OAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.path, "orderId", order_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Информация об одном заказе

Возвращает информацию о заказе.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- order_id::Int64 (required)

Return: GetOrderResponse, OpenAPI.Clients.ApiResponse
"""
function get_order(_api::OrdersApi, campaign_id::Int64, order_id::Int64; _mediaType=nothing)
    _ctx = _oacinternal_get_order(_api, campaign_id, order_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_order(_api::OrdersApi, response_stream::Channel, campaign_id::Int64, order_id::Int64; _mediaType=nothing)
    _ctx = _oacinternal_get_order(_api, campaign_id, order_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_orders_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => GetOrdersResponse,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_get_orders(_api::OrdersApi, campaign_id::Int64; order_ids=nothing, status=nothing, substatus=nothing, from_date=nothing, to_date=nothing, supplier_shipment_date_from=nothing, supplier_shipment_date_to=nothing, updated_at_from=nothing, updated_at_to=nothing, dispatch_type=nothing, fake=nothing, has_cis=nothing, only_waiting_for_cancellation_approve=nothing, only_estimated_delivery=nothing, buyer_type=nothing, page=nothing, page_size=nothing, page_token=nothing, limit=nothing, _mediaType=nothing)


    OpenAPI.validate_param("page", "get_orders", :maximum, page, 10000, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_orders_OrdersApi, "/campaigns/{campaignId}/orders", ["OAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "orderIds", order_ids; style="", is_explode=false)  # type Vector{Int64}
    OpenAPI.Clients.set_param(_ctx.query, "status", status; style="", is_explode=false)  # type Vector{OrderStatusType}
    OpenAPI.Clients.set_param(_ctx.query, "substatus", substatus; style="", is_explode=false)  # type Vector{OrderSubstatusType}
    OpenAPI.Clients.set_param(_ctx.query, "fromDate", from_date; style="", is_explode=false)  # type Date
    OpenAPI.Clients.set_param(_ctx.query, "toDate", to_date; style="", is_explode=false)  # type Date
    OpenAPI.Clients.set_param(_ctx.query, "supplierShipmentDateFrom", supplier_shipment_date_from; style="", is_explode=false)  # type Date
    OpenAPI.Clients.set_param(_ctx.query, "supplierShipmentDateTo", supplier_shipment_date_to; style="", is_explode=false)  # type Date
    OpenAPI.Clients.set_param(_ctx.query, "updatedAtFrom", updated_at_from; style="", is_explode=false)  # type ZonedDateTime
    OpenAPI.Clients.set_param(_ctx.query, "updatedAtTo", updated_at_to; style="", is_explode=false)  # type ZonedDateTime
    OpenAPI.Clients.set_param(_ctx.query, "dispatchType", dispatch_type; style="", is_explode=false)  # type OrderDeliveryDispatchType
    OpenAPI.Clients.set_param(_ctx.query, "fake", fake; style="", is_explode=false)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "hasCis", has_cis; style="", is_explode=false)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "onlyWaitingForCancellationApprove", only_waiting_for_cancellation_approve; style="", is_explode=false)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "onlyEstimatedDelivery", only_estimated_delivery; style="", is_explode=false)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "buyerType", buyer_type; style="", is_explode=false)  # type OrderBuyerType
    OpenAPI.Clients.set_param(_ctx.query, "page", page; style="", is_explode=false)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size; style="", is_explode=false)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "page_token", page_token; style="", is_explode=false)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit; style="", is_explode=false)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Информация о нескольких заказах

Возвращает информацию о заказах. Запрос можно использовать, чтобы узнать, нет ли новых заказов.  Доступна фильтрация по нескольким характеристикам заказов:  * дате оформления;  * статусу;  * идентификаторам заказов;  * этапу обработки или причине отмены;  * типу (настоящий или тестовый);  * дате отгрузки в службу доставки;  * дате и времени обновления заказа.  Информация о заказах, доставленных или отмененных больше 30 дней назад, не возвращается. Ее можно получить с помощью запроса информации об отдельном заказе [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) (если у вас есть идентификатор заказа) или запроса отчета по заказам [POST campaigns/{campaignId}/stats/orders](../../reference/stats/getOrdersStats.md).  Максимальный диапазон дат за один запрос к ресурсу — 30 дней. Максимальное количество заказов в выходных данных запроса — 50.  Результаты возвращаются постранично. Для навигации по страницам используйте параметры `page_token` и `limit`.  Получить более подробную информацию о покупателе и его номере телефона можно с помощью запроса [GET campaigns/{campaignId}/orders/{orderId}/buyer](../../reference/orders/getOrderBuyerInfo.md).  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- order_ids::Vector{Int64}
- status::Vector{OrderStatusType}
- substatus::Vector{OrderSubstatusType}
- from_date::Date
- to_date::Date
- supplier_shipment_date_from::Date
- supplier_shipment_date_to::Date
- updated_at_from::ZonedDateTime
- updated_at_to::ZonedDateTime
- dispatch_type::OrderDeliveryDispatchType
- fake::Bool
- has_cis::Bool
- only_waiting_for_cancellation_approve::Bool
- only_estimated_delivery::Bool
- buyer_type::OrderBuyerType
- page::Int64
- page_size::Int64
- page_token::String
- limit::Int64

Return: GetOrdersResponse, OpenAPI.Clients.ApiResponse
"""
function get_orders(_api::OrdersApi, campaign_id::Int64; order_ids=nothing, status=nothing, substatus=nothing, from_date=nothing, to_date=nothing, supplier_shipment_date_from=nothing, supplier_shipment_date_to=nothing, updated_at_from=nothing, updated_at_to=nothing, dispatch_type=nothing, fake=nothing, has_cis=nothing, only_waiting_for_cancellation_approve=nothing, only_estimated_delivery=nothing, buyer_type=nothing, page=nothing, page_size=nothing, page_token=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_orders(_api, campaign_id; order_ids=order_ids, status=status, substatus=substatus, from_date=from_date, to_date=to_date, supplier_shipment_date_from=supplier_shipment_date_from, supplier_shipment_date_to=supplier_shipment_date_to, updated_at_from=updated_at_from, updated_at_to=updated_at_to, dispatch_type=dispatch_type, fake=fake, has_cis=has_cis, only_waiting_for_cancellation_approve=only_waiting_for_cancellation_approve, only_estimated_delivery=only_estimated_delivery, buyer_type=buyer_type, page=page, page_size=page_size, page_token=page_token, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_orders(_api::OrdersApi, response_stream::Channel, campaign_id::Int64; order_ids=nothing, status=nothing, substatus=nothing, from_date=nothing, to_date=nothing, supplier_shipment_date_from=nothing, supplier_shipment_date_to=nothing, updated_at_from=nothing, updated_at_to=nothing, dispatch_type=nothing, fake=nothing, has_cis=nothing, only_waiting_for_cancellation_approve=nothing, only_estimated_delivery=nothing, buyer_type=nothing, page=nothing, page_size=nothing, page_token=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_orders(_api, campaign_id; order_ids=order_ids, status=status, substatus=substatus, from_date=from_date, to_date=to_date, supplier_shipment_date_from=supplier_shipment_date_from, supplier_shipment_date_to=supplier_shipment_date_to, updated_at_from=updated_at_from, updated_at_to=updated_at_to, dispatch_type=dispatch_type, fake=fake, has_cis=has_cis, only_waiting_for_cancellation_approve=only_waiting_for_cancellation_approve, only_estimated_delivery=only_estimated_delivery, buyer_type=buyer_type, page=page, page_size=page_size, page_token=page_token, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_provide_order_digital_codes_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => EmptyApiResponse,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_provide_order_digital_codes(_api::OrdersApi, campaign_id::Int64, order_id::Int64, provide_order_digital_codes_request::ProvideOrderDigitalCodesRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_provide_order_digital_codes_OrdersApi, "/campaigns/{campaignId}/orders/{orderId}/deliverDigitalGoods", ["OAuth", ], provide_order_digital_codes_request)
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.path, "orderId", order_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Передача ключей цифровых товаров

Передает ключи цифровых товаров, которые покупатель заказал и оплатил. После выполнения запроса Маркет отправит ему письмо с ключами и инструкциями по активации, а также переведет заказ в финальный статус `DELIVERED`.  Ключ нужно передать в течение 30 минут после перехода заказа в статус `PROCESSING`.  Если в один заказ входят несколько ключей, передавайте их все в одном запросе.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- order_id::Int64 (required)
- provide_order_digital_codes_request::ProvideOrderDigitalCodesRequest (required)

Return: EmptyApiResponse, OpenAPI.Clients.ApiResponse
"""
function provide_order_digital_codes(_api::OrdersApi, campaign_id::Int64, order_id::Int64, provide_order_digital_codes_request::ProvideOrderDigitalCodesRequest; _mediaType=nothing)
    _ctx = _oacinternal_provide_order_digital_codes(_api, campaign_id, order_id, provide_order_digital_codes_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function provide_order_digital_codes(_api::OrdersApi, response_stream::Channel, campaign_id::Int64, order_id::Int64, provide_order_digital_codes_request::ProvideOrderDigitalCodesRequest; _mediaType=nothing)
    _ctx = _oacinternal_provide_order_digital_codes(_api, campaign_id, order_id, provide_order_digital_codes_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_provide_order_item_identifiers_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ProvideOrderItemIdentifiersResponse,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_provide_order_item_identifiers(_api::OrdersApi, campaign_id::Int64, order_id::Int64, provide_order_item_identifiers_request::ProvideOrderItemIdentifiersRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_provide_order_item_identifiers_OrdersApi, "/campaigns/{campaignId}/orders/{orderId}/identifiers", ["OAuth", ], provide_order_item_identifiers_request)
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.path, "orderId", order_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Передача кодов маркировки единиц товара

{% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Передает Маркету коды маркировки для единиц товара в указанном заказе.  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  {% note warning %}  Прежде чем работать с этим методом, обязательно прочтите [статью о работе с маркируемыми товарами](https://yandex.ru/support/marketplace/orders/cz.html).  {% endnote %}  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- order_id::Int64 (required)
- provide_order_item_identifiers_request::ProvideOrderItemIdentifiersRequest (required)

Return: ProvideOrderItemIdentifiersResponse, OpenAPI.Clients.ApiResponse
"""
function provide_order_item_identifiers(_api::OrdersApi, campaign_id::Int64, order_id::Int64, provide_order_item_identifiers_request::ProvideOrderItemIdentifiersRequest; _mediaType=nothing)
    _ctx = _oacinternal_provide_order_item_identifiers(_api, campaign_id, order_id, provide_order_item_identifiers_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function provide_order_item_identifiers(_api::OrdersApi, response_stream::Channel, campaign_id::Int64, order_id::Int64, provide_order_item_identifiers_request::ProvideOrderItemIdentifiersRequest; _mediaType=nothing)
    _ctx = _oacinternal_provide_order_item_identifiers(_api, campaign_id, order_id, provide_order_item_identifiers_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_set_order_box_layout_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SetOrderBoxLayoutResponse,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_set_order_box_layout(_api::OrdersApi, campaign_id::Int64, order_id::Int64, set_order_box_layout_request::SetOrderBoxLayoutRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_set_order_box_layout_OrdersApi, "/campaigns/{campaignId}/orders/{orderId}/boxes", ["OAuth", ], set_order_box_layout_request)
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.path, "orderId", order_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Подготовка заказа

{% note tip \"Подходит и для DBS\" %}  Запрос предназначен для работы с FBS-заказами, но вы можете использовать его для обработки DBS-заказов, если это удобно.  {% endnote %}  Позволяет выполнить три операции:  * передать Маркету информацию о распределении товаров по коробкам; * передать Маркету коды маркировки для товаров; * удалить товар из заказа, если его не оказалось на складе.  Если нужно что-то поправить в переданных данных, просто повторите запрос — это можно делать сколько угодно раз до перевода заказа в статус **Готов к отгрузке**. ⚠️ Если вы меняете раскладку уже после печати и расклейки ярлыков, не забудье перепечатать их и наклеить заново.  ## Как передать информацию о распределении товаров  В этом запросе вам нужно передать Маркету список коробок и указать, какие именно товары лежат в каждой из них. Коробки могут быть двух типов:  * **Содержащие товары целиком.** Такая коробка может содержать сколько угодно единиц любых товаров.  * **Содержащие часть товара.** Такие коробки содержат по одной части одного товара. Например, одна содержит внешний блок кондиционера, а другая — внутренний блок.  ⚠️ Одна коробка не может содержать и товары целиком, и части товаров.  ## Как передавать коды маркировки  Если в заказе есть товары, подлежащие маркировке, в запросе нужно передать соответствующие уникальные коды. [Что такое маркировка?](https://yandex.ru/support/marketplace/orders/cz.html)  Принимаются коды следующих типов:  * Коды «Честного знака». * УИН для ювелирных изделий. * РНПТ и ГТД для импортных прослеживаемых товаров.  Для каждой позиции в заказе, требующей маркировки, нужно передать список кодов — по одному для каждой единицы товара. Например, если в заказе две пары тапочек и одна пара туфель, получится список из двух кодов для первой позиции и список из одного кода для второй.  Если товар едет в нескольких коробках, код маркировки нужно передать для каждой из них.  ## Как удалить товар из заказа  Чтобы удалить товар из заказа:  1. Добавьте в запрос `allowRemove: true`. 2. Передайте распределение по коробкам без товара, который нужно удалить.  {% note warning \"Удаление нельзя отменить\" %}  Эта операция необратима: покупатель сразу получит уведомление, а состав заказа изменится.  {% endnote %}  Чтобы удалить позицию целиком, не передавайте соответствующий `OrderBoxLayoutItemDTO`. Чтобы уменьшить количество товара, передайте уменьшенное значение в поле `fullCount`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если вы не можете отгрузить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  ## Примеры  {% cut \"Товар умещается в коробку\" %}  Вот как будет выглядеть запрос, если в одной коробке едут:    * три единицы одного товара, требующего маркировки;   * одна единица другого товара, не требущего маркировки.    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"fullCount\": 3,                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           },                           {                               \"cis\": \"010304109478gftJ14545762!\\u001dhGt264\"                           },                           {                               \"cis\": \"010304109478fRs28323ks23!\\u001dhet201\"                           }                       ]                   },                   {                       \"id\": 654321,                       \"fullCount\": 1                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Товар едет в разных коробках\" %}  Вот как будет выглядеть запрос, если товар едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  {% cut \"Одинаковые товары, где каждый едет в нескольких коробках\" %}  Вот как будет выглядеть запрос, если каждый из двух одинаковых товаров едет в двух коробках:    ```json   {       \"boxes\": [           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 1,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           },           {               \"items\": [                   {                       \"id\": 123456,                       \"partialCount\": {                           \"current\": 2,                           \"total\": 2                       },                       \"instances\": [                           {                               \"cis\": \"01030410947874432155Qbag!\\u001d93Zjqw\"                           }                       ]                   }               ]           }       ]   }   ```  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- order_id::Int64 (required)
- set_order_box_layout_request::SetOrderBoxLayoutRequest (required)

Return: SetOrderBoxLayoutResponse, OpenAPI.Clients.ApiResponse
"""
function set_order_box_layout(_api::OrdersApi, campaign_id::Int64, order_id::Int64, set_order_box_layout_request::SetOrderBoxLayoutRequest; _mediaType=nothing)
    _ctx = _oacinternal_set_order_box_layout(_api, campaign_id, order_id, set_order_box_layout_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function set_order_box_layout(_api::OrdersApi, response_stream::Channel, campaign_id::Int64, order_id::Int64, set_order_box_layout_request::SetOrderBoxLayoutRequest; _mediaType=nothing)
    _ctx = _oacinternal_set_order_box_layout(_api, campaign_id, order_id, set_order_box_layout_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_set_order_shipment_boxes_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SetOrderShipmentBoxesResponse,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_set_order_shipment_boxes(_api::OrdersApi, campaign_id::Int64, order_id::Int64, shipment_id::Int64, set_order_shipment_boxes_request::SetOrderShipmentBoxesRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_set_order_shipment_boxes_OrdersApi, "/campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes", ["OAuth", ], set_order_shipment_boxes_request)
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.path, "orderId", order_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.path, "shipmentId", shipment_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Передача количества грузовых мест в заказе

{% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Отгружаемый Маркету заказ может не влезть в одну коробку или упаковку — в этом случае получается, что он занимает несколько грузовых мест.  Количество грузовых мест нужно обязательно передавать Маркету, если оно не равно 1. Это делается перед переводом его в статус **Готов к отгрузке**. Подробно о том, что в какой момент нужно передавать, рассказано в [пошаговой инструкции](../../step-by-step/fbs.md).  Метод устроен немного нестандартно: количество задается длиной массива пустых объектов.  Раньше метод требовал передачи большего количества данных. Запросы, оформленные по старому образцу, работают, но лучше делать по-новому.  {% cut \"Как было раньше\" %}  Структура тела PUT-запроса:  ``` {   \"boxes\":   [     {       \"fulfilmentId\": \"{string}\",       \"weight\": {int64},       \"width\": {int64},       \"height\": {int64},       \"depth\": {int64},       \"items\":       [         {           \"id\": {int64},           \"count\": {int32}         },         ...       ]     },     ...   ] } ``` | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `boxes`       |           | Список грузовых мест.       |  **Параметры, вложенные в `boxes`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `fulfilmentId`       |  String   | Идентификатор грузового места в информационной системе магазина. Сформируйте идентификатор по шаблону: `номер заказа на Маркете-номер грузового места`. Например, `7206821‑1, 7206821‑2` и т. д. | | `weight`       | Int64        | Масса брутто грузового места (суммарная масса упаковки и содержимого) в граммах. | | `width`       | Int64   | Ширина грузового места в сантиметрах.       | | `height`       | Int64   | Высота грузового места в сантиметрах.       | | `depth`       | Int64   | Глубина грузового места в сантиметрах.        | | `items`       | Int64   | Список товаров в грузовом месте.       |  **Параметры, вложенные в `items`** | **Параметр**  | **Тип**  | **Значение**  | | ----------- | ----------- | ----------- | | `id`       | Int64     | Идентификатор товара в рамках заказа.   | | `count`    | Int32     | Количество единиц товара в грузовом месте.       |  {% endcut %}  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- order_id::Int64 (required)
- shipment_id::Int64 (required)
- set_order_shipment_boxes_request::SetOrderShipmentBoxesRequest (required)

Return: SetOrderShipmentBoxesResponse, OpenAPI.Clients.ApiResponse
"""
function set_order_shipment_boxes(_api::OrdersApi, campaign_id::Int64, order_id::Int64, shipment_id::Int64, set_order_shipment_boxes_request::SetOrderShipmentBoxesRequest; _mediaType=nothing)
    _ctx = _oacinternal_set_order_shipment_boxes(_api, campaign_id, order_id, shipment_id, set_order_shipment_boxes_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function set_order_shipment_boxes(_api::OrdersApi, response_stream::Channel, campaign_id::Int64, order_id::Int64, shipment_id::Int64, set_order_shipment_boxes_request::SetOrderShipmentBoxesRequest; _mediaType=nothing)
    _ctx = _oacinternal_set_order_shipment_boxes(_api, campaign_id, order_id, shipment_id, set_order_shipment_boxes_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_order_items_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_update_order_items(_api::OrdersApi, campaign_id::Int64, order_id::Int64, update_order_item_request::UpdateOrderItemRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_update_order_items_OrdersApi, "/campaigns/{campaignId}/orders/{orderId}/items", ["OAuth", ], update_order_item_request)
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.path, "orderId", order_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Удаление товара из заказа или уменьшение числа единиц

{% note warning \"Этот запрос только для DBS\" %}  Если вы работаете по модели FBS, пользуйтесь [PUT campaigns/{campaignId}/orders/{orderId}/boxes](../../reference/orders/setOrderBoxLayout.md).  {% endnote %}  Изменяет состав заказа, если позволяет выбранная служба доставки, в случаях:  * покупатель уменьшил количество товара; * магазин не может поставить все товары в заказе.  Для этого заказ должен находится в статусе `\"status\": \"PROCESSING\"` этапа обработки `\"substatus\": \"STARTED\"`. После передачи статуса `\"substatus\": \"READY_TO_SHIP\"` изменить состав невозможно.  Если одинаковых товаров несколько, для уменьшения количества передайте обновленное значение в атрибуте `count` параметра `item`.  Чтобы полностью удалить товар из заказа:  * передайте значение `0`; или * не передавайте параметр `item`.  Нельзя удалить или уменьшить количество товара, если он:  * добавлен по акции; * составляет 99% стоимости заказа; * единственный товар в заказе.  Если необходимо удалить такой товар, отмените заказ. Для этого отправьте запрос методом [PUT campaigns/{campaignId}/orders/{orderId}/status](../../reference/orders/updateOrderStatus.md) и передайте статус заказа `CANCELLED` с причиной отмены `SHOP_FAILED`.  {% note info \"Увеличить заказ нельзя\" %}  С помощью запроса нельзя увеличить количество одинаковых товаров, добавить новые товары в заказ или заменить один товар другим.  {% endnote %}  **Возврат денег покупателю**  Если покупатель оплатил товар при оформлении, Маркет вернет ему деньги за удаленные из заказа товары в течение двух дней:  * при оплате банковской картой — с момента, когда магазин переведет заказ в статус `SHIPPED`;  * при оплате через Apple Pay или Google Pay — с момента, когда магазин удалит товар из заказа.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- order_id::Int64 (required)
- update_order_item_request::UpdateOrderItemRequest (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function update_order_items(_api::OrdersApi, campaign_id::Int64, order_id::Int64, update_order_item_request::UpdateOrderItemRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_order_items(_api, campaign_id, order_id, update_order_item_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_order_items(_api::OrdersApi, response_stream::Channel, campaign_id::Int64, order_id::Int64, update_order_item_request::UpdateOrderItemRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_order_items(_api, campaign_id, order_id, update_order_item_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_order_status_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => UpdateOrderStatusResponse,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_update_order_status(_api::OrdersApi, campaign_id::Int64, order_id::Int64, update_order_status_request::UpdateOrderStatusRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_update_order_status_OrdersApi, "/campaigns/{campaignId}/orders/{orderId}/status", ["OAuth", ], update_order_status_request)
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_param(_ctx.path, "orderId", order_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Изменение статуса одного заказа

Изменяет статус заказа. Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- order_id::Int64 (required)
- update_order_status_request::UpdateOrderStatusRequest (required)

Return: UpdateOrderStatusResponse, OpenAPI.Clients.ApiResponse
"""
function update_order_status(_api::OrdersApi, campaign_id::Int64, order_id::Int64, update_order_status_request::UpdateOrderStatusRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_order_status(_api, campaign_id, order_id, update_order_status_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_order_status(_api::OrdersApi, response_stream::Channel, campaign_id::Int64, order_id::Int64, update_order_status_request::UpdateOrderStatusRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_order_status(_api, campaign_id, order_id, update_order_status_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_order_statuses_OrdersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => UpdateOrderStatusesResponse,
    Regex("^" * replace("400", "x"=>".") * "\$") => ApiClientDataErrorResponse,
    Regex("^" * replace("401", "x"=>".") * "\$") => ApiUnauthorizedErrorResponse,
    Regex("^" * replace("403", "x"=>".") * "\$") => ApiForbiddenErrorResponse,
    Regex("^" * replace("404", "x"=>".") * "\$") => ApiNotFoundErrorResponse,
    Regex("^" * replace("420", "x"=>".") * "\$") => ApiLimitErrorResponse,
    Regex("^" * replace("500", "x"=>".") * "\$") => ApiServerErrorResponse,
)

function _oacinternal_update_order_statuses(_api::OrdersApi, campaign_id::Int64, update_order_statuses_request::UpdateOrderStatusesRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_update_order_statuses_OrdersApi, "/campaigns/{campaignId}/orders/status-update", ["OAuth", ], update_order_statuses_request)
    OpenAPI.Clients.set_param(_ctx.path, "campaignId", campaign_id)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Изменение статусов нескольких заказов

Изменяет статусы нескольких заказов.  Возможные изменения статусов:  * Если магазин подтвердил и подготовил заказ к отправке, то заказ из статуса `\"status\": \"PROCESSING\"`и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"PROCESSING\"` и этап обработки `\"substatus\": \"READY_TO_SHIP\"`. * Если магазин подтвердил заказ, но не может его выполнить (например, товар числится в базе, но отсутствует на складе или нет нужного цвета), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"STARTED\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`. * Если магазин подготовил заказ к отгрузке, но не может его выполнить (например, последний товар был поврежден или оказался с браком), то заказ из статуса `\"status\": \"PROCESSING\"` и этапа обработки `\"substatus\": \"READY_TO_SHIP\"` нужно перевести в статус `\"status\": \"CANCELLED\"` с причиной отмены заказа `\"substatus\": \"SHOP_FAILED\"`.  Максимальное количество заказов, у которых можно изменить статус в одном запросе, — 30.  |**⚙️ Лимит:** 1 000 000 запросов в час| |-| 

Params:
- campaign_id::Int64 (required)
- update_order_statuses_request::UpdateOrderStatusesRequest (required)

Return: UpdateOrderStatusesResponse, OpenAPI.Clients.ApiResponse
"""
function update_order_statuses(_api::OrdersApi, campaign_id::Int64, update_order_statuses_request::UpdateOrderStatusesRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_order_statuses(_api, campaign_id, update_order_statuses_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_order_statuses(_api::OrdersApi, response_stream::Channel, campaign_id::Int64, update_order_statuses_request::UpdateOrderStatusesRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_order_statuses(_api, campaign_id, update_order_statuses_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export accept_order_cancellation
export get_order
export get_orders
export provide_order_digital_codes
export provide_order_item_identifiers
export set_order_box_layout
export set_order_shipment_boxes
export update_order_items
export update_order_status
export update_order_statuses
