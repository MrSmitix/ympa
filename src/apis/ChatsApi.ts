// tslint:disable
/**
 * Партнерский API Маркета
 * API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
 *
 * The version of the OpenAPI document: LATEST
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    ApiClientDataErrorResponse,
    ApiClientDataErrorResponseFromJSON,
    ApiClientDataErrorResponseToJSON,
    ApiForbiddenErrorResponse,
    ApiForbiddenErrorResponseFromJSON,
    ApiForbiddenErrorResponseToJSON,
    ApiLimitErrorResponse,
    ApiLimitErrorResponseFromJSON,
    ApiLimitErrorResponseToJSON,
    ApiNotFoundErrorResponse,
    ApiNotFoundErrorResponseFromJSON,
    ApiNotFoundErrorResponseToJSON,
    ApiServerErrorResponse,
    ApiServerErrorResponseFromJSON,
    ApiServerErrorResponseToJSON,
    ApiUnauthorizedErrorResponse,
    ApiUnauthorizedErrorResponseFromJSON,
    ApiUnauthorizedErrorResponseToJSON,
    CreateChatRequest,
    CreateChatRequestFromJSON,
    CreateChatRequestToJSON,
    CreateChatResponse,
    CreateChatResponseFromJSON,
    CreateChatResponseToJSON,
    EmptyApiResponse,
    EmptyApiResponseFromJSON,
    EmptyApiResponseToJSON,
    GetChatHistoryRequest,
    GetChatHistoryRequestFromJSON,
    GetChatHistoryRequestToJSON,
    GetChatHistoryResponse,
    GetChatHistoryResponseFromJSON,
    GetChatHistoryResponseToJSON,
    GetChatsRequest,
    GetChatsRequestFromJSON,
    GetChatsRequestToJSON,
    GetChatsResponse,
    GetChatsResponseFromJSON,
    GetChatsResponseToJSON,
    SendMessageToChatRequest,
    SendMessageToChatRequestFromJSON,
    SendMessageToChatRequestToJSON,
} from '../models';

export interface CreateChatRequest {
    businessId: number;
    createChatRequest: CreateChatRequest;
}

export interface GetChatHistoryRequest {
    businessId: number;
    chatId: number;
    getChatHistoryRequest: GetChatHistoryRequest;
    pageToken?: string;
    limit?: number;
}

export interface GetChatsRequest {
    businessId: number;
    getChatsRequest: GetChatsRequest;
    pageToken?: string;
    limit?: number;
}

export interface SendFileToChatRequest {
    businessId: number;
    chatId: number;
    file: Blob;
}

export interface SendMessageToChatRequest {
    businessId: number;
    chatId: number;
    sendMessageToChatRequest: SendMessageToChatRequest;
}


/**
 * Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
 * Создание нового чата с покупателем
 */
function createChatRaw<T>(requestParameters: CreateChatRequest, requestConfig: runtime.TypedQueryConfig<T, CreateChatResponse> = {}): QueryConfig<T> {
    if (requestParameters.businessId === null || requestParameters.businessId === undefined) {
        throw new runtime.RequiredError('businessId','Required parameter requestParameters.businessId was null or undefined when calling createChat.');
    }

    if (requestParameters.createChatRequest === null || requestParameters.createChatRequest === undefined) {
        throw new runtime.RequiredError('createChatRequest','Required parameter requestParameters.createChatRequest was null or undefined when calling createChat.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/businesses/{businessId}/chats/new`.replace(`{${"businessId"}}`, encodeURIComponent(String(requestParameters.businessId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateChatRequestToJSON(requestParameters.createChatRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CreateChatResponseFromJSON(body), text);
    }

    return config;
}

/**
* Создает новый чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
* Создание нового чата с покупателем
*/
export function createChat<T>(requestParameters: CreateChatRequest, requestConfig?: runtime.TypedQueryConfig<T, CreateChatResponse>): QueryConfig<T> {
    return createChatRaw(requestParameters, requestConfig);
}

/**
 * Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
 * Получение истории сообщений в чате
 */
function getChatHistoryRaw<T>(requestParameters: GetChatHistoryRequest, requestConfig: runtime.TypedQueryConfig<T, GetChatHistoryResponse> = {}): QueryConfig<T> {
    if (requestParameters.businessId === null || requestParameters.businessId === undefined) {
        throw new runtime.RequiredError('businessId','Required parameter requestParameters.businessId was null or undefined when calling getChatHistory.');
    }

    if (requestParameters.chatId === null || requestParameters.chatId === undefined) {
        throw new runtime.RequiredError('chatId','Required parameter requestParameters.chatId was null or undefined when calling getChatHistory.');
    }

    if (requestParameters.getChatHistoryRequest === null || requestParameters.getChatHistoryRequest === undefined) {
        throw new runtime.RequiredError('getChatHistoryRequest','Required parameter requestParameters.getChatHistoryRequest was null or undefined when calling getChatHistory.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.chatId !== undefined) {
        queryParameters['chatId'] = requestParameters.chatId;
    }


    if (requestParameters.pageToken !== undefined) {
        queryParameters['page_token'] = requestParameters.pageToken;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/businesses/{businessId}/chats/history`.replace(`{${"businessId"}}`, encodeURIComponent(String(requestParameters.businessId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || GetChatHistoryRequestToJSON(requestParameters.getChatHistoryRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetChatHistoryResponseFromJSON(body), text);
    }

    return config;
}

/**
* Возвращает историю сообщений в чате с покупателем.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
* Получение истории сообщений в чате
*/
export function getChatHistory<T>(requestParameters: GetChatHistoryRequest, requestConfig?: runtime.TypedQueryConfig<T, GetChatHistoryResponse>): QueryConfig<T> {
    return getChatHistoryRaw(requestParameters, requestConfig);
}

/**
 * Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
 * Получение доступных чатов
 */
function getChatsRaw<T>(requestParameters: GetChatsRequest, requestConfig: runtime.TypedQueryConfig<T, GetChatsResponse> = {}): QueryConfig<T> {
    if (requestParameters.businessId === null || requestParameters.businessId === undefined) {
        throw new runtime.RequiredError('businessId','Required parameter requestParameters.businessId was null or undefined when calling getChats.');
    }

    if (requestParameters.getChatsRequest === null || requestParameters.getChatsRequest === undefined) {
        throw new runtime.RequiredError('getChatsRequest','Required parameter requestParameters.getChatsRequest was null or undefined when calling getChats.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.pageToken !== undefined) {
        queryParameters['page_token'] = requestParameters.pageToken;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/businesses/{businessId}/chats`.replace(`{${"businessId"}}`, encodeURIComponent(String(requestParameters.businessId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || GetChatsRequestToJSON(requestParameters.getChatsRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GetChatsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Возвращает ваши чаты с покупателями.  |**⚙️ Лимит:** 10000 запросов в час| |-| 
* Получение доступных чатов
*/
export function getChats<T>(requestParameters: GetChatsRequest, requestConfig?: runtime.TypedQueryConfig<T, GetChatsResponse>): QueryConfig<T> {
    return getChatsRaw(requestParameters, requestConfig);
}

/**
 * Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
 * Отправка файла в чат
 */
function sendFileToChatRaw<T>(requestParameters: SendFileToChatRequest, requestConfig: runtime.TypedQueryConfig<T, EmptyApiResponse> = {}): QueryConfig<T> {
    if (requestParameters.businessId === null || requestParameters.businessId === undefined) {
        throw new runtime.RequiredError('businessId','Required parameter requestParameters.businessId was null or undefined when calling sendFileToChat.');
    }

    if (requestParameters.chatId === null || requestParameters.chatId === undefined) {
        throw new runtime.RequiredError('chatId','Required parameter requestParameters.chatId was null or undefined when calling sendFileToChat.');
    }

    if (requestParameters.file === null || requestParameters.file === undefined) {
        throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling sendFileToChat.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.chatId !== undefined) {
        queryParameters['chatId'] = requestParameters.chatId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const formData = new FormData();
    if (requestParameters.file !== undefined) {
        formData.append('file', requestParameters.file as any);
    }

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/businesses/{businessId}/chats/file/send`.replace(`{${"businessId"}}`, encodeURIComponent(String(requestParameters.businessId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: formData,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(EmptyApiResponseFromJSON(body), text);
    }

    return config;
}

/**
* Отправляет файл в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
* Отправка файла в чат
*/
export function sendFileToChat<T>(requestParameters: SendFileToChatRequest, requestConfig?: runtime.TypedQueryConfig<T, EmptyApiResponse>): QueryConfig<T> {
    return sendFileToChatRaw(requestParameters, requestConfig);
}

/**
 * Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
 * Отправка сообщения в чат
 */
function sendMessageToChatRaw<T>(requestParameters: SendMessageToChatRequest, requestConfig: runtime.TypedQueryConfig<T, EmptyApiResponse> = {}): QueryConfig<T> {
    if (requestParameters.businessId === null || requestParameters.businessId === undefined) {
        throw new runtime.RequiredError('businessId','Required parameter requestParameters.businessId was null or undefined when calling sendMessageToChat.');
    }

    if (requestParameters.chatId === null || requestParameters.chatId === undefined) {
        throw new runtime.RequiredError('chatId','Required parameter requestParameters.chatId was null or undefined when calling sendMessageToChat.');
    }

    if (requestParameters.sendMessageToChatRequest === null || requestParameters.sendMessageToChatRequest === undefined) {
        throw new runtime.RequiredError('sendMessageToChatRequest','Required parameter requestParameters.sendMessageToChatRequest was null or undefined when calling sendMessageToChat.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.chatId !== undefined) {
        queryParameters['chatId'] = requestParameters.chatId;
    }

    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["market:partner-api"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/businesses/{businessId}/chats/message`.replace(`{${"businessId"}}`, encodeURIComponent(String(requestParameters.businessId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || SendMessageToChatRequestToJSON(requestParameters.sendMessageToChatRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(EmptyApiResponseFromJSON(body), text);
    }

    return config;
}

/**
* Отправляет сообщение в чат с покупателем.  |**⚙️ Лимит:** 1000 запросов в час| |-| 
* Отправка сообщения в чат
*/
export function sendMessageToChat<T>(requestParameters: SendMessageToChatRequest, requestConfig?: runtime.TypedQueryConfig<T, EmptyApiResponse>): QueryConfig<T> {
    return sendMessageToChatRaw(requestParameters, requestConfig);
}

