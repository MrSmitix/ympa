/**
* Партнерский API Маркета
* API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 
*
* The version of the OpenAPI document: LATEST
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package ympa_ktorm_schema.models

import org.ktorm.dsl.*
import org.ktorm.schema.*
import org.ktorm.database.Database
import .*


/**
 * Информация об акции.
 * @param id Идентификатор акции.
 * @param name Название акции.
 * @param period 
 * @param participating Участвует или участвовал ли продавец в этой акции.  Для текущих и будущих акций возвращается со значением `true`, если в акции есть товары, которые были добавлены вручную. Если товары не участвуют в акции или добавлены в нее автоматически, параметр возвращается со значением `false`.  Для прошедших акций всегда возвращается со значением `true`.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
 * @param assortmentInfo 
 * @param mechanicsInfo 
 * @param bestsellerInfo 
 * @param channels Список каналов продвижения товаров.
 * @param constraints 
 */
object GetPromoDTOs : BaseTable<GetPromoDTO>("GetPromoDTO") {
    val id = text("id") /* Идентификатор акции. */
    val name = text("name") /* Название акции. */
    val period = long("period")
    val participating = boolean("participating") /* Участвует или участвовал ли продавец в этой акции.  Для текущих и будущих акций возвращается со значением `true`, если в акции есть товары, которые были добавлены вручную. Если товары не участвуют в акции или добавлены в нее автоматически, параметр возвращается со значением `false`.  Для прошедших акций всегда возвращается со значением `true`.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index).  */
    val assortmentInfo = long("assortmentInfo")
    val mechanicsInfo = long("mechanicsInfo")
    val bestsellerInfo = long("bestsellerInfo")
    val constraints = long("constraints") /* null */

    /**
     * Create an entity of type GetPromoDTO from the model
     */
    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean) = GetPromoDTO(
        id = row[id] ?: "" /* kotlin.String */ /* Идентификатор акции. */,
        name = row[name] ?: "" /* kotlin.String */ /* Название акции. */,
        period = PromoPeriodDTOs.createEntity(row, withReferences) /* PromoPeriodDTO */,
        participating = row[participating] ?: false /* kotlin.Boolean */ /* Участвует или участвовал ли продавец в этой акции.  Для текущих и будущих акций возвращается со значением `true`, если в акции есть товары, которые были добавлены вручную. Если товары не участвуют в акции или добавлены в нее автоматически, параметр возвращается со значением `false`.  Для прошедших акций всегда возвращается со значением `true`.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index).  */,
        assortmentInfo = GetPromoAssortmentInfoDTOs.createEntity(row, withReferences) /* GetPromoAssortmentInfoDTO */,
        mechanicsInfo = GetPromoMechanicsInfoDTOs.createEntity(row, withReferences) /* GetPromoMechanicsInfoDTO */,
        bestsellerInfo = GetPromoBestsellerInfoDTOs.createEntity(row, withReferences) /* GetPromoBestsellerInfoDTO */,
        channels = emptyList() /* kotlin.Array<ChannelType>? */ /* Список каналов продвижения товаров. */,
        constraints = GetPromoConstraintsDTOs.createEntity(row, withReferences) /* GetPromoConstraintsDTO? */
    )

    /**
    * Assign all the columns from the entity of type GetPromoDTO to the DML expression.
    *
    * Usage:
    *
    * ```kotlin
    * let entity = GetPromoDTO()
    * database.update(GetPromoDTOs, {
    *     assignFrom(entity)
    * })
    * ```
    * @return the builder with the columns for the update or insert.
    */
    fun AssignmentsBuilder.assignFrom(entity: GetPromoDTO) {
        this.apply {
            set(GetPromoDTOs.id, entity.id)
            set(GetPromoDTOs.name, entity.name)
            set(GetPromoDTOs.period, entity.period)
            set(GetPromoDTOs.participating, entity.participating)
            set(GetPromoDTOs.assortmentInfo, entity.assortmentInfo)
            set(GetPromoDTOs.mechanicsInfo, entity.mechanicsInfo)
            set(GetPromoDTOs.bestsellerInfo, entity.bestsellerInfo)
            set(GetPromoDTOs.constraints, entity.constraints)
        }
    }

}


object GetPromoDTOChannelType : BaseTable<Pair<kotlin.Long, kotlin.Long>>("GetPromoDTOChannelType") {
    val getPromoDTO = long("getPromoDTO")
    val channelType = long("channelType")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.Long> =
        Pair(row[getPromoDTO] ?: 0, row[channelType] ?: 0)

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.Long>) {
        this.apply {
            set(GetPromoDTOChannelType.getPromoDTO, entity.first)
            set(GetPromoDTOChannelType.channelType, entity.second)
        }
    }

}

